using Printf
using ProgressLogging
using ClimaCorePlots, Plots

# Reference paper: https://rmets.onlinelibrary.wiley.com/doi/pdf/10.1002/qj.2105

# Constants for switching between different experiment setups
const is_small_scale = true
const ùîº_name = :œÅe
const is_discrete_hydrostatic_balance = true # `false` causes large oscillations

# Constants required by "staggered_nonhydrostatic_model.jl"
const p_0 = FT(1.0e5)
const R_d = FT(287.0)
const Œ∫ = FT(2 / 7)
const T_tri = FT(273.16)
const grav = FT(9.80616)
const f = is_small_scale ? FT(0) : 2 * sin(œÄ / 4) * 2œÄ / FT(86164.09)
include("../staggered_nonhydrostatic_model.jl")

# Additional constants required for inertial gravity wave initial condition
const z_top = FT(10e3)
const x_max = is_small_scale ? FT(300e3) : FT(6000e3)
const x_mid = is_small_scale ? FT(100e3) : FT(3000e3)
const d = is_small_scale ? FT(5e3) : FT(100e3)
const u‚ÇÄ = is_small_scale ? FT(20) : FT(0)
const v‚ÇÄ = FT(0)
const T‚ÇÄ = FT(250)
const ŒîT = FT(0.01)

# Other convenient constants used in reference paper
const Œ¥ = grav / (R_d * T‚ÇÄ)        # Bretherton height parameter
const c‚Çõ¬≤ = cp_d / cv_d * R_d * T‚ÇÄ # speed of sound squared
const œÅ‚Çõ = p_0 / (R_d * T‚ÇÄ)        # air density at surface

p‚ÇÄ(z) = p_0 * exp(-Œ¥ * z)
Tb_init(x, z) = ŒîT * exp(-(x - x_mid)^2 / d^2) * sin(œÄ * z / z_top)
T‚Ä≤_init(x, z) = Tb_init(x, z) * exp(Œ¥ * z / 2)

function make_center_initial_condition(Œîz)
    # Y‚Çú.f.w = 0 in implicit tendency                                        ==>
    # -(·∂†grad·µ•(·∂úp) / ·∂†interp(·∂úœÅ) + ·∂†grad·µ•·∂úŒ¶) = 0                             ==>
    # ·∂†grad·µ•(·∂úp) = -grav * ·∂†interp(·∂úœÅ)                                       ==>
    # (p(z + Œîz) - p(z)) / Œîz = -grav * (œÅ(z + Œîz) + œÅ(z)) / 2               ==>
    # p(z + Œîz) + grav * Œîz * œÅ(z + Œîz) / 2 = p(z) - grav * Œîz * œÅ(z) / 2    ==>
    # p(z + Œîz) * (1 + Œ¥ * Œîz / 2) = p(z) * (1 - Œ¥ * Œîz / 2)                 ==>
    # p(z + Œîz) / p(z) = (1 - Œ¥ * Œîz / 2) / (1 + Œ¥ * Œîz / 2)                 ==>
    # p(z) = p(0) * ((1 - Œ¥ * Œîz / 2) / (1 + Œ¥ * Œîz / 2))^(z / Œîz)
    p‚ÇÄ_discrete(z) = p_0 * ((1 - Œ¥ * Œîz / 2) / (1 + Œ¥ * Œîz / 2))^(z / Œîz)
    p‚ÇÄ_func = is_discrete_hydrostatic_balance ? p‚ÇÄ_discrete : p‚ÇÄ

    function center_initial_condition(local_geometry)
        (; x, z) = local_geometry.coordinates
        p = p‚ÇÄ_func(z)
        T = T‚ÇÄ + T‚Ä≤_init(x, z)
        œÅ = p / (R_d * T)
        u‚Çï_local = Geometry.UVVector(u‚ÇÄ, v‚ÇÄ)
        u‚Çï = Geometry.Covariant12Vector(u‚Çï_local, local_geometry)
        if ùîº_name == :œÅŒ∏
            œÅŒ∏ = œÅ * T * (p_0 / p)^(R_d / cp_d)
            return (; œÅ, œÅŒ∏, u‚Çï)
        elseif ùîº_name == :œÅe
            œÅe = œÅ * (cv_d * (T - T_tri) + norm_sqr(u‚Çï_local) / 2 + grav * z)
            return (; œÅ, œÅe, u‚Çï)
        elseif ùîº_name == :œÅe_int
            œÅe_int = œÅ * cv_d * (T - T_tri)
            return (; œÅ, œÅe_int, u‚Çï)
        end
    end
    return center_initial_condition
end
function make_face_initial_condition()
    face_initial_condition(local_geometry) =
        (; w = Geometry.Covariant3Vector(FT(0)))
    return face_initial_condition
end

# TODO: Use full set of Œîxs once the solution can be computed more quickly.
# Œîxs = is_small_scale ? FT[1000, 500, 250, 125, 50, 25] :
#     FT[20e3, 10e3, 5e3, 2.5e3]
Œîxs = is_small_scale ? FT[1000,] : FT[20e3, 10e3]
Œîzs = is_small_scale ? Œîxs ./ 2 : Œîxs ./ 40
setups = map(Œîxs, Œîzs) do Œîx, Œîz
    npoly = 1
    x_elem = Int(x_max / (Œîx * npoly))
    t_end = is_small_scale ? FT(60 * 60 * 0.5) : FT(60 * 60 * 8)
    dt_for_first_Œîx = is_small_scale ? FT(1.5) : FT(30) # this depends on npoly
    animation_duration = FT(5) # output a 5-second gif
    fps = 2 # play the gif at 2 frames per second
    return HybridDriverSetup(;
        center_initial_condition = make_center_initial_condition(Œîz),
        face_initial_condition = make_face_initial_condition(),
        horizontal_mesh = periodic_line_mesh(; x_max, x_elem),
        npoly,
        z_max = z_top,
        z_elem = Int(z_top / Œîz),
        t_end,
        dt = dt_for_first_Œîx / Œîxs[1] * Œîx,
        dt_save_to_sol = t_end / (animation_duration * fps),
        ode_algorithm = Rosenbrock23,
        jacobian_flags = (;
            ‚àÇ·∂úùîº‚Çú‚àÇ·∂†ùïÑ_mode = ùîº_name == :œÅe ? :no_‚àÇ·∂úp‚àÇ·∂úK : :exact,
            ‚àÇ·∂†ùïÑ‚Çú‚àÇ·∂úœÅ_mode = :exact,
        ),
    )
end

function postprocessing(sols, output_dir)
    if ùîº_name == :œÅŒ∏
        press = Y -> @. pressure_œÅŒ∏(Y.c.œÅŒ∏)
        T‚Ä≤ = Y -> begin
            ·∂úp = @. pressure_œÅŒ∏(Y.c.œÅŒ∏)
            @. Y.c.œÅŒ∏ / Y.c.œÅ * (·∂úp / p_0)^(R_d / cp_d) - T‚ÇÄ
        end
    elseif ùîº_name == :œÅe
        press = Y -> begin
            ·∂úK = @. norm_sqr(C123(Y.c.u‚Çï) + C123(·∂úinterp(Y.f.w))) / 2
            ·∂úŒ¶ = Fields.coordinate_field(Y.c).z .* grav
            @. pressure_œÅe(Y.c.œÅe, ·∂úK, ·∂úŒ¶, Y.c.œÅ)
        end
        T‚Ä≤ = Y -> begin
            ·∂úK = @. norm_sqr(C123(Y.c.u‚Çï) + C123(·∂úinterp(Y.f.w))) / 2
            ·∂úŒ¶ = Fields.coordinate_field(Y.c).z .* grav
            @. (Y.c.œÅe / Y.c.œÅ - ·∂úK - ·∂úŒ¶) / cv_d + T_tri - T‚ÇÄ
        end
    elseif ùîº_name == :œÅe_int
        press = Y -> @. pressure_œÅe_int(Y.c.œÅe_int, Y.c.œÅ)
        T‚Ä≤ = Y -> @. Y.c.œÅe_int / Y.c.œÅ / cv_d + T_tri - T‚ÇÄ
    end
    u‚Ä≤ = Y -> @. Geometry.UVVector(Y.c.u‚Çï).components.data.:1 - u‚ÇÄ
    v‚Ä≤ = Y -> @. Geometry.UVVector(Y.c.u‚Çï).components.data.:2 - v‚ÇÄ
    w‚Ä≤ = Y -> @. Geometry.WVector(Y.f.w).components.data.:1

    œÅfb_init_array = œÅfb_init_coefs(1, 600, 40)

    for index in 1:length(sols)
        Œîx = Œîxs[index]
        Œîz = Œîzs[index]
        sol = sols[index]
        ·∂úlocal_geometry = Fields.local_geometry_field(sol.u[1].c)
        ·∂†local_geometry = Fields.local_geometry_field(sol.u[1].f)
        lin_cache = linear_solution_cache(·∂úlocal_geometry, ·∂†local_geometry)

        p‚ÇÄ_discrete(z) = p_0 * ((1 - Œ¥ * Œîz / 2) / (1 + Œ¥ * Œîz / 2))^(z / Œîz)
        p‚ÇÄ_func = is_discrete_hydrostatic_balance ? p‚ÇÄ_discrete : p‚ÇÄ
        p‚Ä≤ = Y -> press(Y) .- p‚ÇÄ_func.(·∂úlocal_geometry.coordinates.z)
        œÅ‚Ä≤ = Y -> @. Y.c.œÅ - p‚ÇÄ_func(·∂úlocal_geometry.coordinates.z) / (R_d * T‚ÇÄ)

        println("Info for Œîx = $Œîx:\n")
        for iframe in (1, length(sol.t))
            t = sol.t[iframe]
            Y = sol.u[iframe]
            (; ·∂úp‚Ä≤, ·∂úœÅ‚Ä≤, ·∂úu‚Ä≤, ·∂úv‚Ä≤, ·∂†w‚Ä≤, ·∂úT‚Ä≤) =
                linear_solution(lin_cache, œÅfb_init_array, t)
            println("Error norms at time t = $t:")
            for (name, f, var_lin) in (
                (:p‚Ä≤, p‚Ä≤, ·∂úp‚Ä≤),
                (:œÅ‚Ä≤, œÅ‚Ä≤, ·∂úœÅ‚Ä≤),
                (:u‚Ä≤, u‚Ä≤, ·∂úu‚Ä≤),
                (:v‚Ä≤, v‚Ä≤, ·∂úv‚Ä≤),
                (:w‚Ä≤, w‚Ä≤, ·∂†w‚Ä≤),
                (:T‚Ä≤, T‚Ä≤, ·∂úT‚Ä≤),
            )
                var = f(Y)
                strings = (
                    norm_strings(var, var_lin, 2)...,
                    norm_strings(var, var_lin, Inf)...,
                )
                println("œï = $name: ", join(strings, ", "))
            end
            println()
        end
    end

    # Animation is very slow, so only do it for the first solution
    sol = sols[1]
    ·∂úlocal_geometry = Fields.local_geometry_field(sol.u[1].c)
    ·∂†local_geometry = Fields.local_geometry_field(sol.u[1].f)
    lin_cache = linear_solution_cache(·∂úlocal_geometry, ·∂†local_geometry)
    Y_lin = similar(sol.u[1])
    anim_vars = (
        (:Tprime, T‚Ä≤, is_small_scale ? 0.014 : 0.014),
        (:uprime, u‚Ä≤, is_small_scale ? 0.042 : 0.014),
        (:wprime, w‚Ä≤, is_small_scale ? 0.0042 : 0.0014),
    )
    anims = [Animation() for _ in 1:(3 * length(anim_vars))]
    @progress "Animations" for iframe in 1:length(sol.t)
        t = sol.t[iframe]
        Y = sol.u[iframe]
        linear_solution!(Y_lin, lin_cache, œÅfb_init_array, t)
        for (ivar, (_, f, lim)) in enumerate(anim_vars)
            var = f(Y)
            var_lin = f(Y_lin)
            var_rel_err = @. (var - var_lin) / (abs(var_lin) + eps(FT))
            # adding eps(FT) to the denominator prevents divisions by 0
            frame(anims[3 * ivar - 2], plot(var_lin, clim = (-lim, lim)))
            frame(anims[3 * ivar - 1], plot(var, clim = (-lim, lim)))
            frame(anims[3 * ivar], plot(var_rel_err, clim = (-10, 10)))
        end
    end
    for (ivar, (name, _, _)) in enumerate(anim_vars)
        mp4(anims[3 * ivar - 2], joinpath(output_dir, "$(name)_lin.mp4"); fps)
        mp4(anims[3 * ivar - 1], joinpath(output_dir, "$name.mp4"); fps)
        mp4(anims[3 * ivar], joinpath(output_dir, "$(name)_rel_err.mp4"); fps)
    end
end

function norm_strings(var, var_lin, p)
    norm_err = norm(var .- var_lin, p; normalize = false)
    scaled_norm_err = norm_err / norm(var_lin, p; normalize = false)
    return (
        @sprintf("‚Äñœï‚Äñ_%d = %-#9.4g", p, norm(var, p; normalize = false)),
        @sprintf("‚Äñœï - œï_lin‚Äñ_%d = %-#9.4g", p, norm_err),
        @sprintf("‚Äñœï - œï_lin‚Äñ_%d/‚Äñœï_lin‚Äñ_%d = %-#9.4g", p, p, scaled_norm_err),
    )
end

# TODO: Verify that this converges as the resolution increases.
function œÅfb_init_coefs(npoly, x_elem, z_elem)
    max_ikx = x_elem * npoly
    max_ikz = 2 * z_elem

    # coordinates
    horizontal_mesh = periodic_line_mesh(; x_max, x_elem)
    h_space = make_horizontal_space(horizontal_mesh, npoly)
    center_space, _ = make_hybrid_spaces(h_space, 2 * z_top, 2 * z_elem)
    ·∂úlocal_geometry = Fields.local_geometry_field(center_space)
    ·∂úx = ·∂úlocal_geometry.coordinates.x
    ·∂úz = ·∂úlocal_geometry.coordinates.z

    # Bretherton transform of initial perturbation
    linearize_density_perturbation = false
    if linearize_density_perturbation
        ·∂úœÅb_init = @. -œÅ‚Çõ * Tb_init(·∂úx, ·∂úz) / T‚ÇÄ
    else
        ·∂úp‚ÇÄ = @. p‚ÇÄ(·∂úz)
        ·∂úœÅ‚ÇÄ = @. ·∂úp‚ÇÄ / (R_d * T‚ÇÄ)
        ·∂úœÅ‚Ä≤_init = @. ·∂úp‚ÇÄ / (R_d * (T‚ÇÄ + T‚Ä≤_init(·∂úx, ·∂úz))) - ·∂úœÅ‚ÇÄ
        ·∂úbretherton_factor_pœÅ = @. exp(-Œ¥ * ·∂úz / 2)
        ·∂úœÅb_init = @. ·∂úœÅ‚Ä≤_init / ·∂úbretherton_factor_pœÅ
    end

    # Fourier coefficients of Bretherton transform of initial perturbation
    œÅfb_init_array = Array{Complex{FT}}(undef, 2 * max_ikx + 1, 2 * max_ikz + 1)
    ·∂úfourier_factor = Fields.Field(Complex{FT}, axes(·∂úlocal_geometry))
    ·∂úintegrand = Fields.Field(Complex{FT}, axes(·∂úlocal_geometry))
    unit_integral = sum(one.(·∂úœÅb_init))
    @progress "œÅfb t=0" for ikx in (-max_ikx):max_ikx, ikz in (-max_ikz):max_ikz
        kx = 2 * œÄ / x_max * ikx
        kz = 2 * œÄ / (2 * z_top) * ikz
        @. ·∂úfourier_factor = exp(im * (kx * ·∂úx + kz * ·∂úz))
        @. ·∂úintegrand = ·∂úœÅb_init / ·∂úfourier_factor
        œÅfb_init_array[ikx + max_ikx + 1, ikz + max_ikz + 1] =
            sum(·∂úintegrand) / unit_integral
    end
    return œÅfb_init_array
end

function linear_solution_cache(·∂úlocal_geometry, ·∂†local_geometry)
    ·∂úz = ·∂úlocal_geometry.coordinates.z
    ·∂†z = ·∂†local_geometry.coordinates.z
    ·∂úp‚ÇÄ = @. p‚ÇÄ(·∂úz)
    return (;
        # coordinates
        ·∂úx = ·∂úlocal_geometry.coordinates.x,
        ·∂†x = ·∂†local_geometry.coordinates.x,
        ·∂úz,
        ·∂†z,

        # background state
        ·∂úp‚ÇÄ,
        ·∂úœÅ‚ÇÄ = (@. ·∂úp‚ÇÄ / (R_d * T‚ÇÄ)),
        ·∂úu‚ÇÄ = map(_ -> u‚ÇÄ, ·∂úlocal_geometry),
        ·∂úv‚ÇÄ = map(_ -> v‚ÇÄ, ·∂úlocal_geometry),
        ·∂†w‚ÇÄ = map(_ -> FT(0), ·∂†local_geometry),

        # Bretherton transform factors
        ·∂úbretherton_factor_pœÅ = (@. exp(-Œ¥ * ·∂úz / 2)),
        ·∂úbretherton_factor_uvwT = (@. exp(Œ¥ * ·∂úz / 2)),
        ·∂†bretherton_factor_uvwT = (@. exp(Œ¥ * ·∂†z / 2)),

        # Fourier transform factors
        ·∂úfourier_factor = Fields.Field(Complex{FT}, axes(·∂úlocal_geometry)),
        ·∂†fourier_factor = Fields.Field(Complex{FT}, axes(·∂†local_geometry)),

        # Bretherton transform of final perturbation
        ·∂úpb = Fields.Field(FT, axes(·∂úlocal_geometry)),
        ·∂úœÅb = Fields.Field(FT, axes(·∂úlocal_geometry)),
        ·∂úub = Fields.Field(FT, axes(·∂úlocal_geometry)),
        ·∂úvb = Fields.Field(FT, axes(·∂úlocal_geometry)),
        ·∂†wb = Fields.Field(FT, axes(·∂†local_geometry)),

        # final state
        ·∂úp = Fields.Field(FT, axes(·∂úlocal_geometry)),
        ·∂úœÅ = Fields.Field(FT, axes(·∂úlocal_geometry)),
        ·∂úu = Fields.Field(FT, axes(·∂úlocal_geometry)),
        ·∂úv = Fields.Field(FT, axes(·∂úlocal_geometry)),
        ·∂†w = Fields.Field(FT, axes(·∂†local_geometry)),

        # final temperature
        ·∂úT = Fields.Field(FT, axes(·∂úlocal_geometry)),
    )
end

function linear_solution!(Y, lin_cache, œÅfb_init_array, t)
    (; ·∂úx, ·∂†x, ·∂úz, ·∂†z, ·∂úp‚ÇÄ, ·∂úœÅ‚ÇÄ, ·∂úu‚ÇÄ, ·∂úv‚ÇÄ, ·∂†w‚ÇÄ) = lin_cache
    (; ·∂úbretherton_factor_pœÅ) = lin_cache
    (; ·∂úbretherton_factor_uvwT, ·∂†bretherton_factor_uvwT) = lin_cache
    (; ·∂úfourier_factor, ·∂†fourier_factor) = lin_cache
    (; ·∂úpb, ·∂úœÅb, ·∂úub, ·∂úvb, ·∂†wb, ·∂úp, ·∂úœÅ, ·∂úu, ·∂úv, ·∂†w, ·∂úT) = lin_cache

    ·∂úpb .= FT(0)
    ·∂úœÅb .= FT(0)
    ·∂úub .= FT(0)
    ·∂úvb .= FT(0)
    ·∂†wb .= FT(0)
    max_ikx, max_ikz = (size(œÅfb_init_array) .- 1) .√∑ 2
    @progress "Y_lin" for ikx in (-max_ikx):max_ikx, ikz in (-max_ikz):max_ikz
        kx = 2 * œÄ / x_max * ikx
        kz = 2 * œÄ / (2 * z_top) * ikz

        # Fourier coefficient of ·∂úœÅb_init (for current kx and kz)
        œÅfb_init = œÅfb_init_array[ikx + max_ikx + 1, ikz + max_ikz + 1]

        # Fourier factors, shifted by u‚ÇÄ * t along the x-axis
        @. ·∂úfourier_factor = exp(im * (kx * (·∂úx - u‚ÇÄ * t) + kz * ·∂úz))
        @. ·∂†fourier_factor = exp(im * (kx * (·∂†x - u‚ÇÄ * t) + kz * ·∂†z))

        # roots of a‚ÇÅ(s)
        p‚ÇÅ = c‚Çõ¬≤ * (kx^2 + kz^2 + Œ¥^2 / 4) + f^2
        q‚ÇÅ = grav * kx^2 * (c‚Çõ¬≤ * Œ¥ - grav) + c‚Çõ¬≤ * f^2 * (kz^2 + Œ¥^2 / 4)
        Œ±¬≤ = p‚ÇÅ / 2 - sqrt(p‚ÇÅ^2 / 4 - q‚ÇÅ)
        Œ≤¬≤ = p‚ÇÅ / 2 + sqrt(p‚ÇÅ^2 / 4 - q‚ÇÅ)
        Œ± = sqrt(Œ±¬≤)
        Œ≤ = sqrt(Œ≤¬≤)

        # inverse Laplace transform of s^p/((s^2 + Œ±^2)(s^2 + Œ≤^2)) for p ‚àà -1:3
        if Œ± == 0
            L‚Çã‚ÇÅ = (Œ≤¬≤ * t^2 / 2 - 1 + cos(Œ≤ * t)) / Œ≤^4
            L‚ÇÄ = (Œ≤ * t - sin(Œ≤ * t)) / Œ≤^3
        else
            L‚Çã‚ÇÅ =
                (-cos(Œ± * t) / Œ±¬≤ + cos(Œ≤ * t) / Œ≤¬≤) / (Œ≤¬≤ - Œ±¬≤) + 1 / (Œ±¬≤ * Œ≤¬≤)
            L‚ÇÄ = (sin(Œ± * t) / Œ± - sin(Œ≤ * t) / Œ≤) / (Œ≤¬≤ - Œ±¬≤)
        end
        L‚ÇÅ = (cos(Œ± * t) - cos(Œ≤ * t)) / (Œ≤¬≤ - Œ±¬≤)
        L‚ÇÇ = (-sin(Œ± * t) * Œ± + sin(Œ≤ * t) * Œ≤) / (Œ≤¬≤ - Œ±¬≤)
        L‚ÇÉ = (-cos(Œ± * t) * Œ±¬≤ + cos(Œ≤ * t) * Œ≤¬≤) / (Œ≤¬≤ - Œ±¬≤)

        # Fourier coefficients of Bretherton transforms of final perturbations
        C‚ÇÅ = grav * (grav - c‚Çõ¬≤ * (im * kz + Œ¥ / 2))
        C‚ÇÇ = grav * (im * kz - Œ¥ / 2)
        pfb = -œÅfb_init * (L‚ÇÅ + L‚Çã‚ÇÅ * f^2) * C‚ÇÅ
        œÅfb =
            œÅfb_init *
            (L‚ÇÉ + L‚ÇÅ * (p‚ÇÅ + C‚ÇÇ) + L‚Çã‚ÇÅ * f^2 * (c‚Çõ¬≤ * (kz^2 + Œ¥^2 / 4) + C‚ÇÇ))
        ufb = œÅfb_init * L‚ÇÄ * im * kx * C‚ÇÅ / œÅ‚Çõ
        vfb = -œÅfb_init * L‚Çã‚ÇÅ * im * kx * f * C‚ÇÅ / œÅ‚Çõ
        wfb = -œÅfb_init * (L‚ÇÇ + L‚ÇÄ * (f^2 + c‚Çõ¬≤ * kx^2)) * grav / œÅ‚Çõ

        # Bretherton transforms of final perturbations
        @. ·∂úpb += real(pfb * ·∂úfourier_factor)
        @. ·∂úœÅb += real(œÅfb * ·∂úfourier_factor)
        @. ·∂úub += real(ufb * ·∂úfourier_factor)
        @. ·∂úvb += real(vfb * ·∂úfourier_factor)
        @. ·∂†wb += real(wfb * ·∂†fourier_factor)
        # The imaginary components should be 0 (or at least very close to 0).
    end

    # final state
    @. ·∂úp = ·∂úp‚ÇÄ + ·∂úpb * ·∂úbretherton_factor_pœÅ
    @. ·∂úœÅ = ·∂úœÅ‚ÇÄ + ·∂úœÅb * ·∂úbretherton_factor_pœÅ
    @. ·∂úu = ·∂úu‚ÇÄ + ·∂úub * ·∂úbretherton_factor_uvwT
    @. ·∂úv = ·∂úv‚ÇÄ + ·∂úvb * ·∂úbretherton_factor_uvwT
    @. ·∂†w = ·∂†w‚ÇÄ + ·∂†wb * ·∂†bretherton_factor_uvwT
    @. ·∂úT = ·∂úp / (R_d * ·∂úœÅ)

    @. Y.c.œÅ = ·∂úœÅ
    if ùîº_name == :œÅŒ∏
        @. Y.c.œÅŒ∏ = ·∂úœÅ * ·∂úT * (p_0 / ·∂úp)^(R_d / cp_d)
    elseif ùîº_name == :œÅe
        @. Y.c.œÅe =
            ·∂úœÅ * (
                cv_d * (·∂úT - T_tri) +
                (·∂úu^2 + ·∂úv^2 + ·∂úinterp(·∂†w)^2) / 2 +
                grav * ·∂úz
            )
    elseif ùîº_name == :œÅe_int
        @. Y.c.œÅe_int = ·∂úœÅ * cv_d * (·∂úT - T_tri)
    end
    @. Y.c.u‚Çï = Geometry.Covariant12Vector(Geometry.UVVector(·∂úu, ·∂úv))
    @. Y.f.w = Geometry.Covariant3Vector(Geometry.WVector(·∂†w))
end

function linear_solution(lin_cache, œÅfb_init_array, t)
    (; ·∂úx, ·∂†x, ·∂úz, ·∂†z, ·∂úp‚ÇÄ, ·∂úœÅ‚ÇÄ, ·∂úbretherton_factor_pœÅ) = lin_cache
    (; ·∂úbretherton_factor_uvwT, ·∂†bretherton_factor_uvwT) = lin_cache
    (; ·∂úfourier_factor, ·∂†fourier_factor, ·∂úpb, ·∂úœÅb, ·∂úub, ·∂úvb, ·∂†wb) = lin_cache

    ·∂úpb .= FT(0)
    ·∂úœÅb .= FT(0)
    ·∂úub .= FT(0)
    ·∂úvb .= FT(0)
    ·∂†wb .= FT(0)
    max_ikx, max_ikz = (size(œÅfb_init_array) .- 1) .√∑ 2
    @progress "Y_lin" for ikx in (-max_ikx):max_ikx, ikz in (-max_ikz):max_ikz
        kx = 2 * œÄ / x_max * ikx
        kz = 2 * œÄ / (2 * z_top) * ikz

        # Fourier coefficient of ·∂úœÅb_init (for current kx and kz)
        œÅfb_init = œÅfb_init_array[ikx + max_ikx + 1, ikz + max_ikz + 1]

        # Fourier factors, shifted by u‚ÇÄ * t along the x-axis
        @. ·∂úfourier_factor = exp(im * (kx * (·∂úx - u‚ÇÄ * t) + kz * ·∂úz))
        @. ·∂†fourier_factor = exp(im * (kx * (·∂†x - u‚ÇÄ * t) + kz * ·∂†z))

        # roots of a‚ÇÅ(s)
        p‚ÇÅ = c‚Çõ¬≤ * (kx^2 + kz^2 + Œ¥^2 / 4) + f^2
        q‚ÇÅ = grav * kx^2 * (c‚Çõ¬≤ * Œ¥ - grav) + c‚Çõ¬≤ * f^2 * (kz^2 + Œ¥^2 / 4)
        Œ±¬≤ = p‚ÇÅ / 2 - sqrt(p‚ÇÅ^2 / 4 - q‚ÇÅ)
        Œ≤¬≤ = p‚ÇÅ / 2 + sqrt(p‚ÇÅ^2 / 4 - q‚ÇÅ)
        Œ± = sqrt(Œ±¬≤)
        Œ≤ = sqrt(Œ≤¬≤)

        # inverse Laplace transform of s^p/((s^2 + Œ±^2)(s^2 + Œ≤^2)) for p ‚àà -1:3
        if Œ± == 0
            L‚Çã‚ÇÅ = (Œ≤¬≤ * t^2 / 2 - 1 + cos(Œ≤ * t)) / Œ≤^4
            L‚ÇÄ = (Œ≤ * t - sin(Œ≤ * t)) / Œ≤^3
        else
            L‚Çã‚ÇÅ =
                (-cos(Œ± * t) / Œ±¬≤ + cos(Œ≤ * t) / Œ≤¬≤) / (Œ≤¬≤ - Œ±¬≤) + 1 / (Œ±¬≤ * Œ≤¬≤)
            L‚ÇÄ = (sin(Œ± * t) / Œ± - sin(Œ≤ * t) / Œ≤) / (Œ≤¬≤ - Œ±¬≤)
        end
        L‚ÇÅ = (cos(Œ± * t) - cos(Œ≤ * t)) / (Œ≤¬≤ - Œ±¬≤)
        L‚ÇÇ = (-sin(Œ± * t) * Œ± + sin(Œ≤ * t) * Œ≤) / (Œ≤¬≤ - Œ±¬≤)
        L‚ÇÉ = (-cos(Œ± * t) * Œ±¬≤ + cos(Œ≤ * t) * Œ≤¬≤) / (Œ≤¬≤ - Œ±¬≤)

        # Fourier coefficients of Bretherton transforms of final perturbations
        C‚ÇÅ = grav * (grav - c‚Çõ¬≤ * (im * kz + Œ¥ / 2))
        C‚ÇÇ = grav * (im * kz - Œ¥ / 2)
        pfb = -œÅfb_init * (L‚ÇÅ + L‚Çã‚ÇÅ * f^2) * C‚ÇÅ
        œÅfb =
            œÅfb_init *
            (L‚ÇÉ + L‚ÇÅ * (p‚ÇÅ + C‚ÇÇ) + L‚Çã‚ÇÅ * f^2 * (c‚Çõ¬≤ * (kz^2 + Œ¥^2 / 4) + C‚ÇÇ))
        ufb = œÅfb_init * L‚ÇÄ * im * kx * C‚ÇÅ / œÅ‚Çõ
        vfb = -œÅfb_init * L‚Çã‚ÇÅ * im * kx * f * C‚ÇÅ / œÅ‚Çõ
        wfb = -œÅfb_init * (L‚ÇÇ + L‚ÇÄ * (f^2 + c‚Çõ¬≤ * kx^2)) * grav / œÅ‚Çõ

        # Bretherton transforms of final perturbations
        @. ·∂úpb += real(pfb * ·∂úfourier_factor)
        @. ·∂úœÅb += real(œÅfb * ·∂úfourier_factor)
        @. ·∂úub += real(ufb * ·∂úfourier_factor)
        @. ·∂úvb += real(vfb * ·∂úfourier_factor)
        @. ·∂†wb += real(wfb * ·∂†fourier_factor)
        # The imaginary components should be 0 (or at least very close to 0).
    end

    # final state
    ·∂úp‚Ä≤ = @. ·∂úpb * ·∂úbretherton_factor_pœÅ
    ·∂úœÅ‚Ä≤ = @. ·∂úœÅb * ·∂úbretherton_factor_pœÅ
    ·∂úu‚Ä≤ = @. ·∂úub * ·∂úbretherton_factor_uvwT
    ·∂úv‚Ä≤ = @. ·∂úvb * ·∂úbretherton_factor_uvwT
    ·∂†w‚Ä≤ = @. ·∂†wb * ·∂†bretherton_factor_uvwT
    ·∂úT‚Ä≤ = @. (·∂úp‚ÇÄ + ·∂úp‚Ä≤) / (R_d * (·∂úœÅ‚ÇÄ + ·∂úœÅ‚Ä≤)) - T‚ÇÄ

    return (; ·∂úp‚Ä≤, ·∂úœÅ‚Ä≤, ·∂úu‚Ä≤, ·∂úv‚Ä≤, ·∂†w‚Ä≤, ·∂úT‚Ä≤)
end
