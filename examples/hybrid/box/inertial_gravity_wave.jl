using Printf
using ProgressLogging
using ClimaCorePlots, Plots

# Reference paper: https://rmets.onlinelibrary.wiley.com/doi/pdf/10.1002/qj.2105

const is_small_scale = true
const ·∂úùîº_name = :œÅe
const is_discrete_hydrostatic_balance = true # `false` causes large oscillations

# Constants required for staggered_nonhydrostatic_model
const p_0 = FT(1.0e5)    # reference pressure
const R_d = FT(287.0)    # dry specific gas constant
const Œ∫ = FT(2 / 7)      # kappa
const cp_d = R_d / Œ∫     # heat capacity at constant pressure
const cv_d = cp_d - R_d  # heat capacity at constant volume
const Œ≥ = cp_d / cv_d    # heat capacity ratio
const T_tri = FT(273.16) # triple point temperature
const grav = FT(9.80616) # Earth's gravitational acceleration
# const Œ© = ?            # Earth's rotation rate (not required for flat space)
const f =                # Coriolis frequency
    is_small_scale ? FT(0) : 2 * sin(œÄ / 4) * 2œÄ / FT(86164.09)

# Additional constants required for inertial gravity wave initial condition
const zmax = FT(10e3)
const xmax = is_small_scale ? FT(300e3) : FT(6000e3)
const xmid = is_small_scale ? FT(100e3) : FT(3000e3)
const d = is_small_scale ? FT(5e3) : FT(100e3)
const u‚ÇÄ = is_small_scale ? FT(20) : FT(0)
const v‚ÇÄ = FT(0)
const T‚ÇÄ = FT(250)
const ŒîT = FT(0.01)

# Other convenient constants used in reference paper
const Œ¥ = grav / (R_d * T‚ÇÄ)        # Bretherton height parameter
const c‚Çõ¬≤ = cp_d / cv_d * R_d * T‚ÇÄ # speed of sound squared
const œÅ‚Çõ = p_0 / (R_d * T‚ÇÄ)        # air density at surface

# TODO: Loop over all domain setups used in reference paper
const Œîx = is_small_scale ? FT(1e3) : FT(20e3)
const Œîz = is_small_scale ? Œîx / 2 : Œîx / 40
zelem = Int(zmax / Œîz)
npoly, xelem = 1, Int(xmax / Œîx) # max small-scale dt = 1.5
# npoly, xelem = 4, Int(xmax / (Œîx * (4 + 1))) # max small-scale dt = 0.8

# Animation-related values
animation_duration = FT(10)
fps = 2

# Values required for driver
space =
    ExtrudedSpace(; zmax, zelem, hspace = PeriodicLine(; xmax, xelem, npoly))
tend = is_small_scale ? FT(60 * 60 * 0.5) : FT(60 * 60 * 8)
dt = is_small_scale ? FT(1.5) : FT(20)
dt_save_to_sol = tend / (animation_duration * fps)
ode_algorithm = OrdinaryDiffEq.Rosenbrock23
jacobian_flags =
    (; ‚àÇ·∂úùîº‚Çú‚àÇ·∂†ùïÑ_mode = ·∂úùîº_name == :œÅe ? :no_‚àÇp‚àÇK : :exact, ‚àÇ·∂†ùïÑ‚Çú‚àÇ·∂úœÅ_mode = :exact)
show_progress_bar = true

if is_discrete_hydrostatic_balance
    # Y‚Çú.f.w = 0 in implicit tendency                                        ==>
    # -(·∂†‚àá·µ•(·∂úp) / ·∂†I(·∂úœÅ) + ·∂†‚àá·µ•·∂úŒ¶) = 0                                        ==>
    # ·∂†‚àá·µ•(·∂úp) = -grav * ·∂†I(·∂úœÅ)                                               ==>
    # (p(z + Œîz) - p(z)) / Œîz = -grav * (œÅ(z + Œîz) + œÅ(z)) / 2               ==>
    # p(z + Œîz) + grav * Œîz * œÅ(z + Œîz) / 2 = p(z) - grav * Œîz * œÅ(z) / 2    ==>
    # p(z + Œîz) * (1 + Œ¥ * Œîz / 2) = p(z) * (1 - Œ¥ * Œîz / 2)                 ==>
    # p(z + Œîz) / p(z) = (1 - Œ¥ * Œîz / 2) / (1 + Œ¥ * Œîz / 2)                 ==>
    # p(z) = p(0) * ((1 - Œ¥ * Œîz / 2) / (1 + Œ¥ * Œîz / 2))^(z / Œîz)
    p‚ÇÄ(z) = p_0 * ((1 - Œ¥ * Œîz / 2) / (1 + Œ¥ * Œîz / 2))^(z / Œîz)
else
    p‚ÇÄ(z) = p_0 * exp(-Œ¥ * z)
end
Tb_init(x, z) = ŒîT * exp(-(x - xmid)^2 / d^2) * sin(œÄ * z / zmax)
T‚Ä≤_init(x, z) = Tb_init(x, z) * exp(Œ¥ * z / 2)

function center_initial_condition(local_geometry)
    (; x, z) = local_geometry.coordinates
    p = p‚ÇÄ(z)
    T = T‚ÇÄ + T‚Ä≤_init(x, z)
    œÅ = p / (R_d * T)
    u‚Çï_local = Geometry.UVVector(u‚ÇÄ, v‚ÇÄ)
    u‚Çï = Geometry.Covariant12Vector(u‚Çï_local, local_geometry)
    if ·∂úùîº_name == :œÅŒ∏
        œÅŒ∏ = œÅ * T * (p_0 / p)^(R_d / cp_d)
        return (; œÅ, œÅŒ∏, u‚Çï)
    elseif ·∂úùîº_name == :œÅe
        œÅe = œÅ * (cv_d * (T - T_tri) + norm_sqr(u‚Çï_local) / 2 + grav * z)
        return (; œÅ, œÅe, u‚Çï)
    elseif ·∂úùîº_name == :œÅe_int
        œÅe_int = œÅ * cv_d * (T - T_tri)
        return (; œÅ, œÅe_int, u‚Çï)
    end
end
face_initial_condition(local_geometry) =
    (; w = Geometry.Covariant3Vector(FT(0)))

function postprocessing(sol, p, path)
    ·∂úlocal_geometry = Fields.local_geometry_field(sol.u[1].c)
    ·∂†local_geometry = Fields.local_geometry_field(sol.u[1].f)
    lin_cache = linear_solution_cache(·∂úlocal_geometry, ·∂†local_geometry)
    Y_lin = similar(sol.u[1])

    œÅ‚Ä≤ = Y -> @. Y.c.œÅ - p‚ÇÄ(·∂úlocal_geometry.coordinates.z) / (R_d * T‚ÇÄ)
    if ·∂úùîº_name == :œÅŒ∏
        T‚Ä≤ =
            Y -> @. Y.c.œÅŒ∏ / Y.c.œÅ * (pressure_œÅŒ∏(Y.c.œÅŒ∏) / p_0)^(R_d / cp_d) -
               T‚ÇÄ
    elseif ·∂úùîº_name == :œÅe
        T‚Ä≤ = Y -> begin
            @. p.·∂úK = norm_sqr(C123(Y.c.u‚Çï) + C123(·∂úI(Y.f.w))) / 2
            @. (Y.c.œÅe / Y.c.œÅ - p.·∂úK - p.·∂úŒ¶) / cv_d + T_tri - T‚ÇÄ
        end
    elseif ·∂úùîº_name == :œÅe_int
        T‚Ä≤ = Y -> @. Y.c.œÅe_int / Y.c.œÅ / cv_d + T_tri - T‚ÇÄ
    end
    u‚Ä≤ = Y -> @. Geometry.UVVector(Y.c.u‚Çï).components.data.:1 - u‚ÇÄ
    v‚Ä≤ = Y -> @. Geometry.UVVector(Y.c.u‚Çï).components.data.:2 - v‚ÇÄ
    w‚Ä≤ = Y -> @. Geometry.WVector(Y.f.w).components.data.:1

    for iframe in (1, length(sol.t))
        t = sol.t[iframe]
        Y = sol.u[iframe]
        linear_solution!(Y_lin, lin_cache, t)
        println("Error norms at time t = $t:")
        for (name, f) in ((:œÅ‚Ä≤, œÅ‚Ä≤), (:T‚Ä≤, T‚Ä≤), (:u‚Ä≤, u‚Ä≤), (:v‚Ä≤, v‚Ä≤), (:w‚Ä≤, w‚Ä≤))
            var = f(Y)
            var_lin = f(Y_lin)
            strings = (
                norm_strings(var, var_lin, 2)...,
                norm_strings(var, var_lin, Inf)...,
            )
            println("œï = $name: ", join(strings, ", "))
        end
        println()
    end

    anim_vars = (
        (:Tprime, T‚Ä≤, is_small_scale ? 0.014 : 0.014),
        (:uprime, u‚Ä≤, is_small_scale ? 0.042 : 0.014),
        (:wprime, w‚Ä≤, is_small_scale ? 0.0042 : 0.0014),
    )
    anims = [Animation() for _ in 1:(3 * length(anim_vars))]
    @progress "Animations" for iframe in 1:length(sol.t)
        t = sol.t[iframe]
        Y = sol.u[iframe]
        linear_solution!(Y_lin, lin_cache, t)
        for (ivar, (_, f, var_max)) in enumerate(anim_vars)
            var = f(Y)
            var_lin = f(Y_lin)
            var_rel_err = @. (var - var_lin) / (abs(var_lin) + eps(FT))
            # adding eps(FT) to the denominator prevents divisions by 0
            frame(anims[3 * ivar], plot(var_lin, clim = (-var_max, var_max)))
            frame(anims[3 * ivar - 1], plot(var, clim = (-var_max, var_max)))
            frame(anims[3 * ivar - 2], plot(var_rel_err, clim = (-10, 10)))
        end
    end
    for (ivar, (name, _, _)) in enumerate(anim_vars)
        mp4(anims[3 * ivar], joinpath(path, "$(name)_lin.mp4"); fps)
        mp4(anims[3 * ivar - 1], joinpath(path, "$name.mp4"); fps)
        mp4(anims[3 * ivar - 2], joinpath(path, "$(name)_rel_err.mp4"); fps)
    end
end

function norm_strings(var, var_lin, p)
    norm_err = norm(var .- var_lin, p; normalize = false)
    scaled_norm_err = norm_err / norm(var_lin, p; normalize = false)
    return (
        @sprintf("‚Äñœï‚Äñ_%d = %-#9.4g", p, norm(var, p; normalize = false)),
        @sprintf("‚Äñœï - œï_lin‚Äñ_%d = %-#9.4g", p, norm_err),
        @sprintf("‚Äñœï - œï_lin‚Äñ_%d/‚Äñœï_lin‚Äñ_%d = %-#9.4g", p, p, scaled_norm_err),
    )
end

# min_Œªx = 2 * (xmax / xelem) / upsampling_factor # should this involve npoly?
# min_Œªz = 2 * (zmax / zelem) / upsampling_factor
# min_Œªx = 2 * œÄ / max_kx = xmax / max_ikx
# min_Œªz = 2 * œÄ / max_kz = 2 * zmax / max_ikz
# max_ikx = xmax / min_Œªx = upsampling_factor * xelem / 2
# max_ikz = 2 * zmax / min_Œªz = upsampling_factor * zelem
function œÅÃÇb_init_coefs(
    upsampling_factor = 3,
    max_ikx = upsampling_factor * xelem √∑ 2,
    max_ikz = upsampling_factor * zelem,
)
    # upsampled coordinates (more upsampling gives more accurate coefficients)
    space = ExtrudedSpace(;
        zmax,
        zelem = upsampling_factor * zelem,
        hspace = PeriodicLine(; xmax, xelem = upsampling_factor * xelem, npoly),
    )
    ·∂úlocal_geometry, _ = local_geometry_fields(space)
    ·∂úx = ·∂úlocal_geometry.coordinates.x
    ·∂úz = ·∂úlocal_geometry.coordinates.z

    # Bretherton transform of initial perturbation
    linearize_density_perturbation = false
    if linearize_density_perturbation
        ·∂úœÅb_init = @. -œÅ‚Çõ * Tb_init(·∂úx, ·∂úz) / T‚ÇÄ
    else
        ·∂úp‚ÇÄ = @. p‚ÇÄ(·∂úz)
        ·∂úœÅ‚ÇÄ = @. ·∂úp‚ÇÄ / (R_d * T‚ÇÄ)
        ·∂úœÅ‚Ä≤_init = @. ·∂úp‚ÇÄ / (R_d * (T‚ÇÄ + T‚Ä≤_init(·∂úx, ·∂úz))) - ·∂úœÅ‚ÇÄ
        ·∂úbretherton_factor_pœÅ = @. exp(-Œ¥ * ·∂úz / 2)
        ·∂úœÅb_init = @. ·∂úœÅ‚Ä≤_init / ·∂úbretherton_factor_pœÅ
    end

    # Fourier coefficients of Bretherton transform of initial perturbation
    œÅÃÇb_init_array = Array{Complex{FT}}(undef, 2 * max_ikx + 1, 2 * max_ikz + 1)
    ·∂úfourier_factor = Fields.Field(Complex{FT}, axes(·∂úlocal_geometry))
    ·∂úintegrand = Fields.Field(Complex{FT}, axes(·∂úlocal_geometry))
    unit_integral = 2 * sum(one.(·∂úœÅb_init))
    # Since the coefficients are for a modified domain of height 2 * zmax, the
    # unit integral over the domain must be multiplied by 2 to ensure correct
    # normalization. On the other hand, ·∂úœÅb_init is assumed to be 0 outside of
    # the "true" domain, so the integral of ·∂úintegrand should not be modified.
    @progress "œÅÃÇb_init" for ikx in (-max_ikx):max_ikx,
        ikz in (-max_ikz):max_ikz

        kx = 2 * œÄ / xmax * ikx
        kz = 2 * œÄ / (2 * zmax) * ikz
        @. ·∂úfourier_factor = exp(im * (kx * ·∂úx + kz * ·∂úz))
        @. ·∂úintegrand = ·∂úœÅb_init / ·∂úfourier_factor
        œÅÃÇb_init_array[ikx + max_ikx + 1, ikz + max_ikz + 1] =
            sum(·∂úintegrand) / unit_integral
    end
    return œÅÃÇb_init_array
end

function linear_solution_cache(·∂úlocal_geometry, ·∂†local_geometry)
    ·∂úz = ·∂úlocal_geometry.coordinates.z
    ·∂†z = ·∂†local_geometry.coordinates.z
    ·∂úp‚ÇÄ = @. p‚ÇÄ(·∂úz)
    return (;
        # coordinates
        ·∂úx = ·∂úlocal_geometry.coordinates.x,
        ·∂†x = ·∂†local_geometry.coordinates.x,
        ·∂úz,
        ·∂†z,

        # background state
        ·∂úp‚ÇÄ,
        ·∂úœÅ‚ÇÄ = (@. ·∂úp‚ÇÄ / (R_d * T‚ÇÄ)),
        ·∂úu‚ÇÄ = map(_ -> u‚ÇÄ, ·∂úlocal_geometry),
        ·∂úv‚ÇÄ = map(_ -> v‚ÇÄ, ·∂úlocal_geometry),
        ·∂†w‚ÇÄ = map(_ -> FT(0), ·∂†local_geometry),

        # Bretherton transform factors
        ·∂úbretherton_factor_pœÅ = (@. exp(-Œ¥ * ·∂úz / 2)),
        ·∂úbretherton_factor_uvwT = (@. exp(Œ¥ * ·∂úz / 2)),
        ·∂†bretherton_factor_uvwT = (@. exp(Œ¥ * ·∂†z / 2)),

        # Fourier coefficients of Bretherton transform of initial perturbation
        œÅÃÇb_init_array = œÅÃÇb_init_coefs(),

        # Fourier transform factors
        ·∂úfourier_factor = Fields.Field(Complex{FT}, axes(·∂úlocal_geometry)),
        ·∂†fourier_factor = Fields.Field(Complex{FT}, axes(·∂†local_geometry)),

        # Bretherton transform of final perturbation
        ·∂úpb = Fields.Field(FT, axes(·∂úlocal_geometry)),
        ·∂úœÅb = Fields.Field(FT, axes(·∂úlocal_geometry)),
        ·∂úub = Fields.Field(FT, axes(·∂úlocal_geometry)),
        ·∂úvb = Fields.Field(FT, axes(·∂úlocal_geometry)),
        ·∂†wb = Fields.Field(FT, axes(·∂†local_geometry)),

        # final state
        ·∂úp = Fields.Field(FT, axes(·∂úlocal_geometry)),
        ·∂úœÅ = Fields.Field(FT, axes(·∂úlocal_geometry)),
        ·∂úu = Fields.Field(FT, axes(·∂úlocal_geometry)),
        ·∂úv = Fields.Field(FT, axes(·∂úlocal_geometry)),
        ·∂†w = Fields.Field(FT, axes(·∂†local_geometry)),

        # final temperature
        ·∂úT = Fields.Field(FT, axes(·∂úlocal_geometry)),
    )
end

function linear_solution!(Y, lin_cache, t)
    (;
        ·∂úx,
        ·∂†x,
        ·∂úz,
        ·∂†z,
        ·∂úp‚ÇÄ,
        ·∂úœÅ‚ÇÄ,
        ·∂úu‚ÇÄ,
        ·∂úv‚ÇÄ,
        ·∂†w‚ÇÄ,
        ·∂úbretherton_factor_pœÅ,
        ·∂úbretherton_factor_uvwT,
        ·∂†bretherton_factor_uvwT,
        œÅÃÇb_init_array,
        ·∂úfourier_factor,
        ·∂†fourier_factor,
        ·∂úpb,
        ·∂úœÅb,
        ·∂úub,
        ·∂úvb,
        ·∂†wb,
        ·∂úp,
        ·∂úœÅ,
        ·∂úu,
        ·∂úv,
        ·∂†w,
        ·∂úT,
    ) = lin_cache

    ·∂úpb .= FT(0)
    ·∂úœÅb .= FT(0)
    ·∂úub .= FT(0)
    ·∂úvb .= FT(0)
    ·∂†wb .= FT(0)
    max_ikx, max_ikz = (size(œÅÃÇb_init_array) .- 1) .√∑ 2
    for ikx in (-max_ikx):max_ikx, ikz in (-max_ikz):max_ikz
        kx = 2 * œÄ / xmax * ikx
        kz = 2 * œÄ / (2 * zmax) * ikz

        # Fourier coefficient of ·∂úœÅb_init (for current kx and kz)
        œÅÃÇb_init = œÅÃÇb_init_array[ikx + max_ikx + 1, ikz + max_ikz + 1]

        # Fourier factors, shifted by u‚ÇÄ * t along the x-axis
        @. ·∂úfourier_factor = exp(im * (kx * (·∂úx - u‚ÇÄ * t) + kz * ·∂úz))
        @. ·∂†fourier_factor = exp(im * (kx * (·∂†x - u‚ÇÄ * t) + kz * ·∂†z))

        # roots of a‚ÇÅ(s)
        p‚ÇÅ = c‚Çõ¬≤ * (kx^2 + kz^2 + Œ¥^2 / 4) + f^2
        q‚ÇÅ = grav * kx^2 * (c‚Çõ¬≤ * Œ¥ - grav) + c‚Çõ¬≤ * f^2 * (kz^2 + Œ¥^2 / 4)
        Œ±¬≤ = p‚ÇÅ / 2 - sqrt(p‚ÇÅ^2 / 4 - q‚ÇÅ)
        Œ≤¬≤ = p‚ÇÅ / 2 + sqrt(p‚ÇÅ^2 / 4 - q‚ÇÅ)
        Œ± = sqrt(Œ±¬≤)
        Œ≤ = sqrt(Œ≤¬≤)

        # inverse Laplace transform of s^p/((s^2 + Œ±^2)(s^2 + Œ≤^2)) for p ‚àà -1:3
        if Œ± == 0
            L‚Çã‚ÇÅ = (Œ≤¬≤ * t^2 / 2 - 1 + cos(Œ≤ * t)) / Œ≤^4
            L‚ÇÄ = (Œ≤ * t - sin(Œ≤ * t)) / Œ≤^3
        else
            L‚Çã‚ÇÅ =
                (-cos(Œ± * t) / Œ±¬≤ + cos(Œ≤ * t) / Œ≤¬≤) / (Œ≤¬≤ - Œ±¬≤) + 1 / (Œ±¬≤ * Œ≤¬≤)
            L‚ÇÄ = (sin(Œ± * t) / Œ± - sin(Œ≤ * t) / Œ≤) / (Œ≤¬≤ - Œ±¬≤)
        end
        L‚ÇÅ = (cos(Œ± * t) - cos(Œ≤ * t)) / (Œ≤¬≤ - Œ±¬≤)
        L‚ÇÇ = (-sin(Œ± * t) * Œ± + sin(Œ≤ * t) * Œ≤) / (Œ≤¬≤ - Œ±¬≤)
        L‚ÇÉ = (-cos(Œ± * t) * Œ±¬≤ + cos(Œ≤ * t) * Œ≤¬≤) / (Œ≤¬≤ - Œ±¬≤)

        # Fourier coefficients of Bretherton transforms of final perturbations
        C‚ÇÅ = grav * (grav - c‚Çõ¬≤ * (im * kz + Œ¥ / 2))
        C‚ÇÇ = grav * (im * kz - Œ¥ / 2)
        pÃÇb = -œÅÃÇb_init * (L‚ÇÅ + L‚Çã‚ÇÅ * f^2) * C‚ÇÅ
        œÅÃÇb =
            œÅÃÇb_init *
            (L‚ÇÉ + L‚ÇÅ * (p‚ÇÅ + C‚ÇÇ) + L‚Çã‚ÇÅ * f^2 * (c‚Çõ¬≤ * (kz^2 + Œ¥^2 / 4) + C‚ÇÇ))
        uÃÇb = œÅÃÇb_init * L‚ÇÄ * im * kx * C‚ÇÅ / œÅ‚Çõ
        vÃÇb = -œÅÃÇb_init * L‚Çã‚ÇÅ * im * kx * f * C‚ÇÅ / œÅ‚Çõ
        wÃÇb = -œÅÃÇb_init * (L‚ÇÇ + L‚ÇÄ * (f^2 + c‚Çõ¬≤ * kx^2)) * grav / œÅ‚Çõ

        # Bretherton transforms of final perturbations
        @. ·∂úpb += real(pÃÇb * ·∂úfourier_factor)
        @. ·∂úœÅb += real(œÅÃÇb * ·∂úfourier_factor)
        @. ·∂úub += real(uÃÇb * ·∂úfourier_factor)
        @. ·∂úvb += real(vÃÇb * ·∂úfourier_factor)
        @. ·∂†wb += real(wÃÇb * ·∂†fourier_factor)
        # The imaginary components should be 0 (or at least very close to 0).
    end

    # final state
    @. ·∂úp = ·∂úp‚ÇÄ + ·∂úpb * ·∂úbretherton_factor_pœÅ
    @. ·∂úœÅ = ·∂úœÅ‚ÇÄ + ·∂úœÅb * ·∂úbretherton_factor_pœÅ
    @. ·∂úu = ·∂úu‚ÇÄ + ·∂úub * ·∂úbretherton_factor_uvwT
    @. ·∂úv = ·∂úv‚ÇÄ + ·∂úvb * ·∂úbretherton_factor_uvwT
    @. ·∂†w = ·∂†w‚ÇÄ + ·∂†wb * ·∂†bretherton_factor_uvwT
    @. ·∂úT = ·∂úp / (R_d * ·∂úœÅ)

    @. Y.c.œÅ = ·∂úœÅ
    if ·∂úùîº_name == :œÅŒ∏
        @. Y.c.œÅŒ∏ = ·∂úœÅ * ·∂úT * (p_0 / ·∂úp)^(R_d / cp_d)
    elseif ·∂úùîº_name == :œÅe
        @. Y.c.œÅe =
            ·∂úœÅ *
            (cv_d * (·∂úT - T_tri) + (·∂úu^2 + ·∂úv^2 + ·∂úI(·∂†w)^2) / 2 + grav * ·∂úz)
    elseif ·∂úùîº_name == :œÅe_int
        @. Y.c.œÅe_int = ·∂úœÅ * cv_d * (·∂úT - T_tri)
    end
    @. Y.c.u‚Çï = Geometry.Covariant12Vector(Geometry.UVVector(·∂úu, ·∂úv))
    @. Y.f.w = Geometry.Covariant3Vector(Geometry.WVector(·∂†w))
end
