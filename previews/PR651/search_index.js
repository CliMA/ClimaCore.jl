var documenterSearchIndex = {"docs":
[{"location":"references/#References","page":"References","title":"References","text":"","category":"section"},{"location":"references/","page":"References","title":"References","text":"","category":"page"},{"location":"lib/ClimaCoreVTK/#ClimaCoreVTK.jl","page":"ClimaCoreVTK.jl","title":"ClimaCoreVTK.jl","text":"","category":"section"},{"location":"lib/ClimaCoreVTK/","page":"ClimaCoreVTK.jl","title":"ClimaCoreVTK.jl","text":"CurrentModule = ClimaCoreVTK","category":"page"},{"location":"lib/ClimaCoreVTK/","page":"ClimaCoreVTK.jl","title":"ClimaCoreVTK.jl","text":"ClimaCoreVTK.jl provides functionality for writing ClimaCore fields to VTK files, using the WriteVTK.jl package.","category":"page"},{"location":"lib/ClimaCoreVTK/#Interface","page":"ClimaCoreVTK.jl","title":"Interface","text":"","category":"section"},{"location":"lib/ClimaCoreVTK/","page":"ClimaCoreVTK.jl","title":"ClimaCoreVTK.jl","text":"writevtk\nwritepvd","category":"page"},{"location":"lib/ClimaCoreVTK/#ClimaCoreVTK.writevtk","page":"ClimaCoreVTK.jl","title":"ClimaCoreVTK.writevtk","text":"writevtk(\n    basename::String,\n    fields;\n    basis=:cell,\n    latlong=false,\n    vtkargs...\n)\n\nWrite fields to as an unstructured mesh VTK file named basename.vtu.\n\nfields can be either:\n\na ClimaCore Field object,\na FieldVector object,\na NamedTuple of Fields.\n\nThe basis keyword option determines the type of cells used to write.:\n\n:cell (default): output values at cell centers (interpolating where necessary).\n:point: output values at cell vertices.\n:lagrange: output values at Lagrange nodes (valid only for spectral element spaces), using Use VTK Lagrange cells to accurately represent high-order elements.\n\nThe latlong=true keyword option will output a spherical or spherical shell domain using the Mercator projection, with longitude along the x-axis, latitude along the y-axis, and altitude along the z-axis (if applicable). Note this currently only displays correctly if the number of elements across the cubed sphere face is even.\n\nAny additional keyword arguments are passed to WriteVTK.vtk_grid.\n\n\n\n\n\n","category":"function"},{"location":"lib/ClimaCoreVTK/#ClimaCoreVTK.writepvd","page":"ClimaCoreVTK.jl","title":"ClimaCoreVTK.writepvd","text":"writepvd(\n    basename::String,\n    times,\n    fields;\n    vtkargs...\n)\n\nWrite a sequence of fields at times as a Paraview collection (.pvd) file, along with VTK files.\n\nfields can be either be an iterable collection of fields, or a NamedTuple of collections.\n\n\n\n\n\n","category":"function"},{"location":"lib/ClimaCoreVTK/#Internal-functions","page":"ClimaCoreVTK.jl","title":"Internal functions","text":"","category":"section"},{"location":"lib/ClimaCoreVTK/","page":"ClimaCoreVTK.jl","title":"ClimaCoreVTK.jl","text":"vtk_grid\nvtk_cells_lagrange\nvtk_cells_linear\nvtk_grid_space\nvtk_cell_space\naddfield!","category":"page"},{"location":"lib/ClimaCoreVTK/#WriteVTK.vtk_grid","page":"ClimaCoreVTK.jl","title":"WriteVTK.vtk_grid","text":"vtk_grid(basename, gridspace::ClimaCore.Spaces.AbstractSpace;\n    basis=:cell, vtkargs...)\n\nConstruct a VTK grid from a ClimaCore.Spaces.AbstractSpace. If basis=:lagrange, it will construct a mesh made of Lagrange cells (valid only for spectral element spaces), otherwise it will it subdivide the space into quads, with vertices at nodal points.\n\n\n\n\n\n","category":"function"},{"location":"lib/ClimaCoreVTK/#ClimaCoreVTK.vtk_cells_lagrange","page":"ClimaCoreVTK.jl","title":"ClimaCoreVTK.vtk_cells_lagrange","text":"vtkcellslagrange(space)\n\nConstruct a vector of MeshCell objects representing the elements of space as an unstuctured mesh of Lagrange polynomial cells, suitable for passing to vtk_grid.\n\n\n\n\n\n","category":"function"},{"location":"lib/ClimaCoreVTK/#ClimaCoreVTK.vtk_cells_linear","page":"ClimaCoreVTK.jl","title":"ClimaCoreVTK.vtk_cells_linear","text":"vtkcellslinear(space)\n\nConstruct a vector of MeshCell objects representing the elements of space as an unstuctured mesh of linear cells, suitable for passing to vtk_grid.\n\n\n\n\n\n","category":"function"},{"location":"lib/ClimaCoreVTK/#ClimaCoreVTK.vtk_grid_space","page":"ClimaCoreVTK.jl","title":"ClimaCoreVTK.vtk_grid_space","text":"vtk_grid_space(space::ClimaCore.Spaces.AbstractSpace)\n\nThe space for the grid used by VTK, for any field on space.\n\nThis generally does two things:\n\nModifies the horizontal space to use a ClosedUniform quadrature rule, which will use equispaced nodal points in the reference element. This is required for using VTK Lagrange elements (see 1).\nModifies the vertical space to be on the faces.\n\n\n\n\n\n","category":"function"},{"location":"lib/ClimaCoreVTK/#ClimaCoreVTK.vtk_cell_space","page":"ClimaCoreVTK.jl","title":"ClimaCoreVTK.vtk_cell_space","text":"vtk_cell_space(gridspace::ClimaCore.Spaces.AbstractSpace)\n\nConstruct a space for outputting cell data, when using outputting a grid gridspace. be stored.\n\nThis generally does two things:\n\nModifies the horizontal space to use a Uniform quadrature rule, which will use equispaced nodal points in the reference element (excluding the boundary).\nModifies the vertical space to be on the centers.\n\n\n\n\n\n","category":"function"},{"location":"lib/ClimaCoreVTK/#ClimaCoreVTK.addfield!","page":"ClimaCoreVTK.jl","title":"ClimaCoreVTK.addfield!","text":"addfield!(vtkfile, prefix::Union{String,Nothing}, f, dataspace)\n\nAdd a field or fields f, optionally prefixing the name with prefix to the VTK file vtkfile, interpolating to dataspace.\n\nf can be any of the following:\n\na scalar or vector field (if no prefix is provided, then the field will be named \"data\")\na composite field, which will be named accordingly\na NamedTuple of fields\n\n\n\n\n\n","category":"function"},{"location":"intro/#Introduction-to-ClimaCore.jl's-API-concepts","page":"Introduction","title":"Introduction to ClimaCore.jl's API concepts","text":"","category":"section"},{"location":"intro/#What-is-ClimaCore.jl?","page":"Introduction","title":"What is ClimaCore.jl?","text":"","category":"section"},{"location":"intro/","page":"Introduction","title":"Introduction","text":"A suite of tools for constructing spatial discretizations, entirely written in Julia.","category":"page"},{"location":"intro/","page":"Introduction","title":"Introduction","text":"primarily aimed at climate and weather models\ninitial aim:\nspectral element discretizations (both Continuous Galerkin and Discontinuous Galerkin) in the horizontal\nstaggered finite difference in the vertical\nsupport for Cartesian and spherical domains\ncurrently under development.","category":"page"},{"location":"intro/","page":"Introduction","title":"Introduction","text":"A sketch of some fundamental API objects in ClimaCore.jl:","category":"page"},{"location":"intro/","page":"Introduction","title":"Introduction","text":"(Image: ClimaCore.jl API objects)","category":"page"},{"location":"intro-to-vectors/#Introduction-to-Vectors-and-Vector-Fields-in-ClimaCore.jl","page":"-","title":"Introduction to Vectors and Vector Fields in ClimaCore.jl","text":"","category":"section"},{"location":"intro-to-vectors/","page":"-","title":"-","text":"Vector can mean a few things depending on context:","category":"page"},{"location":"intro-to-vectors/","page":"-","title":"-","text":"In Julia, a Vector is just an ordered collection of values (i.e., a container).\nIn mathematics, a vector is an element of a vector space: a set of objects,","category":"page"},{"location":"intro-to-vectors/","page":"-","title":"-","text":"which may be added together and multiplied by a scalar.","category":"page"},{"location":"intro-to-vectors/","page":"-","title":"-","text":"In physics, a vector typically refers to a directional quantity: that is","category":"page"},{"location":"intro-to-vectors/","page":"-","title":"-","text":"something with both a direction and a magnitude. This is the best way to think of vectors in ClimaCore,jl.","category":"page"},{"location":"intro-to-vectors/","page":"-","title":"-","text":"A vector field is then a vector-valued field: that is an assignment of a vector to each point in a space. For instance, a vector field in the plane can be visualised as a collection of arrows with a given magnitude and direction, each attached to a point in the plane.","category":"page"},{"location":"intro-to-vectors/","page":"-","title":"-","text":"In a coordinate system, a vector field on a domain in n-dimensional Euclidean space can be represented as a vector-valued function that associates an n-tuple of real numbers to each point of the domain. This representation of a vector field depends on the coordinate system, and there are transformation laws for passing from one coordinate system to the other.","category":"page"},{"location":"intro-to-vectors/","page":"-","title":"-","text":"ClmaCore supports different coordinate systems and, therefore, vector representations. In fact, one of the key requirements of ClimaCore is to support vectors specified in orthogonal (Cartesian) and curvilinear coordinate systems.","category":"page"},{"location":"intro-to-vectors/#LocalVector:-UVector,-UVVector,-and-UVWVector,-etc;-a-\"universal\"-basis","page":"-","title":"LocalVector: UVector, UVVector, and UVWVector, etc; a \"universal\" basis","text":"","category":"section"},{"location":"intro-to-vectors/","page":"-","title":"-","text":"The easiest basis to use is the \"UVW\" basis, which can be defined in both Cartesian or spherical domains:","category":"page"},{"location":"intro-to-vectors/","page":"-","title":"-","text":"in a Cartesian domain, it is the usual Cartesian orthogonal vector basis","category":"page"},{"location":"intro-to-vectors/","page":"-","title":"-","text":"(U along the X-axis, V along the Y-axis, W along the Z-axis).","category":"page"},{"location":"intro-to-vectors/","page":"-","title":"-","text":"in a spherical domain, it is the orthogonal basis relative to spherical","category":"page"},{"location":"intro-to-vectors/","page":"-","title":"-","text":"(curvilinear) coordinates:","category":"page"},{"location":"intro-to-vectors/","page":"-","title":"-","text":"U is the zonal (eastward) component\nV is the meridonal (northward) component\nW is the radial component","category":"page"},{"location":"intro-to-vectors/","page":"-","title":"-","text":"It has some nice properties which make it convenient:","category":"page"},{"location":"intro-to-vectors/","page":"-","title":"-","text":"it's an orthonormal basis:\nit is easy to decompose a vector (take the projection along the basis)\nthe components are easy to interpret (they have unit scale)\nallow us to write code across domains\nU and V are always horizontal, W is vertical","category":"page"},{"location":"intro-to-vectors/","page":"-","title":"-","text":"We can define \"generic\" vectors via UVector, UVVector, and UVWVector that can be equally defined on Cartesian or spherical spaces.","category":"page"},{"location":"intro-to-vectors/","page":"-","title":"-","text":"But if users need to compute with them, or feed differential operators with them, then may want to consider different bases, as not all operators accept all bases.","category":"page"},{"location":"intro-to-vectors/#Covariant-and-Contravariant-bases","page":"-","title":"Covariant and Contravariant bases","text":"","category":"section"},{"location":"intro-to-vectors/","page":"-","title":"-","text":"(Image: Different bases supported in ClimaCore.jl)","category":"page"},{"location":"intro-to-vectors/","page":"-","title":"-","text":"Covariance and contravariance describe how the quantitative description of certain geometric or physical entities changes with a change of basis.","category":"page"},{"location":"intro-to-vectors/","page":"-","title":"-","text":"In ClimaCore.jl, the covariant basis is specified by the partial derivative of the transformation from the reference element xi in -11^d (where d is the dimensionality of the domain Omega) to x in the physical space:","category":"page"},{"location":"intro-to-vectors/","page":"-","title":"-","text":"mathbfe_i = fracpartial xpartial xi^i","category":"page"},{"location":"intro-to-vectors/","page":"-","title":"-","text":"while the contravariant basis is the opposite: gradient in x of the coordinate (the inverse map)","category":"page"},{"location":"intro-to-vectors/","page":"-","title":"-","text":"mathbfe^i = nabla_x xi^i","category":"page"},{"location":"intro-to-vectors/","page":"-","title":"-","text":"Note:","category":"page"},{"location":"intro-to-vectors/","page":"-","title":"-","text":"these are specific to a given element: you generally can't compare covariant or contravariant component from one element with that in another\nin this case, you need to first convert them to UVW basis (e.g. we do this for DSS operations)\nwe choose the coordinates of the reference element so that xi^1 and xi^2 are horizontal, and xi^3 is vertical\nin a Cartesian domain, this means that covariant and contravariant components are just rescaled versions of the UVW components.\n\nthings get a little more complicated in the presence of terrain, but xi^3 is radially aligned\nthe 3rd covariant component is aligned with W, but the 3rd contravariant component may not be (e.g. at the surface it is normal to the boundary).","category":"page"},{"location":"intro-to-vectors/#Cartesian-bases","page":"-","title":"Cartesian bases","text":"","category":"section"},{"location":"intro-to-vectors/","page":"-","title":"-","text":"Analogously to CartesianPoints, in ClimaCore, there are also CartesianVectors: these allow conversion to a global Cartesian basis. It is intended mainly for visualization purposes.","category":"page"},{"location":"intro-to-vectors/#Conversions","page":"-","title":"Conversions","text":"","category":"section"},{"location":"intro-to-vectors/","page":"-","title":"-","text":"To convert between different vector bases, you need a LocalGeometry object: this contains all the necessary information (coordinates, metric terms, etc) to do the conversion. These are constructed as part of the Space.","category":"page"},{"location":"performance_tips/#Performance-tips-and-monitoring","page":"Performance tips","title":"Performance tips and monitoring","text":"","category":"section"},{"location":"performance_tips/","page":"Performance tips","title":"Performance tips","text":"This document outlines some performance tips and performance monitoring strategies.","category":"page"},{"location":"performance_tips/","page":"Performance tips","title":"Performance tips","text":"For the most part, this document focuses on some of the common performance gotcha's that we've observed in the CliMA codebase.","category":"page"},{"location":"performance_tips/","page":"Performance tips","title":"Performance tips","text":"There is a very good and thorough overview of performance tips in Julia's docs.","category":"page"},{"location":"performance_tips/#Avoiding-global-variables","page":"Performance tips","title":"Avoiding global variables","text":"","category":"section"},{"location":"performance_tips/","page":"Performance tips","title":"Performance tips","text":"Julia allows for function closures, which can be very handy, but can also result in performance cliffs, specifically if the captured variable is a non-constant global variable. So, for that reason, it's recommended to avoid closures when possible.","category":"page"},{"location":"performance_tips/#Dynamic-memory-allocations","page":"Performance tips","title":"Dynamic memory allocations","text":"","category":"section"},{"location":"performance_tips/","page":"Performance tips","title":"Performance tips","text":"Some Julia functions incur allocations. For example, push! dynamically allocates memory. Sometimes, we can avoid using push! if the length of the container we're pushing to is known. If the length is unknown, then one can use alternative methods, for example, map. In addition, if push! is the only viable option, it's recommended to specify (if possible) the container type. For example, Float64[] and not []. see these docs for more details.","category":"page"},{"location":"performance_tips/#Tracking-allocations","page":"Performance tips","title":"Tracking allocations","text":"","category":"section"},{"location":"performance_tips/","page":"Performance tips","title":"Performance tips","text":"Julia's performance docs above recommends to pay close attention to allocations. Allocations can be coarsely reported with the @time macro and more finely reported by using julia --track-allocation=all. From CodeCov.jl's docs:","category":"page"},{"location":"performance_tips/","page":"Performance tips","title":"Performance tips","text":"Start julia with","category":"page"},{"location":"performance_tips/","page":"Performance tips","title":"Performance tips","text":"julia --track-allocation=user","category":"page"},{"location":"performance_tips/","page":"Performance tips","title":"Performance tips","text":"Then:","category":"page"},{"location":"performance_tips/","page":"Performance tips","title":"Performance tips","text":"Run whatever commands you wish to test. This first run is to ensure that everything is compiled (because compilation allocates memory).\nCall Profile.clear_malloc_data()\nRun your commands again\nQuit julia","category":"page"},{"location":"performance_tips/","page":"Performance tips","title":"Performance tips","text":"Finally, navigate to the directory holding your source code. Start julia (without command-line flags), and analyze the results using","category":"page"},{"location":"performance_tips/","page":"Performance tips","title":"Performance tips","text":"using Coverage\nanalyze_malloc(dirnames)  # could be \".\" for the current directory, or \"src\", etc.","category":"page"},{"location":"performance_tips/","page":"Performance tips","title":"Performance tips","text":"This will return a vector of MallocInfo objects, specifying the number of bytes allocated, the file name, and the line number. These are sorted in increasing order of allocation size.","category":"page"},{"location":"performance_tips/#ReportMetrics.jl","page":"Performance tips","title":"ReportMetrics.jl","text":"","category":"section"},{"location":"performance_tips/","page":"Performance tips","title":"Performance tips","text":"CliMA's ReportMetrics.jl applies the strategy in the above section and provides a re-useable interface for reporting the top-most important allocations. Here is an example of it in use:","category":"page"},{"location":"performance_tips/","page":"Performance tips","title":"Performance tips","text":"rep_workload.jl\nperf.jl","category":"page"},{"location":"performance_tips/","page":"Performance tips","title":"Performance tips","text":"# File: rep_workload.jl\nimport Profile\n\nx = rand(1000)\n\nfunction foo()\n    s = 0.0\n    for i in x\n        s += i - rand()\n    end\n    return s\nend\n\nfor i in 1:100\n    foo()\nend\nProfile.clear_malloc_data()\nfor i in 1:100\n    foo()\nend","category":"page"},{"location":"performance_tips/","page":"Performance tips","title":"Performance tips","text":"# perf.jl\nimport ReportMetrics\nReportMetrics.report_allocs(;\n    job_name = \"RA_example\",\n    run_cmd = `$(Base.julia_cmd()) --track-allocation=all rep_workload.jl`,\n    dirs_to_monitor = [pwd()],\n)","category":"page"},{"location":"performance_tips/","page":"Performance tips","title":"Performance tips","text":"This will print out something like the following:","category":"page"},{"location":"performance_tips/","page":"Performance tips","title":"Performance tips","text":"[ Info: RA_example: Number of unique allocating sites: 2\n┌───────────────┬─────────────┬─────────────────────────────────────────┐\n│ Allocations % │ Allocations │                    <file>:<line number> │\n│       (xᵢ/∑x) │     (bytes) │                                         │\n├───────────────┼─────────────┼─────────────────────────────────────────┤\n│            77 │     7996800 │ ReportMetrics.jl/test/rep_workload.jl:7 │\n│            23 │     2387200 │ ReportMetrics.jl/test/rep_workload.jl:6 │\n└───────────────┴─────────────┴─────────────────────────────────────────┘","category":"page"},{"location":"performance_tips/","page":"Performance tips","title":"Performance tips","text":"From here, one can investigate where the most important allocations are coming from. Often, allocations arise from either:","category":"page"},{"location":"performance_tips/","page":"Performance tips","title":"Performance tips","text":"Using functions that inherently allocate\nFor example, push! inherently allocates\nAnother example: defining a new variable a = c .+ b. Here, a is a newly allocated variable. It could be put into a cache and computed in-place via a .= c .+ b, which is non-allocating for Julia-native types (e.g., Arrays).\nType instabilities. Sometimes type-instabilities can trigger the compiler to perform runtime inference, which results in allocations. So, fixing type instabilities is one way to fix / remove allocations.","category":"page"},{"location":"performance_tips/#References","page":"Performance tips","title":"References","text":"","category":"section"},{"location":"performance_tips/","page":"Performance tips","title":"Performance tips","text":"General julia-specific performance tips\nCode-coverage while tracking allocations\nCliMA's ReportMetrics.jl","category":"page"},{"location":"api/#API","page":"API","title":"API","text":"","category":"section"},{"location":"api/","page":"API","title":"API","text":"CurrentModule = ClimaCore","category":"page"},{"location":"api/#DataLayouts","page":"API","title":"DataLayouts","text":"","category":"section"},{"location":"api/","page":"API","title":"API","text":"DataLayouts\nDataLayouts.IF\nDataLayouts.IJF\nDataLayouts.VF\nDataLayouts.IFH\nDataLayouts.IJFH\nDataLayouts.VIFH\nDataLayouts.VIJFH","category":"page"},{"location":"api/#ClimaCore.DataLayouts","page":"API","title":"ClimaCore.DataLayouts","text":"ClimaCore.DataLayouts\n\nNotation:\n\ni,j are horizontal node indices within an element\nk is the vertical node index within an element\nf is the field index\nv is the vertical element index in a stack\nh is the element stack index\n\nData layout is specified by the order in which they appear, e.g. IJKFVH indexes the underlying array as [i,j,k,f,v,h]\n\n\n\n\n\n","category":"module"},{"location":"api/#ClimaCore.DataLayouts.IF","page":"API","title":"ClimaCore.DataLayouts.IF","text":"IF{S, Ni, A} <: DataSlab1D{S, Ni}\n\nBacking DataLayout for 1D spectral element slab data.\n\nNodal element data (I) are contiguous for each S datatype struct field (F) for a single element slab.\n\nA DataSlab1D view can be returned from other Data1D objects by calling slab(data, idx...).\n\n\n\n\n\n","category":"type"},{"location":"api/#ClimaCore.DataLayouts.IJF","page":"API","title":"ClimaCore.DataLayouts.IJF","text":"IJF{S, Nij, A} <: DataSlab2D{S, Nij}\n\nBacking DataLayout for 2D spectral element slab data.\n\nNodal element data (I,J) are contiguous for each S datatype struct field (F) for a single element slab.\n\nA DataSlab2D view can be returned from other Data2D objects by calling slab(data, idx...).\n\n\n\n\n\n","category":"type"},{"location":"api/#ClimaCore.DataLayouts.VF","page":"API","title":"ClimaCore.DataLayouts.VF","text":"VF{S, A} <: DataColumn{S}\n\nBacking DataLayout for 1D FV column data.\n\nColumn level data (V) are contiguous for each S datatype struct field (F).\n\nA DataColumn view can be returned from other Data1DX, Data2DX objects by calling column(data, idx...).\n\n\n\n\n\n","category":"type"},{"location":"api/#ClimaCore.DataLayouts.IFH","page":"API","title":"ClimaCore.DataLayouts.IFH","text":"IFH{S, Ni, A} <: Data1D{S, Ni}\n\nBacking DataLayout for 1D spectral element slabs.\n\nElement nodal point (I) data is contiguous for each datatype S struct field (F), for each 1D mesh element (H).\n\n\n\n\n\n","category":"type"},{"location":"api/#ClimaCore.DataLayouts.IJFH","page":"API","title":"ClimaCore.DataLayouts.IJFH","text":"IJFH{S, Nij, A} <: Data2D{S, Nij}\n\nBacking DataLayout for 2D spectral element slabs.\n\nElement nodal point (I,J) data is contiguous for each datatype S struct field (F), for each 2D mesh element slab (H).\n\n\n\n\n\n","category":"type"},{"location":"api/#ClimaCore.DataLayouts.VIFH","page":"API","title":"ClimaCore.DataLayouts.VIFH","text":"VIFH{S, Ni, A} <: Data1DX{S, Ni}\n\nBacking DataLayout for 1D spectral element slab + extruded 1D FV column data.\n\nColumn levels (V) are contiguous for every element nodal point (I) for each datatype S struct field (F), for each 1D mesh element slab (H).\n\n\n\n\n\n","category":"type"},{"location":"api/#ClimaCore.DataLayouts.VIJFH","page":"API","title":"ClimaCore.DataLayouts.VIJFH","text":"VIJFH{S, Nij, A} <: Data2DX{S, Nij}\n\nBacking DataLayout for 2D spectral element slab + extruded 1D FV column data.\n\nColumn levels (V) are contiguous for every element nodal point (I, J) for each S datatype struct field (F), for each 2D mesh element slab (H).\n\n\n\n\n\n","category":"type"},{"location":"api/#Geometry","page":"API","title":"Geometry","text":"","category":"section"},{"location":"api/#Coordinates","page":"API","title":"Coordinates","text":"","category":"section"},{"location":"api/","page":"API","title":"API","text":"Geometry.AbstractPoint\nGeometry.float_type","category":"page"},{"location":"api/#ClimaCore.Geometry.AbstractPoint","page":"API","title":"ClimaCore.Geometry.AbstractPoint","text":"AbstractPoint\n\nRepresents a point in space.\n\nThe following types are supported:\n\nXPoint(x)\nYPoint(y)\nZPoint(z)\nXYPoint(x, y)\nXZPoint(x, z)\nXYZPoint(x, y, z)\nLatLongPoint(lat, long)\nLatLongZPoint(lat, long, z)\nCartesian1Point(x1)\nCartesian2Point(x2)\nCartesian3Point(x3)\nCartesian12Point(x1, x2)\nCartesian13Point(x1, x3)\nCartesian123Point(x1, x2, x3)\n\n\n\n\n\n","category":"type"},{"location":"api/#ClimaCore.Geometry.float_type","page":"API","title":"ClimaCore.Geometry.float_type","text":"float_type(T)\n\nReturn the floating point type backing T: T can either be an object or a type.\n\n\n\n\n\n","category":"function"},{"location":"api/","page":"API","title":"API","text":"Points represent locations in space, specified by coordinates in a given coordinate system (Cartesian, spherical, etc), whereas vectors, on the other hand, represent displacements in space.","category":"page"},{"location":"api/","page":"API","title":"API","text":"An analogy with time works well: times (also called instants or datetimes) are locations in time, while, durations are displacements in time.","category":"page"},{"location":"api/","page":"API","title":"API","text":"Note 1: Latitude and longitude are specified via angles (and, therefore, trigonometric functions: cosd, sind, acosd, asind, tand,...) in degrees, not in radians. Moreover, lat (usually denoted by theta) in -900 900, and long (usually denoted by lambda) in -1800 1800.","category":"page"},{"location":"api/","page":"API","title":"API","text":"Note 2:: In a Geometry.LatLongZPoint(lat, long, z), z represents the elevation above the surface of the sphere with radius R (implicitly accounted for in the geoemtry).","category":"page"},{"location":"api/","page":"API","title":"API","text":"Note 3: There are also a set of specific Cartesian points (Cartesian1Point(x1), Cartesian2Point(x2), etc). These are occasionally useful for converting everything to a full Cartesian domain (e.g. for visualization purposes). These are distinct from XYZPoint as ZPoint can mean different things in different domains.","category":"page"},{"location":"api/#Vectors-and-vector-fields","page":"API","title":"Vectors and vector fields","text":"","category":"section"},{"location":"api/","page":"API","title":"API","text":"Introduction to Vectors and Vector Fields in ClimaCore.jl","category":"page"},{"location":"api/#Domains","page":"API","title":"Domains","text":"","category":"section"},{"location":"api/#Types","page":"API","title":"Types","text":"","category":"section"},{"location":"api/","page":"API","title":"API","text":"Domains.AbstractDomain\nDomains.IntervalDomain\nDomains.RectangleDomain\nDomains.SphereDomain","category":"page"},{"location":"api/#ClimaCore.Domains.AbstractDomain","page":"API","title":"ClimaCore.Domains.AbstractDomain","text":"AbstractDomain\n\nA domain represents a region of space.\n\n\n\n\n\n","category":"type"},{"location":"api/#ClimaCore.Domains.IntervalDomain","page":"API","title":"ClimaCore.Domains.IntervalDomain","text":"IntervalDomain(coord⁻, coord⁺; periodic=true)\nIntervalDomain(coord⁻, coord⁺; boundary_names::Tuple{Symbol,Symbol})\n\nConstruct a IntervalDomain, the closed interval is given by coord⁻, coord⁺ coordinate arguments.\n\nEither a periodic or boundary_names keyword argument is required.\n\n\n\n\n\n","category":"type"},{"location":"api/#ClimaCore.Domains.RectangleDomain","page":"API","title":"ClimaCore.Domains.RectangleDomain","text":"RectangleDomain(x1::ClosedInterval, x2::ClosedInterval;\n    x1boundary::Tuple{Symbol,Symbol},\n    x2boundary::Tuple{Symbol,Symbol},\n    x1periodic = false,\n    x2periodic = false,\n)\n\nConstruct a RectangularDomain in the horizontal. If a given x1 or x2 boundary is not periodic, then x1boundary or x2boundary boundary name keyword arguments must be supplied.\n\n\n\n\n\n","category":"type"},{"location":"api/#ClimaCore.Domains.SphereDomain","page":"API","title":"ClimaCore.Domains.SphereDomain","text":"SphereDomain(radius)\n\nA domain representing the surface of a sphere with radius radius.\n\n\n\n\n\n","category":"type"},{"location":"api/#Interfaces","page":"API","title":"Interfaces","text":"","category":"section"},{"location":"api/","page":"API","title":"API","text":"Domains.boundary_names","category":"page"},{"location":"api/#ClimaCore.Domains.boundary_names","page":"API","title":"ClimaCore.Domains.boundary_names","text":"boundary_names(obj::Union{AbstractDomain, AbstractMesh, AbstractTopology})\n\nA tuple or vector of unique boundary names of a spatial domain.\n\n\n\n\n\n","category":"function"},{"location":"api/#Meshes","page":"API","title":"Meshes","text":"","category":"section"},{"location":"api/","page":"API","title":"API","text":"A Mesh is a division of a domain into elements.","category":"page"},{"location":"api/#Mesh-types","page":"API","title":"Mesh types","text":"","category":"section"},{"location":"api/","page":"API","title":"API","text":"Meshes.AbstractMesh\nMeshes.IntervalMesh\nMeshes.RectilinearMesh\nMeshes.AbstractCubedSphere\nMeshes.EquiangularCubedSphere\nMeshes.EquidistantCubedSphere\nMeshes.ConformalCubedSphere","category":"page"},{"location":"api/#ClimaCore.Meshes.AbstractMesh","page":"API","title":"ClimaCore.Meshes.AbstractMesh","text":"AbstractMesh{dim}\n\nA Mesh is an object which represents how we discretize a domain into elements.\n\nIt should be lightweight (i.e. exists on all MPI ranks), e.g for meshes stored in a file, it would contain the filename.\n\nFace and vertex numbering\n\nIn 1D, faces and vertices are the same, and both are numbered [1,2].\n\nIn 2D, a face is a line segment between to vertices, and both are numbered [1,2,3,4], in a counter-clockwise direction.\n\n v4        f3        v3\n   o-----------------o\n   |                 |\t    face    vertices\n   |                 |\t      f1 =>  v1 v2\nf4 |                 | f2     f2 =>  v2 v3\n   |                 |\t      f3 =>  v3 v4\n   |                 |        f4 =>  v4 v1\n   |                 |\n   o-----------------o\n  v1       f1        v2\n\nInterface\n\nA subtype of AbstractMesh should define the following methods:\n\ndomain(mesh)\nelements(mesh)\nis_boundary_face(mesh, elem, face)\nboundary_face_name(mesh, elem, face)\nopposing_face(mesh, elem, face)\ncoordinates(mesh, elem, vert)\ncontaining_element (optional)\n\nThe following types/methods are provided by AbstractMesh:\n\nSharedVertices(mesh, elem, vert)\nface_connectivity_matrix(mesh[,elemorder])\nvertex_connectivity_matrix(mesh[,elemorder])\n\n\n\n\n\n","category":"type"},{"location":"api/#ClimaCore.Meshes.IntervalMesh","page":"API","title":"ClimaCore.Meshes.IntervalMesh","text":"IntervalMesh <: AbstractMesh\n\nA 1D mesh on an IntervalDomain.\n\nConstuctors\n\nIntervalMesh(domain::IntervalDomain, faces::AbstractVector)\n\nConstruct a 1D mesh with face locations at faces.\n\nIntervalMesh(domain::IntervalDomain[, stetching=Uniform()]; nelems=)\n\nConstuct a 1D mesh on domain with nelems elements, using stretching. Possible values of stretching are:\n\nUniform()\nExponentialStretching(H)\nGeneralizedExponentialStretching(dz_surface, dz_top)\n\n\n\n\n\n","category":"type"},{"location":"api/#ClimaCore.Meshes.RectilinearMesh","page":"API","title":"ClimaCore.Meshes.RectilinearMesh","text":"RectilinearMesh <: AbstractMesh2D\n\nConstructors\n\nRectilinearMesh(domain::RectangleDomain, n1, n2)\n\nConstruct a RectilinearMesh of equally-spaced n1 by n2 elements on domain.\n\nRectilinearMesh(intervalmesh1::IntervalMesh1, intervalmesh2::IntervalMesh2)\n\nConstruct the product mesh of intervalmesh1 and intervalmesh2.\n\n\n\n\n\n","category":"type"},{"location":"api/#ClimaCore.Meshes.AbstractCubedSphere","page":"API","title":"ClimaCore.Meshes.AbstractCubedSphere","text":"AbstractCubedSphere <: AbstractMesh2D\n\nThis is an abstract type of cubed-sphere meshes on SphereDomains. A cubed-sphere mesh has 6 panels, laid out as follows:\n\n                                          :   Panel 1   :\n                            +-------------+-------------+\n                            |     +x1     |     +x1     |\n                            |             |             |\n                            |    Panel    |    Panel    |\n                            |+x3   5   -x3|-x2   6   +x2|\n                            |     -x2     |     -x3     |\n                            |             |             |\n                            |     -x1     |     -x1     |\n              +-------------+-------------+-------------+\n              |     -x2     |     -x2     |\n              |             |             |\n              |    Panel    |    Panel    |\n              |+x1   3   -x1|+x3   4   -x3|\n              |     +x3     |     -x1     |\n              |             |             |\n              |     +x2     |     +x2     |\n+-------------+-------------+-------------+\n|     +x3     |     +x3     |\n|             |             |\n|    Panel    |    Panel    |\n|-x2   1   +x2|+x1   2   -x1|\n|     +x1     |     +x2     |\n|             |             |\n|     -x3     |     -x3     |\n+-------------+-------------+\n:   Panel 6   :\n\nThis is the same panel ordering used by the S2 Geometry library (though we use 1-based instead of 0-based numering).\n\nElements are indexed by a CartesianIndex{3} object, where the components are:\n\nhorizontal element index (left to right) within each panel.\nvertical element index (bottom to top) within each panel.\npanel number\n\nSubtypes should have the following fields:\n\ndomain: a SphereDomain\nne: number of elements across each panel\n\nExternal links\n\nS2Geometry library\nMIT GCM exch2\n\n\n\n\n\n","category":"type"},{"location":"api/#ClimaCore.Meshes.EquiangularCubedSphere","page":"API","title":"ClimaCore.Meshes.EquiangularCubedSphere","text":"EquiangularCubedSphere <: AbstractCubedSphere\n\nAn equiangular gnomonic mesh proposed by C. Ronchi, R. Iacono, P. S. Paolucci (1996). Uses the element indexing convention of AbstractCubedSphere.\n\nConstructors\n\nEquiangularCubedSphere(\n    domain::Domains.SphereDomain,\n    ne::Integer,\n    localelementmap=NormalizedBilinearMap()\n    )\n\nConstuct an EquiangularCubedSphere on domain with ne elements across each panel.\n\n\n\n\n\n","category":"type"},{"location":"api/#ClimaCore.Meshes.EquidistantCubedSphere","page":"API","title":"ClimaCore.Meshes.EquidistantCubedSphere","text":"EquidistantCubedSphere <: AbstractCubedSphere\n\nAn equidistant gnomonic mesh outlined in M. Rančić, R. J. Purser, F. Mesinger (1996) and Ramachandran D Nair, Stephen J Thomas, Richard D Loft (2005). Uses the element indexing convention of AbstractCubedSphere.\n\nConstructors\n\nEquidistantCubedSphere(domain::Domains.SphereDomain, ne::Integer)\n\nConstuct an EquidistantCubedSphere on domain with ne elements across each panel.\n\n\n\n\n\n","category":"type"},{"location":"api/#ClimaCore.Meshes.ConformalCubedSphere","page":"API","title":"ClimaCore.Meshes.ConformalCubedSphere","text":"ConformalCubedSphere <: AbstractCubedSphere\n\nA conformal mesh outlined in M. Rančić, R. J. Purser, F. Mesinger (1996). Uses the element indexing convention of AbstractCubedSphere.\n\nConstructors\n\nConformalCubedSphere(domain::Domains.SphereDomain, ne::Integer)\n\nConstuct a ConformalCubedSphere on domain with ne elements across each panel.\n\n\n\n\n\n","category":"type"},{"location":"api/#Local-element-map","page":"API","title":"Local element map","text":"","category":"section"},{"location":"api/","page":"API","title":"API","text":"Meshes.LocalElementMap\nMeshes.IntrinsicMap\nMeshes.NormalizedBilinearMap","category":"page"},{"location":"api/#ClimaCore.Meshes.LocalElementMap","page":"API","title":"ClimaCore.Meshes.LocalElementMap","text":"LocalElementMap\n\nAn abstract type of mappings from the reference element to a physical domain.\n\n\n\n\n\n","category":"type"},{"location":"api/#ClimaCore.Meshes.IntrinsicMap","page":"API","title":"ClimaCore.Meshes.IntrinsicMap","text":"IntrinsicMap()\n\nThis LocalElementMap uses the intrinsic mapping of the cubed sphere to map the reference element to the physical domain.\n\n\n\n\n\n","category":"type"},{"location":"api/#ClimaCore.Meshes.NormalizedBilinearMap","page":"API","title":"ClimaCore.Meshes.NormalizedBilinearMap","text":"NormalizedBilinearMap()\n\nThe LocalElementMap for meshes on spherical domains of O. Guba, M. A. Taylor, P. A. Ullrich, J. R. Overfelt, M. N. Levy (2014). It uses bilinear interpolation between the Cartesian coordinates of the element vertices, then normalizes the result to lie on the sphere.\n\n\n\n\n\n","category":"type"},{"location":"api/#Mesh-stretching","page":"API","title":"Mesh stretching","text":"","category":"section"},{"location":"api/","page":"API","title":"API","text":"Meshes.Uniform\nMeshes.ExponentialStretching","category":"page"},{"location":"api/#ClimaCore.Meshes.Uniform","page":"API","title":"ClimaCore.Meshes.Uniform","text":"Uniform()\n\nUse uniformly-sized elements.\n\n\n\n\n\n","category":"type"},{"location":"api/#ClimaCore.Meshes.ExponentialStretching","page":"API","title":"ClimaCore.Meshes.ExponentialStretching","text":"ExponentialStretching(H)\n\nApply exponential stretching to the domain when constructing elements. H is the scale height (a typical atmospheric scale height H ≈ 7.5km).\n\nFor an interval z_0z_1, this makes the elements uniformally spaced in zeta, where\n\nzeta = frac1 - e^-etah1-e^-1h\n\nwhere eta = fracz - z_0z_1-z_0, and h = fracHz_1-z_0 is the non-dimensional scale height.\n\n\n\n\n\n","category":"type"},{"location":"api/#Interfaces-2","page":"API","title":"Interfaces","text":"","category":"section"},{"location":"api/","page":"API","title":"API","text":"Meshes.domain\nMeshes.elements\nMeshes.nelements\nMeshes.is_boundary_face\nMeshes.boundary_face_name\nMeshes.opposing_face\nMeshes.coordinates\nMeshes.containing_element\nMeshes.reference_coordinates\nMeshes.SharedVertices\nMeshes.face_connectivity_matrix\nMeshes.vertex_connectivity_matrix\nMeshes.linearindices","category":"page"},{"location":"api/#ClimaCore.Meshes.domain","page":"API","title":"ClimaCore.Meshes.domain","text":"Meshes.domain(mesh::AbstractMesh)\n\nThe Domains.AbstractDomain on which the mesh is defined.\n\n\n\n\n\ndomain(topology)\n\nReturns the domain of the topology from the underlying mesh\n\n\n\n\n\n","category":"function"},{"location":"api/#ClimaCore.Meshes.elements","page":"API","title":"ClimaCore.Meshes.elements","text":"Meshes.elements(mesh::AbstractMesh)\n\nAn iterator over the elements of a mesh. Elements of a mesh can be of any type.\n\n\n\n\n\n","category":"function"},{"location":"api/#ClimaCore.Meshes.nelements","page":"API","title":"ClimaCore.Meshes.nelements","text":"nelements(mesh::AbstractMesh)\n\nThe number of elements in the mesh.\n\n\n\n\n\n","category":"function"},{"location":"api/#ClimaCore.Meshes.is_boundary_face","page":"API","title":"ClimaCore.Meshes.is_boundary_face","text":"Meshes.is_boundary_face(mesh::AbstractMesh, elem, face::Int)::Bool\n\nDetermine whether face face of element elem is on the boundary of mesh.\n\nelem should be an element of elements(mesh).\n\n\n\n\n\n","category":"function"},{"location":"api/#ClimaCore.Meshes.boundary_face_name","page":"API","title":"ClimaCore.Meshes.boundary_face_name","text":"Meshes.boundary_face_name(mesh::AbstractMesh, elem, face::Int)::Union{Symbol,Nothing}\n\nThe name of the boundary facing face of element elem, or nothing if it is not on the boundary.\n\n\n\n\n\n","category":"function"},{"location":"api/#ClimaCore.Meshes.opposing_face","page":"API","title":"ClimaCore.Meshes.opposing_face","text":"opelem, opface, reversed = Meshes.opposing_face(mesh::AbstractMesh, elem, face::Int)\n\nThe element and face (opelem, opface) that oppose face face of element elem.\n\n\n\n\n\n","category":"function"},{"location":"api/#ClimaCore.Meshes.coordinates","page":"API","title":"ClimaCore.Meshes.coordinates","text":"Meshes.coordinates(mesh, elem, vert::Int)\nMeshes.coordinates(mesh, elem, ξ::SVector)\n\nReturn the physical coordinates of a point in an element elem of mesh. The position of the point can either be a vertex number vert or the coordinates ξ in the reference element.\n\n\n\n\n\n","category":"function"},{"location":"api/#ClimaCore.Meshes.containing_element","page":"API","title":"ClimaCore.Meshes.containing_element","text":"elem = Meshes.containing_element(mesh::AbstractMesh, coord)\n\nThe element elem in mesh containing the coordinate coord. If the coordinate falls on the boundary between two or more elements, an arbitrary element is chosen.\n\n\n\n\n\n","category":"function"},{"location":"api/#ClimaCore.Meshes.reference_coordinates","page":"API","title":"ClimaCore.Meshes.reference_coordinates","text":"ξ = Meshes.reference_coordinates(mesh::AbstractMesh, elem, coord)\n\nAn SVector of coordinates in the reference element such that\n\nMeshes.coordinates(mesh, elem, ξ) == coord\n\nThis can be used for interpolation to a specific point.\n\n\n\n\n\n","category":"function"},{"location":"api/#ClimaCore.Meshes.SharedVertices","page":"API","title":"ClimaCore.Meshes.SharedVertices","text":"Meshes.SharedVertices(mesh, elem, vert)\n\nAn iterator over (element, vertex) pairs that are shared with (elem,vert).\n\n\n\n\n\n","category":"type"},{"location":"api/#ClimaCore.Meshes.face_connectivity_matrix","page":"API","title":"ClimaCore.Meshes.face_connectivity_matrix","text":"M = Meshes.face_connectivity_matrix(mesh, elemorder = elements(mesh))\n\nConstruct a Bool-valued SparseCSCMatrix containing the face connections of mesh. Elements are indexed according to elemorder.\n\nNote that M[i,i] == true only if two distinct faces of element i are connected.\n\n\n\n\n\n","category":"function"},{"location":"api/#ClimaCore.Meshes.vertex_connectivity_matrix","page":"API","title":"ClimaCore.Meshes.vertex_connectivity_matrix","text":"M = Meshes.vertex_connectivity_matrix(mesh, elemorder = elements(mesh))\n\nConstruct a Bool-valued SparseCSCMatrix containing the vertex connections of mesh. Elements are indexed according to elemorder.\n\nNote that M[i,i] == true only if two distinct vertices of element i are connected.\n\n\n\n\n\n","category":"function"},{"location":"api/#ClimaCore.Meshes.linearindices","page":"API","title":"ClimaCore.Meshes.linearindices","text":"Meshes.linearindices(elemorder)\n\nGiven a data structure elemorder[i] = elem that orders elements, construct the inverse map from orderindex = linearindices(elemorder) such that orderindex[elem] = i.\n\nThis will try to use the most efficient structure available.\n\n\n\n\n\n","category":"function"},{"location":"api/#Topologies","page":"API","title":"Topologies","text":"","category":"section"},{"location":"api/","page":"API","title":"API","text":"A Topology determines the ordering and connections between elements of a mesh.","category":"page"},{"location":"api/#Types-2","page":"API","title":"Types","text":"","category":"section"},{"location":"api/","page":"API","title":"API","text":"Topologies.AbstractTopology\nTopologies.IntervalTopology\nTopologies.Topology2D","category":"page"},{"location":"api/#ClimaCore.Topologies.AbstractTopology","page":"API","title":"ClimaCore.Topologies.AbstractTopology","text":"AbstractTopology\n\nSubtypes of AbstractHorizontalTopology define connectiveness of a mesh in the horizontal domain.\n\nInterfaces\n\nnelems\ndomain\nmesh\nnlocalelems\nnneighbors\nnsendelems\nnghostelems\nlocalelemindex\nvertex_coordinates\nopposing_face\nface_node_index\ninterior_faces\nghost_faces\nvertex_node_index\nvertices\nneighboring_elements\ninterior_vertices\nghost_vertices\nneighbors\nboundary_tags\nboundary_tag\nboundary_faces\n\n\n\n\n\n","category":"type"},{"location":"api/#ClimaCore.Topologies.IntervalTopology","page":"API","title":"ClimaCore.Topologies.IntervalTopology","text":"IntervalTopology(mesh::IntervalMesh)\n\nA sequential topology on an Meshes.IntervalMesh.\n\n\n\n\n\n","category":"type"},{"location":"api/#ClimaCore.Topologies.Topology2D","page":"API","title":"ClimaCore.Topologies.Topology2D","text":"Topology2D(mesh::AbstractMesh2D, elemorder=Mesh.elements(mesh))\n\nThis is a generic non-distributed topology for 2D meshes. elemorder is a vector or other linear ordering of the Mesh.elements(mesh).\n\n\n\n\n\n","category":"type"},{"location":"api/#Interfaces-3","page":"API","title":"Interfaces","text":"","category":"section"},{"location":"api/","page":"API","title":"API","text":"Topologies.domain\nTopologies.mesh\nTopologies.nlocalelems\nTopologies.vertex_coordinates\nTopologies.opposing_face\nTopologies.interior_faces\nTopologies.boundary_tags\nTopologies.boundary_tag\nTopologies.boundary_faces\nTopologies.vertices","category":"page"},{"location":"api/#ClimaCore.Topologies.mesh","page":"API","title":"ClimaCore.Topologies.mesh","text":"mesh(topology)\n\nReturns the mesh underlying the topology\n\n\n\n\n\n","category":"function"},{"location":"api/#ClimaCore.Topologies.nlocalelems","page":"API","title":"ClimaCore.Topologies.nlocalelems","text":"nlocalelems(topology)\n\nThe number of local elements in topology.\n\n\n\n\n\n","category":"function"},{"location":"api/#ClimaCore.Topologies.vertex_coordinates","page":"API","title":"ClimaCore.Topologies.vertex_coordinates","text":"(c1,c2,c3,c4) = vertex_coordinates(topology, elem)\n\nThe coordinates of the 4 vertices of element elem.\n\n\n\n\n\n","category":"function"},{"location":"api/#ClimaCore.Topologies.opposing_face","page":"API","title":"ClimaCore.Topologies.opposing_face","text":"(opelem, opface, reversed) = opposing_face(topology, elem, face)\n\nThe opposing face of face number face of element elem in topology.\n\nopelem is the opposing element number, 0 for a boundary, negative for a ghost element\nopface is the opposite face number, or boundary face number if a boundary\nreversed indicates whether the opposing face has the opposite orientation.\n\n\n\n\n\n","category":"function"},{"location":"api/#ClimaCore.Topologies.interior_faces","page":"API","title":"ClimaCore.Topologies.interior_faces","text":"interior_faces(topology::AbstractTopology)\n\nAn iterator over the interior faces of topology. Each element of the iterator is a 5-tuple the form\n\n(elem1, face1, elem2, face2, reversed)\n\nwhere elemX, faceX are the element and face numbers, and reversed indicates whether they have opposing orientations.\n\n\n\n\n\n","category":"function"},{"location":"api/#ClimaCore.Topologies.boundary_tags","page":"API","title":"ClimaCore.Topologies.boundary_tags","text":"boundary_tags(topology)\n\nA Tuple or NamedTuple of the boundary tags of the topology. A boundary tag is an integer that uniquely identifies a boundary.\n\n\n\n\n\n","category":"function"},{"location":"api/#ClimaCore.Topologies.boundary_tag","page":"API","title":"ClimaCore.Topologies.boundary_tag","text":"boundary_tag(topology, name::Symbol)\n\nThe boundary tag of the topology for boundary name name. A boundary tag is an integer that uniquely identifies a boundary.\n\n\n\n\n\n","category":"function"},{"location":"api/#ClimaCore.Topologies.boundary_faces","page":"API","title":"ClimaCore.Topologies.boundary_faces","text":"boundary_faces(topology, boundarytag)\n\nAn iterator over the faces of topology which face the boundary with tag boundarytag. Each element of the iterator is an (elem, face) pair.\n\n\n\n\n\n","category":"function"},{"location":"api/#ClimaCore.Topologies.vertices","page":"API","title":"ClimaCore.Topologies.vertices","text":"vertices(topology)\n\nAn iterator over the unique (shared) vertices of the topology topology. Each vertex is an iterator over (element, vertex_number) pairs.\n\n\n\n\n\n","category":"function"},{"location":"api/#Spaces","page":"API","title":"Spaces","text":"","category":"section"},{"location":"api/","page":"API","title":"API","text":"A Space represents a discretized function space over some domain. Currently two main discretizations are supported: Spectral Element Discretization (both Continuous Galerkin and Discontinuous Galerkin types) and a staggered Finite Difference Discretization. Combination of these two in the horizontal/vertical directions, respectively, is what we call a hybrid space.","category":"page"},{"location":"api/","page":"API","title":"API","text":"Sketch of a 2DX hybrid discretization:","category":"page"},{"location":"api/","page":"API","title":"API","text":"(Image: 3D hybrid discretization in a Cartesian domain)","category":"page"},{"location":"api/","page":"API","title":"API","text":"Spaces","category":"page"},{"location":"api/#ClimaCore.Spaces","page":"API","title":"ClimaCore.Spaces","text":"Meshes\n\ndomain\ntopology\ncoordinates\nmetric terms (inverse partial derivatives)\nquadrature rules and weights\n\nReferences / notes\n\nceed\nQA\n\n\n\n\n\n","category":"module"},{"location":"api/#Finite-Difference-Spaces","page":"API","title":"Finite Difference Spaces","text":"","category":"section"},{"location":"api/","page":"API","title":"API","text":"ClimaCore.jl supports staggered Finite Difference discretizations. Finite Differences discretize an interval domain by approximating the function by a value at either the center of each element (also referred to as cell) (CenterFiniteDifferenceSpace), or the interfaces (faces in 3D, edges in 2D or points in 1D) between elements (FaceFiniteDifferenceSpace).","category":"page"},{"location":"api/","page":"API","title":"API","text":"Users should construct either the center or face space from the mesh, then construct the other space from the original one: this internally reuses the same data structures, and avoids allocating additional memory.","category":"page"},{"location":"api/#Spectral-Element-Spaces","page":"API","title":"Spectral Element Spaces","text":"","category":"section"},{"location":"api/","page":"API","title":"API","text":"Introduction to the Finite/Spectral Element Method","category":"page"},{"location":"api/#Quadratures","page":"API","title":"Quadratures","text":"","category":"section"},{"location":"api/","page":"API","title":"API","text":"Spaces.Quadratures.QuadratureStyle\nSpaces.Quadratures.GLL\nSpaces.Quadratures.GL\nSpaces.Quadratures.Uniform\nSpaces.Quadratures.degrees_of_freedom\nSpaces.Quadratures.polynomial_degree\nSpaces.Quadratures.quadrature_points\nSpaces.Quadratures.barycentric_weights\nSpaces.Quadratures.interpolation_matrix\nSpaces.Quadratures.differentiation_matrix\nSpaces.Quadratures.orthonormal_poly","category":"page"},{"location":"api/#ClimaCore.Spaces.Quadratures.QuadratureStyle","page":"API","title":"ClimaCore.Spaces.Quadratures.QuadratureStyle","text":"QuadratureStyle\n\nQuadrature style supertype. See sub-types:\n\nGLL\nGL\nUniform\n\n\n\n\n\n","category":"type"},{"location":"api/#ClimaCore.Spaces.Quadratures.GLL","page":"API","title":"ClimaCore.Spaces.Quadratures.GLL","text":"GLL{Nq}()\n\nGauss-Legendre-Lobatto quadrature using Nq quadrature points.\n\n\n\n\n\n","category":"type"},{"location":"api/#ClimaCore.Spaces.Quadratures.GL","page":"API","title":"ClimaCore.Spaces.Quadratures.GL","text":"GL{Nq}()\n\nGauss-Legendre quadrature using Nq quadrature points.\n\n\n\n\n\n","category":"type"},{"location":"api/#ClimaCore.Spaces.Quadratures.Uniform","page":"API","title":"ClimaCore.Spaces.Quadratures.Uniform","text":"Uniform{Nq}()\n\nUniformly-spaced quadrature.\n\n\n\n\n\n","category":"type"},{"location":"api/#ClimaCore.Spaces.Quadratures.degrees_of_freedom","page":"API","title":"ClimaCore.Spaces.Quadratures.degrees_of_freedom","text":"degrees_of_freedom(QuadratureStyle) -> Int\n\nReturns the degreesoffreedom of the QuadratureStyle concrete type\n\n\n\n\n\n","category":"function"},{"location":"api/#ClimaCore.Spaces.Quadratures.polynomial_degree","page":"API","title":"ClimaCore.Spaces.Quadratures.polynomial_degree","text":"polynomial_degree(QuadratureStyle) -> Int\n\nReturns the polynomial degree of the QuadratureStyle concrete type\n\n\n\n\n\n","category":"function"},{"location":"api/#ClimaCore.Spaces.Quadratures.quadrature_points","page":"API","title":"ClimaCore.Spaces.Quadratures.quadrature_points","text":"points, weights = quadrature_points(::Type{FT}, quadrature_style)\n\nThe points and weights of the quadrature rule in floating point type FT.\n\n\n\n\n\n","category":"function"},{"location":"api/#ClimaCore.Spaces.Quadratures.barycentric_weights","page":"API","title":"ClimaCore.Spaces.Quadratures.barycentric_weights","text":"barycentric_weights(x::SVector{Nq}) where {Nq}\n\nThe barycentric weights associated with the array of point locations x:\n\nw_j = frac1prod_k ne j (x_i - x_j)\n\nSee Jean-Paul Berrut, Lloyd N Trefethen (2004), equation 3.2.\n\n\n\n\n\n","category":"function"},{"location":"api/#ClimaCore.Spaces.Quadratures.interpolation_matrix","page":"API","title":"ClimaCore.Spaces.Quadratures.interpolation_matrix","text":"interpolation_matrix(x::SVector, r::SVector{Nq})\n\nThe matrix which interpolates the Lagrange polynomial of degree Nq-1 through the points r, to points x. The matrix coefficients are computed using the Barycentric formula of Jean-Paul Berrut, Lloyd N Trefethen (2004), section 4:\n\nI_ij = begincases\n1  textif  x_i = r_j \n0  textif  x_i = r_k text for  k ne j \nfracdisplaystyle fracw_jx_i - r_jdisplaystyle sum_k fracw_kx_i - r_k  textotherwise\nendcases\n\nwhere w_j are the barycentric weights, see barycentric_weights.\n\n\n\n\n\n","category":"function"},{"location":"api/#ClimaCore.Spaces.Quadratures.differentiation_matrix","page":"API","title":"ClimaCore.Spaces.Quadratures.differentiation_matrix","text":"differentiation_matrix(r::SVector{Nq, T}) where {Nq, T}\n\nThe spectral differentiation matrix for the Lagrange polynomial of degree Nq-1 interpolating at points r.\n\nThe matrix coefficients are computed using the Jean-Paul Berrut, Lloyd N Trefethen (2004), section 9.3:\n\nD_ij = begincases\n    displaystyle\n    fracw_jw_i (x_i - x_j) text if  i ne j \n    -sum_k ne j D_kj text if  i = j\nendcases\n\nwhere w_j are the barycentric weights, see barycentric_weights.\n\n\n\n\n\ndifferentiation_matrix(FT, quadstyle::QuadratureStyle)\n\nThe spectral differentiation matrix at the quadrature points of quadstyle, using floating point types FT.\n\n\n\n\n\n","category":"function"},{"location":"api/#ClimaCore.Spaces.Quadratures.orthonormal_poly","page":"API","title":"ClimaCore.Spaces.Quadratures.orthonormal_poly","text":"V = orthonormal_poly(points, quad)\n\nV_{ij} contains the j-1th Legendre polynomial evaluated at points[i]. i.e. it is the mapping from the modal to the nodal representation.\n\n\n\n\n\n","category":"function"},{"location":"api/#RecursiveApply","page":"API","title":"RecursiveApply","text":"","category":"section"},{"location":"api/","page":"API","title":"API","text":"RecursiveApply\nRecursiveApply.tuplemap","category":"page"},{"location":"api/#ClimaCore.RecursiveApply","page":"API","title":"ClimaCore.RecursiveApply","text":"RecursiveApply\n\nThis module contains operators to recurse over nested Tuples or NamedTuples.\n\nTo extend to another type T, define RecursiveApply.rmap(fn, args::T...)\n\n\n\n\n\n","category":"module"},{"location":"api/#ClimaCore.RecursiveApply.tuplemap","page":"API","title":"ClimaCore.RecursiveApply.tuplemap","text":"tuplemap(fn::Function, tup)\n\nA map impl for mapping function fn a tuple argument tup\n\nCurrently just calls Base.map behind the scenes but is left  stubbed out for potential specialization in the future.\n\n\n\n\n\ntuplemap(fn::Function, tup1, tup2)\n\nA map impl for mapping function fn over tup1, tup2 tuple arguments.\n\nCurrently just calls Base.map behind the scenes but is left  stubbed out for potential specialization in the future.\n\n\n\n\n\n","category":"function"},{"location":"api/#Fields","page":"API","title":"Fields","text":"","category":"section"},{"location":"api/","page":"API","title":"API","text":"Fields.Field\nFields.coordinate_field\nFields.local_geometry_field\nBase.zeros(::Spaces.AbstractSpace)\nBase.ones(::Spaces.AbstractSpace)\nBase.sum(::Fields.Field)\nFields.Statistics.mean(::Fields.Field)\nFields.LinearAlgebra.norm(::Fields.Field)","category":"page"},{"location":"api/#ClimaCore.Fields.Field","page":"API","title":"ClimaCore.Fields.Field","text":"Field(values, space)\n\nA set of values defined at each point of a space.\n\n\n\n\n\n","category":"type"},{"location":"api/#ClimaCore.Fields.coordinate_field","page":"API","title":"ClimaCore.Fields.coordinate_field","text":"coordinate_field(space::AbstractSpace)\n\nConstruct a Field of the coordinates of the space.\n\n\n\n\n\n","category":"function"},{"location":"api/#ClimaCore.Fields.local_geometry_field","page":"API","title":"ClimaCore.Fields.local_geometry_field","text":"local_geometry_field(space::AbstractSpace)\n\nConstruct a Field of the LocalGeometry of the space.\n\n\n\n\n\n","category":"function"},{"location":"api/#Base.zeros-Tuple{ClimaCore.Spaces.AbstractSpace}","page":"API","title":"Base.zeros","text":"zeros(space::AbstractSpace)\n\nConstruct a field on space that is zero everywhere.\n\n\n\n\n\n","category":"method"},{"location":"api/#Base.ones-Tuple{ClimaCore.Spaces.AbstractSpace}","page":"API","title":"Base.ones","text":"ones(space::AbstractSpace)\n\nConstruct a field on space that is one everywhere.\n\n\n\n\n\n","category":"method"},{"location":"api/#Base.sum-Tuple{ClimaCore.Fields.Field}","page":"API","title":"Base.sum","text":"sum([f=identity,]v::Field)\n\nApproximate integration of v or f.(v) over the domain. In an AbstractSpectralElementSpace, an integral over the entire space is computed by summation over the elements of the integrand multiplied by the Jacobian determinants and the quadrature weights at each node within an element. Hence, sum is computed by summation of the field values multiplied by the Jacobian determinants and quadrature weights:\n\nsum_i f(v_i) W_i J_i\napprox\nint_Omega f(v)  d Omega\n\nwhere v_i is the value at each node, and f is the identity function if not specified.\n\n\n\n\n\n","category":"method"},{"location":"api/#Statistics.mean-Tuple{ClimaCore.Fields.Field}","page":"API","title":"Statistics.mean","text":"mean([f=identity, ]v::Field)\n\nThe mean value of field or f.(field) over the domain, weighted by area. Similar to sum, in an AbstractSpectralElementSpace, this is computed by summation of the field values multiplied by the Jacobian determinants and quadrature weights:\n\nfracsum_i f(v_i) W_i J_isum_i W_i J_i\napprox\nfracint_Omega f(v)  d Omegaint_Omega  d Omega\n\nwhere v_i is the Field value at each node, and f is the identity function if not specified.\n\n\n\n\n\n","category":"method"},{"location":"api/#LinearAlgebra.norm-Tuple{ClimaCore.Fields.Field}","page":"API","title":"LinearAlgebra.norm","text":"norm(v::Field, p=2; normalize=true)\n\nThe approximate L^p norm of v, where L^p represents the space of measurable functions for which the p-th power of the absolute value is Lebesgue integrable, that is:\n\n v _p = left( int_Omega v^p d Omega right)^1p\n\nwhere v is defined to be the absolute value if v is a scalar-valued Field, or the 2-norm if it is a vector-valued Field or composite Field (see LinearAlgebra.norm). Similar to sum and mean, in an AbstractSpectralElementSpace, this is computed by summation of the field values multiplied by the Jacobian determinants and quadrature weights. If normalize=true (the default), then internally the discrete norm is divided by the sum of the Jacobian determinants and quadrature weights:\n\nleft(fracsum_i v_i^p W_i J_isum_i W_i J_iright)^1p\napprox\nleft(fracint_Omega v^p  d Omegaint_Omega  d Omegaright)^1p\n\nIf p=Inf, then the norm is the maximum of the absolute values\n\nmax_i v_i approx sup_Omega v\n\nConsequently all norms should have the same units for all p (being the same as calling norm on a single value).\n\nIf normalize=false, then the denominator term is omitted, and so the result will be the norm as described above multiplied by the length/area/volume of Omega to the power of 1p.\n\n\n\n\n\n","category":"method"},{"location":"api/#Limiters","page":"API","title":"Limiters","text":"","category":"section"},{"location":"api/#Interfaces-4","page":"API","title":"Interfaces","text":"","category":"section"},{"location":"api/","page":"API","title":"API","text":"Limiters.quasimonotone_limiter!","category":"page"},{"location":"api/#ClimaCore.Limiters.quasimonotone_limiter!","page":"API","title":"ClimaCore.Limiters.quasimonotone_limiter!","text":"quasimonotone_limiter!(ρq, ρ, min_ρq, max_ρq; rtol)\n\nArguments:\n\nρq: tracer density Field, where q denotes tracer concentration per unit mass\nρ: fluid density Field\nmin_ρq: Matrix of min(ρq) per element, per level: shape [horznelems, vertnelems]\nmax_ρq: Matrix of max(ρq) per element, per level: shape [horznelems, vertnelems]\nrtol: relative tolerance needed to solve element-wise optimization problem\n\nThis limiter is inspired by the one presented in Guba et al Oksana Guba, Mark Taylor, Amik St-Cyr (2014). In the reference paper, it is denoted by OP1, and is outlined in eqs. (37)-(40). Quasimonotone here is meant to be monotone with respect to the spectral element nodal values. This limiter involves solving a constrained optimization problem (a weighted least square problem up to a fixed tolerance denoted by rtol) that is completely local to each element. As in HOMME, the implementation idea here is the following: we need to find a grid field which is closest to the initial field (in terms of weighted sum), but satisfies the min/max constraints. So, first we find values that do not satisfy constraints and bring these values to a closest constraint. This way we introduce some mass change (mass_change), which we then redistribute so that the l2 error is smallest. This redistribution might violate constraints; thus, we do a few iterations (typically a couple).\n\n\n\n\n\n","category":"function"},{"location":"intro-to-sem/#Introduction-to-the-Finite/Spectral-Element-Method","page":"-","title":"Introduction to the Finite/Spectral Element Method","text":"","category":"section"},{"location":"intro-to-sem/","page":"-","title":"-","text":"In finite element formulations, the weak form of a Partial Differential Equation (PDE)–-which involves integrating all terms in the PDE over the domain–-is evaluated on a subdomain Omega_e (element) and the local results are composed into a larger system of equations that models the entire problem on the global domain Omega.","category":"page"},{"location":"intro-to-sem/","page":"-","title":"-","text":"A spectral element space is a function space in which each function is approximated with a finite-dimensional polynomial interpolation in each element. Hence, we use polynomials as basis functions to approximate a given function (e.g., solution state). There are different ways of defininig basis functions: nodal basis functions and modal basis functions. We use nodal basis functions (e.g. by using Lagrange interpolation), which are defined via the values of the polynomials at particular nodal points in each element (termed Finite Element nodes). Even though the basis functions can interpolate globally, it’s better to limit each function to interpolate locally within each element, so to avoid a dense matrix system of equations when adding up the element contributions on the global domain Omega.","category":"page"},{"location":"intro-to-sem/","page":"-","title":"-","text":"The Finite Element nodes can be chosen to coincide with those of a particular quadrature rule, (this is referred to as using collocated nodes) which allows us to integrate functions over the domain.","category":"page"},{"location":"intro-to-sem/","page":"-","title":"-","text":"Let us give a concrete example of strong and weak form of a PDE. A Poisson's problem (in strong form) is given by","category":"page"},{"location":"intro-to-sem/","page":"-","title":"-","text":"   nabla cdot nabla u = f textrm for   mathbfx in Omega ","category":"page"},{"location":"intro-to-sem/","page":"-","title":"-","text":"To obtain the weak form, let us multiply all terms by a test function v and integrate by parts (i.e., apply the divergence theorem in multiple dimensions):","category":"page"},{"location":"intro-to-sem/","page":"-","title":"-","text":"   int_Omega nabla v cdot nabla u  dV - int_partial Omega v nabla u cdot hatmathbf n dS = int_Omega  v f  dV ","category":"page"},{"location":"intro-to-sem/","page":"-","title":"-","text":"Often, we choose to represent a field (say, the velocity field) such that nabla u cdot hatmathbf n = 0, so that we're only left with the volumetric parts of the equation above.","category":"page"},{"location":"intro-to-sem/","page":"-","title":"-","text":"The only supported choice for now in ClimaCore.jl is a Gauss-Legendre-Lobatto rule and nodes.","category":"page"},{"location":"tutorials/introduction/","page":"Introduction to ClimaCore.jl","title":"Introduction to ClimaCore.jl","text":"EditURL = \"https://github.com/CliMA/ClimaCore.jl/blob/main/docs/tutorials/introduction.jl\"","category":"page"},{"location":"tutorials/introduction/#Introduction-to-ClimaCore.jl","page":"Introduction to ClimaCore.jl","title":"Introduction to ClimaCore.jl","text":"","category":"section"},{"location":"tutorials/introduction/","page":"Introduction to ClimaCore.jl","title":"Introduction to ClimaCore.jl","text":"This tutorial is available as a Jupyter notebook.","category":"page"},{"location":"tutorials/introduction/#What-is-ClimaCore?","page":"Introduction to ClimaCore.jl","title":"What is ClimaCore?","text":"","category":"section"},{"location":"tutorials/introduction/","page":"Introduction to ClimaCore.jl","title":"Introduction to ClimaCore.jl","text":"A suite of tools for constructing spatial discretizations","category":"page"},{"location":"tutorials/introduction/","page":"Introduction to ClimaCore.jl","title":"Introduction to ClimaCore.jl","text":"primarily aimed at climate and weather models\ninitial aim:\nspectral element discretization in the horizontal\nstaggered finite difference in the vertical\ncurrently under development","category":"page"},{"location":"tutorials/introduction/","page":"Introduction to ClimaCore.jl","title":"Introduction to ClimaCore.jl","text":"using ClimaCore,\n    ClimaCorePlots, LinearAlgebra, IntervalSets, UnPack, Plots, OrdinaryDiffEq","category":"page"},{"location":"tutorials/introduction/#.-Constructing-a-discretization","page":"Introduction to ClimaCore.jl","title":"1. Constructing a discretization","text":"","category":"section"},{"location":"tutorials/introduction/#.1-Domains","page":"Introduction to ClimaCore.jl","title":"1.1 Domains","text":"","category":"section"},{"location":"tutorials/introduction/","page":"Introduction to ClimaCore.jl","title":"Introduction to ClimaCore.jl","text":"A domain a region of space (think of a mathematical domain).","category":"page"},{"location":"tutorials/introduction/","page":"Introduction to ClimaCore.jl","title":"Introduction to ClimaCore.jl","text":"column_domain = ClimaCore.Domains.IntervalDomain(\n    ClimaCore.Geometry.ZPoint(0.0) .. ClimaCore.Geometry.ZPoint(10.0),\n    boundary_tags = (:bottom, :top),\n)","category":"page"},{"location":"tutorials/introduction/","page":"Introduction to ClimaCore.jl","title":"Introduction to ClimaCore.jl","text":"rectangle_domain = ClimaCore.Domains.RectangleDomain(\n    ClimaCore.Geometry.XPoint(-2π) .. ClimaCore.Geometry.XPoint(2π),\n    ClimaCore.Geometry.YPoint(-2π) .. ClimaCore.Geometry.YPoint(2π),\n    x1periodic = true,\n    x2periodic = true,\n)","category":"page"},{"location":"tutorials/introduction/#.2-Meshes","page":"Introduction to ClimaCore.jl","title":"1.2 Meshes","text":"","category":"section"},{"location":"tutorials/introduction/","page":"Introduction to ClimaCore.jl","title":"Introduction to ClimaCore.jl","text":"A mesh is a division of a domain into elements","category":"page"},{"location":"tutorials/introduction/","page":"Introduction to ClimaCore.jl","title":"Introduction to ClimaCore.jl","text":"column_mesh = ClimaCore.Meshes.IntervalMesh(column_domain, nelems = 32)","category":"page"},{"location":"tutorials/introduction/","page":"Introduction to ClimaCore.jl","title":"Introduction to ClimaCore.jl","text":"rectangle_mesh = ClimaCore.Meshes.RectilinearMesh(rectangle_domain, 16, 16)","category":"page"},{"location":"tutorials/introduction/#.3-Topologies","page":"Introduction to ClimaCore.jl","title":"1.3 Topologies","text":"","category":"section"},{"location":"tutorials/introduction/","page":"Introduction to ClimaCore.jl","title":"Introduction to ClimaCore.jl","text":"A topology determines the ordering and connections between elements of a mesh","category":"page"},{"location":"tutorials/introduction/","page":"Introduction to ClimaCore.jl","title":"Introduction to ClimaCore.jl","text":"At the moment, this is only required for 2D meshes","category":"page"},{"location":"tutorials/introduction/","page":"Introduction to ClimaCore.jl","title":"Introduction to ClimaCore.jl","text":"rectangle_topology = ClimaCore.Topologies.Topology2D(rectangle_mesh)","category":"page"},{"location":"tutorials/introduction/#.4-Spaces","page":"Introduction to ClimaCore.jl","title":"1.4 Spaces","text":"","category":"section"},{"location":"tutorials/introduction/","page":"Introduction to ClimaCore.jl","title":"Introduction to ClimaCore.jl","text":"A space represents a discretized function space over some domain. Currently two discretizations are supported.","category":"page"},{"location":"tutorials/introduction/#.4.1-Staggered-finite-difference-discretization","page":"Introduction to ClimaCore.jl","title":"1.4.1 Staggered finite difference discretization","text":"","category":"section"},{"location":"tutorials/introduction/","page":"Introduction to ClimaCore.jl","title":"Introduction to ClimaCore.jl","text":"This discretizes an interval domain by approximating the function by a value at either the center of each element (CenterFiniteDifferenceSpace), or the faces between elements (FaceFiniteDifferenceSpace).","category":"page"},{"location":"tutorials/introduction/","page":"Introduction to ClimaCore.jl","title":"Introduction to ClimaCore.jl","text":"You can construct either the center or face space from the mesh, then construct the opposite space from the original one (this is to avoid allocating additional memory).","category":"page"},{"location":"tutorials/introduction/","page":"Introduction to ClimaCore.jl","title":"Introduction to ClimaCore.jl","text":"column_center_space = ClimaCore.Spaces.CenterFiniteDifferenceSpace(column_mesh)\n# construct the face space from the center one\ncolumn_face_space =\n    ClimaCore.Spaces.FaceFiniteDifferenceSpace(column_center_space)","category":"page"},{"location":"tutorials/introduction/#.4.2-Spectral-element-discretization","page":"Introduction to ClimaCore.jl","title":"1.4.2 Spectral element discretization","text":"","category":"section"},{"location":"tutorials/introduction/","page":"Introduction to ClimaCore.jl","title":"Introduction to ClimaCore.jl","text":"A spectral element space approximates the function with polynomials in each element. The polynomials are represented using a nodal discretization, which stores the values of the polynomials at particular points in each element (termed nodes or degrees of freedom).","category":"page"},{"location":"tutorials/introduction/","page":"Introduction to ClimaCore.jl","title":"Introduction to ClimaCore.jl","text":"These nodes are chosen by a particular quadrature rule, which allows us to integrate functions over the domain. The only supported choice for now is a Gauss-Legendre-Lobatto rule.","category":"page"},{"location":"tutorials/introduction/","page":"Introduction to ClimaCore.jl","title":"Introduction to ClimaCore.jl","text":"# Gauss-Legendre-Lobatto quadrature with 4 nodes in each direction, so 16 in each element\nquad = ClimaCore.Spaces.Quadratures.GLL{4}()\nrectangle_space =\n    ClimaCore.Spaces.SpectralElementSpace2D(rectangle_topology, quad)","category":"page"},{"location":"tutorials/introduction/#.5-Fields","page":"Introduction to ClimaCore.jl","title":"1.5 Fields","text":"","category":"section"},{"location":"tutorials/introduction/","page":"Introduction to ClimaCore.jl","title":"Introduction to ClimaCore.jl","text":"Finally, we can construct a field: a function in a space. A field is simply a space and the values at each node in the space.","category":"page"},{"location":"tutorials/introduction/","page":"Introduction to ClimaCore.jl","title":"Introduction to ClimaCore.jl","text":"The easiest field to construct is the coordinate field","category":"page"},{"location":"tutorials/introduction/","page":"Introduction to ClimaCore.jl","title":"Introduction to ClimaCore.jl","text":"coord = ClimaCore.Fields.coordinate_field(rectangle_space)","category":"page"},{"location":"tutorials/introduction/","page":"Introduction to ClimaCore.jl","title":"Introduction to ClimaCore.jl","text":"This is a struct-value field: it contains coordinates in a struct at each point. We can extract just the x coordinate, to get a scalar field:","category":"page"},{"location":"tutorials/introduction/","page":"Introduction to ClimaCore.jl","title":"Introduction to ClimaCore.jl","text":"x = coord.x","category":"page"},{"location":"tutorials/introduction/","page":"Introduction to ClimaCore.jl","title":"Introduction to ClimaCore.jl","text":"Although you can't index directly into a field, it can be used in some other ways similar to a Julia Array. For example, broadcasting can be used to define new fields in terms of other ones:","category":"page"},{"location":"tutorials/introduction/","page":"Introduction to ClimaCore.jl","title":"Introduction to ClimaCore.jl","text":"sinx = sin.(x)","category":"page"},{"location":"tutorials/introduction/","page":"Introduction to ClimaCore.jl","title":"Introduction to ClimaCore.jl","text":"Fields can be easily vizualized with Plots.jl:","category":"page"},{"location":"tutorials/introduction/","page":"Introduction to ClimaCore.jl","title":"Introduction to ClimaCore.jl","text":"import Plots\nPlots.plot(sinx)","category":"page"},{"location":"tutorials/introduction/","page":"Introduction to ClimaCore.jl","title":"Introduction to ClimaCore.jl","text":"If you're using the terminal, UnicodePlots is also supported.","category":"page"},{"location":"tutorials/introduction/","page":"Introduction to ClimaCore.jl","title":"Introduction to ClimaCore.jl","text":"This works similarly for finite difference discretizations","category":"page"},{"location":"tutorials/introduction/","page":"Introduction to ClimaCore.jl","title":"Introduction to ClimaCore.jl","text":"column_center_coords = ClimaCore.Fields.coordinate_field(column_center_space)\ncolumn_face_coords = ClimaCore.Fields.coordinate_field(column_face_space)","category":"page"},{"location":"tutorials/introduction/","page":"Introduction to ClimaCore.jl","title":"Introduction to ClimaCore.jl","text":"plot(sin.(column_center_coords.z), ylim = (0.0, 10.0))\nplot!(cos.(column_face_coords.z), ylim = (0.0, 10.0))","category":"page"},{"location":"tutorials/introduction/","page":"Introduction to ClimaCore.jl","title":"Introduction to ClimaCore.jl","text":"Reduction operations are defined anologously:","category":"page"},{"location":"tutorials/introduction/","page":"Introduction to ClimaCore.jl","title":"Introduction to ClimaCore.jl","text":"sum will give the integral of the function","category":"page"},{"location":"tutorials/introduction/","page":"Introduction to ClimaCore.jl","title":"Introduction to ClimaCore.jl","text":"int_D f(x) dx","category":"page"},{"location":"tutorials/introduction/","page":"Introduction to ClimaCore.jl","title":"Introduction to ClimaCore.jl","text":"norm will give the L² function norm","category":"page"},{"location":"tutorials/introduction/","page":"Introduction to ClimaCore.jl","title":"Introduction to ClimaCore.jl","text":"sqrtint_D f(x)^2 dx","category":"page"},{"location":"tutorials/introduction/","page":"Introduction to ClimaCore.jl","title":"Introduction to ClimaCore.jl","text":"sum(sinx) ## integral","category":"page"},{"location":"tutorials/introduction/","page":"Introduction to ClimaCore.jl","title":"Introduction to ClimaCore.jl","text":"norm(sinx) ## L² norm","category":"page"},{"location":"tutorials/introduction/#.6-Vectors-and-vector-fields","page":"Introduction to ClimaCore.jl","title":"1.6 Vectors and vector fields","text":"","category":"section"},{"location":"tutorials/introduction/","page":"Introduction to ClimaCore.jl","title":"Introduction to ClimaCore.jl","text":"A vector field is a field with vector-valued quantity, i.e. at every point in space, you have a vector.","category":"page"},{"location":"tutorials/introduction/","page":"Introduction to ClimaCore.jl","title":"Introduction to ClimaCore.jl","text":"However one of the key requirements of ClimaCore is to support vectors specified in curvilinear or non-Cartesian coordinates. We will discuss this in a bit further, but for now, you can define a 2-dimensional vector field using Geometry.UVVector:","category":"page"},{"location":"tutorials/introduction/","page":"Introduction to ClimaCore.jl","title":"Introduction to ClimaCore.jl","text":"v = ClimaCore.Geometry.UVVector.(coord.y, .-coord.x)","category":"page"},{"location":"tutorials/introduction/#.-Operators","page":"Introduction to ClimaCore.jl","title":"2. Operators","text":"","category":"section"},{"location":"tutorials/introduction/","page":"Introduction to ClimaCore.jl","title":"Introduction to ClimaCore.jl","text":"Operators can compute spatial derivative operations.","category":"page"},{"location":"tutorials/introduction/","page":"Introduction to ClimaCore.jl","title":"Introduction to ClimaCore.jl","text":"for performance reasons, we need to be able to \"fuse\" multiple operators and function applications\nJulia provides a tool for this: broadcasting, with a very flexible API","category":"page"},{"location":"tutorials/introduction/","page":"Introduction to ClimaCore.jl","title":"Introduction to ClimaCore.jl","text":"Can think of operators are \"pseudo-functions\": can't be called directly, but act similar to functions in the context of broadcasting.","category":"page"},{"location":"tutorials/introduction/#.1-Spectral-element-operators","page":"Introduction to ClimaCore.jl","title":"2.1 Spectral element operators","text":"","category":"section"},{"location":"tutorials/introduction/","page":"Introduction to ClimaCore.jl","title":"Introduction to ClimaCore.jl","text":"The Gradient operator takes the gradient of a scalar field, and returns a vector field.","category":"page"},{"location":"tutorials/introduction/","page":"Introduction to ClimaCore.jl","title":"Introduction to ClimaCore.jl","text":"grad = ClimaCore.Operators.Gradient()\n∇sinx = grad.(sinx)","category":"page"},{"location":"tutorials/introduction/","page":"Introduction to ClimaCore.jl","title":"Introduction to ClimaCore.jl","text":"plot(∇sinx.components.data.:1, clim = (-1, 1))","category":"page"},{"location":"tutorials/introduction/","page":"Introduction to ClimaCore.jl","title":"Introduction to ClimaCore.jl","text":"This returns the gradient in covariant coordinates","category":"page"},{"location":"tutorials/introduction/","page":"Introduction to ClimaCore.jl","title":"Introduction to ClimaCore.jl","text":"(nabla f)_i = fracpartial fpartial xi^i","category":"page"},{"location":"tutorials/introduction/","page":"Introduction to ClimaCore.jl","title":"Introduction to ClimaCore.jl","text":"where (xi^1xi^2) are the coordinates in the reference element: a square -11^2.","category":"page"},{"location":"tutorials/introduction/","page":"Introduction to ClimaCore.jl","title":"Introduction to ClimaCore.jl","text":"This can be converted to a local orthogonal basis by multiplying by the partial derivative matrix","category":"page"},{"location":"tutorials/introduction/","page":"Introduction to ClimaCore.jl","title":"Introduction to ClimaCore.jl","text":"fracpartial xipartial x","category":"page"},{"location":"tutorials/introduction/","page":"Introduction to ClimaCore.jl","title":"Introduction to ClimaCore.jl","text":"This can be done calling `ClimaCore.Geometry.LocalVector:","category":"page"},{"location":"tutorials/introduction/","page":"Introduction to ClimaCore.jl","title":"Introduction to ClimaCore.jl","text":"∇sinx_cart = ClimaCore.Geometry.LocalVector.(∇sinx)","category":"page"},{"location":"tutorials/introduction/","page":"Introduction to ClimaCore.jl","title":"Introduction to ClimaCore.jl","text":"plot(∇sinx_cart.components.data.:1, clim = (-1, 1))","category":"page"},{"location":"tutorials/introduction/","page":"Introduction to ClimaCore.jl","title":"Introduction to ClimaCore.jl","text":"plot(∇sinx_cart.components.data.:2, clim = (-1, 1))","category":"page"},{"location":"tutorials/introduction/","page":"Introduction to ClimaCore.jl","title":"Introduction to ClimaCore.jl","text":"∇sinx_ref = ClimaCore.Geometry.UVVector.(cos.(x), 0.0)\nnorm(∇sinx_cart .- ∇sinx_ref)","category":"page"},{"location":"tutorials/introduction/","page":"Introduction to ClimaCore.jl","title":"Introduction to ClimaCore.jl","text":"Similarly, the Divergence operator takes the divergence of vector field, and returns a scalar field.","category":"page"},{"location":"tutorials/introduction/","page":"Introduction to ClimaCore.jl","title":"Introduction to ClimaCore.jl","text":"If we take the divergence of a gradient, we can get a Laplacian:","category":"page"},{"location":"tutorials/introduction/","page":"Introduction to ClimaCore.jl","title":"Introduction to ClimaCore.jl","text":"div = ClimaCore.Operators.Divergence()\n∇²sinx = div.(grad.(sinx))\nplot(∇²sinx)","category":"page"},{"location":"tutorials/introduction/","page":"Introduction to ClimaCore.jl","title":"Introduction to ClimaCore.jl","text":"Note: In curvilinear coordinates, the divergence is defined in terms of the contravariant components u^i:","category":"page"},{"location":"tutorials/introduction/","page":"Introduction to ClimaCore.jl","title":"Introduction to ClimaCore.jl","text":"nabla cdot u = frac1J sum_i fracpartialpartial xi^i (J u^i)","category":"page"},{"location":"tutorials/introduction/","page":"Introduction to ClimaCore.jl","title":"Introduction to ClimaCore.jl","text":"The Divergence operator handles this conversion internally.","category":"page"},{"location":"tutorials/introduction/#.1.1-Direct-stiffness-summation","page":"Introduction to ClimaCore.jl","title":"2.1.1 Direct stiffness summation","text":"","category":"section"},{"location":"tutorials/introduction/","page":"Introduction to ClimaCore.jl","title":"Introduction to ClimaCore.jl","text":"Spectral element operators only operate within a single element, and so the result may be discontinuous. To address this, the usual fix is direct stiffness summation (DSS), which averages the values at the element boundaries.","category":"page"},{"location":"tutorials/introduction/","page":"Introduction to ClimaCore.jl","title":"Introduction to ClimaCore.jl","text":"This corresponds to the L^2 projection onto the subset of continuous functions in our function space.","category":"page"},{"location":"tutorials/introduction/","page":"Introduction to ClimaCore.jl","title":"Introduction to ClimaCore.jl","text":"∇²sinx_dss = ClimaCore.Spaces.weighted_dss!(copy(∇²sinx))\nplot(∇²sinx_dss)","category":"page"},{"location":"tutorials/introduction/","page":"Introduction to ClimaCore.jl","title":"Introduction to ClimaCore.jl","text":"plot(∇²sinx_dss .- ∇²sinx)","category":"page"},{"location":"tutorials/introduction/#.2-Finite-difference-operators","page":"Introduction to ClimaCore.jl","title":"2.2 Finite difference operators","text":"","category":"section"},{"location":"tutorials/introduction/","page":"Introduction to ClimaCore.jl","title":"Introduction to ClimaCore.jl","text":"Finite difference operators are similar with some subtle differences:","category":"page"},{"location":"tutorials/introduction/","page":"Introduction to ClimaCore.jl","title":"Introduction to ClimaCore.jl","text":"they can change staggering (center to face, or vice versa)\nthey can span multiple elements\nno DSS is required\nboundary handling may be required","category":"page"},{"location":"tutorials/introduction/","page":"Introduction to ClimaCore.jl","title":"Introduction to ClimaCore.jl","text":"We use the following convention:","category":"page"},{"location":"tutorials/introduction/","page":"Introduction to ClimaCore.jl","title":"Introduction to ClimaCore.jl","text":"centers are indexed by integers 1, 2, ..., n\nfaces are indexed by half integers ½, 1+½, ..., n+½","category":"page"},{"location":"tutorials/introduction/","page":"Introduction to ClimaCore.jl","title":"Introduction to ClimaCore.jl","text":"Face to center gradient","category":"page"},{"location":"tutorials/introduction/","page":"Introduction to ClimaCore.jl","title":"Introduction to ClimaCore.jl","text":"An finite-difference operator defines a stencil. For example, the gradient operator","category":"page"},{"location":"tutorials/introduction/","page":"Introduction to ClimaCore.jl","title":"Introduction to ClimaCore.jl","text":"nablathetai = fractheta i+tfrac12 - thetai-tfrac12Delta z","category":"page"},{"location":"tutorials/introduction/","page":"Introduction to ClimaCore.jl","title":"Introduction to ClimaCore.jl","text":"(actually, a little more complicated as it gives a vector in a covariant basis)","category":"page"},{"location":"tutorials/introduction/","page":"Introduction to ClimaCore.jl","title":"Introduction to ClimaCore.jl","text":"        ...\n      /\nθ[2+½]\n      \\\n        ∇θ[2]\n      /\nθ[1+½]\n      \\\n        ∇θ[1]\n      /\nθ[½]","category":"page"},{"location":"tutorials/introduction/","page":"Introduction to ClimaCore.jl","title":"Introduction to ClimaCore.jl","text":"Every center value is well-defined, so boundary handling is optional.","category":"page"},{"location":"tutorials/introduction/","page":"Introduction to ClimaCore.jl","title":"Introduction to ClimaCore.jl","text":"cosz = cos.(column_face_coords.z)\ngradf2c = ClimaCore.Operators.GradientF2C()\n∇cosz = gradf2c.(cosz)","category":"page"},{"location":"tutorials/introduction/","page":"Introduction to ClimaCore.jl","title":"Introduction to ClimaCore.jl","text":"plot(map(x -> x.w, ClimaCore.Geometry.WVector.(∇cosz)), ylim = (0, 10))","category":"page"},{"location":"tutorials/introduction/","page":"Introduction to ClimaCore.jl","title":"Introduction to ClimaCore.jl","text":"Center to face gradient","category":"page"},{"location":"tutorials/introduction/","page":"Introduction to ClimaCore.jl","title":"Introduction to ClimaCore.jl","text":"Uses the same stencil, but doesn't work directly:","category":"page"},{"location":"tutorials/introduction/","page":"Introduction to ClimaCore.jl","title":"Introduction to ClimaCore.jl","text":"sinz = sin.(column_center_coords.z)\ngradc2f = ClimaCore.Operators.GradientC2F()\n# ∇sinz = gradc2f.(sinz) ## this would throw an error","category":"page"},{"location":"tutorials/introduction/","page":"Introduction to ClimaCore.jl","title":"Introduction to ClimaCore.jl","text":"This throws an error because face values at the boundary are not well-defined:","category":"page"},{"location":"tutorials/introduction/","page":"Introduction to ClimaCore.jl","title":"Introduction to ClimaCore.jl","text":"...\n      \\\n        ∇θ[2+½]\n      /\nθ[2]\n      \\\n        ∇θ[1+½]\n      /\nθ[1]\n      \\\n        ????","category":"page"},{"location":"tutorials/introduction/","page":"Introduction to ClimaCore.jl","title":"Introduction to ClimaCore.jl","text":"To handle boundaries we need to modify the stencil. Two options:","category":"page"},{"location":"tutorials/introduction/","page":"Introduction to ClimaCore.jl","title":"Introduction to ClimaCore.jl","text":"provide the value theta^* of theta at the boundary:","category":"page"},{"location":"tutorials/introduction/","page":"Introduction to ClimaCore.jl","title":"Introduction to ClimaCore.jl","text":"nablathetatfrac12 = fractheta1 - theta^*Delta z 2","category":"page"},{"location":"tutorials/introduction/","page":"Introduction to ClimaCore.jl","title":"Introduction to ClimaCore.jl","text":"provide the gradient nablatheta^* of theta at the boundary:","category":"page"},{"location":"tutorials/introduction/","page":"Introduction to ClimaCore.jl","title":"Introduction to ClimaCore.jl","text":"nablathetatfrac12 = nablatheta^*","category":"page"},{"location":"tutorials/introduction/","page":"Introduction to ClimaCore.jl","title":"Introduction to ClimaCore.jl","text":"These modified stencils are provided as keyword arguments to the operator (based on the boundary label names):","category":"page"},{"location":"tutorials/introduction/","page":"Introduction to ClimaCore.jl","title":"Introduction to ClimaCore.jl","text":"sinz = sin.(column_center_coords.z)\ngradc2f = ClimaCore.Operators.GradientC2F(\n    bottom = ClimaCore.Operators.SetValue(sin(0.0)),\n    top = ClimaCore.Operators.SetGradient(\n        ClimaCore.Geometry.WVector(cos(10.0)),\n    ),\n)\n∇sinz = gradc2f.(sinz)","category":"page"},{"location":"tutorials/introduction/","page":"Introduction to ClimaCore.jl","title":"Introduction to ClimaCore.jl","text":"plot(map(x -> x.w, ClimaCore.Geometry.WVector.(∇sinz)), ylim = (0, 10))","category":"page"},{"location":"tutorials/introduction/","page":"Introduction to ClimaCore.jl","title":"Introduction to ClimaCore.jl","text":"As before, multiple operators (or functions) can be fused together with broadcasting.","category":"page"},{"location":"tutorials/introduction/","page":"Introduction to ClimaCore.jl","title":"Introduction to ClimaCore.jl","text":"One extra advantage of this is that boundaries of the inner operators only need to be specified if they would affect the final result.","category":"page"},{"location":"tutorials/introduction/","page":"Introduction to ClimaCore.jl","title":"Introduction to ClimaCore.jl","text":"Consider the center-to-center Laplacian:","category":"page"},{"location":"tutorials/introduction/","page":"Introduction to ClimaCore.jl","title":"Introduction to ClimaCore.jl","text":"...\n      \\       /\n        ∇θ[2+½]\n      /       \\\nθ[2]            ∇⋅∇θ[2]\n      \\       /\n        ∇θ[1+½]\n      /       \\\nθ[1]            ∇⋅∇θ[1]\n              /\n         ∇θ*","category":"page"},{"location":"tutorials/introduction/","page":"Introduction to ClimaCore.jl","title":"Introduction to ClimaCore.jl","text":"sinz = sin.(column_center_coords.z)\n# we don't need to specify boundaries, as the stencil won't reach that far\ngradc2f = ClimaCore.Operators.GradientC2F()\ndivf2c = ClimaCore.Operators.DivergenceF2C(\n    bottom = ClimaCore.Operators.SetValue(ClimaCore.Geometry.WVector(cos(0.0))),\n    top = ClimaCore.Operators.SetValue(ClimaCore.Geometry.WVector(cos(10.0))),\n)\n∇∇sinz = divf2c.(gradc2f.(sinz))","category":"page"},{"location":"tutorials/introduction/","page":"Introduction to ClimaCore.jl","title":"Introduction to ClimaCore.jl","text":"plot(∇∇sinz, ylim = (0, 10))","category":"page"},{"location":"tutorials/introduction/#.-Solving-PDEs","page":"Introduction to ClimaCore.jl","title":"3. Solving PDEs","text":"","category":"section"},{"location":"tutorials/introduction/","page":"Introduction to ClimaCore.jl","title":"Introduction to ClimaCore.jl","text":"ClimaCore can be used for spatial discretizations of PDEs. For temporal discretization, we can use the OrdinaryDiffEq package, which we aim to be compatibile with.","category":"page"},{"location":"tutorials/introduction/","page":"Introduction to ClimaCore.jl","title":"Introduction to ClimaCore.jl","text":"using OrdinaryDiffEq","category":"page"},{"location":"tutorials/introduction/#.1-Heat-equation-using-finite-differences","page":"Introduction to ClimaCore.jl","title":"3.1 Heat equation using finite differences","text":"","category":"section"},{"location":"tutorials/introduction/","page":"Introduction to ClimaCore.jl","title":"Introduction to ClimaCore.jl","text":"We will use a cell-center discretization of the heat equation:","category":"page"},{"location":"tutorials/introduction/","page":"Introduction to ClimaCore.jl","title":"Introduction to ClimaCore.jl","text":"fracpartial ypartial t = alpha nabla cdot nabla y","category":"page"},{"location":"tutorials/introduction/","page":"Introduction to ClimaCore.jl","title":"Introduction to ClimaCore.jl","text":"At the bottom we will use a Dirichlet condition y(0) = 1at the bottom: since we don't actually have a value located at the bottom, we will use aSetValue` boundary modifier on the inner gradient.","category":"page"},{"location":"tutorials/introduction/","page":"Introduction to ClimaCore.jl","title":"Introduction to ClimaCore.jl","text":"At the top we will use a Neumann condition fracpartial ypartial z(10) = 0. We can do this two equivalent ways:","category":"page"},{"location":"tutorials/introduction/","page":"Introduction to ClimaCore.jl","title":"Introduction to ClimaCore.jl","text":"a SetGradient on the gradient operator\na SetValue on the divergence operator","category":"page"},{"location":"tutorials/introduction/","page":"Introduction to ClimaCore.jl","title":"Introduction to ClimaCore.jl","text":"either will work.","category":"page"},{"location":"tutorials/introduction/","page":"Introduction to ClimaCore.jl","title":"Introduction to ClimaCore.jl","text":"y0 = zeros(column_center_space)\n\n# define the tendency function\nfunction heat_fd_tendency!(dydt, y, α, t)\n    gradc2f = ClimaCore.Operators.GradientC2F(\n        bottom = ClimaCore.Operators.SetValue(1.0),\n        top = ClimaCore.Operators.SetGradient(ClimaCore.Geometry.WVector(0.0)),\n    )\n    divf2c = ClimaCore.Operators.DivergenceF2C()\n    # the @. macro \"dots\" the whole expression\n    # i.e.  dydt .= α .* divf2c.(gradc2f.(y))\n    @. dydt = α * divf2c(gradc2f(y))\nend\n\nheat_fd_prob = ODEProblem(heat_fd_tendency!, y0, (0.0, 5.0), 0.1)\nheat_fd_sol = solve(heat_fd_prob, SSPRK33(), dt = 0.1, saveat = 0.25)","category":"page"},{"location":"tutorials/introduction/","page":"Introduction to ClimaCore.jl","title":"Introduction to ClimaCore.jl","text":"anim = Plots.@animate for u in heat_fd_sol.u\n    plot(u, xlim = (0, 1), ylim = (0, 10))\nend\nmp4(anim)","category":"page"},{"location":"tutorials/introduction/#.2-Heat-equation-using-continuous-Galerkin-(CG)-spectral-element","page":"Introduction to ClimaCore.jl","title":"3.2 Heat equation using continuous Galerkin (CG) spectral element","text":"","category":"section"},{"location":"tutorials/introduction/","page":"Introduction to ClimaCore.jl","title":"Introduction to ClimaCore.jl","text":"function heat_cg_tendency!(dydt, y, α, t)\n    grad = ClimaCore.Operators.Gradient()\n    wdiv = ClimaCore.Operators.WeakDivergence()\n    # apply element operators\n    @. dydt = α * wdiv(grad(y))\n\n    # direct stiffness summation (DSS): project to continuous function space\n    ClimaCore.Spaces.weighted_dss!(dydt)\n    return dydt\nend\n\ny0 = exp.(.-(coord.y .^ 2 .+ coord.x .^ 2) ./ 2)\n\nheat_cg_prob = ODEProblem(heat_cg_tendency!, y0, (0.0, 5.0), 0.1)\nheat_cg_sol = solve(heat_cg_prob, SSPRK33(), dt = 0.1, saveat = 0.5)","category":"page"},{"location":"tutorials/introduction/","page":"Introduction to ClimaCore.jl","title":"Introduction to ClimaCore.jl","text":"anim = Plots.@animate for u in heat_cg_sol.u\n    Plots.plot(u, c = :thermal)\nend\nmp4(anim)","category":"page"},{"location":"tutorials/introduction/#.3-Shallow-water-equations","page":"Introduction to ClimaCore.jl","title":"3.3 Shallow water equations","text":"","category":"section"},{"location":"tutorials/introduction/","page":"Introduction to ClimaCore.jl","title":"Introduction to ClimaCore.jl","text":"The shallow water equations in vector invariant form can be written as","category":"page"},{"location":"tutorials/introduction/","page":"Introduction to ClimaCore.jl","title":"Introduction to ClimaCore.jl","text":"beginalign*\n    fracpartial rhopartial t + nabla cdot (rho u) = 0\n    fracpartial u_ipartial t + nabla (Phi + tfrac12u^2)_i  = J (u times (nabla times u))_i\nendalign*","category":"page"},{"location":"tutorials/introduction/","page":"Introduction to ClimaCore.jl","title":"Introduction to ClimaCore.jl","text":"where J is the Jacobian determinant, and Phi = g rho.","category":"page"},{"location":"tutorials/introduction/","page":"Introduction to ClimaCore.jl","title":"Introduction to ClimaCore.jl","text":"Note that the velocity u is specified in covariant coordinates u_i.","category":"page"},{"location":"tutorials/introduction/","page":"Introduction to ClimaCore.jl","title":"Introduction to ClimaCore.jl","text":"For vizualization purposes, we can model a passive tracer theta as","category":"page"},{"location":"tutorials/introduction/","page":"Introduction to ClimaCore.jl","title":"Introduction to ClimaCore.jl","text":"fracpartial rho thetapartial t + nabla cdot (rho theta u) = 0","category":"page"},{"location":"tutorials/introduction/","page":"Introduction to ClimaCore.jl","title":"Introduction to ClimaCore.jl","text":"using ClimaCore.Geometry\n\nparameters = (\n    ϵ = 0.1,  ## perturbation size for initial condition\n    l = 0.5, ## Gaussian width\n    k = 0.5, ## Sinusoidal wavenumber\n    ρ₀ = 1.0, ## reference density\n    c = 2,\n    g = 10,\n    D₄ = 1e-4, ## hyperdiffusion coefficient\n)\n\nfunction init_state(local_geometry, p)\n    coord = local_geometry.coordinates\n    @unpack x, y = coord\n    # set initial state\n    ρ = p.ρ₀\n\n    # set initial velocity\n    U₁ = cosh(y)^(-2)\n\n    # Ψ′ = exp(-(x2 + p.l / 10)^2 / 2p.l^2) * cos(p.k * x) * cos(p.k * y)\n    # Vortical velocity fields (u₁′, u₂′) = (-∂²Ψ′, ∂¹Ψ′)\n    ϕ = exp(-(y + p.l / 10)^2 / 2p.l^2)\n    u₁′ = ϕ * (y + p.l / 10) / p.l^2 * cos(p.k * x) * cos(p.k * y)\n    u₁′ += p.k * ϕ * cos(p.k * x) * sin(p.k * y)\n    u₂′ = -p.k * ϕ * sin(p.k * x) * cos(p.k * y)\n\n    u = Geometry.Covariant12Vector(\n        Geometry.UVVector(U₁ + p.ϵ * u₁′, p.ϵ * u₂′),\n        local_geometry,\n    )\n\n    # set initial tracer\n    θ = sin(p.k * y)\n    return (ρ = ρ, u = u, ρθ = ρ * θ)\nend\n\n\ny0 =\n    init_state.(\n        ClimaCore.Fields.local_geometry_field(rectangle_space),\n        Ref(parameters),\n    )\n\n# plot initial tracer\nPlots.plot(y0.ρθ)","category":"page"},{"location":"tutorials/introduction/","page":"Introduction to ClimaCore.jl","title":"Introduction to ClimaCore.jl","text":"function shallow_water_tendency!(dydt, y, _, t)\n\n    @unpack D₄, g = parameters\n\n    sdiv = ClimaCore.Operators.Divergence()\n    wdiv = ClimaCore.Operators.WeakDivergence()\n    grad = ClimaCore.Operators.Gradient()\n    wgrad = ClimaCore.Operators.WeakGradient()\n    curl = ClimaCore.Operators.Curl()\n    wcurl = ClimaCore.Operators.WeakCurl()\n\n\n    # compute hyperviscosity first\n    @. dydt.u =\n        wgrad(sdiv(y.u)) -\n        Geometry.Covariant12Vector(wcurl(Geometry.Covariant3Vector(curl(y.u))))\n    @. dydt.ρθ = wdiv(grad(y.ρθ))\n\n    ClimaCore.Spaces.weighted_dss!(dydt)\n\n    @. dydt.u =\n        -D₄ * (\n            wgrad(sdiv(dydt.u)) - Geometry.Covariant12Vector(\n                wcurl(Geometry.Covariant3Vector(curl(dydt.u))),\n            )\n        )\n    @. dydt.ρθ = -D₄ * wdiv(grad(dydt.ρθ))\n\n    # comute rest of tendency\n    @. begin\n        dydt.ρ = -wdiv(y.ρ * y.u)\n        dydt.u += -grad(g * y.ρ + norm(y.u)^2 / 2) + y.u × curl(y.u)\n        dydt.ρθ += -wdiv(y.ρθ * y.u)\n    end\n    ClimaCore.Spaces.weighted_dss!(dydt)\n    return dydt\nend","category":"page"},{"location":"tutorials/introduction/","page":"Introduction to ClimaCore.jl","title":"Introduction to ClimaCore.jl","text":"shallow_water_prob = ODEProblem(shallow_water_tendency!, y0, (0.0, 20.0))\n@time shallow_water_sol =\n    solve(shallow_water_prob, SSPRK33(), dt = 0.05, saveat = 1.0)\nanim = Plots.@animate for u in shallow_water_sol.u\n    Plots.plot(u.ρθ, clim = (-1, 1))\nend\nmp4(anim)","category":"page"},{"location":"tutorials/introduction/","page":"Introduction to ClimaCore.jl","title":"Introduction to ClimaCore.jl","text":"","category":"page"},{"location":"tutorials/introduction/","page":"Introduction to ClimaCore.jl","title":"Introduction to ClimaCore.jl","text":"This page was generated using Literate.jl.","category":"page"},{"location":"lib/ClimaCoreTempestRemap/#ClimaCoreTempestRemap.jl","page":"ClimaCoreTempestRemap.jl","title":"ClimaCoreTempestRemap.jl","text":"","category":"section"},{"location":"lib/ClimaCoreTempestRemap/","page":"ClimaCoreTempestRemap.jl","title":"ClimaCoreTempestRemap.jl","text":"CurrentModule = ClimaCoreTempestRemap","category":"page"},{"location":"lib/ClimaCoreTempestRemap/","page":"ClimaCoreTempestRemap.jl","title":"ClimaCoreTempestRemap.jl","text":"ClimaCoreTempestRemap.jl provides an interfaces for using ClimaCore data with the TempestRemap remapping package, by Paul Ullrich.","category":"page"},{"location":"lib/ClimaCoreTempestRemap/#Interface","page":"ClimaCoreTempestRemap.jl","title":"Interface","text":"","category":"section"},{"location":"lib/ClimaCoreTempestRemap/#Mesh-export","page":"ClimaCoreTempestRemap.jl","title":"Mesh export","text":"","category":"section"},{"location":"lib/ClimaCoreTempestRemap/","page":"ClimaCoreTempestRemap.jl","title":"ClimaCoreTempestRemap.jl","text":"write_exodus","category":"page"},{"location":"lib/ClimaCoreTempestRemap/#ClimaCoreTempestRemap.write_exodus","page":"ClimaCoreTempestRemap.jl","title":"ClimaCoreTempestRemap.write_exodus","text":"write_exodus(filename, topology::Topology2D; normalize_coordinates=true)\n\nWrite the topology to an Exodus-formatted NetCDF file.\n\nIt tries to adhere to the Exodus II specification, but it is primarily intended for use with TempestRemap.\n\nNote: the generated meshes will use a different ordering of nodes and elements than those generated by TempestRemap itself.\n\nOptions:\n\nnormalize_coordinates: if true, the coordinates are normalized to be on the unit sphere (this is required for use with TempestRemap)\n\nReferences\n\nEXODUS II: A finite element data model: https://www.osti.gov/biblio/10102115-exodus-ii-finite-element-data-model\n\n\n\n\n\n","category":"function"},{"location":"lib/ClimaCoreTempestRemap/#NetCDF-data-export","page":"ClimaCoreTempestRemap.jl","title":"NetCDF data export","text":"","category":"section"},{"location":"lib/ClimaCoreTempestRemap/","page":"ClimaCoreTempestRemap.jl","title":"ClimaCoreTempestRemap.jl","text":"def_time_coord\ndef_space_coord\nNCDatasets.defVar(::NCDatasets.NCDataset, ::Any, field::Fields.Field)\nBase.setindex!(::NCDatasets.CFVariable, ::Fields.Field, ::Colon)","category":"page"},{"location":"lib/ClimaCoreTempestRemap/#ClimaCoreTempestRemap.def_time_coord","page":"ClimaCoreTempestRemap.jl","title":"ClimaCoreTempestRemap.def_time_coord","text":"def_time_coord(nc::NCDataset, length=Inf, eltype=Float64;\n    units = \"seconds since 2020-01-01 00:00:00\"\n    kwargs...\n)\n\nDeine a time coordinate (dimension + variable) \"time\" in the NetCDF dataset nc. By default its length is set to be unlimited. The variable corresponding to the coordinate is returned.\n\nAdditional attributes can be added as keyword arguments.\n\nExample\n\ntimevar = add_time_coord!(nc; units = \"seconds since 2020-01-01 00:00:00\",)\ntimevar[:] = collect(0.0:0.5:60)\n\n\n\n\n\n","category":"function"},{"location":"lib/ClimaCoreTempestRemap/#ClimaCoreTempestRemap.def_space_coord","page":"ClimaCoreTempestRemap.jl","title":"ClimaCoreTempestRemap.def_space_coord","text":"def_space_coord(nc::NCDataset, space::Spaces.AbstractSpace; type = \"dgll\")\n\nAdd spatial dimensions for space in the NetCDF dataset nc, compatible with the type used by remap_weights.\n\nIf a compatible dimension already exists, it will be reused.\n\n\n\n\n\n","category":"function"},{"location":"lib/ClimaCoreTempestRemap/#NCDatasets.defVar-Tuple{NCDatasets.NCDataset, Any, ClimaCore.Fields.Field}","page":"ClimaCoreTempestRemap.jl","title":"NCDatasets.defVar","text":"NCDatasets.defVar(nc::NCDataset, name, field::Field, extradims=())\n\nDefine a new variable in nc named name of suitable for storing field, along with any further dimensions specified in extradims. The new variable is returned.\n\nnote: Note\nThis does not write any data to the variable.\n\n\n\n\n\n","category":"method"},{"location":"lib/ClimaCoreTempestRemap/#Base.setindex!-Tuple{NCDatasets.CFVariable, ClimaCore.Fields.Field, Colon}","page":"ClimaCoreTempestRemap.jl","title":"Base.setindex!","text":"var[:, extraidx...] = field\n\nWrite the data in field to a NetCDF variable var. extraidx are any extra indices of var.\n\nAppropriate spatial dimensions should already be defined by defVar.\n\n# Given a collection of fields U, write them as a single array to a NetCDF file.\ndef_space_coord(nc, space)\nnc_time = def_time_coord(nc)\nnc_u = defVar(nc, \"u\", Float64, space, (\"time\",))\nfor (i,t) in enumerate(times)\n    nc_time[i] = t\n    nc_u[:,i] = U[i]\nend\n\n\n\n\n\n","category":"method"},{"location":"lib/ClimaCoreTempestRemap/#Wrapper-functions","page":"ClimaCoreTempestRemap.jl","title":"Wrapper functions","text":"","category":"section"},{"location":"lib/ClimaCoreTempestRemap/","page":"ClimaCoreTempestRemap.jl","title":"ClimaCoreTempestRemap.jl","text":"rll_mesh\noverlap_mesh\nremap_weights\napply_remap","category":"page"},{"location":"lib/ClimaCoreTempestRemap/#ClimaCoreTempestRemap.rll_mesh","page":"ClimaCoreTempestRemap.jl","title":"ClimaCoreTempestRemap.rll_mesh","text":"rll_mesh(filename::AbstractString; nlat=90, nlon = round(Int, nlat * 1.6); verbose=false)\n\nCreate a regular latitude-longitude (RLL) mesh and write it to filename in Exodus format. nlat is the number of latitudinal cells, and nlon is the number of longitudinal cells.\n\nSet verbose=true to print information.\n\nSee Tempest remap: mesh generation\n\n\n\n\n\n","category":"function"},{"location":"lib/ClimaCoreTempestRemap/#ClimaCoreTempestRemap.overlap_mesh","page":"ClimaCoreTempestRemap.jl","title":"ClimaCoreTempestRemap.overlap_mesh","text":"overlap_mesh(outfile::AbstractString, meshfile_a::AbstractString, meshfile_b::AbstractString; verbose=false)\n\nCreate the overlap mesh of meshfile_a and meshfile_b and write it to outfile. All files should be in Exodus format.\n\nSet verbose=true to print information.\n\nSee Tempest remap: mesh generation\n\n\n\n\n\n","category":"function"},{"location":"lib/ClimaCoreTempestRemap/#ClimaCoreTempestRemap.remap_weights","page":"ClimaCoreTempestRemap.jl","title":"ClimaCoreTempestRemap.remap_weights","text":"remap_weights(\n    weightfile::AbstractString,\n    meshfile_in::AbstractString,\n    meshfile_out::AbstractString,\n    meshfile_overlap::AbstractString;\n    verbose=false,\n    kwargs...\n)\n\nCreate a file weightfile in SCRIP format containing the remapping weights from meshfile_in to meshfile_out, where overlap_meshfile is constructed via overlap_meshfile(meshfile_overlap, meshfile_in, meshfile_out).\n\nKeyword arguments are passed as command-line options. These include:\n\nin_type / out_type: the type of the input and output mesh:\n\"fv\" (default): finite volume (one value per element)\n\"cgll\": continuous GLL finite element method (a single value for colocated nodes)\n\"dgll\": discontinuous GLL finite element method (duplicate values for colocated nodes)\n'innp'/'outnp': Order of input and output meshes\n\nSet verbose=true to print information.\n\nSee Tempest remap: offline map generation\n\n\n\n\n\n","category":"function"},{"location":"lib/ClimaCoreTempestRemap/#ClimaCoreTempestRemap.apply_remap","page":"ClimaCoreTempestRemap.jl","title":"ClimaCoreTempestRemap.apply_remap","text":"apply_remap(outfile::AbstractString, infile::AbstractString, weightfile::AbstractString, vars; verbose=false)\n\nRemap the NetCDF file infile to outfile, using the remapping weights weightfile constructed via remap_weights. vars should be a collection of variable names to remap.\n\nSet verbose=true to print information.\n\nSee Tempest remap: offline map application\n\n\n\n\n\n","category":"function"},{"location":"lib/ClimaCoreTempestRemap/#Example","page":"ClimaCoreTempestRemap.jl","title":"Example","text":"","category":"section"},{"location":"lib/ClimaCoreTempestRemap/","page":"ClimaCoreTempestRemap.jl","title":"ClimaCoreTempestRemap.jl","text":"The following example converts an OrdinaryDiffEq solution object sol to a netcdf file, and remaps it to an regular latitude-longitude (RLL) grid.","category":"page"},{"location":"lib/ClimaCoreTempestRemap/","page":"ClimaCoreTempestRemap.jl","title":"ClimaCoreTempestRemap.jl","text":"using ClimaCore: Geometry, Meshes, Domains, Topologies, Spaces\nusing NCDatasets, ClimaCoreTempestRemap\n\n# sol is the integrator solution\n# cspace is the center extrduded space\n# fspace is the face extruded space\n\n# the issue is that the Space types changed since this changed\n# we can reconstruct it by digging around a bit\nNq = Spaces.Quadratures.degrees_of_freedom(cspace.quadrature_style)\n\ndatafile_cc = \"test.nc\"\nNCDataset(datafile_cc, \"c\") do nc\n    # defines the appropriate dimensions and variables for a space coordinate\n    def_space_coord(nc, cspace)\n    def_space_coord(nc, fspace)\n    # defines the appropriate dimensions and variables for a time coordinate (by default, unlimited size)\n    nc_time = def_time_coord(nc)\n\n    # define variables\n    nc_rho = defVar(nc, \"rho\", Float64, cspace, (\"time\",))\n    nc_theta = defVar(nc, \"theta\", Float64, cspace, (\"time\",))\n    nc_u = defVar(nc, \"u\", Float64, cspace, (\"time\",))\n    nc_v = defVar(nc, \"v\", Float64, cspace, (\"time\",))\n    nc_w = defVar(nc, \"w\", Float64, fspace, (\"time\",))\n\n    # write data to netcdf file\n    for i = 1:length(sol.u)\n        nc_time[i] = sol.t[i]\n\n        # extract fields and convert to orthogonal coordinates\n        Yc = sol.u[i].Yc\n        uₕ = Geometry.UVVector.(sol.u[i].uₕ)\n        w = Geometry.WVector.(sol.u[i].w)\n\n        # write fields to file\n        nc_rho[:,i] = Yc.ρ\n        nc_theta[:,i] = Yc.ρθ ./ Yc.ρ\n        nc_u[:,i] = map(u -> u.u, uₕ)\n        nc_v[:,i] = map(u -> u.v, uₕ)\n        nc_w[:,i] = map(u -> u.w, w)\n    end\nend\n\n# write out our cubed sphere mesh\nmeshfile_cc = \"mesh_cubedsphere.g\"\nwrite_exodus(meshfile_cc, cspace.horizontal_space.topology)\n\n# write out RLL mesh\nnlat = 90\nnlon = 180\nmeshfile_rll = \"mesh_rll.g\"\nrll_mesh(meshfile_rll; nlat = nlat, nlon = nlon)\n\n# construct overlap mesh\nmeshfile_overlap = \"mesh_overlap.g\"\noverlap_mesh(meshfile_overlap, meshfile_cc, meshfile_rll)\n\n# construct remap weight file\nweightfile = \"remap_weights.nc\"\nremap_weights(\n    weightfile,\n    meshfile_cc,\n    meshfile_rll,\n    meshfile_overlap;\n    in_type = \"cgll\",\n    in_np = Spaces.degrees_of_freedom(space),\n)\n\n# apply remap\ndatafile_rll = \"data_rll.nc\"\napply_remap(datafile_rll, datafile_cc, weightfile, [\"rho\", \"theta\", \"u\", \"v\", \"w\"])","category":"page"},{"location":"operators/#Operators","page":"Operators","title":"Operators","text":"","category":"section"},{"location":"operators/","page":"Operators","title":"Operators","text":"CurrentModule = ClimaCore.Operators","category":"page"},{"location":"operators/","page":"Operators","title":"Operators","text":"Operators can compute spatial derivative operations.","category":"page"},{"location":"operators/","page":"Operators","title":"Operators","text":"for performance reasons, we need to be able to \"fuse\" multiple operators and","category":"page"},{"location":"operators/","page":"Operators","title":"Operators","text":"function applications","category":"page"},{"location":"operators/","page":"Operators","title":"Operators","text":"Julia provides a tool for this: broadcasting, with a very flexible API","category":"page"},{"location":"operators/","page":"Operators","title":"Operators","text":"Can think of operators are \"pseudo-functions\": can't be called directly, but act similar to functions in the context of broadcasting. They are matrix-free, in the sense that we define the action of the operator directly on a field, without explicitly assembling the matrix representing the discretized operator.","category":"page"},{"location":"operators/#Spectral-element-operators","page":"Operators","title":"Spectral element operators","text":"","category":"section"},{"location":"operators/#Differential-Operators","page":"Operators","title":"Differential Operators","text":"","category":"section"},{"location":"operators/","page":"Operators","title":"Operators","text":"Gradient\nDivergence\nWeakDivergence\nWeakGradient\nCurl\nWeakCurl","category":"page"},{"location":"operators/#ClimaCore.Operators.Gradient","page":"Operators","title":"ClimaCore.Operators.Gradient","text":"grad = Gradient()\ngrad.(f)\n\nCompute the (strong) gradient of f on each element, returning a CovariantVector-field.\n\nThe ith covariant component of the gradient is the partial derivative with respect to the reference element:\n\n(nabla f)_i = fracpartial fpartial xi^i\n\nDiscretely, this can be written in matrix form as\n\nD_i f\n\nwhere D_i is the derivative matrix along the ith dimension.\n\nReferences\n\nMark A Taylor, Aimé Fournier (2010), equation 16\n\n\n\n\n\n","category":"type"},{"location":"operators/#ClimaCore.Operators.Divergence","page":"Operators","title":"ClimaCore.Operators.Divergence","text":"div = Divergence()\ndiv.(u)\n\nComputes the per-element spectral (strong) divergence of a vector field u.\n\nThe divergence of a vector field u is defined as\n\nnabla cdot u = sum_i frac1J fracpartial (J u^i)partial xi^i\n\nwhere J is the Jacobian determinant, u^i is the ith contravariant component of u.\n\nThis is discretized by\n\nsum_i I leftfrac1J fracpartial (IJ u^i)partial xi^i right\n\nwhere Ix is the interpolation operator that projects to the unique polynomial interpolating x at the quadrature points. In matrix form, this can be written as\n\nJ^-1 sum_i D_i J u^i\n\nwhere D_i is the derivative matrix along the ith dimension\n\nReferences\n\nMark A Taylor, Aimé Fournier (2010), equation 15\n\n\n\n\n\n","category":"type"},{"location":"operators/#ClimaCore.Operators.WeakDivergence","page":"Operators","title":"ClimaCore.Operators.WeakDivergence","text":"wdiv = WeakDivergence()\nwdiv.(u)\n\nComputes the \"weak divergence\" of a vector field u.\n\nThis is defined as the scalar field theta in mathcalV_0 such that for all phiin mathcalV_0\n\nint_Omega phi theta  d Omega\n=\n- int_Omega (nabla phi) cdot u d Omega\n\nwhere mathcalV_0 is the space of u.\n\nThis arises as the contribution of the volume integral after by applying integration by parts to the weak form expression of the divergence\n\nint_Omega phi (nabla cdot u)  d Omega\n=\n- int_Omega (nabla phi) cdot u d Omega\n+ oint_partial Omega phi (u cdot n) d sigma\n\nIt can be written in matrix form as\n\nϕ^top WJ θ = - sum_i (D_i ϕ)^top WJ u^i\n\nwhich reduces to\n\nθ = -(WJ)^-1 sum_i D_i^top WJ u^i\n\nwhere\n\nJ is the diagonal Jacobian matrix\nW is the diagonal matrix of quadrature weights\nD_i is the derivative matrix along the ith dimension\n\n\n\n\n\n","category":"type"},{"location":"operators/#ClimaCore.Operators.WeakGradient","page":"Operators","title":"ClimaCore.Operators.WeakGradient","text":"wgrad = WeakGradient()\nwgrad.(f)\n\nCompute the \"weak gradient\" of f on each element.\n\nThis is defined as the the vector field theta in mathcalV_0 such that for all phi in mathcalV_0\n\nint_Omega phi cdot theta  d Omega\n=\n- int_Omega (nabla cdot phi) f  dOmega\n\nwhere mathcalV_0 is the space of f.\n\nThis arises from the contribution of the volume integral after by applying integration by parts to the weak form expression of the gradient\n\nint_Omega phi cdot (nabla f)  d Omega\n=\n- int_Omega f (nabla cdot phi)  dOmega\n+ oint_partial Omega f (phi cdot n)  d sigma\n\nIn matrix form, this becomes\n\nphi^i^top W J theta_i = - ( J^-1 D_i J phi^i )^top W J f\n\nwhich reduces to\n\ntheta_i = -W^-1 D_i^top W f\n\nwhere D_i is the derivative matrix along the ith dimension.\n\n\n\n\n\n","category":"type"},{"location":"operators/#ClimaCore.Operators.Curl","page":"Operators","title":"ClimaCore.Operators.Curl","text":"curl = Curl()\ncurl.(u)\n\nComputes the per-element spectral (strong) curl of a covariant vector field u.\n\nNote: The vector field u needs to be excliclty converted to a CovaraintVector, as then the Curl is independent of the local metric tensor.\n\nThe curl of a vector field u is a vector field with contravariant components\n\n(nabla times u)^i = frac1J sum_jk epsilon^ijk fracpartial u_kpartial xi^j\n\nwhere J is the Jacobian determinant, u_k is the kth covariant component of u, and epsilon^ijk are the Levi-Civita symbols. In other words\n\nbeginbmatrix\n  (nabla times u)^1 \n  (nabla times u)^2 \n  (nabla times u)^3\nendbmatrix\n=\nfrac1J beginbmatrix\n  fracpartial u_3partial xi^2 - fracpartial u_2partial xi^3 \n  fracpartial u_1partial xi^3 - fracpartial u_3partial xi^1 \n  fracpartial u_2partial xi^1 - fracpartial u_1partial xi^2\nendbmatrix\n\nIn matrix form, this becomes\n\nepsilon^ijk J^-1 D_j u_k\n\nNote that unused dimensions will be dropped: e.g. the 2D curl of a Covariant12Vector-field will return a Contravariant3Vector.\n\nReferences\n\nMark A Taylor, Aimé Fournier (2010), equation 17\n\n\n\n\n\n","category":"type"},{"location":"operators/#ClimaCore.Operators.WeakCurl","page":"Operators","title":"ClimaCore.Operators.WeakCurl","text":"wcurl = WeakCurl()\nwcurl.(u)\n\nComputes the \"weak curl\" on each element of a covariant vector field u.\n\nNote: The vector field u needs to be excliclty converted to a CovaraintVector, as then the WeakCurl is independent of the local metric tensor.\n\nThis is defined as the vector field theta in mathcalV_0 such that for all phi in mathcalV_0\n\nint_Omega phi cdot theta  d Omega\n=\nint_Omega (nabla times phi) cdot u d Omega\n\nwhere mathcalV_0 is the space of f.\n\nThis arises from the contribution of the volume integral after by applying integration by parts to the weak form expression of the curl\n\nint_Omega phi cdot (nabla times u) dOmega\n=\nint_Omega (nabla times phi) cdot u d Omega\n- oint_partial Omega (phi times u) cdot n dsigma\n\nIn matrix form, this becomes\n\nphi_i^top W J theta^i = (J^-1 epsilon^kji D_j phi_i)^top W J u_k\n\nwhich, by using the anti-symmetry of the Levi-Civita symbol, reduces to\n\ntheta^i = - epsilon^ijk (WJ)^-1 D_j^top W u_k\n\n\n\n\n\n","category":"type"},{"location":"operators/#Interpolation-Operators","page":"Operators","title":"Interpolation Operators","text":"","category":"section"},{"location":"operators/","page":"Operators","title":"Operators","text":"Interpolate\nRestrict","category":"page"},{"location":"operators/#ClimaCore.Operators.Interpolate","page":"Operators","title":"ClimaCore.Operators.Interpolate","text":"i = Interpolate(space)\ni.(f)\n\nInterpolates f to the space. If space has equal or higher polynomial degree as the space of f, this is exact, otherwise it will be lossy.\n\nIn matrix form, it is the linear operator\n\nI = bigotimes_i I_i\n\nwhere I_i is the barycentric interpolation matrix in the ith dimension.\n\nSee also Restrict.\n\n\n\n\n\n","category":"type"},{"location":"operators/#ClimaCore.Operators.Restrict","page":"Operators","title":"ClimaCore.Operators.Restrict","text":"r = Restrict(space)\nr.(f)\n\nComputes the projection of a field f on mathcalV_0 to a lower degree polynomial space space (mathcalV_0^*). space must be on the same topology as the space of f, but have a lower polynomial degree.\n\nIt is defined as the field theta in mathcalV_0^* such that for all phi in mathcalV_0^*\n\nint_Omega phi theta dOmega = int_Omega phi f dOmega\n\nIn matrix form, this is\n\nphi^top W^* J^* theta = (I phi)^top WJ f\n\nwhere W^* and J^* are the quadrature weights and Jacobian determinant of mathcalV_0^*, and I is the interpolation operator (see Interpolate) from mathcalV_0^* to mathcalV_0. This reduces to\n\ntheta = (W^* J^*)^-1 I^top WJ f\n\n\n\n\n\n","category":"type"},{"location":"operators/#DSS","page":"Operators","title":"DSS","text":"","category":"section"},{"location":"operators/","page":"Operators","title":"Operators","text":"Spaces.weighted_dss!","category":"page"},{"location":"operators/#ClimaCore.Spaces.weighted_dss!","page":"Operators","title":"ClimaCore.Spaces.weighted_dss!","text":"Spaces.weighted_dss!(f::Field)\n\nApply weighted direct stiffness summation (DSS) to f. This operates in-place (i.e. it modifies the f).\n\nThis is a projection operation from the piecewise polynomial space mathcalV_0 to the continuous space mathcalV_1 = mathcalV_0 cap mathcalC_0, defined as the field theta in mathcalV_1 such that for all phi in mathcalV_1\n\nint_Omega phi theta dOmega = int_Omega phi f dOmega\n\nIn matrix form, we define bar theta to be the unique global node representation, and Q to be the \"scatter\" operator which maps to the redundant node representation theta\n\ntheta = Q bar theta\n\nThen the problem can be written as\n\n(Q barphi)^top W J Q bartheta = (Q barphi)^top W J f\n\nwhich reduces to\n\ntheta = Q bartheta = Q (Q^top W J Q)^-1 Q^top W J f\n\n\n\n\n\n","category":"function"},{"location":"operators/#Finite-difference-operators","page":"Operators","title":"Finite difference operators","text":"","category":"section"},{"location":"operators/","page":"Operators","title":"Operators","text":"Finite difference operators are similar with some subtle differences:","category":"page"},{"location":"operators/","page":"Operators","title":"Operators","text":"they can change staggering (center to face, or vice versa)\nthey can span multiple elements\nno DSS is required\nboundary handling may be required","category":"page"},{"location":"operators/","page":"Operators","title":"Operators","text":"We use the following convention:","category":"page"},{"location":"operators/","page":"Operators","title":"Operators","text":"centers are indexed by integers 1, 2, ..., n\nfaces are indexed by half integers half, 1+half, ..., n+half","category":"page"},{"location":"operators/#Interpolation-operators","page":"Operators","title":"Interpolation operators","text":"","category":"section"},{"location":"operators/","page":"Operators","title":"Operators","text":"InterpolateC2F\nInterpolateF2C\nWeightedInterpolateC2F\nWeightedInterpolateF2C\nUpwindBiasedProductC2F\nUpwind3rdOrderBiasedProductC2F\nLeftBiasedC2F\nRightBiasedC2F\nLeftBiasedF2C\nRightBiasedF2C","category":"page"},{"location":"operators/#ClimaCore.Operators.InterpolateC2F","page":"Operators","title":"ClimaCore.Operators.InterpolateC2F","text":"I = InterpolateC2F(;boundaries..)\nI.(x)\n\nInterpolate a center-valued field x to faces, using the stencil\n\nI(x)i = frac12 (xi+tfrac12 + xi-tfrac12)\n\nSupported boundary conditions are:\n\nSetValue(x₀): set the value at the boundary face to be x₀. On the left boundary the stencil is\n\nI(x)tfrac12 = x₀\n\nSetGradient(v): set the value at the boundary such that the gradient is v. At the left boundary the stencil is\n\nI(x)tfrac12 = x1 - frac12 v³\n\nExtrapolate: use the closest interior point as the boundary value. At the left boundary the stencil is\n\nI(x)tfrac12 = x1\n\n\n\n\n\n","category":"type"},{"location":"operators/#ClimaCore.Operators.InterpolateF2C","page":"Operators","title":"ClimaCore.Operators.InterpolateF2C","text":"InterpolateF2C()\n\nInterpolate from face to center mesh. No boundary conditions are required (or supported).\n\n\n\n\n\n","category":"type"},{"location":"operators/#ClimaCore.Operators.WeightedInterpolateC2F","page":"Operators","title":"ClimaCore.Operators.WeightedInterpolateC2F","text":"WI = WeightedInterpolateC2F(; boundaries)\nWI.(w, x)\n\nInterpolate a center-valued field x to faces, weighted by a center-valued field w, using the stencil\n\nWI(w x)i = frac\n    wi+tfrac12 xi+tfrac12 +  wi-tfrac12 xi-tfrac12)\n\n    2 (wi+tfrac12 + wi-tfrac12)\n\n\nSupported boundary conditions are:\n\nSetValue(val): set the value at the boundary face to be val.\nSetGradient: set the value at the boundary such that the gradient is val.\nExtrapolate: use the closest interior point as the boundary value\n\n\n\n\n\n","category":"type"},{"location":"operators/#ClimaCore.Operators.WeightedInterpolateF2C","page":"Operators","title":"ClimaCore.Operators.WeightedInterpolateF2C","text":"WI = WeightedInterpolateF2C(; boundaries)\nWI.(w, x)\n\nInterpolate a face-valued field x to centers, weighted by a face-valued field w, using the stencil\n\nWI(w x)i = frac\n        wi+tfrac12 xi+tfrac12 +  wi-tfrac12 xi-tfrac12)\n    \n        2 (wi+tfrac12 + wi-tfrac12)\n    \n\nNo boundary conditions are required (or supported)\n\n\n\n\n\n","category":"type"},{"location":"operators/#ClimaCore.Operators.UpwindBiasedProductC2F","page":"Operators","title":"ClimaCore.Operators.UpwindBiasedProductC2F","text":"U = UpwindBiasedProductC2F(;boundaries)\nU.(v, x)\n\nCompute the product of a face-valued vector field v and a center-valued field x at cell faces by upwinding x according to v\n\nU(vx)i = begincases\n  vi xi-tfrac12 textrm if  vi  0 \n  vi xi+tfrac12 textrm if  vi  0\n  endcases\n\nSupported boundary conditions are:\n\nSetValue(x₀): set the value of x to be x₀ on the boundary. On the left boundary the stencil is\nU(vx)tfrac12 = begincases\n  vtfrac12 x_0 textrm if   vtfrac12  0 \n  vtfrac12 x1 textrm if   vtfrac12  0\n  endcases\nExtrapolate(): set the value of x to be the same as the closest interior point. On the left boundary, the stencil is\nU(vx)tfrac12 = U(vx)1 + tfrac12\n\n\n\n\n\n","category":"type"},{"location":"operators/#ClimaCore.Operators.Upwind3rdOrderBiasedProductC2F","page":"Operators","title":"ClimaCore.Operators.Upwind3rdOrderBiasedProductC2F","text":"U = Upwind3rdOrderBiasedProductC2F(;boundaries)\nU.(v, x)\n\nCompute the product of a face-valued vector field v and a center-valued field x at cell faces by upwinding x, to third-order of accuracy, according to v\n\nU(vx)i = begincases\n  vi left(-2 xi-tfrac32 + 10 xi-tfrac12 + 4 xi+tfrac12 right)  12  textrm if  vi  0 \n  vi left(4 xi-tfrac12 + 10 xi+tfrac12 -2 xi+tfrac32  right)  12  textrm if  vi  0\n  endcases\n\nThis stencil is based on Louis J. Wicker, William C. Skamarock (2002), eq. 4(a).\n\nSupported boundary conditions are:\n\nAt the moment this is defined only for periodic meshes.\n\n\n\n\n\n","category":"type"},{"location":"operators/#ClimaCore.Operators.LeftBiasedC2F","page":"Operators","title":"ClimaCore.Operators.LeftBiasedC2F","text":"L = LeftBiasedC2F(;boundaries)\nL.(x)\n\nInterpolate a center-value field to a face-valued field from the left.\n\nL(x)i = xi-tfrac12\n\nOnly the left boundary condition should be set. Currently supported is:\n\nSetValue(x₀): set the value to be x₀ on the boundary.\n\nL(x)tfrac12 = x_0\n\n\n\n\n\n","category":"type"},{"location":"operators/#ClimaCore.Operators.RightBiasedC2F","page":"Operators","title":"ClimaCore.Operators.RightBiasedC2F","text":"R = RightBiasedC2F(;boundaries)\nR.(x)\n\nInterpolate a center-valued field to a face-valued field from the right.\n\nR(x)i = xi+tfrac12\n\nOnly the right boundary condition should be set. Currently supported is:\n\nSetValue(x₀): set the value to be x₀ on the boundary.\n\nR(x)n+tfrac12 = x_0\n\n\n\n\n\n","category":"type"},{"location":"operators/#ClimaCore.Operators.LeftBiasedF2C","page":"Operators","title":"ClimaCore.Operators.LeftBiasedF2C","text":"L = LeftBiasedF2C(;boundaries)\nL.(x)\n\nInterpolate a face-value field to a center-valued field from the left.\n\nL(x)i+tfrac12 = xi\n\nOnly the left boundary condition should be set. Currently supported is:\n\nSetValue(x₀): set the value to be x₀ on the boundary.\n\nL(x)1 = x_0\n\n\n\n\n\n","category":"type"},{"location":"operators/#ClimaCore.Operators.RightBiasedF2C","page":"Operators","title":"ClimaCore.Operators.RightBiasedF2C","text":"R = RightBiasedF2C(;boundaries)\nR.(x)\n\nInterpolate a face-valued field to a center-valued field from the right.\n\nR(x)i = xi+tfrac12\n\nOnly the right boundary condition should be set. Currently supported is:\n\nSetValue(x₀): set the value to be x₀ on the boundary.\n\nR(x)n+tfrac12 = x_0\n\n\n\n\n\n","category":"type"},{"location":"operators/#Derivative-operators","page":"Operators","title":"Derivative operators","text":"","category":"section"},{"location":"operators/","page":"Operators","title":"Operators","text":"GradientF2C\nGradientC2F\nAdvectionF2F\nAdvectionC2C\nDivergenceF2C\nDivergenceC2F\nCurlC2F","category":"page"},{"location":"operators/#ClimaCore.Operators.GradientF2C","page":"Operators","title":"ClimaCore.Operators.GradientF2C","text":"G = GradientF2C(;boundaryname=boundarycondition...)\nG.(x)\n\nCompute the gradient of a face-valued field x, returning a center-valued Covariant3 vector field, using the stencil:\n\nG(x)i^3 = xi+tfrac12 - xi-tfrac12\n\nWe note that the usual division factor 1  Delta z that appears in a first-order finite difference operator is accounted for in the LocalVector basis. Hence, users need to cast the output of the GradientF2C to a UVector, VVector or WVector, according to the type of domain on which the operator is defined.\n\nThe following boundary conditions are supported:\n\nby default, the value of x at the boundary face will be used.\nSetValue(x₀): calculate the gradient assuming the value at the boundary is x₀. For the left boundary, this becomes:\n\nG(x)1³ = x1+tfrac12 - x₀\n\nExtrapolate(): set the value at the center closest to the boundary\n\nto be the same as the neighbouring interior value. For the left boundary, this becomes:\n\nG(x)1³ = G(x)2³\n\n\n\n\n\n","category":"type"},{"location":"operators/#ClimaCore.Operators.GradientC2F","page":"Operators","title":"ClimaCore.Operators.GradientC2F","text":"G = GradientC2F(;boundaryname=boundarycondition...)\nG.(x)\n\nCompute the gradient of a center-valued field x, returning a face-valued Covariant3 vector field, using the stencil:\n\nG(x)i^3 = xi+tfrac12 - xi-tfrac12\n\nThe following boundary conditions are supported:\n\nSetValue(x₀): calculate the gradient assuming the value at the boundary is x₀. For the left boundary, this becomes:\nG(x)tfrac12³ = 2 (x1 - x₀)\nSetGradient(v₀): set the value of the gradient at the boundary to be v₀. For the left boundary, this becomes:\nG(x)tfrac12 = v₀\n\n\n\n\n\n","category":"type"},{"location":"operators/#ClimaCore.Operators.AdvectionF2F","page":"Operators","title":"ClimaCore.Operators.AdvectionF2F","text":"A = AdvectionF2F(;boundaries)\nA.(v, θ)\n\nVertical advection operator at cell faces, for a face-valued velocity field v and face-valued variables θ, approximating v^3 partial_3 theta.\n\nIt uses the following stencil\n\nA(vθ)i = frac12 (θi+1 - θi-1) v³i\n\nNo boundary conditions are currently supported.\n\n\n\n\n\n","category":"type"},{"location":"operators/#ClimaCore.Operators.AdvectionC2C","page":"Operators","title":"ClimaCore.Operators.AdvectionC2C","text":"A = AdvectionC2C(;boundaries)\nA.(v, θ)\n\nVertical advection operator at cell centers, for cell face velocity field v cell center variables θ, approximating v^3 partial_3 theta.\n\nIt uses the following stencil\n\nA(vθ)i = frac12  (θi+1 - θi) v³i+tfrac12 + (θi - θi-1)v³i-tfrac12\n\nSupported boundary conditions:\n\nSetValue(θ₀): set the value of θ at the boundary face to be θ₀. At the lower boundary, this is:\n\nA(vθ)1 = frac12  (θ2 - θ1) v³1 + tfrac12 + (θ1 - θ₀)v³tfrac12\n\nExtrapolate: use the closest interior point as the boundary value. At the lower boundary, this is:\n\nA(vθ)1 = (θ2 - θ1) v³1 + tfrac12 \n\n\n\n\n\n","category":"type"},{"location":"operators/#ClimaCore.Operators.DivergenceF2C","page":"Operators","title":"ClimaCore.Operators.DivergenceF2C","text":"D = DivergenceF2C(;boundaryname=boundarycondition...)\nD.(v)\n\nCompute the vertical contribution to the divergence of a face-valued field vector v, returning a center-valued scalar field, using the stencil\n\nD(v)i = (Jv³i+tfrac12 - Jv³i-tfrac12)  Ji\n\nwhere Jv³ is the Jacobian multiplied by the third contravariant component of v.\n\nThe following boundary conditions are supported:\n\nby default, the value of v at the boundary face will be used.\nSetValue(v₀): calculate the divergence assuming the value at the boundary is v₀. For the left boundary, this becomes:\n\nD(v)1 = (Jv³1+tfrac12 - Jv³₀)  Ji\n\nExtrapolate(): set the value at the center closest to the boundary to be the same as the neighbouring interior value. For the left boundary, this becomes:\n\nD(v)1³ = D(v)2³\n\n\n\n\n\n","category":"type"},{"location":"operators/#ClimaCore.Operators.DivergenceC2F","page":"Operators","title":"ClimaCore.Operators.DivergenceC2F","text":"D = DivergenceC2F(;boundaryname=boundarycondition...)\nD.(v)\n\nCompute the vertical contribution to the divergence of a center-valued field vector v, returning a face-valued scalar field, using the stencil\n\nD(v)i = (Jv³i+tfrac12 - Jv³i-tfrac12)  Ji\n\nwhere Jv³ is the Jacobian multiplied by the third contravariant component of v.\n\nThe following boundary conditions are supported:\n\nSetValue(v₀): calculate the divergence assuming the value at the  boundary is v₀. For the left boundary, this becomes:\nD(v)tfrac12 = frac12 (Jv³1 - Jv³₀)  Ji\nSetDivergence(x): set the value of the divergence at the boundary to be x.\nD(v)tfrac12 = x\n\n\n\n\n\n","category":"type"},{"location":"operators/#ClimaCore.Operators.CurlC2F","page":"Operators","title":"ClimaCore.Operators.CurlC2F","text":"C = CurlC2F(;boundaryname=boundarycondition...)\nC.(v)\n\nCompute the vertical-derivative contribution to the curl of a center-valued covariant vector field v. It acts on the horizontal covariant components of v (that is it only depends on v₁ and v₂), and will return a face-valued horizontal contravariant vector field (that is C(v)³ = 0).\n\nSpecifically it approximates:\n\nbeginalign*\nC(v)^1 = -frac1J fracpartial v_2partial xi^3  \nC(v)^2 = frac1J fracpartial v_1partial xi^3 \nendalign*\n\nusing the stencils\n\nbeginalign*\nC(v)i^1 = - frac1Ji (v₂i+tfrac12 - v₂i-tfrac12) \nC(v)i^2 = frac1Ji  (v₁i+tfrac12 - v₁i-tfrac12)\nendalign*\n\nwhere v₁ andv₂are the 1st and 2nd covariant components ofv andJ`` is the Jacobian determinant.\n\nThe following boundary conditions are supported:\n\nSetValue(v₀): calculate the curl assuming the value of v at the  boundary is v₀. For the left boundary, this becomes:\nC(v)tfrac12^1 = -frac2Ji (v_21 - (v₀)_2)\nC(v)tfrac12^2 = frac2Ji (v_11 - (v₀)_1)\nSetCurl(v⁰): enforce the curl operator output at the boundary to be the contravariant vector v⁰.\n\n\n\n\n\n","category":"type"},{"location":"operators/#Other","page":"Operators","title":"Other","text":"","category":"section"},{"location":"operators/","page":"Operators","title":"Operators","text":"SetBoundaryOperator","category":"page"},{"location":"operators/#ClimaCore.Operators.SetBoundaryOperator","page":"Operators","title":"ClimaCore.Operators.SetBoundaryOperator","text":"SetBoundaryOperator(;boundaries...)\n\nThis operator only modifies the values at the boundary:\n\nSetValue(val): set the value to be val on the boundary.\n\n\n\n\n\n","category":"type"},{"location":"operators/#Finite-difference-boundary-conditions","page":"Operators","title":"Finite difference boundary conditions","text":"","category":"section"},{"location":"operators/","page":"Operators","title":"Operators","text":"SetValue\nSetGradient\nSetDivergence\nExtrapolate","category":"page"},{"location":"operators/#ClimaCore.Operators.SetValue","page":"Operators","title":"ClimaCore.Operators.SetValue","text":"SetValue(val)\n\nSet the value at the boundary to be val. In the case of gradient operators, this will set the input value from which the gradient is computed.\n\n\n\n\n\n","category":"type"},{"location":"operators/#ClimaCore.Operators.SetGradient","page":"Operators","title":"ClimaCore.Operators.SetGradient","text":"SetGradient(val)\n\nSet the gradient at the boundary to be val. In the case of gradient operators this will set the output value of the gradient.\n\n\n\n\n\n","category":"type"},{"location":"operators/#ClimaCore.Operators.SetDivergence","page":"Operators","title":"ClimaCore.Operators.SetDivergence","text":"SetDivergence(val)\n\nSet the divergence at the boundary to be val.\n\n\n\n\n\n","category":"type"},{"location":"operators/#ClimaCore.Operators.Extrapolate","page":"Operators","title":"ClimaCore.Operators.Extrapolate","text":"Extrapolate()\n\nSet the value at the boundary to be the same as the closest interior point.\n\n\n\n\n\n","category":"type"},{"location":"#ClimaCore.jl","page":"Home","title":"ClimaCore.jl","text":"","category":"section"}]
}
