<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>MatrixFields · ClimaCore.jl</title><script data-outdated-warner src="../assets/warner.js"></script><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.045/juliamono.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.4/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.4/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.4/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.13.24/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL=".."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../assets/documenter.js"></script><script src="../siteinfo.js"></script><script src="../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><a class="docs-logo" href="../"><img src="../assets/logo.png" alt="ClimaCore.jl logo"/></a><div class="docs-package-name"><span class="docs-autofit"><a href="../">ClimaCore.jl</a></span></div><form class="docs-search" action="../search/"><input class="docs-search-query" id="documenter-search-query" name="q" type="text" placeholder="Search docs"/></form><ul class="docs-menu"><li><a class="tocitem" href="../">Home</a></li><li><a class="tocitem" href="../intro/">Introduction</a></li><li><a class="tocitem" href="../math_framework/">Mathematical Framework</a></li><li><a class="tocitem" href="../installation_instructions/">Installation and How-to Guides</a></li><li><a class="tocitem" href="../operators/">Operators</a></li><li class="is-active"><a class="tocitem" href>MatrixFields</a><ul class="internal"><li><a class="tocitem" href="#Matrix-Field-Element-Type"><span>Matrix Field Element Type</span></a></li><li><a class="tocitem" href="#Matrix-Field-Multiplication"><span>Matrix Field Multiplication</span></a></li><li><a class="tocitem" href="#Operator-Matrices"><span>Operator Matrices</span></a></li><li><a class="tocitem" href="#Internals"><span>Internals</span></a></li><li><a class="tocitem" href="#Utilities"><span>Utilities</span></a></li></ul></li><li><a class="tocitem" href="../api/">API</a></li><li><input class="collapse-toggle" id="menuitem-8" type="checkbox"/><label class="tocitem" for="menuitem-8"><span class="docs-label">Developer docs</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../performance_tips/">Performance tips</a></li></ul></li><li><input class="collapse-toggle" id="menuitem-9" type="checkbox"/><label class="tocitem" for="menuitem-9"><span class="docs-label">Tutorials</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../tutorials/introduction/">Introduction to ClimaCore.jl</a></li></ul></li><li><a class="tocitem" href="../examples/">Examples</a></li><li><input class="collapse-toggle" id="menuitem-11" type="checkbox"/><label class="tocitem" for="menuitem-11"><span class="docs-label">Libraries</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../lib/ClimaCorePlots/">ClimaCorePlots.jl</a></li><li><a class="tocitem" href="../lib/ClimaCoreMakie/">ClimaCoreMakie.jl</a></li><li><a class="tocitem" href="../lib/ClimaCoreVTK/">ClimaCoreVTK.jl</a></li><li><a class="tocitem" href="../lib/ClimaCoreTempestRemap/">ClimaCoreTempestRemap.jl</a></li><li><a class="tocitem" href="../lib/ClimaCoreSpectra/">ClimaCoreSpectra.jl</a></li></ul></li><li><a class="tocitem" href="../Contributing/">Contributing guide</a></li><li><a class="tocitem" href="../code_of_conduct/">Code of Conduct</a></li><li><a class="tocitem" href="../references/">References</a></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><nav class="breadcrumb"><ul class="is-hidden-mobile"><li class="is-active"><a href>MatrixFields</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>MatrixFields</a></li></ul></nav><div class="docs-right"><a class="docs-edit-link" href="https://github.com/CliMA/ClimaCore.jl/blob/main/docs/src/matrix_fields.md" title="Edit on GitHub"><span class="docs-icon fab"></span><span class="docs-label is-hidden-touch">Edit on GitHub</span></a><a class="docs-settings-button fas fa-cog" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-sidebar-button fa fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a></div></header><article class="content" id="documenter-page"><h1 id="MatrixFields"><a class="docs-heading-anchor" href="#MatrixFields">MatrixFields</a><a id="MatrixFields-1"></a><a class="docs-heading-anchor-permalink" href="#MatrixFields" title="Permalink"></a></h1><article class="docstring"><header><a class="docstring-binding" id="ClimaCore.MatrixFields" href="#ClimaCore.MatrixFields"><code>ClimaCore.MatrixFields</code></a> — <span class="docstring-category">Module</span></header><section><div><pre><code class="language-julia hljs">MatrixFields</code></pre><p>This module adds support for defining and manipulating <code>Field</code>s that represent matrices. Specifically, it specifies the <code>BandMatrixRow</code> type, which can be used to store the entries of a band matrix. A <code>Field</code> of <code>BandMatrixRow</code>s on a <code>FiniteDifferenceSpace</code> can be interpreted as a band matrix by vertically concatenating the <code>BandMatrixRow</code>s. Similarly, a <code>Field</code> of <code>BandMatrixRow</code>s on an <code>ExtrudedFiniteDifferenceSpace</code> can be interpreted as a collection of band matrices, one for each column of the <code>Field</code>. Such <code>Field</code>s are called <code>ColumnwiseBandMatrixField</code>s, and this module adds the following functionality for them:</p><ul><li>Constructors, e.g., <code>matrix_field = @. BidiagonalMatrixRow(field1, field2)</code></li><li>Linear combinations, e.g., <code>@. 3 * matrix_field1 + matrix_field2 / 3</code></li><li>Matrix-vector multiplication, e.g., <code>@. matrix_field ⋅ field</code></li><li>Matrix-matrix multiplication, e.g., <code>@. matrix_field1 ⋅ matrix_field2</code></li><li>Compatibility with <code>LinearAlgebra.I</code>, e.g., <code>@. matrix_field = (4I,)</code> or   <code>@. matrix_field - (4I,)</code></li><li>Integration with <code>RecursiveApply</code>, e.g., the entries of <code>matrix_field</code> can be   <code>Tuple</code>s or <code>NamedTuple</code>s instead of single values, which allows   <code>matrix_field</code> to represent multiple band matrices at the same time</li><li>Conversions to native array types, e.g., <code>field2arrays(matrix_field)</code> can   convert each column of <code>matrix_field</code> into a <code>BandedMatrix</code> from   <code>BandedMatrices.jl</code></li><li>Custom printing, e.g., <code>matrix_field</code> gets displayed as a <code>BandedMatrix</code>,   specifically, as the <code>BandedMatrix</code> that corresponds to its first column</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/CliMA/ClimaCore.jl/blob/8227450b0429d3ae0482e952da6a90da63b2eb7a/src/MatrixFields/MatrixFields.jl#L1-L27">source</a></section></article><h2 id="Matrix-Field-Element-Type"><a class="docs-heading-anchor" href="#Matrix-Field-Element-Type">Matrix Field Element Type</a><a id="Matrix-Field-Element-Type-1"></a><a class="docs-heading-anchor-permalink" href="#Matrix-Field-Element-Type" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-binding" id="ClimaCore.MatrixFields.BandMatrixRow" href="#ClimaCore.MatrixFields.BandMatrixRow"><code>ClimaCore.MatrixFields.BandMatrixRow</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">BandMatrixRow{ld}(entries...)</code></pre><p>Stores the nonzero entries in a row of a band matrix, starting with the lowest diagonal, which has index <code>ld</code>. Supported operations include accessing the entry on the diagonal with index <code>d</code> by calling <code>row[d]</code>, taking linear combinations with other band matrix rows (and with <code>LinearAlgebra.I</code>), and checking for equality with other band matrix rows (and with <code>LinearAlgebra.I</code>). There are several aliases for commonly used subtypes of <code>BandMatrixRow</code>:</p><ul><li><code>DiagonalMatrixRow(entry_1)</code></li><li><code>BidiagonalMatrixRow(entry_1, entry_2)</code></li><li><code>TridiagonalMatrixRow(entry_1, entry_2, entry_3)</code></li><li><code>QuaddiagonalMatrixRow(entry_1, entry_2, entry_3, entry_4)</code></li><li><code>PentadiagonalMatrixRow(entry_1, entry_2, entry_3, entry_4, entry_5)</code></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/CliMA/ClimaCore.jl/blob/8227450b0429d3ae0482e952da6a90da63b2eb7a/src/MatrixFields/band_matrix_row.jl#L1-L15">source</a></section></article><h2 id="Matrix-Field-Multiplication"><a class="docs-heading-anchor" href="#Matrix-Field-Multiplication">Matrix Field Multiplication</a><a id="Matrix-Field-Multiplication-1"></a><a class="docs-heading-anchor-permalink" href="#Matrix-Field-Multiplication" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-binding" id="ClimaCore.MatrixFields.MultiplyColumnwiseBandMatrixField" href="#ClimaCore.MatrixFields.MultiplyColumnwiseBandMatrixField"><code>ClimaCore.MatrixFields.MultiplyColumnwiseBandMatrixField</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">MultiplyColumnwiseBandMatrixField()</code></pre><p>An operator that multiplies a <code>ColumnwiseBandMatrixField</code> by another <code>Field</code>, i.e., matrix-vector or matrix-matrix multiplication. The <code>⋅</code> symbol is an alias for <code>MultiplyColumnwiseBandMatrixField()</code>.</p><p>What follows is a derivation of the algorithm used by this operator with single-column <code>Field</code>s. For <code>Field</code>s on multiple columns, the same computation is done for each column.</p><p>In this derivation, we will use <span>$M_1$</span> and <span>$M_2$</span> to denote two <code>ColumnwiseBandMatrixField</code>s, and we will use <span>$V$</span> to denote a regular (vector-like) <code>Field</code>. For both <span>$M_1$</span> and <span>$M_2$</span>, we will use the array-like index notation <span>$M[row, col]$</span> to denote <span>$M[row][col-row]$</span>, i.e., the entry in the <code>BandMatrixRow</code> <span>$M[row]$</span> located on the diagonal with index <span>$col - row$</span>. We will also use <code>outer_indices</code><span>$($</span><code>space</code><span>$)$</span> to denote the tuple <span>$($</span><code>left_idx</code><span>$($</span><code>space</code><span>$),$</span><code>right_idx</code><span>$($</span><code>space</code><span>$))$</span>.</p><p><strong>1. Matrix-Vector Multiplication</strong></p><p>From the definition of matrix-vector multiplication,</p><p class="math-container">\[(M_1 ⋅ V)[i] = \sum_k M_1[i, k] * V[k].\]</p><p>To establish bounds on the values of <span>$k$</span>, let us define the following values:</p><ul><li><span>$li_1, ri_1 ={}$</span><code>outer_indices</code><span>$($</span><code>column_axes</code><span>$(M_1))$</span></li><li><span>$ld_1, ud_1 ={}$</span><code>outer_diagonals</code><span>$($</span><code>eltype</code><span>$(M_1))$</span></li></ul><p>Since <span>$M_1[i, k]$</span> is only well-defined if <span>$k$</span> is a valid column index and <span>$k - i$</span> is a valid diagonal index, we know that</p><p class="math-container">\[li_1 \leq k \leq ri_1 \quad \text{and} \quad ld_1 \leq k - i \leq ud_1.\]</p><p>Combining these into a single inequality gives us</p><p class="math-container">\[\text{max}(li_1, i + ld_1) \leq k \leq \text{min}(ri_1, i + ud_1).\]</p><p>So, we can rewrite the expression for <span>$(M_1 ⋅ V)[i]$</span> as</p><p class="math-container">\[(M_1 ⋅ V)[i] =
    \sum_{k\ =\ \text{max}(li_1, i + ld_1)}^{\text{min}(ri_1, i + ud_1)}
    M_1[i, k] * V[k].\]</p><p>If we replace the variable <span>$k$</span> with <span>$d = k - i$</span> and switch from array-like indexing to <code>Field</code> indexing, we find that</p><p class="math-container">\[(M_1 ⋅ V)[i] =
    \sum_{d\ =\ \text{max}(li_1 - i, ld_1)}^{\text{min}(ri_1 - i, ud_1)}
    M_1[i][d] * V[i + d].\]</p><p><strong>1.1 Interior vs. Boundary Indices</strong></p><p>Now, suppose that the row index <span>$i$</span> is such that</p><p class="math-container">\[li_1 - ld_1 \leq i \leq ri_1 - ud_1.\]</p><p>If this is the case, then the bounds on <span>$d$</span> can be simplified to</p><p class="math-container">\[\text{max}(li_1 - i, ld_1) = ld_1 \quad \text{and} \quad
\text{min}(ri_1 - i, ud_1) = ud_1.\]</p><p>The expression for <span>$(M_1 ⋅ V)[i]$</span> then becomes</p><p class="math-container">\[(M_1 ⋅ V)[i] = \sum_{d = ld_1}^{ud_1} M_1[i][d] * V[i + d].\]</p><p>The values of <span>$i$</span> in this range are considered to be in the &quot;interior&quot; of the operator, while those not in this range (for which we cannot make the above simplification) are considered to be on the &quot;boundary&quot;.</p><p><strong>2. Matrix-Matrix Multiplication</strong></p><p>From the definition of matrix-matrix multiplication,</p><p class="math-container">\[(M_1 ⋅ M_2)[i, j] = \sum_k M_1[i, k] * M_2[k, j].\]</p><p>To establish bounds on the values of <span>$j$</span> and <span>$k$</span>, let us define the following values:</p><ul><li><span>$li_1, ri_1 ={}$</span><code>outer_indices</code><span>$($</span><code>column_axes</code><span>$(M_1))$</span></li><li><span>$ld_1, ud_1 ={}$</span><code>outer_diagonals</code><span>$($</span><code>eltype</code><span>$(M_1))$</span></li><li><span>$li_2, ri_2 ={}$</span><code>outer_indices</code><span>$($</span><code>column_axes</code><span>$(M_2))$</span></li><li><span>$ld_2, ud_2 ={}$</span><code>outer_diagonals</code><span>$($</span><code>eltype</code><span>$(M_2))$</span></li></ul><p>In addition, let <span>$ld_{prod}$</span> and <span>$ud_{prod}$</span> denote the outer diagonal indices of the product matrix <span>$M_1 ⋅ M_2$</span>. We will derive the values of <span>$ld_{prod}$</span> and <span>$ud_{prod}$</span> in the last section.</p><p>Since <span>$M_1[i, k]$</span> is only well-defined if <span>$k$</span> is a valid column index and <span>$k - i$</span> is a valid diagonal index, we know that</p><p class="math-container">\[li_1 \leq k \leq ri_1 \quad \text{and} \quad ld_1 \leq k - i \leq ud_1.\]</p><p>Since <span>$M_2[k, j]$</span> is only well-defined if <span>$j$</span> is a valid column index and <span>$j - k$</span> is a valid diagonal index, we also know that</p><p class="math-container">\[li_2 \leq j \leq ri_2 \quad \text{and} \quad ld_2 \leq j - k \leq ud_2.\]</p><p>Finally, <span>$(M_1 ⋅ M_2)[i, j]$</span> is only well-defined if <span>$j - i$</span> is a valid diagonal index, so</p><p class="math-container">\[ld_{prod} \leq j - i \leq ud_{prod}.\]</p><p>These inequalities can be combined to obtain</p><p class="math-container">\[\begin{gather*}
\text{max}(li_2, i + ld_{prod}) \leq j \leq
\text{min}(ri_2, i + ud_{prod}) \\
\text{and} \\
\text{max}(li_1, i + ld_1, j - ud_2) \leq k \leq
\text{min}(ri_1, i + ud_1, j - ld_2).
\end{gather*}\]</p><p>So, we can rewrite the expression for <span>$(M_1 ⋅ M_2)[i, j]$</span> as</p><p class="math-container">\[\begin{gather*}
(M_1 ⋅ M_2)[i, j] =
    \sum_{
        k\ =\ \text{max}(li_1, i + ld_1, j - ud_2)
    }^{\text{min}(ri_1, i + ud_1, j - ld_2)}
    M_1[i, k] * M_2[k, j], \text{ where} \\[0.5em]
\text{max}(li_2, i + ld_{prod}) \leq j \leq \text{min}(ri_2, i + ud_{prod}).
\end{gather*}\]</p><p>If we replace the variable <span>$k$</span> with <span>$d = k - i$</span>, replace the variable <span>$j$</span> with <span>$d_{prod} = j - i$</span>, and switch from array-like indexing to <code>Field</code> indexing, we find that</p><p class="math-container">\[\begin{gather*}
(M_1 ⋅ M_2)[i][d_{prod}] =
    \sum_{
        d\ =\ \text{max}(li_1 - i, ld_1, d_{prod} - ud_2)
    }^{\text{min}(ri_1 - i, ud_1, d_{prod} - ld_2)}
    M_1[i][d] * M_2[i + d][d_{prod} - d], \text{ where} \\[0.5em]
\text{max}(li_2 - i, ld_{prod}) \leq d_{prod} \leq
    \text{min}(ri_2 - i, ud_{prod}).
\end{gather*}\]</p><p><strong>2.1 Interior vs. Boundary Indices</strong></p><p>Now, suppose that the row index <span>$i$</span> is such that</p><p class="math-container">\[\text{max}(li_1 - ld_1, li_2 - ld_{prod}) \leq i \leq
    \text{min}(ri_1 - ud_1, ri_2 - ud_{prod}).\]</p><p>If this is the case, then the bounds on <span>$d_{prod}$</span> can be simplified to</p><p class="math-container">\[\text{max}(li_2 - i, ld_{prod}) = ld_{prod} \quad \text{and} \quad
\text{min}(ri_2 - i, ud_{prod}) = ud_{prod}.\]</p><p>Similarly, the bounds on <span>$d$</span> can be simplified using the fact that</p><p class="math-container">\[\text{max}(li_1 - i, ld_1) = ld_1 \quad \text{and} \quad
\text{min}(ri_1 - i, ud_1) = ud_1.\]</p><p>The expression for <span>$(M_1 ⋅ M_2)[i][d_{prod}]$</span> then becomes</p><p class="math-container">\[\begin{gather*}
(M_1 ⋅ M_2)[i][d_{prod}] =
    \sum_{
        d\ =\ \text{max}(ld_1, d_{prod} - ud_2)
    }^{\text{min}(ud_1, d_{prod} - ld_2)}
    M_1[i][d] * M_2[i + d][d_{prod} - d], \text{ where} \\[0.5em]
ld_{prod} \leq d_{prod} \leq ud_{prod}.
\end{gather*}\]</p><p>The values of <span>$i$</span> in this range are considered to be in the &quot;interior&quot; of the operator, while those not in this range (for which we cannot make these simplifications) are considered to be on the &quot;boundary&quot;.</p><p><strong>2.2 <span>$ld_{prod}$</span> and <span>$ud_{prod}$</span></strong></p><p>We only need to compute <span>$(M_1 ⋅ M_2)[i][d_{prod}]$</span> for values of <span>$d_{prod}$</span> that correspond to a nonempty sum in the interior, i.e, those for which</p><p class="math-container">\[\text{max}(ld_1, d_{prod} - ud_2) \leq \text{min}(ud_1, d_{prod} - ld_2).\]</p><p>This can be broken down into the four inequalities</p><p class="math-container">\[ld_1 \leq ud_1, \qquad ld_1 \leq d_{prod} - ld_2, \qquad
d_{prod} - ud_2 \leq ud_1, \quad \text{and} \quad
d_{prod} - ud_2 \leq d_{prod} - ld_2.\]</p><p>By definition, <span>$ld_1 \leq ud_1$</span> and <span>$ld_2 \leq ud_2$</span>, so the first and last inequality are always true. Rearranging the remaining two inequalities tells us that</p><p class="math-container">\[ld_1 + ld_2 \leq d_{prod} \leq ud_1 + ud_2.\]</p><p>In other words, the outer diagonal indices of <span>$M_1 ⋅ M_2$</span> are</p><p class="math-container">\[ld_{prod} = ld_1 + ld_2 \quad \text{and} \quad ud_{prod} = ud_1 + ud_2.\]</p><p>This means that we can express the bounds on the interior values of <span>$i$</span> as</p><p class="math-container">\[\text{max}(li_1, li_2 - ld_2) - ld_1 \leq i \leq
    \text{min}(ri_1, ri_2 - ud_2) - ud_1.\]</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/CliMA/ClimaCore.jl/blob/8227450b0429d3ae0482e952da6a90da63b2eb7a/src/MatrixFields/matrix_multiplication.jl#L1-L200">source</a></section></article><h2 id="Operator-Matrices"><a class="docs-heading-anchor" href="#Operator-Matrices">Operator Matrices</a><a id="Operator-Matrices-1"></a><a class="docs-heading-anchor-permalink" href="#Operator-Matrices" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-binding" id="ClimaCore.MatrixFields.operator_matrix" href="#ClimaCore.MatrixFields.operator_matrix"><code>ClimaCore.MatrixFields.operator_matrix</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">operator_matrix(op)</code></pre><p>Constructs a new operator (or operator-like object) that generates the matrix applied by <code>op</code> to its final argument. If <code>op_matrix = operator_matrix(op)</code>, we can use the following identities:</p><ul><li>When <code>op</code> takes one argument, <code>@. op(arg) == @. op_matrix() ⋅ arg</code>.</li><li>When <code>op</code> takes multiple arguments,   <code>@. op(args..., arg) == @. op_matrix(args...) ⋅ arg</code>.</li></ul><p>When <code>op</code> takes more than one argument, <code>operator_matrix(op)</code> constructs a <code>FiniteDifferenceOperator</code> that generates the operator matrix. When <code>op</code> only takes one argument, it instead constructs an <code>AbstractLazyOperator</code>, which is internally converted into a <code>FiniteDifferenceOperator</code> when used in a broadcast expression. Implementing <code>op_matrix</code> as a lazy operator allows us to add an argument to the expression <code>op_matrix.()</code>, and we then use this argument to infer the space and element type of the operator matrix.</p><p>As an example, the <code>InterpolateF2C()</code> operator on a space with <span>$n$</span> cell centers applies an <span>$n \times (n + 1)$</span> bidiagonal matrix:</p><p class="math-container">\[\textrm{interp}(arg) = \begin{bmatrix}
    0.5 &amp;     0.5 &amp;       0 &amp; \cdots &amp;       0 &amp;       0 &amp;       0 \\
      0 &amp;     0.5 &amp;     0.5 &amp; \cdots &amp;       0 &amp;       0 &amp;       0 \\
      0 &amp;       0 &amp;     0.5 &amp; \cdots &amp;       0 &amp;       0 &amp;       0 \\
\vdots &amp; \vdots &amp; \vdots &amp; \ddots &amp; \vdots &amp; \vdots &amp; \vdots \\
      0 &amp;       0 &amp;       0 &amp; \cdots &amp;     0.5 &amp;     0.5 &amp;       0 \\
      0 &amp;       0 &amp;       0 &amp; \cdots &amp;       0 &amp;     0.5 &amp;     0.5
\end{bmatrix} ⋅ arg\]</p><p>The <code>GradientF2C()</code> operator applies a similar matrix, but with different entries:</p><p class="math-container">\[\textrm{grad}(arg) = \begin{bmatrix}
-\textbf{e}^3 &amp;  \textbf{e}^3 &amp;              0 &amp; \cdots &amp;              0 &amp;              0 &amp;             0 \\
             0 &amp; -\textbf{e}^3 &amp;  \textbf{e}^3 &amp; \cdots &amp;              0 &amp;              0 &amp;             0 \\
             0 &amp;              0 &amp; -\textbf{e}^3 &amp; \cdots &amp;              0 &amp;              0 &amp;             0 \\
       \vdots &amp;        \vdots &amp;        \vdots &amp; \ddots &amp;        \vdots &amp;        \vdots &amp;       \vdots \\
             0 &amp;              0 &amp;              0 &amp; \cdots &amp; -\textbf{e}^3 &amp;  \textbf{e}^3 &amp;             0 \\
             0 &amp;              0 &amp;              0 &amp; \cdots &amp;              0 &amp; -\textbf{e}^3 &amp; \textbf{e}^3
\end{bmatrix} ⋅ arg\]</p><p>The unit vector <span>$\textbf{e}^3$</span>, which can also be thought of as the differential along the third coordinate axis (<span>$\textrm{d}\xi^3$</span>), is implemented as a <code>Geometry.Covariant3Vector(1)</code>.</p><p>Not all operators have well-defined operator matrices. For example, the operator <code>GradientC2F(; bottom = SetGradient(grad_b), top = SetGradient(grad_t))</code> applies an affine transformation:</p><p class="math-container">\[\textrm{grad}(arg) = \begin{bmatrix}
grad_b \\ 0 \\ 0 \\ \vdots \\ 0 \\ 0 \\ grad_t
\end{bmatrix} + \begin{bmatrix}
             0 &amp;              0 &amp;              0 &amp; \cdots &amp;              0 &amp;             0 \\
-\textbf{e}^3 &amp;  \textbf{e}^3 &amp;              0 &amp; \cdots &amp;              0 &amp;             0 \\
             0 &amp; -\textbf{e}^3 &amp;  \textbf{e}^3 &amp; \cdots &amp;              0 &amp;             0 \\
       \vdots &amp;        \vdots &amp;        \vdots &amp; \ddots &amp;        \vdots &amp;       \vdots \\
             0 &amp;              0 &amp;              0 &amp; \cdots &amp;  \textbf{e}^3 &amp;             0 \\
             0 &amp;              0 &amp;              0 &amp; \cdots &amp; -\textbf{e}^3 &amp; \textbf{e}^3 \\
             0 &amp;              0 &amp;              0 &amp; \cdots &amp;              0 &amp;             0
\end{bmatrix} ⋅ arg\]</p><p>However, this simplifies to a linear transformation when <span>$grad_b$</span> and <span>$grad_t$</span> are both 0:</p><p class="math-container">\[\textrm{grad}(arg) = \begin{bmatrix}
             0 &amp;              0 &amp;              0 &amp; \cdots &amp;              0 &amp;             0 \\
-\textbf{e}^3 &amp;  \textbf{e}^3 &amp;              0 &amp; \cdots &amp;              0 &amp;             0 \\
             0 &amp; -\textbf{e}^3 &amp;  \textbf{e}^3 &amp; \cdots &amp;              0 &amp;             0 \\
       \vdots &amp;        \vdots &amp;        \vdots &amp; \ddots &amp;        \vdots &amp;       \vdots \\
             0 &amp;              0 &amp;              0 &amp; \cdots &amp;  \textbf{e}^3 &amp;             0 \\
             0 &amp;              0 &amp;              0 &amp; \cdots &amp; -\textbf{e}^3 &amp; \textbf{e}^3 \\
             0 &amp;              0 &amp;              0 &amp; \cdots &amp;              0 &amp;             0
\end{bmatrix} ⋅ arg\]</p><p>In general, when <code>op</code> has nonzero boundary conditions that make it apply an affine transformation, <code>operator_matrix(op)</code> will print out a warning and zero out the boundary conditions before computing the operator matrix.</p><p>In addition to affine transformations, there are also some operators that apply nonlinear transformations to their arguments; that is, transformations which cannot be accurately approximated without using more terms of the form</p><p class="math-container">\[\textrm{op}(\textbf{0}) +
\textrm{op}&#39;(\textbf{0}) ⋅ arg +
\textrm{op}&#39;&#39;(\textbf{0}) ⋅ arg ⋅ arg +
\ldots.\]</p><p>When <code>op</code> is such an operator, <code>operator_matrix(op)</code> will throw an error. In the future, we may want to modify <code>operator_matrix(op)</code> so that it will instead return <span>$\textrm{op}&#39;(\textbf{0})$</span>, where <span>$\textbf{0} ={}$</span><code>zero.(arg)</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/CliMA/ClimaCore.jl/blob/8227450b0429d3ae0482e952da6a90da63b2eb7a/src/MatrixFields/operator_matrices.jl#L116-L207">source</a></section></article><h2 id="Internals"><a class="docs-heading-anchor" href="#Internals">Internals</a><a id="Internals-1"></a><a class="docs-heading-anchor-permalink" href="#Internals" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-binding" id="ClimaCore.MatrixFields.outer_diagonals" href="#ClimaCore.MatrixFields.outer_diagonals"><code>ClimaCore.MatrixFields.outer_diagonals</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">outer_diagonals(::Type{&lt;:BandMatrixRow})</code></pre><p>Gets the indices of the lower and upper diagonals, <code>ld</code> and <code>ud</code>, of the given subtype of <code>BandMatrixRow</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/CliMA/ClimaCore.jl/blob/8227450b0429d3ae0482e952da6a90da63b2eb7a/src/MatrixFields/band_matrix_row.jl#L34-L39">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="ClimaCore.MatrixFields.band_matrix_row_type" href="#ClimaCore.MatrixFields.band_matrix_row_type"><code>ClimaCore.MatrixFields.band_matrix_row_type</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">band_matrix_row_type(ld, ud, T)</code></pre><p>A shorthand for getting the subtype of <code>BandMatrixRow</code> that has entries of type <code>T</code> on the diagonals with indices in the range <code>ld:ud</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/CliMA/ClimaCore.jl/blob/8227450b0429d3ae0482e952da6a90da63b2eb7a/src/MatrixFields/band_matrix_row.jl#L43-L48">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="ClimaCore.MatrixFields.mul_with_projection" href="#ClimaCore.MatrixFields.mul_with_projection"><code>ClimaCore.MatrixFields.mul_with_projection</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">mul_with_projection(x, y, lg)</code></pre><p>Similar to <code>x * y</code>, except that this version automatically projects <code>y</code> to avoid <code>DimensionMismatch</code> errors for <code>AxisTensor</code>s. For example, if <code>x</code> is a covector along the <code>Covariant3Axis</code> (e.g., <code>Covariant3Vector(1)&#39;</code>), then <code>y</code> will be projected onto the <code>Contravariant3Axis</code>. In general, the first axis of <code>y</code> will be projected onto the dual of the last axis of <code>x</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/CliMA/ClimaCore.jl/blob/8227450b0429d3ae0482e952da6a90da63b2eb7a/src/MatrixFields/rmul_with_projection.jl#L1-L9">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="ClimaCore.MatrixFields.rmul_with_projection" href="#ClimaCore.MatrixFields.rmul_with_projection"><code>ClimaCore.MatrixFields.rmul_with_projection</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">rmul_with_projection(x, y, lg)</code></pre><p>Similar to <code>rmul(x, y)</code>, except that this version calls <code>mul_with_projection</code> instead of <code>*</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/CliMA/ClimaCore.jl/blob/8227450b0429d3ae0482e952da6a90da63b2eb7a/src/MatrixFields/rmul_with_projection.jl#L17-L22">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="ClimaCore.MatrixFields.mul_return_type" href="#ClimaCore.MatrixFields.mul_return_type"><code>ClimaCore.MatrixFields.mul_return_type</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">mul_return_type(X, Y)</code></pre><p>Computes the return type of <code>mul_with_projection(x, y, lg)</code>, where <code>x isa X</code> and <code>y isa Y</code>. This can also be used to obtain the return type of <code>x * y</code>, although <code>x * y</code> will throw an error when projection is necessary.</p><p>Note that this is equivalent to calling the internal function <code>_return_type</code>: <code>Base._return_type(mul_with_projection, Tuple{X, Y, LG})</code>, where <code>lg isa LG</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/CliMA/ClimaCore.jl/blob/8227450b0429d3ae0482e952da6a90da63b2eb7a/src/MatrixFields/rmul_with_projection.jl#L51-L60">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="ClimaCore.MatrixFields.rmul_return_type" href="#ClimaCore.MatrixFields.rmul_return_type"><code>ClimaCore.MatrixFields.rmul_return_type</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">rmul_return_type(X, Y)</code></pre><p>Computes the return type of <code>rmul_with_projection(x, y, lg)</code>, where <code>x isa X</code> and <code>y isa Y</code>. This can also be used to obtain the return type of <code>rmul(x, y)</code>, although <code>rmul(x, y)</code> will throw an error when projection is necessary.</p><p>Note that this is equivalent to calling the internal function <code>_return_type</code>: <code>Base._return_type(rmul_with_projection, Tuple{X, Y, LG})</code>, where <code>lg isa LG</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/CliMA/ClimaCore.jl/blob/8227450b0429d3ae0482e952da6a90da63b2eb7a/src/MatrixFields/rmul_with_projection.jl#L137-L146">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="ClimaCore.MatrixFields.matrix_shape" href="#ClimaCore.MatrixFields.matrix_shape"><code>ClimaCore.MatrixFields.matrix_shape</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">matrix_shape(matrix_field, [matrix_space])</code></pre><p>Returns either <code>Square()</code>, <code>FaceToCenter()</code>, or <code>CenterToFace()</code>, depending on whether the diagonal indices of <code>matrix_field</code> are <code>Int</code>s or <code>PlusHalf</code>s and whether <code>matrix_space</code> is on cell centers or cell faces. By default, <code>matrix_space</code> is set to <code>axes(matrix_field)</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/CliMA/ClimaCore.jl/blob/8227450b0429d3ae0482e952da6a90da63b2eb7a/src/MatrixFields/matrix_shape.jl#L6-L13">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="ClimaCore.MatrixFields.column_axes" href="#ClimaCore.MatrixFields.column_axes"><code>ClimaCore.MatrixFields.column_axes</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">column_axes(matrix_field, [matrix_space])</code></pre><p>Returns the space that corresponds to the columns of <code>matrix_field</code>, i.e., the <code>axes</code> of the <code>Field</code>s by which <code>matrix_field</code> can be multiplied. The <code>matrix_space</code>, on the other hand, is the space that corresponds to the rows of <code>matrix_field</code>. By default, <code>matrix_space</code> is set to <code>axes(matrix_field)</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/CliMA/ClimaCore.jl/blob/8227450b0429d3ae0482e952da6a90da63b2eb7a/src/MatrixFields/matrix_shape.jl#L23-L30">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="ClimaCore.MatrixFields.AbstractLazyOperator" href="#ClimaCore.MatrixFields.AbstractLazyOperator"><code>ClimaCore.MatrixFields.AbstractLazyOperator</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">AbstractLazyOperator</code></pre><p>Supertype for &quot;lazy operators&quot;, i.e., operators that can be called without any arguments by users, as long as they appear in broadcast expressions that contain at least one <code>Field</code>. If <code>lazy_op</code> is an <code>AbstractLazyOperator</code>, the expression <code>lazy_op.()</code> will internally be translated to <code>non_lazy_op.(fields...)</code>, as long as it appears in a broadcast expression with at least one <code>Field</code>. This translation is done by the function <code>replace_lazy_operator(space, lazy_op)</code>, which must be implemented by every subtype of <code>AbstractLazyOperator</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/CliMA/ClimaCore.jl/blob/8227450b0429d3ae0482e952da6a90da63b2eb7a/src/MatrixFields/lazy_operators.jl#L1-L11">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="ClimaCore.MatrixFields.replace_lazy_operator" href="#ClimaCore.MatrixFields.replace_lazy_operator"><code>ClimaCore.MatrixFields.replace_lazy_operator</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">replace_lazy_operator(space, lazy_op)</code></pre><p>Generates an instance of <code>Base.AbstractBroadcasted</code> that corresponds to the expression <code>lazy_op.()</code>, where the broadcast in which this expression appears is being evaluated on the given <code>space</code>. Note that the staggering (<code>CellCenter</code> or <code>CellFace</code>) of this <code>space</code> depends on the specifics of the broadcast and is not predetermined.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/CliMA/ClimaCore.jl/blob/8227450b0429d3ae0482e952da6a90da63b2eb7a/src/MatrixFields/lazy_operators.jl#L71-L79">source</a></section></article><h2 id="Utilities"><a class="docs-heading-anchor" href="#Utilities">Utilities</a><a id="Utilities-1"></a><a class="docs-heading-anchor-permalink" href="#Utilities" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-binding" id="ClimaCore.MatrixFields.column_field2array" href="#ClimaCore.MatrixFields.column_field2array"><code>ClimaCore.MatrixFields.column_field2array</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">column_field2array(field)</code></pre><p>Converts a field defined on a <code>FiniteDifferenceSpace</code> into either a <code>Vector</code> or a <code>BandedMatrix</code>, depending on whether the elements of the field are single values or <code>BandMatrixRow</code>s. This involves copying the data stored in the field. Because <code>BandedMatrix</code> does not currently support operations with <code>CuArray</code>s, all GPU data is copied to the CPU.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/CliMA/ClimaCore.jl/blob/8227450b0429d3ae0482e952da6a90da63b2eb7a/src/MatrixFields/field2arrays.jl#L25-L33">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="ClimaCore.MatrixFields.column_field2array_view" href="#ClimaCore.MatrixFields.column_field2array_view"><code>ClimaCore.MatrixFields.column_field2array_view</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">column_field2array_view(field)</code></pre><p>Similar to <code>column_field2array(field)</code>, except that this version avoids copying the data stored in the field.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/CliMA/ClimaCore.jl/blob/8227450b0429d3ae0482e952da6a90da63b2eb7a/src/MatrixFields/field2arrays.jl#L64-L69">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="ClimaCore.MatrixFields.field2arrays" href="#ClimaCore.MatrixFields.field2arrays"><code>ClimaCore.MatrixFields.field2arrays</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">field2arrays(field)</code></pre><p>Converts a field defined on a <code>FiniteDifferenceSpace</code> or on an <code>ExtrudedFiniteDifferenceSpace</code> into a collection of arrays, each of which corresponds to a column of the field. This is done by calling <code>column_field2array</code> on each of the field&#39;s columns.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/CliMA/ClimaCore.jl/blob/8227450b0429d3ae0482e952da6a90da63b2eb7a/src/MatrixFields/field2arrays.jl#L101-L108">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="ClimaCore.MatrixFields.field2arrays_view" href="#ClimaCore.MatrixFields.field2arrays_view"><code>ClimaCore.MatrixFields.field2arrays_view</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">field2arrays_view(field)</code></pre><p>Similar to <code>field2arrays(field)</code>, except that this version calls <code>column_field2array_view</code> instead of <code>column_field2array</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/CliMA/ClimaCore.jl/blob/8227450b0429d3ae0482e952da6a90da63b2eb7a/src/MatrixFields/field2arrays.jl#L111-L116">source</a></section></article></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../operators/">« Operators</a><a class="docs-footer-nextpage" href="../api/">API »</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 0.27.25 on <span class="colophon-date" title="Tuesday 19 September 2023 20:08">Tuesday 19 September 2023</span>. Using Julia version 1.9.3.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
