var documenterSearchIndex = {"docs":
[{"location":"api/#API","page":"API","title":"API","text":"","category":"section"},{"location":"api/","page":"API","title":"API","text":"CurrentModule = ClimaCore","category":"page"},{"location":"api/#DataLayouts","page":"API","title":"DataLayouts","text":"","category":"section"},{"location":"api/","page":"API","title":"API","text":"DataLayouts\nDataLayouts.IJFH","category":"page"},{"location":"api/#ClimaCore.DataLayouts","page":"API","title":"ClimaCore.DataLayouts","text":"ClimaCore.DataLayouts\n\nNotation:\n\ni,j are horizontal node indices within an element\nk is the vertical node index within an element\nf is the field index\nv is the vertical element index in a stack\nh is the element stack index\n\nData layout is specified by the order in which they appear, e.g. IJKFVH indexes the underlying array as [i,j,k,f,v,h]\n\n\n\n\n\n","category":"module"},{"location":"api/#ClimaCore.DataLayouts.IJFH","page":"API","title":"ClimaCore.DataLayouts.IJFH","text":"IJFH{S,Nij}(ArrayType, nelements)\n\nConstruct an IJFH structure given the backing ArrayType, quadrature degrees of freedom Nij, and the number of mesh elements nelements.\n\n\n\n\n\n","category":"type"},{"location":"api/#Geometry","page":"API","title":"Geometry","text":"","category":"section"},{"location":"api/","page":"API","title":"API","text":"Geometry.Cartesian12Vector","category":"page"},{"location":"api/#Domains","page":"API","title":"Domains","text":"","category":"section"},{"location":"api/","page":"API","title":"API","text":"Domains.IntervalDomain\nDomains.RectangleDomain","category":"page"},{"location":"api/#ClimaCore.Domains.IntervalDomain","page":"API","title":"ClimaCore.Domains.IntervalDomain","text":"IntervalDomain(coord⁻, coord⁺; periodic=true)\nIntervalDomain(coord⁻, coord⁺; boundary_tags::Tuple{Symbol,Symbol})\n\nConstruct a IntervalDomain, the closed interval is given by coord⁻, coord⁺ coordinate arguments.\n\nEither a periodic or boundary_tags keyword argument is required.\n\n\n\n\n\nIntervalDomain(coords::ClosedInterval; boundary_tags::Tuple{Symbol,Symbol})\n\nConstruct a IntervalDomain, over the closed coordinate interval coords Because IntervalDomain does not support periodic boundary conditions, the boundary_tags keyword arugment must be supplied.\n\n\n\n\n\n","category":"type"},{"location":"api/#ClimaCore.Domains.RectangleDomain","page":"API","title":"ClimaCore.Domains.RectangleDomain","text":"RectangleDomain(x1::ClosedInterval, x2::ClosedInterval;\n    x1boundary::Tuple{Symbol,Symbol},\n    x2boundary::Tuple{Symbol,Symbol},\n    x1periodic = false,\n    x2periodic = false,\n)\n\nConstruct a RectangularDomain in the horizontal. If a given x1 or x2 boundary is not periodic, then x1boundary or x2boundary boundary tag keyword arguments must be supplied.\n\n\n\n\n\n","category":"type"},{"location":"api/#Meshes","page":"API","title":"Meshes","text":"","category":"section"},{"location":"api/","page":"API","title":"API","text":"Meshes.IntervalMesh\nMeshes.Uniform\nMeshes.ExponentialStretching\nMeshes.EquispacedRectangleMesh","category":"page"},{"location":"api/#ClimaCore.Meshes.IntervalMesh","page":"API","title":"ClimaCore.Meshes.IntervalMesh","text":"IntervalMesh <: AbstractMesh\n\nA 1D mesh on an IntervalDomain.\n\nConstuctors\n\nIntervalMesh(domain::IntervalDomain, faces::AbstractVector)\n\nConstruct a 1D mesh with face locations at faces.\n\nIntervalMesh(domain::IntervalDomain[, stetching=Uniform()]; nelems=)\n\nConstuct a 1D mesh on domain with nelems elements, using stretching. Possible values of stretching are:\n\nUniform()\nExponentialStretching(H)\n\n\n\n\n\n","category":"type"},{"location":"api/#ClimaCore.Meshes.Uniform","page":"API","title":"ClimaCore.Meshes.Uniform","text":"Uniform()\n\nUse uniformly-sized elements.\n\n\n\n\n\n","category":"type"},{"location":"api/#ClimaCore.Meshes.ExponentialStretching","page":"API","title":"ClimaCore.Meshes.ExponentialStretching","text":"ExponentialStretching(H)\n\nApply exponential stretching to the domain when constructing elements. H is the scale height (a typical atmospheric scale height H ≈ 7.5e3km).\n\nFor an interval z_0z_1, this makes the elements uniformally spaced in zeta, where\n\nzeta = frac1 - e^-etah1-e^-1h\n\nwhere eta = fracz - z_0z_1-z_0, and h = fracHz_1-z_0 is the non-dimensional scale height.\n\n\n\n\n\n","category":"type"},{"location":"api/#ClimaCore.Meshes.EquispacedRectangleMesh","page":"API","title":"ClimaCore.Meshes.EquispacedRectangleMesh","text":"EquispacedRectangleMesh(domain::RectangleDomain, n1::Integer, n2::Integer)\n\nA regular AbstractMesh of domain with n1 elements in dimension 1, and n2 in dimension 2.\n\n\n\n\n\n","category":"type"},{"location":"api/#Topologies","page":"API","title":"Topologies","text":"","category":"section"},{"location":"api/","page":"API","title":"API","text":"Topologies\nTopologies.IntervalTopology","category":"page"},{"location":"api/#ClimaCore.Topologies","page":"API","title":"ClimaCore.Topologies","text":"ClimaCore.Topologies\n\nObjects describing the horizontal connections between elements.\n\nAll elements are quadrilaterals, using the following face and vertex numbering convention:\n\n          3\n      4-------3\n ^    |       |\n |  4 |       | 2\nξ2    |       |\n      1-------2\n          1\n        ξ1-->\n\n\n\n\n\n","category":"module"},{"location":"api/#ClimaCore.Topologies.IntervalTopology","page":"API","title":"ClimaCore.Topologies.IntervalTopology","text":"IntervalTopology(mesh::IntervalMesh)\n\nA sequential topology on an Meshes.IntervalMesh.\n\n\n\n\n\n","category":"type"},{"location":"api/#Spaces","page":"API","title":"Spaces","text":"","category":"section"},{"location":"api/","page":"API","title":"API","text":"Spaces\nSpaces.Quadratures.degrees_of_freedom\nSpaces.Quadratures.GL\nSpaces.Quadratures.Uniform\nSpaces.Quadratures.quadrature_points\nSpaces.Quadratures.GLL\nSpaces.Quadratures.polynomial_degree\nSpaces.Quadratures.QuadratureStyle","category":"page"},{"location":"api/#ClimaCore.Spaces","page":"API","title":"ClimaCore.Spaces","text":"Meshes\n\ndomain\ntopology\ncoordinates\nmetric terms (inverse partial derivatives)\nquadrature rules and weights\n\nReferences / notes\n\nceed\nQA\n\n\n\n\n\n","category":"module"},{"location":"api/#ClimaCore.Spaces.Quadratures.degrees_of_freedom","page":"API","title":"ClimaCore.Spaces.Quadratures.degrees_of_freedom","text":"degrees_of_freedom(QuadratureStyle) -> Int\n\nReturns the degreesoffreedom of the QuadratureStyle concrete type\n\n\n\n\n\n","category":"function"},{"location":"api/#ClimaCore.Spaces.Quadratures.GL","page":"API","title":"ClimaCore.Spaces.Quadratures.GL","text":"GL{Nq}()\n\nGauss-Legendre quadrature using Nq quadrature points.\n\n\n\n\n\n","category":"type"},{"location":"api/#ClimaCore.Spaces.Quadratures.Uniform","page":"API","title":"ClimaCore.Spaces.Quadratures.Uniform","text":"Uniform{Nq}()\n\nUniformly-spaced quadrature.\n\n\n\n\n\n","category":"type"},{"location":"api/#ClimaCore.Spaces.Quadratures.quadrature_points","page":"API","title":"ClimaCore.Spaces.Quadratures.quadrature_points","text":"points, weights = quadrature_points(::Type{FT}, quadrature_style)\n\nThe points and weights of the quadrature rule in floating point type FT.\n\n\n\n\n\n","category":"function"},{"location":"api/#ClimaCore.Spaces.Quadratures.GLL","page":"API","title":"ClimaCore.Spaces.Quadratures.GLL","text":"GLL{Nq}()\n\nGauss-Legendre-Lobatto quadrature using Nq quadrature points.\n\n\n\n\n\n","category":"type"},{"location":"api/#ClimaCore.Spaces.Quadratures.polynomial_degree","page":"API","title":"ClimaCore.Spaces.Quadratures.polynomial_degree","text":"polynomial_degree(QuadratureStyle) -> Int\n\nReturns the polynomial degree of the QuadratureStyle concrete type\n\n\n\n\n\n","category":"function"},{"location":"api/#ClimaCore.Spaces.Quadratures.QuadratureStyle","page":"API","title":"ClimaCore.Spaces.Quadratures.QuadratureStyle","text":"QuadratureStyle\n\nQuadrature style supertype. See sub-types:\n\nGLL\nGL\nUniform\n\n\n\n\n\n","category":"type"},{"location":"api/#RecursiveApply","page":"API","title":"RecursiveApply","text":"","category":"section"},{"location":"api/","page":"API","title":"API","text":"RecursiveApply","category":"page"},{"location":"api/#ClimaCore.RecursiveApply","page":"API","title":"ClimaCore.RecursiveApply","text":"RecursiveApply\n\nThis module contains operators to recurse over nested Tuples or NamedTuples.\n\nTo extend to another type T, define RecursiveApply.rmap(fn, args::T...)\n\n\n\n\n\n","category":"module"},{"location":"operators/#Operators","page":"Operators","title":"Operators","text":"","category":"section"},{"location":"operators/","page":"Operators","title":"Operators","text":"CurrentModule = ClimaCore.Operators","category":"page"},{"location":"operators/#Spectral-element-operators","page":"Operators","title":"Spectral element operators","text":"","category":"section"},{"location":"operators/#Differential-Operators","page":"Operators","title":"Differential Operators","text":"","category":"section"},{"location":"operators/","page":"Operators","title":"Operators","text":"Divergence\nWeakDivergence\nGradient\nWeakGradient\nCurl\nWeakCurl","category":"page"},{"location":"operators/#ClimaCore.Operators.Divergence","page":"Operators","title":"ClimaCore.Operators.Divergence","text":"div = Divergence()\ndiv.(u)\n\nComputes the per-element spectral (strong) divergence of a vector field u.\n\nThe divergence of a vector field u is defined as\n\nnabla cdot u = sum_i frac1J fracpartial (J u^i)partial xi^i\n\nwhere J is the Jacobian determinant, u^i is the ith contravariant component of u.\n\nThis is discretized by\n\nsum_i I leftfrac1J fracpartial (IJ u^i)partial xi^i right\n\nwhere Ix is the interpolation operator that projects to the unique polynomial interpolating x at the quadrature points. In matrix form, this can be written as\n\nJ^-1 sum_i D_i J u^i\n\nwhere D_i is the derivative matrix along the ith dimension\n\nReferences\n\nTaylor and Fournier (2010), equation 15\n\n\n\n\n\n","category":"type"},{"location":"operators/#ClimaCore.Operators.WeakDivergence","page":"Operators","title":"ClimaCore.Operators.WeakDivergence","text":"wdiv = WeakDivergence()\nwdiv.(u)\n\nComputes the \"weak divergence\" of a vector field u.\n\nThis is defined as the scalar field theta in mathcalV_0 such that for all phiin mathcalV_0\n\nint_Omega phi theta  d Omega\n=\n- int_Omega (nabla phi) cdot u d Omega\n\nwhere mathcalV_0 is the space of u.\n\nThis arises as the contribution of the volume integral after by applying integration by parts to the weak form expression of the divergence\n\nint_Omega phi (nabla cdot u)  d Omega\n=\n- int_Omega (nabla phi) cdot u d Omega\n+ oint_partial Omega phi (u cdot n) d sigma\n\nIt can be written in matrix form as\n\nϕ^top WJ θ = - sum_i (D_i ϕ)^top WJ u^i\n\nwhich reduces to\n\nθ = -(WJ)^-1 sum_i D_i^top WJ u^i\n\nwhere\n\nJ is the diagonal Jacobian matrix\nW is the diagonal matrix of quadrature weights\nD_i is the derivative matrix along the ith dimension\n\n\n\n\n\n","category":"type"},{"location":"operators/#ClimaCore.Operators.Gradient","page":"Operators","title":"ClimaCore.Operators.Gradient","text":"grad = Gradient()\ngrad.(f)\n\nCompute the (strong) gradient of f on each element, returning a CovariantVector-field.\n\nThe ith covariant component of the gradient is the partial derivative with respect to the reference element:\n\n(nabla f)_i = fracpartial fpartial xi^i\n\nDiscretely, this can be written in matrix form as\n\nD_i f\n\nwhere D_i is the derivative matrix along the ith dimension\n\n\n\n\n\n","category":"type"},{"location":"operators/#ClimaCore.Operators.WeakGradient","page":"Operators","title":"ClimaCore.Operators.WeakGradient","text":"wgrad = WeakGradient()\nwgrad.(f)\n\nCompute the \"weak gradient\" of f on each element.\n\nThis is defined as the the vector field theta in mathcalV_0 such that for all phi in mathcalV_0\n\nint_Omega phi cdot theta  d Omega\n=\n- int_Omega (nabla cdot phi) f  dOmega\n\nwhere mathcalV_0 is the space of f.\n\nThis arises from the contribution of the volume integral after by applying integration by parts to the weak form expression of the gradient\n\nint_Omega phi cdot (nabla f)  d Omega\n=\n- int_Omega f (nabla cdot phi)  dOmega\n+ oint_partial Omega f (phi cdot n)  d sigma\n\nIn matrix form, this becomes\n\nphi^i^top W J theta_i = - ( J^-1 D_i J phi^i )^top W J f\n\nwhich reduces to\n\ntheta_i = -W^-1 D_i^top W f\n\nwhere D_i is the derivative matrix along the ith dimension.\n\n\n\n\n\n","category":"type"},{"location":"operators/#ClimaCore.Operators.Curl","page":"Operators","title":"ClimaCore.Operators.Curl","text":"curl = Curl()\ncurl.(u)\n\nComputes the per-element spectral (strong) curl of a vector field u.\n\nThe curl of a vector field u is a vector field with contravariant components\n\n(nabla times u)^i = frac1J sum_jk epsilon^ijk fracpartial u_kpartial xi^j\n\nwhere J is the Jacobian determinant, u_k is the kth covariant component of u, and epsilon^ijk are the Levi-Civita symbols. In other words\n\nbeginbmatrix\n  (nabla times u)^1 \n  (nabla times u)^2 \n  (nabla times u)^3\nendbmatrix\n=\nfrac1J beginbmatrix\n  fracpartial u_3partial xi^2 - fracpartial u_2partial xi^3 \n  fracpartial u_1partial xi^3 - fracpartial u_3partial xi^1 \n  fracpartial u_2partial xi^1 - fracpartial u_1partial xi^2\nendbmatrix\n\nIn matrix form, this becomes\n\nepsilon^ijk J^-1 D_j u_k\n\nNote that unused dimensions will be dropped: e.g. the 2D curl of a Covariant12Vector-field will return a Contravariant3Vector.\n\n\n\n\n\n","category":"type"},{"location":"operators/#ClimaCore.Operators.WeakCurl","page":"Operators","title":"ClimaCore.Operators.WeakCurl","text":"wcurl = WeakCurl()\nwcurl.(u)\n\nComputes the \"weak curl\" on each element of a vector field u.\n\nThis is defined as the vector field theta in mathcalV_0 such that for all phi in mathcalV_0\n\nint_Omega phi cdot theta  d Omega\n=\nint_Omega (nabla times phi) cdot u d Omega\n\nwhere mathcalV_0 is the space of f.\n\nThis arises from the contribution of the volume integral after by applying integration by parts to the weak form expression of the curl\n\nint_Omega phi cdot (nabla times u) dOmega\n=\nint_Omega (nabla times phi) cdot u d Omega\n- oint_partial Omega (phi times u) cdot n dsigma\n\nIn matrix form, this becomes\n\nphi_i^top W J theta^i = (J^-1 epsilon^kji D_j phi_i)^top W J u_k\n\nwhich, by using the anti-symmetry of the Levi-Civita symbol, reduces to\n\ntheta^i = - epsilon^ijk (WJ)^-1 D_j^top W u_k\n\n\n\n\n\n","category":"type"},{"location":"operators/#Interpolation-Operators","page":"Operators","title":"Interpolation Operators","text":"","category":"section"},{"location":"operators/","page":"Operators","title":"Operators","text":"Interpolate\nRestrict","category":"page"},{"location":"operators/#ClimaCore.Operators.Interpolate","page":"Operators","title":"ClimaCore.Operators.Interpolate","text":"i = Interpolate(space)\ni.(f)\n\nInterpolates f to the space. If space has equal or higher polynomial degree as the space of f, this is exact, otherwise it will be lossy.\n\nIn matrix form, it is the linear operator\n\nI = bigotimes_i I_i\n\nwhere I_i is the barycentric interpolation matrix in the ith dimension.\n\nSee also Restrict.\n\n\n\n\n\n","category":"type"},{"location":"operators/#ClimaCore.Operators.Restrict","page":"Operators","title":"ClimaCore.Operators.Restrict","text":"r = Restrict(space)\nr.(f)\n\nComputes the projection of a field f on mathcalV_0 to a lower degree polynomial space space (mathcalV_0^*). space must be on the same topology as the space of f, but have a lower polynomial degree.\n\nIt is defined as the field theta in mathcalV_0^* such that for all phi in mathcalV_0^*\n\nint_Omega phi theta dOmega = int_Omega phi f dOmega\n\nIn matrix form, this is\n\nphi^top W^* J^* theta = (I phi)^top WJ f\n\nwhere W^* and J^* are the quadrature weights and Jacobian determinant of mathcalV_0^*, and I is the interpolation operator (see Interpolate) from mathcalV_0^* to mathcalV_0. This reduces to\n\ntheta = (W^* J^*)^-1 I^top WJ f\n\n\n\n\n\n","category":"type"},{"location":"operators/#DSS","page":"Operators","title":"DSS","text":"","category":"section"},{"location":"operators/","page":"Operators","title":"Operators","text":"Spaces.weighted_dss!","category":"page"},{"location":"operators/#ClimaCore.Spaces.weighted_dss!","page":"Operators","title":"ClimaCore.Spaces.weighted_dss!","text":"Spaces.weighted_dss!(f::Field)\n\nApply weighted direct stiffness summation (DSS) to f. This operates in-place (i.e. it modifies the f).\n\nThis is a projection operation from the piecewise polynomial space mathcalV_0 to the continuous space mathcalV_1 = mathcalV_0 cap mathcalC_0, defined as the field theta in mathcalV_1 such that for all phi in mathcalV_1\n\nint_Omega phi theta dOmega = int_Omega phi f dOmega\n\nIn matrix form, we define bar theta to be the unique global node representation, and Q to be the \"scatter\" operator which maps to the redundant node representation theta\n\ntheta = Q bar theta\n\nThen the problem can be written as\n\n(Q barphi)^top W J Q bartheta = (Q barphi)^top W J f\n\nwhich reduces to\n\ntheta = Q bartheta = Q (Q^top W J Q)^-1 Q^top W J f\n\n\n\n\n\n","category":"function"},{"location":"operators/#Finite-difference-operators","page":"Operators","title":"Finite difference operators","text":"","category":"section"},{"location":"operators/#Interpolation-operators","page":"Operators","title":"Interpolation operators","text":"","category":"section"},{"location":"operators/","page":"Operators","title":"Operators","text":"InterpolateC2F\nInterpolateF2C\nUpwindBiasedProductC2F\nLeftBiasedC2F\nRightBiasedC2F","category":"page"},{"location":"operators/#ClimaCore.Operators.InterpolateC2F","page":"Operators","title":"ClimaCore.Operators.InterpolateC2F","text":"I = InterpolateC2F(;boundaries..)\nI.(x)\n\nInterpolate a center-valued field x to faces, using the stencil\n\nI(x)i = frac12 (xi+tfrac12 + xi-tfrac12)\n\nSupported boundary conditions are:\n\nSetValue(x₀): set the value at the boundary face to be x₀. On the left boundary the stencil is\n\nI(x)tfrac12 = x₀\n\nSetGradient(v): set the value at the boundary such that the gradient is v. At the left boundary the stencil is\n\nI(x)tfrac12 = x1 - frac12 v³\n\nExtrapolate: use the closest interior point as the boundary value. At the left boundary the stencil is\n\nI(x)tfrac12 = x1\n\n\n\n\n\n","category":"type"},{"location":"operators/#ClimaCore.Operators.InterpolateF2C","page":"Operators","title":"ClimaCore.Operators.InterpolateF2C","text":"InterpolateF2C()\n\nInterpolate from face to center mesh. No boundary conditions are required (or supported).\n\n\n\n\n\n","category":"type"},{"location":"operators/#ClimaCore.Operators.UpwindBiasedProductC2F","page":"Operators","title":"ClimaCore.Operators.UpwindBiasedProductC2F","text":"U = UpwindBiasedProductC2F(;boundaries)\nU.(v, x)\n\nCompute the product of a face-valued vector field v and a center-valued field x at cell faces by upwinding x according to v\n\nU(vx)i = begincases\n  vi xi-tfrac12 quad v^3i  0 \n  vi xi+tfrac12 quad v^3i  0\n  endcases\n\nSupported boundary conditions are:\n\nSetValue(x₀): set the value of x to be x₀ on the boundary. On the left boundary the stencil is\nU(vx)tfrac12 = begincases\n  vtfrac12 x_0 quad v^3tfrac12  0 \n  vtfrac12 x1 quad v^3tfrac12  0\n  endcases\nExtrapolate(): set the value of x to be the same as the closest interior point. On the left boundary, the stencil is\nU(vx)tfrac12 = U(vx)1 + tfrac12\n\n\n\n\n\n","category":"type"},{"location":"operators/#ClimaCore.Operators.LeftBiasedC2F","page":"Operators","title":"ClimaCore.Operators.LeftBiasedC2F","text":"L = LeftBiasedC2F(;boundaries)\nL.(x)\n\nInterpolate a left-value field to a face-valued field from the left.\n\nL(x)i = xi-tfrac12\n\nOnly the left boundary condition should be set. Currently supported is:\n\nSetValue(x₀): set the value to be x₀ on the boundary.\n\nL(x)tfrac12 = x_0\n\n\n\n\n\n","category":"type"},{"location":"operators/#ClimaCore.Operators.RightBiasedC2F","page":"Operators","title":"ClimaCore.Operators.RightBiasedC2F","text":"R = RightBiasedC2F(;boundaries)\nR.(x)\n\nInterpolate a center-valued field to a face-valued field from the right.\n\nR(x)i = xi+tfrac12\n\nOnly the right boundary condition should be set. Currently supported is:\n\nSetValue(x₀): set the value to be x₀ on the boundary.\n\nR(x)n+tfrac12 = x_0\n\n\n\n\n\n","category":"type"},{"location":"operators/#Advection-operators","page":"Operators","title":"Advection operators","text":"","category":"section"},{"location":"operators/","page":"Operators","title":"Operators","text":"AdvectionF2F\nAdvectionC2C","category":"page"},{"location":"operators/#ClimaCore.Operators.AdvectionF2F","page":"Operators","title":"ClimaCore.Operators.AdvectionF2F","text":"A = AdvectionF2F(;boundaries)\nA.(v, θ)\n\nVertical advection operator at cell faces, for a face-valued velocity field v and face-valued variables θ, approximating v^3 partial_3 theta.\n\nIt uses the following stencil\n\nA(vθ)i = frac12 (θi+1 - θi-1) v³i\n\nNo boundary conditions are currently supported.\n\n\n\n\n\n","category":"type"},{"location":"operators/#ClimaCore.Operators.AdvectionC2C","page":"Operators","title":"ClimaCore.Operators.AdvectionC2C","text":"A = AdvectionC2C(;boundaries)\nA.(v, θ)\n\nVertical advection operator at cell centers, for cell face velocity field v cell center variables θ, approximating v^3 partial_3 theta.\n\nIt uses the following stencil\n\nA(vθ)i = frac12  (θi+1 - θi) v³i+tfrac12 + (θi - θi-1)v³i-tfrac12\n\nSupported boundary conditions:\n\nSetValue(θ₀): set the value of θ at the boundary face to be θ₀. At the lower boundary, this is:\n\nA(vθ)1 = frac12  (θ2 - θ1) v³1 + tfrac12 + (θ1 - θ₀)v³tfrac12\n\nExtrapolate: use the closest interior point as the boundary value. At the lower boundary, this is:\n\nA(vθ)1 = (θ2 - θ1) v³1 + tfrac12 \n\n\n\n\n\n","category":"type"},{"location":"operators/#Gradient-operators","page":"Operators","title":"Gradient operators","text":"","category":"section"},{"location":"operators/","page":"Operators","title":"Operators","text":"GradientF2C\nGradientC2F","category":"page"},{"location":"operators/#ClimaCore.Operators.GradientF2C","page":"Operators","title":"ClimaCore.Operators.GradientF2C","text":"G = GradientF2C(;boundaryname=boundarycondition...)\nG.(x)\n\nCompute the gradient of a face-valued field x, returning a center-valued Covariant3 vector field, using the stencil:\n\nG(x)i^3 = xi+tfrac12 - xi-tfrac12\n\nThe following boundary conditions are supported:\n\nby default, the value of x at the boundary face will be used.\nSetValue(x₀): calculate the gradient assuming the value at the boundary is x₀. For the left boundary, this becomes:\n\nG(x)1³ = x1+tfrac12 - x₀\n\nExtrapolate(): set the value at the center closest to the boundary\n\nto be the same as the neighbouring interior value. For the left boundary, this becomes:\n\nG(x)1³ = G(x)2³\n\n\n\n\n\n","category":"type"},{"location":"operators/#ClimaCore.Operators.GradientC2F","page":"Operators","title":"ClimaCore.Operators.GradientC2F","text":"G = GradientC2F(;boundaryname=boundarycondition...)\nG.(x)\n\nCompute the gradient of a center-valued field x, returning a face-valued Covariant3 vector field, using the stencil:\n\nG(x)i^3 = xi+tfrac12 - xi-tfrac12\n\nThe following boundary conditions are supported:\n\nSetValue(x₀): calculate the gradient assuming the value at the boundary is x₀. For the left boundary, this becomes:\nG(x)tfrac12³ = 2 (x1 - x₀)\nSetGradient(v₀): set the value of the gradient at the boundary to be v₀. For the left boundary, this becomes:\nG(x)tfrac12 = v₀\n\n\n\n\n\n","category":"type"},{"location":"operators/#Divergence-operators","page":"Operators","title":"Divergence operators","text":"","category":"section"},{"location":"operators/","page":"Operators","title":"Operators","text":"DivergenceF2C\nDivergenceC2F","category":"page"},{"location":"operators/#ClimaCore.Operators.DivergenceF2C","page":"Operators","title":"ClimaCore.Operators.DivergenceF2C","text":"D = DivergenceF2C(;boundaryname=boundarycondition...)\nD.(v)\n\nCompute the vertical contribution to the divergence of a face-valued field vector v, returning a center-valued scalar field, using the stencil\n\nD(v)i = (Jv³i+tfrac12 - Jv³i-tfrac12)  Ji\n\nwhere Jv³ is the Jacobian multiplied by the third contravariant component of v.\n\nThe following boundary conditions are supported:\n\nby default, the value of v at the boundary face will be used.\nSetValue(v₀): calculate the divergence assuming the value at the boundary is v₀. For the left boundary, this becomes:\n\nD(v)1 = (Jv³1+tfrac12 - Jv³₀)  Ji\n\nExtrapolate(): set the value at the center closest to the boundary to be the same as the neighbouring interior value. For the left boundary, this becomes:\n\nD(v)1³ = D(v)2³\n\n\n\n\n\n","category":"type"},{"location":"operators/#ClimaCore.Operators.DivergenceC2F","page":"Operators","title":"ClimaCore.Operators.DivergenceC2F","text":"D = DivergenceC2F(;boundaryname=boundarycondition...)\nD.(v)\n\nCompute the vertical contribution to the divergence of a center-valued field vector v, returning a face-valued scalar field, using the stencil\n\nD(v)i = (Jv³i+tfrac12 - Jv³i-tfrac12)  Ji\n\nwhere Jv³ is the Jacobian multiplied by the third contravariant component of v.\n\nThe following boundary conditions are supported:\n\nSetValue(v₀): calculate the divergence assuming the value at the  boundary is v₀. For the left boundary, this becomes:\nD(v)tfrac12 = frac12 (Jv³1 - Jv³₀)  Ji\nSetDivergence(x): set the value of the divergence at the boundary to be x.\nD(v)tfrac12 = x\n\n\n\n\n\n","category":"type"},{"location":"operators/#Other","page":"Operators","title":"Other","text":"","category":"section"},{"location":"operators/","page":"Operators","title":"Operators","text":"SetBoundaryOperator","category":"page"},{"location":"operators/#ClimaCore.Operators.SetBoundaryOperator","page":"Operators","title":"ClimaCore.Operators.SetBoundaryOperator","text":"SetBoundaryOperator(;boundaries...)\n\nThis operator only modifies the values at the boundary:\n\nSetValue(val): set the value to be val on the boundary.\n\n\n\n\n\n","category":"type"},{"location":"operators/#Finite-difference-boundary-conditions","page":"Operators","title":"Finite difference boundary conditions","text":"","category":"section"},{"location":"operators/","page":"Operators","title":"Operators","text":"SetValue\nSetGradient\nSetDivergence\nExtrapolate","category":"page"},{"location":"operators/#ClimaCore.Operators.SetValue","page":"Operators","title":"ClimaCore.Operators.SetValue","text":"SetValue(val)\n\nSet the value at the boundary to be val. In the case of gradient operators, this will set the input value from which the gradient is computed.\n\n\n\n\n\n","category":"type"},{"location":"operators/#ClimaCore.Operators.SetGradient","page":"Operators","title":"ClimaCore.Operators.SetGradient","text":"SetGradient(val)\n\nSet the gradient at the boundary to be val. In the case of gradient operators this will set the output value of the gradient.\n\n\n\n\n\n","category":"type"},{"location":"operators/#ClimaCore.Operators.SetDivergence","page":"Operators","title":"ClimaCore.Operators.SetDivergence","text":"SetDivergence(val)\n\nSet the divergence at the boundary to be val.\n\n\n\n\n\n","category":"type"},{"location":"operators/#ClimaCore.Operators.Extrapolate","page":"Operators","title":"ClimaCore.Operators.Extrapolate","text":"Extrapolate()\n\nSet the value at the boundary to be the same as the closest interior point.\n\n\n\n\n\n","category":"type"},{"location":"#ClimaCore.jl","page":"Home","title":"ClimaCore.jl","text":"","category":"section"},{"location":"tutorials/introduction/","page":"Introduction to ClimaCore.jl","title":"Introduction to ClimaCore.jl","text":"EditURL = \"https://github.com/CliMA/ClimaCore.jl/blob/master/docs/tutorials/introduction.jl\"","category":"page"},{"location":"tutorials/introduction/#Introduction-to-ClimaCore.jl","page":"Introduction to ClimaCore.jl","title":"Introduction to ClimaCore.jl","text":"","category":"section"},{"location":"tutorials/introduction/","page":"Introduction to ClimaCore.jl","title":"Introduction to ClimaCore.jl","text":"This tutorial is available as a Jupyter notebook.","category":"page"},{"location":"tutorials/introduction/#What-is-ClimaCore?","page":"Introduction to ClimaCore.jl","title":"What is ClimaCore?","text":"","category":"section"},{"location":"tutorials/introduction/","page":"Introduction to ClimaCore.jl","title":"Introduction to ClimaCore.jl","text":"A suite of tools for constructing spatial discretizations","category":"page"},{"location":"tutorials/introduction/","page":"Introduction to ClimaCore.jl","title":"Introduction to ClimaCore.jl","text":"primarily aimed at climate and weather models\ninitial aim:\nspectral element discretization in the horizontal\nstaggered finite difference in the vertical\ncurrently under development","category":"page"},{"location":"tutorials/introduction/","page":"Introduction to ClimaCore.jl","title":"Introduction to ClimaCore.jl","text":"using ClimaCore, LinearAlgebra, IntervalSets, UnPack, Plots, OrdinaryDiffEq","category":"page"},{"location":"tutorials/introduction/#.-Constructing-a-discretization","page":"Introduction to ClimaCore.jl","title":"1. Constructing a discretization","text":"","category":"section"},{"location":"tutorials/introduction/#.1-Domains","page":"Introduction to ClimaCore.jl","title":"1.1 Domains","text":"","category":"section"},{"location":"tutorials/introduction/","page":"Introduction to ClimaCore.jl","title":"Introduction to ClimaCore.jl","text":"A domain a region of space (think of a mathematical domain).","category":"page"},{"location":"tutorials/introduction/","page":"Introduction to ClimaCore.jl","title":"Introduction to ClimaCore.jl","text":"column_domain = ClimaCore.Domains.IntervalDomain(\n    ClimaCore.Geometry.ZPoint(0.0)..ClimaCore.Geometry.ZPoint(10.0),\n    boundary_tags = (:bottom, :top),\n)","category":"page"},{"location":"tutorials/introduction/","page":"Introduction to ClimaCore.jl","title":"Introduction to ClimaCore.jl","text":"rectangle_domain = ClimaCore.Domains.RectangleDomain(\n    ClimaCore.Geometry.XPoint(-2π)..ClimaCore.Geometry.XPoint(2π),\n    ClimaCore.Geometry.YPoint(-2π)..ClimaCore.Geometry.YPoint(2π),\n    x1periodic = true,\n    x2periodic = true,\n)","category":"page"},{"location":"tutorials/introduction/#.2-Meshes","page":"Introduction to ClimaCore.jl","title":"1.2 Meshes","text":"","category":"section"},{"location":"tutorials/introduction/","page":"Introduction to ClimaCore.jl","title":"Introduction to ClimaCore.jl","text":"A mesh is a division of a domain into elements","category":"page"},{"location":"tutorials/introduction/","page":"Introduction to ClimaCore.jl","title":"Introduction to ClimaCore.jl","text":"column_mesh = ClimaCore.Meshes.IntervalMesh(column_domain, nelems = 32)","category":"page"},{"location":"tutorials/introduction/","page":"Introduction to ClimaCore.jl","title":"Introduction to ClimaCore.jl","text":"rectangle_mesh =\n    ClimaCore.Meshes.EquispacedRectangleMesh(rectangle_domain, 16, 16)","category":"page"},{"location":"tutorials/introduction/#.3-Topologies","page":"Introduction to ClimaCore.jl","title":"1.3 Topologies","text":"","category":"section"},{"location":"tutorials/introduction/","page":"Introduction to ClimaCore.jl","title":"Introduction to ClimaCore.jl","text":"A topology determines the ordering and connections between elements of a mesh","category":"page"},{"location":"tutorials/introduction/","page":"Introduction to ClimaCore.jl","title":"Introduction to ClimaCore.jl","text":"At the moment, this is only required for 2D meshes","category":"page"},{"location":"tutorials/introduction/","page":"Introduction to ClimaCore.jl","title":"Introduction to ClimaCore.jl","text":"rectangle_topology = ClimaCore.Topologies.GridTopology(rectangle_mesh)","category":"page"},{"location":"tutorials/introduction/#.4-Spaces","page":"Introduction to ClimaCore.jl","title":"1.4 Spaces","text":"","category":"section"},{"location":"tutorials/introduction/","page":"Introduction to ClimaCore.jl","title":"Introduction to ClimaCore.jl","text":"A space represents a discretized function space over some domain. Currently two discretizations are supported.","category":"page"},{"location":"tutorials/introduction/#.4.1-Staggered-finite-difference-discretization","page":"Introduction to ClimaCore.jl","title":"1.4.1 Staggered finite difference discretization","text":"","category":"section"},{"location":"tutorials/introduction/","page":"Introduction to ClimaCore.jl","title":"Introduction to ClimaCore.jl","text":"This discretizes an interval domain by approximating the function by a value at either the center of each element (CenterFiniteDifferenceSpace), or the faces between elements (FaceFiniteDifferenceSpace).","category":"page"},{"location":"tutorials/introduction/","page":"Introduction to ClimaCore.jl","title":"Introduction to ClimaCore.jl","text":"You can construct either the center or face space from the mesh, then construct the opposite space from the original one (this is to avoid allocating additional memory).","category":"page"},{"location":"tutorials/introduction/","page":"Introduction to ClimaCore.jl","title":"Introduction to ClimaCore.jl","text":"column_center_space = ClimaCore.Spaces.CenterFiniteDifferenceSpace(column_mesh)\n# construct the face space from the center one\ncolumn_face_space =\n    ClimaCore.Spaces.FaceFiniteDifferenceSpace(column_center_space)","category":"page"},{"location":"tutorials/introduction/#.4.2-Spectral-element-discretization","page":"Introduction to ClimaCore.jl","title":"1.4.2 Spectral element discretization","text":"","category":"section"},{"location":"tutorials/introduction/","page":"Introduction to ClimaCore.jl","title":"Introduction to ClimaCore.jl","text":"A spectral element space approximates the function with polynomials in each element. The polynomials are represented using a nodal discretization, which stores the values of the polynomials at particular points in each element (termed nodes or degrees of freedom).","category":"page"},{"location":"tutorials/introduction/","page":"Introduction to ClimaCore.jl","title":"Introduction to ClimaCore.jl","text":"These nodes are chosen by a particular quadrature rule, which allows us to integrate functions over the domain. The only supported choice for now is a Gauss-Legendre-Lobatto rule.","category":"page"},{"location":"tutorials/introduction/","page":"Introduction to ClimaCore.jl","title":"Introduction to ClimaCore.jl","text":"# Gauss-Legendre-Lobatto quadrature with 4 nodes in each direction, so 16 in each element\nquad = ClimaCore.Spaces.Quadratures.GLL{4}()\nrectangle_space =\n    ClimaCore.Spaces.SpectralElementSpace2D(rectangle_topology, quad)","category":"page"},{"location":"tutorials/introduction/#.5-Fields","page":"Introduction to ClimaCore.jl","title":"1.5 Fields","text":"","category":"section"},{"location":"tutorials/introduction/","page":"Introduction to ClimaCore.jl","title":"Introduction to ClimaCore.jl","text":"Finally, we can construct a field: a function in a space. A field is simply a space and the values at each node in the space.","category":"page"},{"location":"tutorials/introduction/","page":"Introduction to ClimaCore.jl","title":"Introduction to ClimaCore.jl","text":"The easiest field to construct is the coordinate field","category":"page"},{"location":"tutorials/introduction/","page":"Introduction to ClimaCore.jl","title":"Introduction to ClimaCore.jl","text":"coord = ClimaCore.Fields.coordinate_field(rectangle_space)","category":"page"},{"location":"tutorials/introduction/","page":"Introduction to ClimaCore.jl","title":"Introduction to ClimaCore.jl","text":"This is a struct-value field: it contains coordinates in a struct at each point. We can extract just the x coordinate, to get a scalar field:","category":"page"},{"location":"tutorials/introduction/","page":"Introduction to ClimaCore.jl","title":"Introduction to ClimaCore.jl","text":"x = coord.x","category":"page"},{"location":"tutorials/introduction/","page":"Introduction to ClimaCore.jl","title":"Introduction to ClimaCore.jl","text":"Although you can't index directly into a field, it can be used in some other ways similar to a Julia Array. For example, broadcasting can be used to define new fields in terms of other ones:","category":"page"},{"location":"tutorials/introduction/","page":"Introduction to ClimaCore.jl","title":"Introduction to ClimaCore.jl","text":"sinx = sin.(x)","category":"page"},{"location":"tutorials/introduction/","page":"Introduction to ClimaCore.jl","title":"Introduction to ClimaCore.jl","text":"Fields can be easily vizualized with Plots.jl:","category":"page"},{"location":"tutorials/introduction/","page":"Introduction to ClimaCore.jl","title":"Introduction to ClimaCore.jl","text":"import Plots\nPlots.plot(sinx)","category":"page"},{"location":"tutorials/introduction/","page":"Introduction to ClimaCore.jl","title":"Introduction to ClimaCore.jl","text":"If you're using the terminal, UnicodePlots is also supported.","category":"page"},{"location":"tutorials/introduction/","page":"Introduction to ClimaCore.jl","title":"Introduction to ClimaCore.jl","text":"This works similarly for finite difference discretizations","category":"page"},{"location":"tutorials/introduction/","page":"Introduction to ClimaCore.jl","title":"Introduction to ClimaCore.jl","text":"column_center_coords = ClimaCore.Fields.coordinate_field(column_center_space)\ncolumn_face_coords = ClimaCore.Fields.coordinate_field(column_face_space)","category":"page"},{"location":"tutorials/introduction/","page":"Introduction to ClimaCore.jl","title":"Introduction to ClimaCore.jl","text":"plot(sin.(column_center_coords.z), ylim = (0.0, 10.0))\nplot!(cos.(column_face_coords.z), ylim = (0.0, 10.0))","category":"page"},{"location":"tutorials/introduction/","page":"Introduction to ClimaCore.jl","title":"Introduction to ClimaCore.jl","text":"Reduction operations are defined anologously:","category":"page"},{"location":"tutorials/introduction/","page":"Introduction to ClimaCore.jl","title":"Introduction to ClimaCore.jl","text":"sum will give the integral of the function","category":"page"},{"location":"tutorials/introduction/","page":"Introduction to ClimaCore.jl","title":"Introduction to ClimaCore.jl","text":"int_D f(x) dx","category":"page"},{"location":"tutorials/introduction/","page":"Introduction to ClimaCore.jl","title":"Introduction to ClimaCore.jl","text":"norm will give the L² function norm","category":"page"},{"location":"tutorials/introduction/","page":"Introduction to ClimaCore.jl","title":"Introduction to ClimaCore.jl","text":"sqrtint_D f(x)^2 dx","category":"page"},{"location":"tutorials/introduction/","page":"Introduction to ClimaCore.jl","title":"Introduction to ClimaCore.jl","text":"sum(sinx) ## integral","category":"page"},{"location":"tutorials/introduction/","page":"Introduction to ClimaCore.jl","title":"Introduction to ClimaCore.jl","text":"norm(sinx) ## L² norm","category":"page"},{"location":"tutorials/introduction/#.6-Vectors-and-vector-fields","page":"Introduction to ClimaCore.jl","title":"1.6 Vectors and vector fields","text":"","category":"section"},{"location":"tutorials/introduction/","page":"Introduction to ClimaCore.jl","title":"Introduction to ClimaCore.jl","text":"A vector field is a field with vector-valued quantity, i.e. at every point in space, you have a vector.","category":"page"},{"location":"tutorials/introduction/","page":"Introduction to ClimaCore.jl","title":"Introduction to ClimaCore.jl","text":"However one of the key requirements of ClimaCore is to support vectors specified in curvilinear or non-Cartesian coordinates. We will discuss this in a bit further, but for now, you can define a 2-dimensional vector field using Geometry.Cartesian12Vector:","category":"page"},{"location":"tutorials/introduction/","page":"Introduction to ClimaCore.jl","title":"Introduction to ClimaCore.jl","text":"v = ClimaCore.Geometry.Cartesian12Vector.(coord.y, .-coord.x)","category":"page"},{"location":"tutorials/introduction/#.-Operators","page":"Introduction to ClimaCore.jl","title":"2. Operators","text":"","category":"section"},{"location":"tutorials/introduction/","page":"Introduction to ClimaCore.jl","title":"Introduction to ClimaCore.jl","text":"Operators can compute spatial derivative operations.","category":"page"},{"location":"tutorials/introduction/","page":"Introduction to ClimaCore.jl","title":"Introduction to ClimaCore.jl","text":"for performance reasons, we need to be able to \"fuse\" multiple operators and function applications\nJulia provides a tool for this: broadcasting, with a very flexible API","category":"page"},{"location":"tutorials/introduction/","page":"Introduction to ClimaCore.jl","title":"Introduction to ClimaCore.jl","text":"Can think of operators are \"pseudo-functions\": can't be called directly, but act similar to functions in the context of broadcasting.","category":"page"},{"location":"tutorials/introduction/#.1-Spectral-element-operators","page":"Introduction to ClimaCore.jl","title":"2.1 Spectral element operators","text":"","category":"section"},{"location":"tutorials/introduction/","page":"Introduction to ClimaCore.jl","title":"Introduction to ClimaCore.jl","text":"The Gradient operator takes the gradient of a scalar field, and returns a vector field.","category":"page"},{"location":"tutorials/introduction/","page":"Introduction to ClimaCore.jl","title":"Introduction to ClimaCore.jl","text":"grad = ClimaCore.Operators.Gradient()\n∇sinx = grad.(sinx)","category":"page"},{"location":"tutorials/introduction/","page":"Introduction to ClimaCore.jl","title":"Introduction to ClimaCore.jl","text":"plot(∇sinx.components.data.:1, clim = (-1, 1))","category":"page"},{"location":"tutorials/introduction/","page":"Introduction to ClimaCore.jl","title":"Introduction to ClimaCore.jl","text":"This returns the gradient in covariant coordinates","category":"page"},{"location":"tutorials/introduction/","page":"Introduction to ClimaCore.jl","title":"Introduction to ClimaCore.jl","text":"(nabla f)_i = fracpartial fpartial xi^i","category":"page"},{"location":"tutorials/introduction/","page":"Introduction to ClimaCore.jl","title":"Introduction to ClimaCore.jl","text":"where (xi^1xi^2) are the coordinates in the reference element: a square -11^2.","category":"page"},{"location":"tutorials/introduction/","page":"Introduction to ClimaCore.jl","title":"Introduction to ClimaCore.jl","text":"This can be converted to a Cartesian basis by multiplying by the partial derivative matrix","category":"page"},{"location":"tutorials/introduction/","page":"Introduction to ClimaCore.jl","title":"Introduction to ClimaCore.jl","text":"fracpartial xipartial x","category":"page"},{"location":"tutorials/introduction/","page":"Introduction to ClimaCore.jl","title":"Introduction to ClimaCore.jl","text":"This can be done calling `ClimaCore.Geometry.CartesianVector:","category":"page"},{"location":"tutorials/introduction/","page":"Introduction to ClimaCore.jl","title":"Introduction to ClimaCore.jl","text":"∇sinx_cart = ClimaCore.Geometry.CartesianVector.(∇sinx)","category":"page"},{"location":"tutorials/introduction/","page":"Introduction to ClimaCore.jl","title":"Introduction to ClimaCore.jl","text":"plot(∇sinx_cart.components.data.:1, clim = (-1, 1))","category":"page"},{"location":"tutorials/introduction/","page":"Introduction to ClimaCore.jl","title":"Introduction to ClimaCore.jl","text":"plot(∇sinx_cart.components.data.:2, clim = (-1, 1))","category":"page"},{"location":"tutorials/introduction/","page":"Introduction to ClimaCore.jl","title":"Introduction to ClimaCore.jl","text":"∇sinx_ref = ClimaCore.Geometry.Cartesian12Vector.(cos.(x), 0.0)\nnorm(∇sinx_cart .- ∇sinx_ref)","category":"page"},{"location":"tutorials/introduction/","page":"Introduction to ClimaCore.jl","title":"Introduction to ClimaCore.jl","text":"Similarly, the Divergence operator takes the divergence of vector field, and returns a scalar field.","category":"page"},{"location":"tutorials/introduction/","page":"Introduction to ClimaCore.jl","title":"Introduction to ClimaCore.jl","text":"If we take the divergence of a gradient, we can get a Laplacian:","category":"page"},{"location":"tutorials/introduction/","page":"Introduction to ClimaCore.jl","title":"Introduction to ClimaCore.jl","text":"div = ClimaCore.Operators.Divergence()\n∇²sinx = div.(grad.(sinx))\nplot(∇²sinx)","category":"page"},{"location":"tutorials/introduction/","page":"Introduction to ClimaCore.jl","title":"Introduction to ClimaCore.jl","text":"Note: In curvilinear coordinates, the divergence is defined in terms of the contravariant components u^i:","category":"page"},{"location":"tutorials/introduction/","page":"Introduction to ClimaCore.jl","title":"Introduction to ClimaCore.jl","text":"nabla cdot u = frac1J sum_i fracpartialpartial xi^i (J u^i)","category":"page"},{"location":"tutorials/introduction/","page":"Introduction to ClimaCore.jl","title":"Introduction to ClimaCore.jl","text":"The Divergence operator handles this conversion internally.","category":"page"},{"location":"tutorials/introduction/#.1.1-Direct-stiffness-summation","page":"Introduction to ClimaCore.jl","title":"2.1.1 Direct stiffness summation","text":"","category":"section"},{"location":"tutorials/introduction/","page":"Introduction to ClimaCore.jl","title":"Introduction to ClimaCore.jl","text":"Spectral element operators only operate within a single element, and so the result may be discontinuous. To address this, the usual fix is direct stiffness summation (DSS), which averages the values at the element boundaries.","category":"page"},{"location":"tutorials/introduction/","page":"Introduction to ClimaCore.jl","title":"Introduction to ClimaCore.jl","text":"This corresponds to the L^2 projection onto the subset of continuous functions in our function space.","category":"page"},{"location":"tutorials/introduction/","page":"Introduction to ClimaCore.jl","title":"Introduction to ClimaCore.jl","text":"∇²sinx_dss = ClimaCore.Spaces.weighted_dss!(copy(∇²sinx))\nplot(∇²sinx_dss)","category":"page"},{"location":"tutorials/introduction/","page":"Introduction to ClimaCore.jl","title":"Introduction to ClimaCore.jl","text":"plot(∇²sinx_dss .- ∇²sinx)","category":"page"},{"location":"tutorials/introduction/#.2-Finite-difference-operators","page":"Introduction to ClimaCore.jl","title":"2.2 Finite difference operators","text":"","category":"section"},{"location":"tutorials/introduction/","page":"Introduction to ClimaCore.jl","title":"Introduction to ClimaCore.jl","text":"Finite difference operators are similar with some subtle differences:","category":"page"},{"location":"tutorials/introduction/","page":"Introduction to ClimaCore.jl","title":"Introduction to ClimaCore.jl","text":"they can change staggering (center to face, or vice versa)\nthey can span multiple elements\nno DSS is required\nboundary handling may be required","category":"page"},{"location":"tutorials/introduction/","page":"Introduction to ClimaCore.jl","title":"Introduction to ClimaCore.jl","text":"We use the following convention:","category":"page"},{"location":"tutorials/introduction/","page":"Introduction to ClimaCore.jl","title":"Introduction to ClimaCore.jl","text":"centers are indexed by integers 1, 2, ..., n\nfaces are indexed by half integers ½, 1+½, ..., n+½","category":"page"},{"location":"tutorials/introduction/","page":"Introduction to ClimaCore.jl","title":"Introduction to ClimaCore.jl","text":"Face to center gradient","category":"page"},{"location":"tutorials/introduction/","page":"Introduction to ClimaCore.jl","title":"Introduction to ClimaCore.jl","text":"An finite-difference operator defines a stencil. For example, the gradient operator","category":"page"},{"location":"tutorials/introduction/","page":"Introduction to ClimaCore.jl","title":"Introduction to ClimaCore.jl","text":"nablathetai = fractheta i+tfrac12 - thetai-tfrac12Delta z","category":"page"},{"location":"tutorials/introduction/","page":"Introduction to ClimaCore.jl","title":"Introduction to ClimaCore.jl","text":"(actually, a little more complicated as it gives a vector in a covariant basis)","category":"page"},{"location":"tutorials/introduction/","page":"Introduction to ClimaCore.jl","title":"Introduction to ClimaCore.jl","text":"        ...\n      /\nθ[2+½]\n      \\\n        ∇θ[2]\n      /\nθ[1+½]\n      \\\n        ∇θ[1]\n      /\nθ[½]","category":"page"},{"location":"tutorials/introduction/","page":"Introduction to ClimaCore.jl","title":"Introduction to ClimaCore.jl","text":"Every center value is well-defined, so boundary handling is optional.","category":"page"},{"location":"tutorials/introduction/","page":"Introduction to ClimaCore.jl","title":"Introduction to ClimaCore.jl","text":"cosz = cos.(column_face_coords.z)\ngradf2c = ClimaCore.Operators.GradientF2C()\n∇cosz = gradf2c.(cosz)","category":"page"},{"location":"tutorials/introduction/","page":"Introduction to ClimaCore.jl","title":"Introduction to ClimaCore.jl","text":"plot(\n    ClimaCore.Geometry.CartesianVector.(∇cosz).components.data.:1,\n    ylim = (0, 10),\n)","category":"page"},{"location":"tutorials/introduction/","page":"Introduction to ClimaCore.jl","title":"Introduction to ClimaCore.jl","text":"Center to face gradient","category":"page"},{"location":"tutorials/introduction/","page":"Introduction to ClimaCore.jl","title":"Introduction to ClimaCore.jl","text":"Uses the same stencil, but doesn't work directly:","category":"page"},{"location":"tutorials/introduction/","page":"Introduction to ClimaCore.jl","title":"Introduction to ClimaCore.jl","text":"sinz = sin.(column_center_coords.z)\ngradc2f = ClimaCore.Operators.GradientC2F()\n# ∇sinz = gradc2f.(sinz) ## this would throw an error","category":"page"},{"location":"tutorials/introduction/","page":"Introduction to ClimaCore.jl","title":"Introduction to ClimaCore.jl","text":"This throws an error because face values at the boundary are not well-defined:","category":"page"},{"location":"tutorials/introduction/","page":"Introduction to ClimaCore.jl","title":"Introduction to ClimaCore.jl","text":"...\n      \\\n        ∇θ[2+½]\n      /\nθ[2]\n      \\\n        ∇θ[1+½]\n      /\nθ[1]\n      \\\n        ????","category":"page"},{"location":"tutorials/introduction/","page":"Introduction to ClimaCore.jl","title":"Introduction to ClimaCore.jl","text":"To handle boundaries we need to modify the stencil. Two options:","category":"page"},{"location":"tutorials/introduction/","page":"Introduction to ClimaCore.jl","title":"Introduction to ClimaCore.jl","text":"provide the value theta^* of theta at the boundary:","category":"page"},{"location":"tutorials/introduction/","page":"Introduction to ClimaCore.jl","title":"Introduction to ClimaCore.jl","text":"nablathetatfrac12 = fractheta1 - theta^*Delta z 2","category":"page"},{"location":"tutorials/introduction/","page":"Introduction to ClimaCore.jl","title":"Introduction to ClimaCore.jl","text":"provide the gradient nablatheta^* of theta at the boundary:","category":"page"},{"location":"tutorials/introduction/","page":"Introduction to ClimaCore.jl","title":"Introduction to ClimaCore.jl","text":"nablathetatfrac12 = nablatheta^*","category":"page"},{"location":"tutorials/introduction/","page":"Introduction to ClimaCore.jl","title":"Introduction to ClimaCore.jl","text":"These modified stencils are provided as keyword arguments to the operator (based on the boundary label names):","category":"page"},{"location":"tutorials/introduction/","page":"Introduction to ClimaCore.jl","title":"Introduction to ClimaCore.jl","text":"sinz = sin.(column_center_coords.z)\ngradc2f = ClimaCore.Operators.GradientC2F(\n    bottom = ClimaCore.Operators.SetValue(sin(0.0)),\n    top = ClimaCore.Operators.SetGradient(\n        ClimaCore.Geometry.Cartesian3Vector(cos(10.0)),\n    ),\n)\n∇sinz = gradc2f.(sinz)","category":"page"},{"location":"tutorials/introduction/","page":"Introduction to ClimaCore.jl","title":"Introduction to ClimaCore.jl","text":"plot(\n    ClimaCore.Geometry.CartesianVector.(∇sinz).components.data.:1,\n    ylim = (0, 10),\n)","category":"page"},{"location":"tutorials/introduction/","page":"Introduction to ClimaCore.jl","title":"Introduction to ClimaCore.jl","text":"As before, multiple operators (or functions) can be fused together with broadcasting.","category":"page"},{"location":"tutorials/introduction/","page":"Introduction to ClimaCore.jl","title":"Introduction to ClimaCore.jl","text":"One extra advantage of this is that boundaries of the inner operators only need to be specified if they would affect the final result.","category":"page"},{"location":"tutorials/introduction/","page":"Introduction to ClimaCore.jl","title":"Introduction to ClimaCore.jl","text":"Consider the center-to-center Laplacian:","category":"page"},{"location":"tutorials/introduction/","page":"Introduction to ClimaCore.jl","title":"Introduction to ClimaCore.jl","text":"...\n      \\       /\n        ∇θ[2+½]\n      /       \\\nθ[2]            ∇⋅∇θ[2]\n      \\       /\n        ∇θ[1+½]\n      /       \\\nθ[1]            ∇⋅∇θ[1]\n              /\n         ∇θ*","category":"page"},{"location":"tutorials/introduction/","page":"Introduction to ClimaCore.jl","title":"Introduction to ClimaCore.jl","text":"sinz = sin.(column_center_coords.z)\n# we don't need to specify boundaries, as the stencil won't reach that far\ngradc2f = ClimaCore.Operators.GradientC2F()\ndivf2c = ClimaCore.Operators.DivergenceF2C(\n    bottom = ClimaCore.Operators.SetValue(\n        ClimaCore.Geometry.Cartesian3Vector(cos(0.0)),\n    ),\n    top = ClimaCore.Operators.SetValue(\n        ClimaCore.Geometry.Cartesian3Vector(cos(10.0)),\n    ),\n)\n∇∇sinz = divf2c.(gradc2f.(sinz))","category":"page"},{"location":"tutorials/introduction/","page":"Introduction to ClimaCore.jl","title":"Introduction to ClimaCore.jl","text":"plot(∇∇sinz, ylim = (0, 10))","category":"page"},{"location":"tutorials/introduction/#.-Solving-PDEs","page":"Introduction to ClimaCore.jl","title":"3. Solving PDEs","text":"","category":"section"},{"location":"tutorials/introduction/","page":"Introduction to ClimaCore.jl","title":"Introduction to ClimaCore.jl","text":"ClimaCore can be used for spatial discretizations of PDEs. For temporal discretization, we can use the OrdinaryDiffEq package, which we aim to be compatibile with.","category":"page"},{"location":"tutorials/introduction/","page":"Introduction to ClimaCore.jl","title":"Introduction to ClimaCore.jl","text":"using OrdinaryDiffEq","category":"page"},{"location":"tutorials/introduction/#.1-Heat-equation-using-finite-differences","page":"Introduction to ClimaCore.jl","title":"3.1 Heat equation using finite differences","text":"","category":"section"},{"location":"tutorials/introduction/","page":"Introduction to ClimaCore.jl","title":"Introduction to ClimaCore.jl","text":"We will use a cell-center discretization of the heat equation:","category":"page"},{"location":"tutorials/introduction/","page":"Introduction to ClimaCore.jl","title":"Introduction to ClimaCore.jl","text":"fracpartial ypartial t = alpha nabla cdot nabla y","category":"page"},{"location":"tutorials/introduction/","page":"Introduction to ClimaCore.jl","title":"Introduction to ClimaCore.jl","text":"At the bottom we will use a Dirichlet condition y(0) = 1at the bottom: since we don't actually have a value located at the bottom, we will use aSetValue` boundary modifier on the inner gradient.","category":"page"},{"location":"tutorials/introduction/","page":"Introduction to ClimaCore.jl","title":"Introduction to ClimaCore.jl","text":"At the top we will use a Neumann condition fracpartial ypartial z(10) = 0. We can do this two equivalent ways:","category":"page"},{"location":"tutorials/introduction/","page":"Introduction to ClimaCore.jl","title":"Introduction to ClimaCore.jl","text":"a SetGradient on the gradient operator\na SetValue on the divergence operator","category":"page"},{"location":"tutorials/introduction/","page":"Introduction to ClimaCore.jl","title":"Introduction to ClimaCore.jl","text":"either will work.","category":"page"},{"location":"tutorials/introduction/","page":"Introduction to ClimaCore.jl","title":"Introduction to ClimaCore.jl","text":"y0 = zeros(column_center_space)\n\n# define the tendency function\nfunction heat_fd_tendency!(dydt, y, α, t)\n    gradc2f = ClimaCore.Operators.GradientC2F(\n        bottom = ClimaCore.Operators.SetValue(1.0),\n        top = ClimaCore.Operators.SetGradient(\n            ClimaCore.Geometry.Cartesian3Vector(0.0),\n        ),\n    )\n    divf2c = ClimaCore.Operators.DivergenceF2C()\n    # the @. macro \"dots\" the whole expression\n    # i.e.  dydt .= α .* divf2c.(gradc2f.(y))\n    @. dydt = α * divf2c(gradc2f(y))\nend\n\nheat_fd_prob = ODEProblem(heat_fd_tendency!, y0, (0.0, 5.0), 0.1)\nheat_fd_sol = solve(heat_fd_prob, SSPRK33(), dt = 0.1, saveat = 0.25)","category":"page"},{"location":"tutorials/introduction/","page":"Introduction to ClimaCore.jl","title":"Introduction to ClimaCore.jl","text":"anim = Plots.@animate for u in heat_fd_sol.u\n    plot(u, xlim = (0, 1), ylim = (0, 10))\nend\nmp4(anim)","category":"page"},{"location":"tutorials/introduction/#.2-Heat-equation-using-continuous-Galerkin-(CG)-spectral-element","page":"Introduction to ClimaCore.jl","title":"3.2 Heat equation using continuous Galerkin (CG) spectral element","text":"","category":"section"},{"location":"tutorials/introduction/","page":"Introduction to ClimaCore.jl","title":"Introduction to ClimaCore.jl","text":"function heat_cg_tendency!(dydt, y, α, t)\n    grad = ClimaCore.Operators.Gradient()\n    wdiv = ClimaCore.Operators.WeakDivergence()\n    # apply element operators\n    @. dydt = α * wdiv(grad(y))\n\n    # direct stiffness summation (DSS): project to continuous function space\n    ClimaCore.Spaces.weighted_dss!(dydt)\n    return dydt\nend\n\ny0 = exp.(.-(coord.y .^ 2 .+ coord.x .^ 2) ./ 2)\n\nheat_cg_prob = ODEProblem(heat_cg_tendency!, y0, (0.0, 5.0), 0.1)\nheat_cg_sol = solve(heat_cg_prob, SSPRK33(), dt = 0.1, saveat = 0.5)","category":"page"},{"location":"tutorials/introduction/","page":"Introduction to ClimaCore.jl","title":"Introduction to ClimaCore.jl","text":"anim = Plots.@animate for u in heat_cg_sol.u\n    Plots.plot(u, c = :thermal)\nend\nmp4(anim)","category":"page"},{"location":"tutorials/introduction/#.3-Shallow-water-equations","page":"Introduction to ClimaCore.jl","title":"3.3 Shallow water equations","text":"","category":"section"},{"location":"tutorials/introduction/","page":"Introduction to ClimaCore.jl","title":"Introduction to ClimaCore.jl","text":"The shallow water equations in vector invariant form can be written as","category":"page"},{"location":"tutorials/introduction/","page":"Introduction to ClimaCore.jl","title":"Introduction to ClimaCore.jl","text":"beginalign*\n    fracpartial rhopartial t + nabla cdot (rho u) = 0\n    fracpartial u_ipartial t + nabla (Phi + tfrac12u^2)_i  = J (u times (nabla times u))_i\nendalign*","category":"page"},{"location":"tutorials/introduction/","page":"Introduction to ClimaCore.jl","title":"Introduction to ClimaCore.jl","text":"where J is the Jacobian determinant, and Phi = g rho.","category":"page"},{"location":"tutorials/introduction/","page":"Introduction to ClimaCore.jl","title":"Introduction to ClimaCore.jl","text":"Note that the velocity u is specified in covariant coordinates u_i.","category":"page"},{"location":"tutorials/introduction/","page":"Introduction to ClimaCore.jl","title":"Introduction to ClimaCore.jl","text":"For vizualization purposes, we can model a passive tracer theta as","category":"page"},{"location":"tutorials/introduction/","page":"Introduction to ClimaCore.jl","title":"Introduction to ClimaCore.jl","text":"fracpartial rho thetapartial t + nabla cdot (rho theta u) = 0","category":"page"},{"location":"tutorials/introduction/","page":"Introduction to ClimaCore.jl","title":"Introduction to ClimaCore.jl","text":"using ClimaCore.Geometry\n\nparameters = (\n    ϵ = 0.1,  ## perturbation size for initial condition\n    l = 0.5, ## Gaussian width\n    k = 0.5, ## Sinusoidal wavenumber\n    ρ₀ = 1.0, ## reference density\n    c = 2,\n    g = 10,\n    D₄ = 1e-4, ## hyperdiffusion coefficient\n)\n\nfunction init_state(local_geometry, p)\n    coord = local_geometry.coordinates\n    @unpack x, y = coord\n    # set initial state\n    ρ = p.ρ₀\n\n    # set initial velocity\n    U₁ = cosh(y)^(-2)\n\n    # Ψ′ = exp(-(x2 + p.l / 10)^2 / 2p.l^2) * cos(p.k * x) * cos(p.k * y)\n    # Vortical velocity fields (u₁′, u₂′) = (-∂²Ψ′, ∂¹Ψ′)\n    ϕ = exp(-(y + p.l / 10)^2 / 2p.l^2)\n    u₁′ = ϕ * (y + p.l / 10) / p.l^2 * cos(p.k * x) * cos(p.k * y)\n    u₁′ += p.k * ϕ * cos(p.k * x) * sin(p.k * y)\n    u₂′ = -p.k * ϕ * sin(p.k * x) * cos(p.k * y)\n\n    u = Geometry.Covariant12Vector(\n        Geometry.Cartesian12Vector(U₁ + p.ϵ * u₁′, p.ϵ * u₂′),\n        local_geometry,\n    )\n\n    # set initial tracer\n    θ = sin(p.k * y)\n    return (ρ = ρ, u = u, ρθ = ρ * θ)\nend\n\n\ny0 =\n    init_state.(\n        ClimaCore.Fields.local_geometry_field(rectangle_space),\n        Ref(parameters),\n    )\n\n# plot initial tracer\nPlots.plot(y0.ρθ)","category":"page"},{"location":"tutorials/introduction/","page":"Introduction to ClimaCore.jl","title":"Introduction to ClimaCore.jl","text":"function shallow_water_tendency!(dydt, y, _, t)\n\n    space = axes(y)\n    J = ClimaCore.Fields.local_geometry_field(space).J\n\n    @unpack D₄, g = parameters\n\n    sdiv = ClimaCore.Operators.Divergence()\n    wdiv = ClimaCore.Operators.WeakDivergence()\n    grad = ClimaCore.Operators.Gradient()\n    wgrad = ClimaCore.Operators.WeakGradient()\n    curl = ClimaCore.Operators.Curl()\n    wcurl = ClimaCore.Operators.WeakCurl()\n\n\n    # compute hyperviscosity first\n    @. dydt.u =\n        wgrad(sdiv(y.u)) -\n        Geometry.Covariant12Vector(wcurl(Geometry.Covariant3Vector(curl(y.u))))\n    @. dydt.ρθ = wdiv(grad(y.ρθ))\n\n    ClimaCore.Spaces.weighted_dss!(dydt)\n\n    @. dydt.u =\n        -D₄ * (\n            wgrad(sdiv(dydt.u)) - Geometry.Covariant12Vector(\n                wcurl(Geometry.Covariant3Vector(curl(dydt.u))),\n            )\n        )\n    @. dydt.ρθ = -D₄ * wdiv(grad(dydt.ρθ))\n\n    # comute rest of tendency\n    @. begin\n        dydt.ρ = -wdiv(y.ρ * y.u)\n        dydt.u +=\n            -grad(g * y.ρ + norm(y.u)^2 / 2) +\n            Geometry.Covariant12Vector((J * (y.u × curl(y.u))))\n        dydt.ρθ += -wdiv(y.ρθ * y.u)\n    end\n    ClimaCore.Spaces.weighted_dss!(dydt)\n    return dydt\nend","category":"page"},{"location":"tutorials/introduction/","page":"Introduction to ClimaCore.jl","title":"Introduction to ClimaCore.jl","text":"shallow_water_prob = ODEProblem(shallow_water_tendency!, y0, (0.0, 20.0))\n@time shallow_water_sol =\n    solve(shallow_water_prob, SSPRK33(), dt = 0.05, saveat = 1.0)\nanim = Plots.@animate for u in shallow_water_sol.u\n    Plots.plot(u.ρθ, clim = (-1, 1))\nend\nmp4(anim)","category":"page"},{"location":"tutorials/introduction/","page":"Introduction to ClimaCore.jl","title":"Introduction to ClimaCore.jl","text":"","category":"page"},{"location":"tutorials/introduction/","page":"Introduction to ClimaCore.jl","title":"Introduction to ClimaCore.jl","text":"This page was generated using Literate.jl.","category":"page"}]
}
