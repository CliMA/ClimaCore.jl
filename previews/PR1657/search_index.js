var documenterSearchIndex = {"docs":
[{"location":"references/#References","page":"References","title":"References","text":"","category":"section"},{"location":"references/","page":"References","title":"References","text":"M. A. Taylor and A. Fournier. A compatible and conservative spectral element method on unstructured grids. Journal of Computational Physics 229, 5879–5895 (2010).\n\n\n\nL. J. Wicker and W. C. Skamarock. Time-Splitting Methods for Elastic Models Using Forward Time Schemes. Monthly Weather Review 130, 2088–2097 (2002).\n\n\n\nJ. P. Boris and D. L. Book. Flux-corrected transport. I. SHASTA, a fluid transport algorithm that works. Journal of Computational Physics 11, 38–69 (1973).\n\n\n\nD. R. Durran. Numerical Methods for Fluid Dynamics (Springer New York, NY, 2010).\n\n\n\nS. T. Zalesak. Fully multidimensional flux-corrected transport algorithms for fluids. Journal of computational physics 31, 335–362 (1979).\n\n\n\nM. Benzi, G. H. Golub and J. Liesen. Numerical solution of saddle point problems. Acta Numerica 14, 1–137 (2005).\n\n\n\nC. Ronchi, R. Iacono and P. S. Paolucci. The cubed sphere: a new method for the solution of partial differential equations in spherical geometry. Journal of Computational Physics 124, 93–114 (1996).\n\n\n\nM. Rančić, R. J. Purser and F. Mesinger. A global shallow-water model using an expanded spherical cube: Gnomonic versus conformal coordinates. Quarterly Journal of the Royal Meteorological Society 122, 959–982 (1996).\n\n\n\nR. D. Nair, S. J. Thomas and R. D. Loft. A Discontinuous Galerkin Transport Scheme on the Cubed Sphere. Monthly Weather Review 133, 814–828 (2005).\n\n\n\nO. Guba, M. A. Taylor, P. A. Ullrich, J. R. Overfelt and M. N. Levy. The spectral element method (SEM) on variable-resolution grids: evaluating grid sensitivity and resolution-aware numerical viscosity. Geoscientific Model Development 7, 2803–2816 (2014).\n\n\n\nJ.-P. Berrut and L. N. Trefethen. Barycentric lagrange interpolation. SIAM review 46, 501–517 (2004).\n\n\n\nT. Gal-Chen and R. C. Somerville. On the use of a coordinate transformation for the solution of the Navier-Stokes equations. Journal of Computational Physics 17, 209–228 (1975).\n\n\n\nC. Schär, D. Leuenberger, O. Fuhrer, D. Lüthi and C. Girard\". A New Terrain-Following Vertical Coordinate Formulation for Atmospheric Prediction Models\". Monthly Weather Review 130, 2459–2480 (2002).\n\n\n\nO. Guba, M. Taylor and A. St-Cyr. Optimization-based limiters for the spectral element method. Journal of Computational Physics 267, 176–195 (2014).\n\n\n\nL. Bao, R. D. Nair and H. M. Tufo. A mass and momentum flux-form high-order discontinuous Galerkin shallow water model on the cubed-sphere. Journal of Computational Physics 271, 224–243 (2014).\n\n\n\nD. L. Williamson, J. B. Drake, J. J. Hack, R. Jakob and P. N. Swarztrauber. A standard test set for numerical approximations to the shallow water equations in spherical geometry. Journal of Computational Physics 102, 211–224 (1992).\n\n\n\nJ. Galewsky, R. K. Scott and L. M. Polvani. An initial-value problem for testing numerical models of the global shallow-water equations. Tellus A: Dynamic Meteorology and Oceanography 56, 429–440 (2004).\n\n\n\nP. A. Ullrich, C. Jablonowski and B. van Leer. High-Order Finite-Volume Methods for the Shallow-Water Equations on the Sphere. J. Comput. Phys. 229, 6104–6134 (2010).\n\n\n\nP. A. Ullrich, C. Jablonowski, J. Kent, P. H. Lauritzen and R. D. Nair. Test Case Document. In: Dynamical Core Model Intercomparison Project ( DCMIP ) (2012).\n\n\n\nF. Baer. An alternate scale representation of atmospheric energy spectra. Journal of the Atmospheric Sciences 29, 649–664 (1972).\n\n\n\nA. WIIN-NIELSEN. On the annual variation and spectral distribution of atmospheric energy 1. Tellus 19, 540–559 (1967).\n\n\n\n","category":"page"},{"location":"lib/ClimaCoreSpectra/#ClimaCoreSpectra.jl","page":"ClimaCoreSpectra.jl","title":"ClimaCoreSpectra.jl","text":"","category":"section"},{"location":"lib/ClimaCoreSpectra/","page":"ClimaCoreSpectra.jl","title":"ClimaCoreSpectra.jl","text":"CurrentModule = ClimaCoreSpectra","category":"page"},{"location":"lib/ClimaCoreSpectra/","page":"ClimaCoreSpectra.jl","title":"ClimaCoreSpectra.jl","text":"ClimaCoreSpectra.jl provides functionality for calculating kinetic energy spectra using spherical harmonics.","category":"page"},{"location":"lib/ClimaCoreSpectra/#Interface","page":"ClimaCoreSpectra.jl","title":"Interface","text":"","category":"section"},{"location":"lib/ClimaCoreSpectra/","page":"ClimaCoreSpectra.jl","title":"ClimaCoreSpectra.jl","text":"ClimaCoreSpectra.SpectralSphericalMesh\nClimaCoreSpectra.power_spectrum_1d\nClimaCoreSpectra.power_spectrum_2d\nClimaCoreSpectra.compute_gaussian!\nClimaCoreSpectra.compute_legendre!\nClimaCoreSpectra.trans_grid_to_spherical!\nClimaCoreSpectra.compute_wave_numbers!","category":"page"},{"location":"lib/ClimaCoreSpectra/#ClimaCoreSpectra.SpectralSphericalMesh","page":"ClimaCoreSpectra.jl","title":"ClimaCoreSpectra.SpectralSphericalMesh","text":"SpectralSphericalMesh\n\nSpherical mesh data structure for calculating spectra. The mesh represents a regular lat-long grid.\n\n\n\n\n\n","category":"type"},{"location":"lib/ClimaCoreSpectra/#ClimaCoreSpectra.power_spectrum_1d","page":"ClimaCoreSpectra.jl","title":"ClimaCoreSpectra.power_spectrum_1d","text":"power_spectrum_1d(FT, var_grid, z, lat, lon, weight)\n\nFor a variable var_grid on a (lon,lat,z) grid, given an array of weights, compute the zonal (1D) power spectrum using a Fourier transform at each Gaussian latitude. The input field must be first intepolated to a Gaussian grid.\n\nArguments\n\nFT: FloatType\nvar_grid: variable on a Gaussian (lon, lat, z) grid to be transformed\nz: Array with uniform z levels\nlat: Array with uniform lats\nlon: Array with uniform longs\nweight: Array with weights for mass-weighted calculations\n\n\n\n\n\n","category":"function"},{"location":"lib/ClimaCoreSpectra/#ClimaCoreSpectra.power_spectrum_2d","page":"ClimaCoreSpectra.jl","title":"ClimaCoreSpectra.power_spectrum_2d","text":"power_spectrum_2d(FT, var_grid, mass_weight)\n\nTransform a variable defined on a regular lat long grid to the 2d spectral space using fft on latitude circles (as for the 1D spectrum) and Legendre polynomials for meridians, and calculate spectra.\n\nArguments\n\nFT: FloatType\nvar_grid: variable on a Gaussian (lon, lat, z) grid to be transformed\nmass_weight: Array with weights for mass-weighted calculations.\n\nReferences\n\n[20]\n\n\n\n\n\n","category":"function"},{"location":"lib/ClimaCoreSpectra/#ClimaCoreSpectra.compute_gaussian!","page":"ClimaCoreSpectra.jl","title":"ClimaCoreSpectra.compute_gaussian!","text":"compute_gaussian!(FT, n)\n\nCompute sin(latitude) and the weight factors for Gaussian integration.\n\nArguments\n\nFT: FloatType\nn: Int, number of Gaussian latitudes\n\nReferences\n\nEhrendorfer, M., Spectral Numerical Weather Prediction Models, Appendix B, Society for Industrial and Applied Mathematics, 2011\n\nDetails (following notation from Ehrendorfer, 2011):\n\nPn(x) is an odd function\nsolve half of the n roots and weightes of Pn(x) # n = 2n_half\nP_{-1}(x) = 0\nP_0(x) = 1\nP_1(x) = x\nnP_n(x) = (2n-1)xP_{n-1}(x) - (n-1)P_{n-2}(x)\nP'_n(x) = n/(x^2-1)(xP_{n}(x) - P_{n-1}(x))\nx -= P_n(x)/P'_{n}()\nInitial guess xi^{0} = cos(π(i-0.25)/(n+0.5))\nwi = 2/(1-xi^2)/P_n'(xi)^2\n\n\n\n\n\n","category":"function"},{"location":"lib/ClimaCoreSpectra/#ClimaCoreSpectra.compute_legendre!","page":"ClimaCoreSpectra.jl","title":"ClimaCoreSpectra.compute_legendre!","text":"compute_legendre!(FT, num_fourier, num_spherical, sinθ, nθ)\n\nNormalized associated Legendre polynomials, P_{m,l} = qnm.\n\nArguments:\n\nFT: FloatType\nnum_fourier: Int, number of truncated zonal wavenumbers (m)\nnum_spherical: Int, number of total wavenumbers (n)\nsinθ: Array{FT} with sin(latitude)\nnθ: Int, number of Gaussian latitudes\n\nReferences:\n\nEhrendorfer, M. (2011) Spectral Numerical Weather Prediction Models, Appendix B, Society for Industrial and Applied Mathematics\nWinch, D. (2007) Spherical harmonics, in Encyclopedia of Geomagnetism and Paleomagnetism, Eds Gubbins D. and Herrero-Bervera, E., Springer\n\nDetails (using notation and Eq. references from Ehrendorfer, 2011):\n\nl=0,1...∞    and m = -l, -l+1, ... l-1, l\nP_{0,0} = 1, such that 1/4π ∫∫YYdS = δ (where Y = spherical harmonics, S = domain surface area)\nP_{m,m} = sqrt((2m+1)/2m) cosθ P_{m-1,m-1}\nP_{m+1,m} = sqrt(2m+3) sinθ P_{m,m}\nsqrt((l^2-m^2)/(4l^2-1))P_{l,m} = P_{l-1, m} -  sqrt(((l-1)^2-m^2)/(4(l-1)^2 - 1))P_{l-2,m}\nTHe normalization assures that 1/2 ∫_{-1}^1 P_{l,m}(sinθ) P_{n,m}(sinθ) dsinθ = δ_{n,l}\nJulia index starts with 1, so qnm[m+1,l+1] = P_l^m\n\n\n\n\n\n","category":"function"},{"location":"lib/ClimaCoreSpectra/#ClimaCoreSpectra.trans_grid_to_spherical!","page":"ClimaCoreSpectra.jl","title":"ClimaCoreSpectra.trans_grid_to_spherical!","text":"trans_grid_to_spherical!(mesh::SpectralSphericalMesh, pfield::Arr{FT,2})\n\nTransforms a variable on a Gaussian grid (pfield[nλ, nθ]) into the spherical harmonics domain (varspherical2d[numfourier+1, num_spherical+1]).\n\nDetails:\n\nHere λ = longitude, θ = latitude, η = sinθ, m = zonal wavenumber, n = total wavenumber:\nvar_spherical2d = F_{m,n}    # Output variable in spectral space (Complex{FT}[num_fourier+1, num_spherical+1])\nqwg = P_{m,n}(η)w(η)         # Weighted Legendre polynomials (FT[num_fourier+1, num_spherical+1, nθ])\nvar_fourier2d = g_{m, θ}     # Untruncated Fourier transformation (Complex{FT} [nλ, nθ])\npfield = F(λ, η)             # Input variable on Gaussian grid FT[nλ, nθ]\n\nArguments\n\nmesh: struct with mesh information\npfield: variable on Gaussian grid to be transformed\n\nReferences\n\nEhrendorfer, M., Spectral Numerical Weather Prediction Models, Appendix B, Society for Industrial and Applied Mathematics, 2011\n[21]\n\n\n\n\n\n","category":"function"},{"location":"lib/ClimaCoreSpectra/#ClimaCoreSpectra.compute_wave_numbers!","page":"ClimaCoreSpectra.jl","title":"ClimaCoreSpectra.compute_wave_numbers!","text":"compute_wave_numbers!(wave_numbers, num_fourier::Int, num_spherical::Int)\n\nStore the total wave number n for this basis in a matrix wave_numbers of shape [m,n].\n\nArguments:\n\nwavenumbers: Matrix of [Int, Int] to store the wave wavenumbers\nnum_fourier: Int, number of truncated zonal wavenumbers (m)\nnum_spherical: Int, number of total wavenumbers (n)\n\n\n\n\n\n","category":"function"},{"location":"lib/ClimaCoreSpectra/#Examples","page":"ClimaCoreSpectra.jl","title":"Examples","text":"","category":"section"},{"location":"lib/ClimaCoreSpectra/","page":"ClimaCoreSpectra.jl","title":"ClimaCoreSpectra.jl","text":"import ClimaCore\nfn = joinpath(pkgdir(ClimaCore), \"lib\", \"ClimaCoreSpectra\", \"test\", \"gcm_visual_test.jl\")\n@show fn\nENV[\"BUILD_DOCS\"]=true\ninclude(fn)","category":"page"},{"location":"lib/ClimaCoreSpectra/#1D-Spectrum-Test","page":"ClimaCoreSpectra.jl","title":"1D Spectrum Test","text":"","category":"section"},{"location":"lib/ClimaCoreSpectra/#Input-wave-frequency","page":"ClimaCoreSpectra.jl","title":"Input wave frequency","text":"","category":"section"},{"location":"lib/ClimaCoreSpectra/","page":"ClimaCoreSpectra.jl","title":"ClimaCoreSpectra.jl","text":"(Image: A 1D wave.)","category":"page"},{"location":"lib/ClimaCoreSpectra/#Raw-data-on-rll-grid","page":"ClimaCoreSpectra.jl","title":"Raw data on rll grid","text":"","category":"section"},{"location":"lib/ClimaCoreSpectra/","page":"ClimaCoreSpectra.jl","title":"ClimaCoreSpectra.jl","text":"(Image: The 1D raw data to be transformed.)","category":"page"},{"location":"lib/ClimaCoreSpectra/#1D-Spectrum","page":"ClimaCoreSpectra.jl","title":"1D Spectrum","text":"","category":"section"},{"location":"lib/ClimaCoreSpectra/","page":"ClimaCoreSpectra.jl","title":"ClimaCoreSpectra.jl","text":"(Image: The 1D spectrum calculated from the data.)","category":"page"},{"location":"lib/ClimaCoreSpectra/#2D-Spectrum-Test","page":"ClimaCoreSpectra.jl","title":"2D Spectrum Test","text":"","category":"section"},{"location":"lib/ClimaCoreSpectra/#Raw-data-on-rll-grid-2","page":"ClimaCoreSpectra.jl","title":"Raw data on rll grid","text":"","category":"section"},{"location":"lib/ClimaCoreSpectra/","page":"ClimaCoreSpectra.jl","title":"ClimaCoreSpectra.jl","text":"(Image: The 2D raw data to be transformed.)","category":"page"},{"location":"lib/ClimaCoreSpectra/#Reconstruct-onto-spectral-space-and-transform-back-to-original","page":"ClimaCoreSpectra.jl","title":"Reconstruct onto spectral space and transform back to original","text":"","category":"section"},{"location":"lib/ClimaCoreSpectra/","page":"ClimaCoreSpectra.jl","title":"ClimaCoreSpectra.jl","text":"(Image: The 2D transformed data.)","category":"page"},{"location":"lib/ClimaCoreSpectra/#Error","page":"ClimaCoreSpectra.jl","title":"Error","text":"","category":"section"},{"location":"lib/ClimaCoreSpectra/","page":"ClimaCoreSpectra.jl","title":"ClimaCoreSpectra.jl","text":"(Image: The error between the transformed and initial data.)","category":"page"},{"location":"lib/ClimaCoreSpectra/#2D-Spectra","page":"ClimaCoreSpectra.jl","title":"2D Spectra","text":"","category":"section"},{"location":"lib/ClimaCoreSpectra/","page":"ClimaCoreSpectra.jl","title":"ClimaCoreSpectra.jl","text":"(Image: The 2D spectrum calculated from the data.)","category":"page"},{"location":"lib/ClimaCorePlots/#ClimaCorePlots.jl","page":"ClimaCorePlots.jl","title":"ClimaCorePlots.jl","text":"","category":"section"},{"location":"lib/ClimaCorePlots/","page":"ClimaCorePlots.jl","title":"ClimaCorePlots.jl","text":"CurrentModule = ClimaCorePlots","category":"page"},{"location":"lib/ClimaCorePlots/","page":"ClimaCorePlots.jl","title":"ClimaCorePlots.jl","text":"ClimaCorePlots.jl provides functionality for plotting ClimaCore fields extending the Plots.jl package.","category":"page"},{"location":"lib/ClimaCoreVTK/#ClimaCoreVTK.jl","page":"ClimaCoreVTK.jl","title":"ClimaCoreVTK.jl","text":"","category":"section"},{"location":"lib/ClimaCoreVTK/","page":"ClimaCoreVTK.jl","title":"ClimaCoreVTK.jl","text":"CurrentModule = ClimaCoreVTK","category":"page"},{"location":"lib/ClimaCoreVTK/","page":"ClimaCoreVTK.jl","title":"ClimaCoreVTK.jl","text":"ClimaCoreVTK.jl provides functionality for writing ClimaCore fields to VTK files, using the WriteVTK.jl package.","category":"page"},{"location":"lib/ClimaCoreVTK/#Interface","page":"ClimaCoreVTK.jl","title":"Interface","text":"","category":"section"},{"location":"lib/ClimaCoreVTK/","page":"ClimaCoreVTK.jl","title":"ClimaCoreVTK.jl","text":"writevtk\nwritepvd","category":"page"},{"location":"lib/ClimaCoreVTK/#ClimaCoreVTK.writevtk","page":"ClimaCoreVTK.jl","title":"ClimaCoreVTK.writevtk","text":"writevtk(\n    basename::String,\n    fields;\n    basis=:cell,\n    latlong=false,\n    vtkargs...\n)\n\nWrite fields to as an unstructured mesh VTK file named basename.vtu.\n\nfields can be either:\n\na ClimaCore Field object,\na FieldVector object,\na NamedTuple of Fields.\n\nThe basis keyword option determines the type of cells used to write.:\n\n:cell (default): output values at cell centers (interpolating where necessary).\n:point: output values at cell vertices.\n:lagrange: output values at Lagrange nodes (valid only for spectral element spaces), using Use VTK Lagrange cells to accurately represent high-order elements.\n\nThe latlong=true keyword option will output a spherical or spherical shell domain using the Mercator projection, with longitude along the x-axis, latitude along the y-axis, and altitude along the z-axis (if applicable). Note this currently only displays correctly if the number of elements across the cubed sphere face is even.\n\nAny additional keyword arguments are passed to WriteVTK.vtk_grid.\n\n\n\n\n\n","category":"function"},{"location":"lib/ClimaCoreVTK/#ClimaCoreVTK.writepvd","page":"ClimaCoreVTK.jl","title":"ClimaCoreVTK.writepvd","text":"writepvd(\n    basename::String,\n    times,\n    fields;\n    vtkargs...\n)\n\nWrite a sequence of fields at times as a Paraview collection (.pvd) file, along with VTK files.\n\nfields can be either be an iterable collection of fields, or a NamedTuple of collections.\n\n\n\n\n\n","category":"function"},{"location":"lib/ClimaCoreVTK/#Internal-functions","page":"ClimaCoreVTK.jl","title":"Internal functions","text":"","category":"section"},{"location":"lib/ClimaCoreVTK/","page":"ClimaCoreVTK.jl","title":"ClimaCoreVTK.jl","text":"vtk_grid\nvtk_cells_lagrange\nvtk_cells_linear\nvtk_grid_space\nvtk_cell_space\naddfield!","category":"page"},{"location":"lib/ClimaCoreVTK/#WriteVTK.vtk_grid","page":"ClimaCoreVTK.jl","title":"WriteVTK.vtk_grid","text":"vtk_grid(basename, gridspace::ClimaCore.Spaces.AbstractSpace;\n    basis=:cell, vtkargs...)\n\nConstruct a VTK grid from a ClimaCore.Spaces.AbstractSpace. If basis=:lagrange, it will construct a mesh made of Lagrange cells (valid only for spectral element spaces), otherwise it will it subdivide the space into quads, with vertices at nodal points.\n\n\n\n\n\n","category":"function"},{"location":"lib/ClimaCoreVTK/#ClimaCoreVTK.vtk_cells_lagrange","page":"ClimaCoreVTK.jl","title":"ClimaCoreVTK.vtk_cells_lagrange","text":"vtkcellslagrange(space)\n\nConstruct a vector of MeshCell objects representing the elements of space as an unstuctured mesh of Lagrange polynomial cells, suitable for passing to vtk_grid.\n\n\n\n\n\n","category":"function"},{"location":"lib/ClimaCoreVTK/#ClimaCoreVTK.vtk_cells_linear","page":"ClimaCoreVTK.jl","title":"ClimaCoreVTK.vtk_cells_linear","text":"vtkcellslinear(space)\n\nConstruct a vector of MeshCell objects representing the elements of space as an unstuctured mesh of linear cells, suitable for passing to vtk_grid.\n\n\n\n\n\n","category":"function"},{"location":"lib/ClimaCoreVTK/#ClimaCoreVTK.vtk_grid_space","page":"ClimaCoreVTK.jl","title":"ClimaCoreVTK.vtk_grid_space","text":"vtk_grid_space(space::ClimaCore.Spaces.AbstractSpace)\n\nThe space for the grid used by VTK, for any field on space.\n\nThis generally does two things:\n\nModifies the horizontal space to use a ClosedUniform quadrature rule, which will use equispaced nodal points in the reference element. This is required for using VTK Lagrange elements (see 1).\nModifies the vertical space to be on the faces.\n\n\n\n\n\n","category":"function"},{"location":"lib/ClimaCoreVTK/#ClimaCoreVTK.vtk_cell_space","page":"ClimaCoreVTK.jl","title":"ClimaCoreVTK.vtk_cell_space","text":"vtk_cell_space(gridspace::ClimaCore.Spaces.AbstractSpace)\n\nConstruct a space for outputting cell data, when using outputting a grid gridspace. be stored.\n\nThis generally does two things:\n\nModifies the horizontal space to use a Uniform quadrature rule, which will use equispaced nodal points in the reference element (excluding the boundary).\nModifies the vertical space to be on the centers.\n\n\n\n\n\n","category":"function"},{"location":"lib/ClimaCoreVTK/#ClimaCoreVTK.addfield!","page":"ClimaCoreVTK.jl","title":"ClimaCoreVTK.addfield!","text":"addfield!(vtkfile, prefix::Union{String,Nothing}, f, dataspace)\n\nAdd a field or fields f, optionally prefixing the name with prefix to the VTK file vtkfile, interpolating to dataspace.\n\nf can be any of the following:\n\na scalar or vector field (if no prefix is provided, then the field will be named \"data\")\na composite field, which will be named accordingly\na NamedTuple of fields\n\n\n\n\n\n","category":"function"},{"location":"installation_instructions/#Installation","page":"Installation and How-to Guides","title":"Installation","text":"","category":"section"},{"location":"installation_instructions/","page":"Installation and How-to Guides","title":"Installation and How-to Guides","text":"ClimaCore.jl is a registered Julia package. You can install the latest version of ClimaCore.jl through the built-in package manager. Press ] in the Julia REPL command prompt and","category":"page"},{"location":"installation_instructions/","page":"Installation and How-to Guides","title":"Installation and How-to Guides","text":"julia> ]\n(v1.10) pkg> add ClimaCore\n(v1.10) pkg> instantiate","category":"page"},{"location":"installation_instructions/","page":"Installation and How-to Guides","title":"Installation and How-to Guides","text":"This will install the latest tagged release of the package.","category":"page"},{"location":"installation_instructions/","page":"Installation and How-to Guides","title":"Installation and How-to Guides","text":"info: But I wanna be on the bleeding edge...\nIf you want the most recent developer's version of the package thenjulia> ]\n(v1.10) pkg> add ClimaCore#main\n(v1.10) pkg> instantiate","category":"page"},{"location":"installation_instructions/","page":"Installation and How-to Guides","title":"Installation and How-to Guides","text":"You can run the tests via the package manager by:","category":"page"},{"location":"installation_instructions/","page":"Installation and How-to Guides","title":"Installation and How-to Guides","text":"julia> ]\n(v1.10) pkg> test ClimaCore","category":"page"},{"location":"installation_instructions/#Running-examples","page":"Installation and How-to Guides","title":"Running examples","text":"","category":"section"},{"location":"installation_instructions/","page":"Installation and How-to Guides","title":"Installation and How-to Guides","text":"We have a selection of examples, found within the examples/ directory to demonstrate different use of our library. Each example directory contains a Project.toml","category":"page"},{"location":"installation_instructions/","page":"Installation and How-to Guides","title":"Installation and How-to Guides","text":"To build with the latest ClimaCore.jl release:","category":"page"},{"location":"installation_instructions/","page":"Installation and How-to Guides","title":"Installation and How-to Guides","text":"> cd examples/\n> julia --project -e 'using Pkg; Pkg.instantiate()'\n> julia --project example_file_name.jl","category":"page"},{"location":"installation_instructions/","page":"Installation and How-to Guides","title":"Installation and How-to Guides","text":"If you wish to run a local modified version of ClimaCore.jl then try the following (starting from the ClimaCore.jl package root)","category":"page"},{"location":"installation_instructions/","page":"Installation and How-to Guides","title":"Installation and How-to Guides","text":"> cd examples/\n> julia --project\n> julia> ]\n> (examples)> rm ClimaCore.jl\n> (examples)> dev ../\n> (examples)> instantiate","category":"page"},{"location":"installation_instructions/","page":"Installation and How-to Guides","title":"Installation and How-to Guides","text":"followed by","category":"page"},{"location":"installation_instructions/","page":"Installation and How-to Guides","title":"Installation and How-to Guides","text":"> julia --project example_file_name.jl","category":"page"},{"location":"installation_instructions/#Attribution-and-Credits","page":"Installation and How-to Guides","title":"Attribution and Credits","text":"","category":"section"},{"location":"installation_instructions/","page":"Installation and How-to Guides","title":"Installation and How-to Guides","text":"These instructions and how-to guides are heavily based on the excellent EnsembleKalmanProcesses.jl Installation Instructions","category":"page"},{"location":"intro/#Introduction-to-ClimaCore.jl's-API-concepts","page":"Introduction","title":"Introduction to ClimaCore.jl's API concepts","text":"","category":"section"},{"location":"intro/#What-is-ClimaCore.jl?","page":"Introduction","title":"What is ClimaCore.jl?","text":"","category":"section"},{"location":"intro/","page":"Introduction","title":"Introduction","text":"A suite of tools for constructing spatial discretizations, entirely written in Julia.","category":"page"},{"location":"intro/","page":"Introduction","title":"Introduction","text":"primarily aimed at climate and weather models\ninitial aim:\nspectral element discretizations (both Continuous Galerkin and Discontinuous Galerkin) in the horizontal\nstaggered finite difference in the vertical\nsupport for Cartesian and spherical domains\ncurrently under development.","category":"page"},{"location":"intro/","page":"Introduction","title":"Introduction","text":"A sketch of some fundamental API objects in ClimaCore.jl:","category":"page"},{"location":"intro/","page":"Introduction","title":"Introduction","text":"(Image: ClimaCore.jl API objects)","category":"page"},{"location":"performance_tips/#Performance-tips-and-monitoring","page":"Performance tips","title":"Performance tips and monitoring","text":"","category":"section"},{"location":"performance_tips/","page":"Performance tips","title":"Performance tips","text":"This document outlines some performance tips and performance monitoring strategies.","category":"page"},{"location":"performance_tips/","page":"Performance tips","title":"Performance tips","text":"For the most part, this document focuses on some of the common performance gotcha's that we've observed in the CliMA codebase.","category":"page"},{"location":"performance_tips/","page":"Performance tips","title":"Performance tips","text":"There is a very good and thorough overview of performance tips in Julia's docs.","category":"page"},{"location":"performance_tips/#Avoiding-global-variables","page":"Performance tips","title":"Avoiding global variables","text":"","category":"section"},{"location":"performance_tips/","page":"Performance tips","title":"Performance tips","text":"Julia allows for function closures, which can be very handy, but can also result in performance cliffs, specifically if the captured variable is a non-constant global variable. So, for that reason, it's recommended to avoid closures when possible.","category":"page"},{"location":"performance_tips/#Dynamic-memory-allocations","page":"Performance tips","title":"Dynamic memory allocations","text":"","category":"section"},{"location":"performance_tips/","page":"Performance tips","title":"Performance tips","text":"Some Julia functions incur allocations. For example, push! dynamically allocates memory. Sometimes, we can avoid using push! if the length of the container we're pushing to is known. If the length is unknown, then one can use alternative methods, for example, map. In addition, if push! is the only viable option, it's recommended to specify (if possible) the container type. For example, Float64[] and not []. see these docs for more details.","category":"page"},{"location":"performance_tips/#Tracking-allocations","page":"Performance tips","title":"Tracking allocations","text":"","category":"section"},{"location":"performance_tips/","page":"Performance tips","title":"Performance tips","text":"Julia's performance docs above recommends to pay close attention to allocations. Allocations can be coarsely reported with the @time macro and more finely reported by using julia --track-allocation=all. From CodeCov.jl's docs:","category":"page"},{"location":"performance_tips/","page":"Performance tips","title":"Performance tips","text":"Start julia with","category":"page"},{"location":"performance_tips/","page":"Performance tips","title":"Performance tips","text":"julia --track-allocation=user","category":"page"},{"location":"performance_tips/","page":"Performance tips","title":"Performance tips","text":"Then:","category":"page"},{"location":"performance_tips/","page":"Performance tips","title":"Performance tips","text":"Run whatever commands you wish to test. This first run is to ensure that everything is compiled (because compilation allocates memory).\nCall Profile.clear_malloc_data()\nRun your commands again\nQuit julia","category":"page"},{"location":"performance_tips/","page":"Performance tips","title":"Performance tips","text":"Finally, navigate to the directory holding your source code. Start julia (without command-line flags), and analyze the results using","category":"page"},{"location":"performance_tips/","page":"Performance tips","title":"Performance tips","text":"using Coverage\nanalyze_malloc(dirnames)  # could be \".\" for the current directory, or \"src\", etc.","category":"page"},{"location":"performance_tips/","page":"Performance tips","title":"Performance tips","text":"This will return a vector of MallocInfo objects, specifying the number of bytes allocated, the file name, and the line number. These are sorted in increasing order of allocation size.","category":"page"},{"location":"performance_tips/#ReportMetrics.jl","page":"Performance tips","title":"ReportMetrics.jl","text":"","category":"section"},{"location":"performance_tips/","page":"Performance tips","title":"Performance tips","text":"CliMA's ReportMetrics.jl applies the strategy in the above section and provides a re-useable interface for reporting the top-most important allocations. Here is an example of it in use:","category":"page"},{"location":"performance_tips/","page":"Performance tips","title":"Performance tips","text":"rep_workload.jl\nperf.jl","category":"page"},{"location":"performance_tips/","page":"Performance tips","title":"Performance tips","text":"# File: rep_workload.jl\nimport Profile\n\nx = rand(1000)\n\nfunction foo()\n    s = 0.0\n    for i in x\n        s += i - rand()\n    end\n    return s\nend\n\nfor i in 1:100\n    foo()\nend\nProfile.clear_malloc_data()\nfor i in 1:100\n    foo()\nend","category":"page"},{"location":"performance_tips/","page":"Performance tips","title":"Performance tips","text":"# perf.jl\nimport ReportMetrics\nReportMetrics.report_allocs(;\n    job_name = \"RA_example\",\n    run_cmd = `$(Base.julia_cmd()) --track-allocation=all rep_workload.jl`,\n    dirs_to_monitor = [pwd()],\n)","category":"page"},{"location":"performance_tips/","page":"Performance tips","title":"Performance tips","text":"This will print out something like the following:","category":"page"},{"location":"performance_tips/","page":"Performance tips","title":"Performance tips","text":"[ Info: RA_example: Number of unique allocating sites: 2\n┌───────────────┬─────────────┬─────────────────────────────────────────┐\n│ Allocations % │ Allocations │                    <file>:<line number> │\n│       (xᵢ/∑x) │     (bytes) │                                         │\n├───────────────┼─────────────┼─────────────────────────────────────────┤\n│            77 │     7996800 │ ReportMetrics.jl/test/rep_workload.jl:7 │\n│            23 │     2387200 │ ReportMetrics.jl/test/rep_workload.jl:6 │\n└───────────────┴─────────────┴─────────────────────────────────────────┘","category":"page"},{"location":"performance_tips/","page":"Performance tips","title":"Performance tips","text":"From here, one can investigate where the most important allocations are coming from. Often, allocations arise from either:","category":"page"},{"location":"performance_tips/","page":"Performance tips","title":"Performance tips","text":"Using functions that inherently allocate\nFor example, push! inherently allocates\nAnother example: defining a new variable a = c .+ b. Here, a is a newly allocated variable. It could be put into a cache and computed in-place via a .= c .+ b, which is non-allocating for Julia-native types (e.g., Arrays).\nType instabilities. Sometimes type-instabilities can trigger the compiler to perform runtime inference, which results in allocations. So, fixing type instabilities is one way to fix / remove allocations.","category":"page"},{"location":"performance_tips/#References","page":"Performance tips","title":"References","text":"","category":"section"},{"location":"performance_tips/","page":"Performance tips","title":"Performance tips","text":"General julia-specific performance tips\nCode-coverage while tracking allocations\nCliMA's ReportMetrics.jl","category":"page"},{"location":"lib/ClimaCoreMakie/#ClimaCoreMakie.jl","page":"ClimaCoreMakie.jl","title":"ClimaCoreMakie.jl","text":"","category":"section"},{"location":"lib/ClimaCoreMakie/","page":"ClimaCoreMakie.jl","title":"ClimaCoreMakie.jl","text":"CurrentModule = ClimaCoreMakie","category":"page"},{"location":"lib/ClimaCoreMakie/","page":"ClimaCoreMakie.jl","title":"ClimaCoreMakie.jl","text":"ClimaCoreMakie.jl provides functionality for plotting ClimaCore fields extending the Makie.jl package.","category":"page"},{"location":"lib/ClimaCoreMakie/","page":"ClimaCoreMakie.jl","title":"ClimaCoreMakie.jl","text":"fieldheatmap\nfieldcontourf","category":"page"},{"location":"lib/ClimaCoreMakie/#ClimaCoreMakie.fieldheatmap","page":"ClimaCoreMakie.jl","title":"ClimaCoreMakie.fieldheatmap","text":"fieldheatmap(field)\n\nPlots a heatmap of a field.\n\nAttributes\n\nInherited from Makie.mesh. \n\ncolormap::Union{Symbol, Vector{<:Colorant}} = :viridis` sets the colormap that is sampled for numeric colors.\ncolorrange::Tuple{<:Real, <:Real} sets the values representing the start and end points of colormap.\nnan_color::Union{Symbol, <:Colorant} = RGBAf(0,0,0,0) sets a replacement color for color = NaN.\nlowclip::Union{Automatic, Symbol, <:Colorant} = automatic sets a color for any value below the colorrange.\nhighclip::Union{Automatic, Symbol, <:Colorant} = automatic sets a color for any value above the colorrange.\n\n\n\n\n\n","category":"function"},{"location":"lib/ClimaCoreMakie/#ClimaCoreMakie.fieldcontourf","page":"ClimaCoreMakie.jl","title":"ClimaCoreMakie.fieldcontourf","text":"fieldcontourf(field::Field)\n\nPlots a 2D filled contour plot of a field.\n\nAttributes\n\nThese are inherited from Makie.tricontourf:\n\nlevels = 10 can be either an Int which results in n bands delimited by n+1 equally spaced levels, or it can be an AbstractVector{<:Real} that lists n consecutive edges from low to high, which result in n-1 bands.\nmode = :normal sets the way in which a vector of levels is interpreted, if it's set to :relative, each number is interpreted as a fraction between the minimum and maximum values of zs. For example, levels = 0.1:0.1:1.0 would exclude the lower 10% of data.\nextendlow = nothing. This sets the color of an optional additional band from minimum(zs) to the lowest value in levels. If it's :auto, the lower end of the colormap is picked and the remaining colors are shifted accordingly. If it's any color representation, this color is used. If it's nothing, no band is added.\nextendhigh = nothing. This sets the color of an optional additional band from the highest value of levels to maximum(zs). If it's :auto, the high end of the colormap is picked and the remaining colors are shifted accordingly. If it's any color representation, this color is used. If it's nothing, no band is added.\ncolor sets the color of the plot. It can be given as a named color Symbol or a Colors.Colorant. Transparency can be included either directly as an alpha value in the Colorant or as an additional float in a tuple (color, alpha). The color can also be set for each scattered marker by passing a Vector of colors or be used to index the colormap by passing a Real number or Vector{<: Real}.\ncolormap::Union{Symbol, Vector{<:Colorant}} = :viridis sets the colormap from which the band colors are sampled.\n\n\n\n\n\n","category":"function"},{"location":"Contributing/#Contributing-Guide","page":"Contributing guide","title":"Contributing Guide","text":"","category":"section"},{"location":"Contributing/","page":"Contributing guide","title":"Contributing guide","text":"Thank you for considering contributing to ClimaCore.jl! We hope this guide helps you make a contribution.","category":"page"},{"location":"Contributing/#What-to-contribute?","page":"Contributing guide","title":"What to contribute?","text":"","category":"section"},{"location":"Contributing/","page":"Contributing guide","title":"Contributing guide","text":"The easiest way to contribute is by running ClimaCore.jl, identifying problems and opening issues.\nYou can tackle an existing issue. See our open Issues. We try to keep a list of good first issues accessible to new contributors.\nWrite an example or tutorial.\nImprove documentation or comments if you found something hard to use.\nImplement a new feature for ClimaCore.jl and its users.","category":"page"},{"location":"Contributing/","page":"Contributing guide","title":"Contributing guide","text":"If you're interested in working on something, let us know by commenting on existing issues or by opening a new issue. This is to make sure no one else is working on the same issue and so we can help and guide you in case there is anything you need to know beforehand.","category":"page"},{"location":"Contributing/#How-to-contribute-and-bug-reporting","page":"Contributing guide","title":"How to contribute and bug reporting","text":"","category":"section"},{"location":"Contributing/","page":"Contributing guide","title":"Contributing guide","text":"The simplest way to contribute to ClimaCore.jl is to create or comment on issues, requesting something you think is missing or reporting something you think is not functioning properly.","category":"page"},{"location":"Contributing/","page":"Contributing guide","title":"Contributing guide","text":"The most useful issues or bug reports:","category":"page"},{"location":"Contributing/","page":"Contributing guide","title":"Contributing guide","text":"Head over to the issues page.\nSearch to see if your issue already exists or has even been solved previously.\nIf you indeed have a new issue or request, click the \"New Issue\" button and select the Bug report template.\nProvide an explicit code snippet of code that reproduces the bug in the latest tagged version of ClimaCore.jl. Please be as specific as possible. Include the version of the code you were using, as well as what operating system you are running. The output of Julia's versioninfo() and ] status is helpful to include. Try your best to include a complete, \"minimal working example\" that reproduces the issue. Reducing bug-producing code to a minimal example can dramatically decrease the time it takes to resolve an issue.\nPaste the entire error received when running the code snippet, even if it's unbelievably long.\nUse triple backticks (e.g., ```some_code; and_some_more_code;```) to enclose code snippets, and other markdown formatting syntax to make your issue easy and quick to read.\nReport the ClimaCore.jl version, Julia version, machine (especially if using a GPU) and any other possibly useful details of the computational environment in which the bug was created.","category":"page"},{"location":"Contributing/","page":"Contributing guide","title":"Contributing guide","text":"Discussions are recommended for asking questions about (for example) the user interface, implementation details, science, and life in general.","category":"page"},{"location":"Contributing/#But-I-want-to-*code*!","page":"Contributing guide","title":"But I want to code!","text":"","category":"section"},{"location":"Contributing/","page":"Contributing guide","title":"Contributing guide","text":"New users help write ClimaCore.jl code and documentation by forking the ClimaCore.jl repository, using git to edit code and docs, and then creating a pull request. Pull requests are reviewed by ClimaCore.jl collaborators.\nA pull request can be merged once it is reviewed and approved by collaborators. If the pull request author has write access, they have the reponsibility of merging their pull request. Otherwise, ClimaCore.jl collabators will execute the merge with permission from the pull request author.\nNote: for small or minor changes (such as fixing a typo in documentation), the GitHub editor is super useful for forking and opening a pull request with a single click.\nWrite your code with love and care. In particular, conform to existing ClimaCore.jl style and formatting conventions. For example, we love verbose and explicit variable names, use TitleCase for types, snake_case for objects, and always.put.spaces.after.commas. For formatting decisions we loosely follow the YASGuide. It's worth few extra minutes of our time to leave future generations with well-written, readable code.","category":"page"},{"location":"Contributing/#Using-git","page":"Contributing guide","title":"Using git","text":"","category":"section"},{"location":"Contributing/","page":"Contributing guide","title":"Contributing guide","text":"If you are unfamiliar with git and version control, the following guides can be helpful:","category":"page"},{"location":"Contributing/","page":"Contributing guide","title":"Contributing guide","text":"Atlassian (bitbucket) git tutorials. A set of tips and tricks for getting started with git.\nGitHub's git tutorials. A set of resources from GitHub to learn git.","category":"page"},{"location":"Contributing/","page":"Contributing guide","title":"Contributing guide","text":"We provide a brief git tutorial in the Introduction to Best Practices of our ClimaWorkshops series.","category":"page"},{"location":"Contributing/#General-coding-guidelines","page":"Contributing guide","title":"General coding guidelines","text":"","category":"section"},{"location":"Contributing/","page":"Contributing guide","title":"Contributing guide","text":"Keep the number of members of Julia structs small if possible (less than 8 members).\nCode should reflect \"human intuition\" if possible. This mean abstraction should reflect how humans reason about the problem under consideration.\nCode with small blast radius. If your code needs to be modified or extendended, the resulting required changes should be as small and as localized as possible.\nWhen you write code, write it with testing and debugging in mind.\nIdeally, the lowest level structs have no defaults for their member fields. Nobody can remember all the defaults, so it is better to introduce them at the high-level API only.\nMake sure that module imports are specific so that it is easy to trace back where functions that are used inside a module are coming from.\nConsider naming abstract Julia types \"AbstractMyType\" in order to avoid confusion for the reader of your code.\nComments in your code should explain why the code exists and clarify if necessary, not just restate the line of code in words.\nBe mindful of namespace issues when writing functional code, especially when writing function code that represents mathematical or physical concepts.\nCondider using keywords in your structs to allow readers to more effectively reason about your code.","category":"page"},{"location":"Contributing/#Who-is-a-\"collaborator\"-and-how-can-I-become-one?","page":"Contributing guide","title":"Who is a \"collaborator\" and how can I become one?","text":"","category":"section"},{"location":"Contributing/","page":"Contributing guide","title":"Contributing guide","text":"Collaborators have permissions to review pull requests and status allows a contributor to review pull requests in addition to opening them. Collaborators can also create branches in the main ClimaCore.jl repository.\nWe ask that new contributors try their hand at forking ClimaCore.jl, and opening and merging a pull request before requesting collaborator status.","category":"page"},{"location":"Contributing/#Ground-Rules","page":"Contributing guide","title":"Ground Rules","text":"","category":"section"},{"location":"Contributing/","page":"Contributing guide","title":"Contributing guide","text":"Each pull request should consist of a logical collection of changes. You can include multiple bug fixes in a single pull request, but they should be related. For unrelated changes, please submit multiple pull requests.\nDo not commit changes to files that are irrelevant to your feature or bugfix (eg: .gitignore).\nBe willing to accept criticism and work on improving your code; we don't want to break other users' code, so care must be taken not to introduce bugs. We discuss pull requests and keep working on them until we believe we've done a good job.\nBe aware that the pull request review process is not immediate, and is generally proportional to the size of the pull request.","category":"page"},{"location":"Contributing/#Setting-up-your-development-environment","page":"Contributing guide","title":"Setting up your development environment","text":"","category":"section"},{"location":"Contributing/","page":"Contributing guide","title":"Contributing guide","text":"Install Julia on your system.\nInstall git on your system if it is not already there (install XCode command line tools on a Mac or git bash on Windows).\nLogin to your GitHub account and make a fork of the ClimaCore.jl repository by clicking the \"Fork\" button.\nClone your fork of the ClimaCore.jl repository (in terminal on Mac/Linux or git shell/ GUI on Windows) in the location you'd like to keep it.\ngit clone https://github.com/your-user-name/ClimaCore.jl.git\nNavigate to that folder in the terminal or in Anaconda Prompt if you're on Windows.\nConnect your repository to the upstream (main project).\ngit remote add `ClimaCore.jl` https://github.com/CLiMA/ClimaCore.jl.git\nCreate the development environment by opening Julia via julia --project then typing in ] instantiate. This will install all the dependencies in the Project.toml file.\nYou can test to make sure ClimaCore.jl works by typing in ] test. Doing so will run all the tests (and this can take a while).","category":"page"},{"location":"Contributing/","page":"Contributing guide","title":"Contributing guide","text":"Your development environment is now ready!","category":"page"},{"location":"Contributing/#Pull-Requests","page":"Contributing guide","title":"Pull Requests","text":"","category":"section"},{"location":"Contributing/","page":"Contributing guide","title":"Contributing guide","text":"We follow the ColPrac guide for collaborative practices. We ask that new contributors read that guide before submitting a pull request.","category":"page"},{"location":"Contributing/","page":"Contributing guide","title":"Contributing guide","text":"Changes and contributions should be made via GitHub pull requests against the main branch.","category":"page"},{"location":"Contributing/","page":"Contributing guide","title":"Contributing guide","text":"When you're done making changes, commit the changes you made. Chris Beams has written a guide on how to write good commit messages.","category":"page"},{"location":"Contributing/","page":"Contributing guide","title":"Contributing guide","text":"When you think your changes are ready to be merged into the main repository, push to your fork and submit a pull request.","category":"page"},{"location":"Contributing/","page":"Contributing guide","title":"Contributing guide","text":"Working on your first Pull Request? You can learn how from this free video series How to Contribute to an Open Source Project on GitHub, Aaron Meurer's tutorial on the git workflow, or the guide “How to Contribute to Open Source\".","category":"page"},{"location":"Contributing/#Unit-testing","page":"Contributing guide","title":"Unit testing","text":"","category":"section"},{"location":"Contributing/","page":"Contributing guide","title":"Contributing guide","text":"Currently a number of checks are run per commit for a given PR.","category":"page"},{"location":"Contributing/","page":"Contributing guide","title":"Contributing guide","text":"JuliaFormatter checks if the PR is formatted with .dev/climaformat.jl.\nDocumentation rebuilds the documentation for the PR and checks if the docs are consistent and generate valid output.\nUnit Tests run subsets of the unit tests defined in tests/, using Pkg.test(). The tests are run in parallel to ensure that they finish in a reasonable time. The tests only run the latest commit for a PR, branch and will kill any stale jobs on push. These tests are only run on linux (Ubuntu LTS).","category":"page"},{"location":"Contributing/","page":"Contributing guide","title":"Contributing guide","text":"Unit tests are run against every new commit for a given PR, the status of the unit-tests are not checked during the merge process but act as a sanity check for developers and reviewers. Depending on the content changed in the PR, some CI checks that are not necessary will be skipped.  For example doc only changes do not require the unit tests to be run.","category":"page"},{"location":"Contributing/#Integration-testing","page":"Contributing guide","title":"Integration testing","text":"","category":"section"},{"location":"Contributing/","page":"Contributing guide","title":"Contributing guide","text":"Currently a number of checks are run during integration testing before being merged into master.","category":"page"},{"location":"Contributing/","page":"Contributing guide","title":"Contributing guide","text":"JuliaFormatter checks if the PR is formatted with .dev/climaformat.jl.\nDocumentation checks that the documentation correctly builds for the merged PR.\nOS Unit Tests checks that ClimaCore.jl package unit tests can pass  on every OS supported with a pre-compiled system image (Linux, macOS, Windows).\nClimaCore CI computationally expensive integration testing on CPU and GPU hardware using HPC cluster resources.","category":"page"},{"location":"Contributing/","page":"Contributing guide","title":"Contributing guide","text":"Integration tests are run when triggered by a reviewer through bors. Integration tests are more computationally heavyweight than unit-tests and can exercise tests using accelerator hardware (GPUs).","category":"page"},{"location":"Contributing/","page":"Contributing guide","title":"Contributing guide","text":"Currently HPC cluster integration tests are run using the Buildkite CI service. Tests are parallelized and run as individual Slurm batch jobs on the HPC cluster and defined in .buildkite/pipeline.yml.","category":"page"},{"location":"Contributing/#Contributing-to-Documentation","page":"Contributing guide","title":"Contributing to Documentation","text":"","category":"section"},{"location":"Contributing/","page":"Contributing guide","title":"Contributing guide","text":"Documentation is written in Julia-flavored markdown and generated from two sources:","category":"page"},{"location":"Contributing/","page":"Contributing guide","title":"Contributing guide","text":"$CLIMACORE_HOME/docs/src","category":"page"},{"location":"Contributing/","page":"Contributing guide","title":"Contributing guide","text":"And Literate.jl tutorials:","category":"page"},{"location":"Contributing/","page":"Contributing guide","title":"Contributing guide","text":"$$CLIMACORE_HOME/tutorials","category":"page"},{"location":"Contributing/","page":"Contributing guide","title":"Contributing guide","text":"To locally build the documentation you need to create a new docs project to build and install the documentation related dependencies:","category":"page"},{"location":"Contributing/","page":"Contributing guide","title":"Contributing guide","text":"cd $CLIMACORE_HOME\njulia --project=docs/ -e 'using Pkg; Pkg.instantiate()'\njulia --project=docs docs/make.jl","category":"page"},{"location":"Contributing/","page":"Contributing guide","title":"Contributing guide","text":"The makefile script will generate the appropriate markdown files and static html from both the docs/src and tutorials/ directories, saving the output in docs/src/generated.","category":"page"},{"location":"Contributing/#How-to-generate-a-literate-tutorial-file","page":"Contributing guide","title":"How to generate a literate tutorial file","text":"","category":"section"},{"location":"Contributing/","page":"Contributing guide","title":"Contributing guide","text":"To create a tutorial using ClimaCore.jl, please use Literate.jl, and consult the Literate documentation for questions. For now, all literate tutorials are held in the tutorials directory.","category":"page"},{"location":"Contributing/","page":"Contributing guide","title":"Contributing guide","text":"With Literate, all comments turn into markdown text and any Julia code is read and run as if it is in the Julia REPL. As a small caveat to this, you might need to suppress the output of certain commands. For example, if you define and run the following function","category":"page"},{"location":"Contributing/","page":"Contributing guide","title":"Contributing guide","text":"function f()\n    return x = [i * i for i in 1:10]\nend\nx = f()","category":"page"},{"location":"Contributing/","page":"Contributing guide","title":"Contributing guide","text":"The entire list will be output, while","category":"page"},{"location":"Contributing/","page":"Contributing guide","title":"Contributing guide","text":"f();","category":"page"},{"location":"Contributing/","page":"Contributing guide","title":"Contributing guide","text":"does not (because of the ;).","category":"page"},{"location":"Contributing/","page":"Contributing guide","title":"Contributing guide","text":"To show plots, you may do something like the following:","category":"page"},{"location":"Contributing/","page":"Contributing guide","title":"Contributing guide","text":"using Plots\nplot(x)","category":"page"},{"location":"Contributing/","page":"Contributing guide","title":"Contributing guide","text":"Please consider writing the comments in your tutorial as if they are meant to be read as an article explaining the topic the tutorial is meant to explain. If there are any specific nuances to writing Literate documentation for ClimaCore.jl, please let us know!","category":"page"},{"location":"Contributing/#Credits","page":"Contributing guide","title":"Credits","text":"","category":"section"},{"location":"Contributing/","page":"Contributing guide","title":"Contributing guide","text":"This contributor's guide is heavily based on the excellent ClimateMachine.jl contributor's guide and ClimaAtmos.jl contributor's guide, which is heavily based on the excellent Oceananigans.jl contributor's guide which, in turn, is heavily based on the excellent MetPy contributor's guide.","category":"page"},{"location":"api/#API","page":"API","title":"API","text":"","category":"section"},{"location":"api/","page":"API","title":"API","text":"CurrentModule = ClimaCore","category":"page"},{"location":"api/#Utilities","page":"API","title":"Utilities","text":"","category":"section"},{"location":"api/","page":"API","title":"API","text":"Utilities.PlusHalf\nUtilities.half\nUtilities.UnrolledFunctions","category":"page"},{"location":"api/#ClimaCore.Utilities.PlusHalf","page":"API","title":"ClimaCore.Utilities.PlusHalf","text":"PlusHalf(i)\n\nRepresents i + 1/2, but stored as internally as an integer value. Used for indexing into staggered finite difference meshes: the convention \"half\" values are indexed at cell faces, whereas centers are indexed at cell centers.\n\nSupports +, - and inequalities.\n\nSee also half.\n\n\n\n\n\n","category":"type"},{"location":"api/#ClimaCore.Utilities.half","page":"API","title":"ClimaCore.Utilities.half","text":"const half = PlusHalf(0)\n\n\n\n\n\n","category":"constant"},{"location":"api/#ClimaCore.Utilities.UnrolledFunctions","page":"API","title":"ClimaCore.Utilities.UnrolledFunctions","text":"UnrolledFunctions\n\nA collection of generated functions that get unrolled during compilation, which make it possible to iterate over nonuniform collections without sacrificing type-stability.\n\nThe functions exported by this module are\n\nunrolled_map(f, values, [values2]): alternative to map\nunrolled_any(f, values): alternative to any\nunrolled_all(f, values): alternative to all\nunrolled_filter(f, values): alternative to filter\nunrolled_foreach(f, values): alternative to foreach\nunrolled_in(value, values): alternative to in\nunrolled_unique(values): alternative to unique\nunrolled_flatten(values): alternative to Iterators.flatten\nunrolled_flatmap(f, values): alternative to Iterators.flatmap\nunrolled_product(values1, values2): alternative to Iterators.product\nunrolled_findonly(f, values): checks that only one value satisfies f, and then returns that value\nunrolled_split(f, values): returns a tuple that contains the result of calling unrolled_filter with f and the result of calling it with !f\nunrolled_take(values, ::Val{N}): alternative to Iterators.take, but with an Int wrapped in a Val as the second argument instead of a regular Int; this usually compiles more quickly than values[1:N]\nunrolled_drop(values, ::Val{N}): alternative to Iterators.drop, but with an Int wrapped in a Val as the second argument instead of a regular Int; this usually compiles more quickly than values[(end - N + 1):end]\n\n\n\n\n\n","category":"module"},{"location":"api/#Utilities.Cache","page":"API","title":"Utilities.Cache","text":"","category":"section"},{"location":"api/","page":"API","title":"API","text":"Utilities.Cache\nUtilities.Cache.cached_objects\nUtilities.Cache.clean_cache!","category":"page"},{"location":"api/#ClimaCore.Utilities.Cache","page":"API","title":"ClimaCore.Utilities.Cache","text":"Utilities.Cache\n\nClimaCore maintains an internal cache of topology and grid objects: this ensures that if the constructor with the same arguments is invoked again (e.g. by reading from a file), the cached object will be returned (also known as memoization). This has two main advantages:\n\ntopology and metric information can be reused, reducing memory usage.\nit is easy to check if two fields live on the same grid: we can just check if the underlying grid objects are the same (===), rather than checking all the fields are equal (via ==).\n\nHowever this means that objects in the cache will not be removed from the garbage collector, so we provide an interface to remove these.\n\n\n\n\n\n","category":"module"},{"location":"api/#ClimaCore.Utilities.Cache.cached_objects","page":"API","title":"ClimaCore.Utilities.Cache.cached_objects","text":"Utilities.Cache.cached_objects()\n\nList all currently cached objects.\n\n\n\n\n\n","category":"function"},{"location":"api/#ClimaCore.Utilities.Cache.clean_cache!","page":"API","title":"ClimaCore.Utilities.Cache.clean_cache!","text":"Utilities.Cache.clean_cache!(object)\n\nRemove object from the cache of created objects. \n\nIn most cases, this function should not need to be called, unless you are constructing many grid objects, for example when doing a sweep over grid paramaters.\n\n\n\n\n\nUtilities.Cache.clean_cache!()\n\nRemove all objects from the cache of created objects. \n\nIn most cases, this function should not need to be called, unless you are constructing many grid objects, for example when doing a sweep over grid paramaters.\n\n\n\n\n\n","category":"function"},{"location":"api/#DataLayouts","page":"API","title":"DataLayouts","text":"","category":"section"},{"location":"api/","page":"API","title":"API","text":"DataLayouts\nDataLayouts.DataF\nDataLayouts.IF\nDataLayouts.IJF\nDataLayouts.VF\nDataLayouts.IFH\nDataLayouts.IJFH\nDataLayouts.VIFH\nDataLayouts.VIJFH","category":"page"},{"location":"api/#ClimaCore.DataLayouts","page":"API","title":"ClimaCore.DataLayouts","text":"ClimaCore.DataLayouts\n\nDefines the following DataLayouts (see individual docs for more info):\n\nTODO: Add links to these datalayouts\n\nIJKFVH\nIJFH\nIFH\nDataF\nIJF\nIF\nVF\nVIJFH\nVIFH\nIH1JH2\nIV1JH2\n\nNotation:\n\ni,j are horizontal node indices within an element\nk is the vertical node index within an element\nf is the field index (1 if field is scalar, >1 if it is a vector field)\nv is the vertical element index in a stack\nh is the element stack index\n\nData layout is specified by the order in which they appear, e.g. IJKFVH indexes the underlying array as [i,j,k,f,v,h]\n\n\n\n\n\n","category":"module"},{"location":"api/#ClimaCore.DataLayouts.DataF","page":"API","title":"ClimaCore.DataLayouts.DataF","text":"DataF{S, A} <: Data0D{S}\n\nBacking DataLayout for 0D point data.\n\n\n\n\n\n","category":"type"},{"location":"api/#ClimaCore.DataLayouts.IF","page":"API","title":"ClimaCore.DataLayouts.IF","text":"IF{S, Ni, A} <: DataSlab1D{S, Ni}\n\nBacking DataLayout for 1D spectral element slab data.\n\nNodal element data (I) are contiguous for each S datatype struct field (F) for a single element slab.\n\nA DataSlab1D view can be returned from other Data1D objects by calling slab(data, idx...).\n\n\n\n\n\n","category":"type"},{"location":"api/#ClimaCore.DataLayouts.IJF","page":"API","title":"ClimaCore.DataLayouts.IJF","text":"IJF{S, Nij, A} <: DataSlab2D{S, Nij}\n\nBacking DataLayout for 2D spectral element slab data.\n\nNodal element data (I,J) are contiguous for each S datatype struct field (F) for a single element slab.\n\nA DataSlab2D view can be returned from other Data2D objects by calling slab(data, idx...).\n\n\n\n\n\n","category":"type"},{"location":"api/#ClimaCore.DataLayouts.VF","page":"API","title":"ClimaCore.DataLayouts.VF","text":"VF{S, A} <: DataColumn{S, Nv}\n\nBacking DataLayout for 1D FV column data.\n\nColumn level data (V) are contiguous for each S datatype struct field (F).\n\nA DataColumn view can be returned from other Data1DX, Data2DX objects by calling column(data, idx...).\n\n\n\n\n\n","category":"type"},{"location":"api/#ClimaCore.DataLayouts.IFH","page":"API","title":"ClimaCore.DataLayouts.IFH","text":"IFH{S,Ni,Nh,A} <: Data1D{S, Ni}\nIFH{S,Ni,Nh}(ArrayType)\n\nBacking DataLayout for 1D spectral element slabs.\n\nElement nodal point (I) data is contiguous for each datatype S struct field (F), for each 1D mesh element (H).\n\nThe ArrayType-constructor makes a IFH 1D Spectral DataLayout given the backing ArrayType, quadrature degrees of freedom Ni, and the number of mesh elements Nh.\n\n\n\n\n\n","category":"type"},{"location":"api/#ClimaCore.DataLayouts.IJFH","page":"API","title":"ClimaCore.DataLayouts.IJFH","text":"IJFH{S, Nij, A} <: Data2D{S, Nij}\nIJFH{S,Nij}(ArrayType, nelements)\n\nBacking DataLayout for 2D spectral element slabs.\n\nElement nodal point (I,J) data is contiguous for each datatype S struct field (F), for each 2D mesh element slab (H).\n\nThe ArrayType-constructor constructs a IJFH 2D Spectral DataLayout given the backing ArrayType, quadrature degrees of freedom Nij × Nij, and the number of mesh elements nelements.\n\n\n\n\n\n","category":"type"},{"location":"api/#ClimaCore.DataLayouts.VIFH","page":"API","title":"ClimaCore.DataLayouts.VIFH","text":"VIFH{S, Nv, Ni, A} <: Data1DX{S, Nv, Ni}\n\nBacking DataLayout for 1D spectral element slab + extruded 1D FV column data.\n\nColumn levels (V) are contiguous for every element nodal point (I) for each datatype S struct field (F), for each 1D mesh element slab (H).\n\n\n\n\n\n","category":"type"},{"location":"api/#ClimaCore.DataLayouts.VIJFH","page":"API","title":"ClimaCore.DataLayouts.VIJFH","text":"VIJFH{S, Nij, A} <: Data2DX{S, Nij}\n\nBacking DataLayout for 2D spectral element slab + extruded 1D FV column data.\n\nColumn levels (V) are contiguous for every element nodal point (I, J) for each S datatype struct field (F), for each 2D mesh element slab (H).\n\n\n\n\n\n","category":"type"},{"location":"api/#Geometry","page":"API","title":"Geometry","text":"","category":"section"},{"location":"api/#Coordinates","page":"API","title":"Coordinates","text":"","category":"section"},{"location":"api/","page":"API","title":"API","text":"Geometry.AbstractPoint\nGeometry.float_type","category":"page"},{"location":"api/#ClimaCore.Geometry.AbstractPoint","page":"API","title":"ClimaCore.Geometry.AbstractPoint","text":"AbstractPoint\n\nRepresents a point in space.\n\nThe following types are supported:\n\nXPoint(x)\nYPoint(y)\nZPoint(z)\nXYPoint(x, y)\nXZPoint(x, z)\nXYZPoint(x, y, z)\nLatPoint(lat)\nLongPoint(long)\nLatLongPoint(lat, long)\nLatLongZPoint(lat, long, z)\nCartesian1Point(x1)\nCartesian2Point(x2)\nCartesian3Point(x3)\nCartesian12Point(x1, x2)\nCartesian13Point(x1, x3)\nCartesian123Point(x1, x2, x3)\n\n\n\n\n\n","category":"type"},{"location":"api/#ClimaCore.Geometry.float_type","page":"API","title":"ClimaCore.Geometry.float_type","text":"float_type(T)\n\nReturn the floating point type backing T: T can either be an object or a type.\n\n\n\n\n\n","category":"function"},{"location":"api/","page":"API","title":"API","text":"Points represent locations in space, specified by coordinates in a given coordinate system (Cartesian, spherical, etc), whereas vectors, on the other hand, represent displacements in space.","category":"page"},{"location":"api/","page":"API","title":"API","text":"An analogy with time works well: times (also called instants or datetimes) are locations in time, while, durations are displacements in time.","category":"page"},{"location":"api/","page":"API","title":"API","text":"Note 1: Latitude and longitude are specified via angles (and, therefore, trigonometric functions: cosd, sind, acosd, asind, tand,...) in degrees, not in radians. Moreover, lat (usually denoted by theta) in -900 900, and long (usually denoted by lambda) in -1800 1800.","category":"page"},{"location":"api/","page":"API","title":"API","text":"Note 2:: In a Geometry.LatLongZPoint(lat, long, z), z represents the elevation above the surface of the sphere with radius R (implicitly accounted for in the geoemtry).","category":"page"},{"location":"api/","page":"API","title":"API","text":"Note 3: There are also a set of specific Cartesian points (Cartesian1Point(x1), Cartesian2Point(x2), etc). These are occasionally useful for converting everything to a full Cartesian domain (e.g. for visualization purposes). These are distinct from XYZPoint as ZPoint can mean different things in different domains.","category":"page"},{"location":"api/#Domains","page":"API","title":"Domains","text":"","category":"section"},{"location":"api/#Types","page":"API","title":"Types","text":"","category":"section"},{"location":"api/","page":"API","title":"API","text":"Domains.AbstractDomain\nDomains.IntervalDomain\nDomains.RectangleDomain\nDomains.SphereDomain","category":"page"},{"location":"api/#ClimaCore.Domains.AbstractDomain","page":"API","title":"ClimaCore.Domains.AbstractDomain","text":"AbstractDomain\n\nA domain represents a region of space.\n\n\n\n\n\n","category":"type"},{"location":"api/#ClimaCore.Domains.IntervalDomain","page":"API","title":"ClimaCore.Domains.IntervalDomain","text":"IntervalDomain(coord⁻, coord⁺; periodic=true)\nIntervalDomain(coord⁻, coord⁺; boundary_names::Tuple{Symbol,Symbol})\n\nConstruct a IntervalDomain, the closed interval is given by coord⁻, coord⁺ coordinate arguments.\n\nEither a periodic or boundary_names keyword argument is required.\n\n\n\n\n\n","category":"type"},{"location":"api/#ClimaCore.Domains.RectangleDomain","page":"API","title":"ClimaCore.Domains.RectangleDomain","text":"RectangleDomain(x1::ClosedInterval, x2::ClosedInterval;\n    x1boundary::Tuple{Symbol,Symbol},\n    x2boundary::Tuple{Symbol,Symbol},\n    x1periodic = false,\n    x2periodic = false,\n)\n\nConstruct a RectangularDomain in the horizontal. If a given x1 or x2 boundary is not periodic, then x1boundary or x2boundary boundary name keyword arguments must be supplied.\n\n\n\n\n\n","category":"type"},{"location":"api/#ClimaCore.Domains.SphereDomain","page":"API","title":"ClimaCore.Domains.SphereDomain","text":"SphereDomain(radius)\n\nA domain representing the surface of a sphere with radius radius.\n\n\n\n\n\n","category":"type"},{"location":"api/#Interfaces","page":"API","title":"Interfaces","text":"","category":"section"},{"location":"api/","page":"API","title":"API","text":"Domains.boundary_names","category":"page"},{"location":"api/#ClimaCore.Domains.boundary_names","page":"API","title":"ClimaCore.Domains.boundary_names","text":"boundary_names(obj::Union{AbstractDomain, AbstractMesh, AbstractTopology})\n\nA tuple or vector of unique boundary names of a spatial domain.\n\n\n\n\n\n","category":"function"},{"location":"api/#Meshes","page":"API","title":"Meshes","text":"","category":"section"},{"location":"api/","page":"API","title":"API","text":"A Mesh is a division of a domain into elements.","category":"page"},{"location":"api/#Mesh-types","page":"API","title":"Mesh types","text":"","category":"section"},{"location":"api/","page":"API","title":"API","text":"Meshes.AbstractMesh\nMeshes.IntervalMesh\nMeshes.RectilinearMesh\nMeshes.AbstractCubedSphere\nMeshes.EquiangularCubedSphere\nMeshes.EquidistantCubedSphere\nMeshes.ConformalCubedSphere","category":"page"},{"location":"api/#ClimaCore.Meshes.AbstractMesh","page":"API","title":"ClimaCore.Meshes.AbstractMesh","text":"AbstractMesh{dim}\n\nA Mesh is an object which represents how we discretize a domain into elements.\n\nIt should be lightweight (i.e. exists on all MPI ranks), e.g for meshes stored in a file, it would contain the filename.\n\nFace and vertex numbering\n\nIn 1D, faces and vertices are the same, and both are numbered [1,2].\n\nIn 2D, a face is a line segment between to vertices, and both are numbered [1,2,3,4], in a counter-clockwise direction.\n\n v4        f3        v3\n   o-----------------o\n   |                 |\t    face    vertices\n   |                 |\t      f1 =>  v1 v2\nf4 |                 | f2     f2 =>  v2 v3\n   |                 |\t      f3 =>  v3 v4\n   |                 |        f4 =>  v4 v1\n   |                 |\n   o-----------------o\n  v1       f1        v2\n\nInterface\n\nA subtype of AbstractMesh should define the following methods:\n\ndomain(mesh)\nelements(mesh)\nis_boundary_face(mesh, elem, face)\nboundary_face_name(mesh, elem, face)\nopposing_face(mesh, elem, face)\ncoordinates(mesh, elem, vert)\ncontaining_element (optional)\n\nThe following types/methods are provided by AbstractMesh:\n\nSharedVertices(mesh, elem, vert)\nface_connectivity_matrix(mesh[,elemorder])\nvertex_connectivity_matrix(mesh[,elemorder])\n\n\n\n\n\n","category":"type"},{"location":"api/#ClimaCore.Meshes.IntervalMesh","page":"API","title":"ClimaCore.Meshes.IntervalMesh","text":"IntervalMesh <: AbstractMesh\n\nA 1D mesh on an IntervalDomain.\n\nConstuctors\n\nIntervalMesh(domain::IntervalDomain, faces::AbstractVector)\n\nConstruct a 1D mesh with face locations at faces.\n\nIntervalMesh(domain::IntervalDomain[, stretching=Uniform()]; nelems=)\n\nConstuct a 1D mesh on domain with nelems elements, using stretching. Possible values of stretching are:\n\nUniform()\nExponentialStretching(H)\nGeneralizedExponentialStretching(dz_bottom, dz_top)\n\n\n\n\n\n","category":"type"},{"location":"api/#ClimaCore.Meshes.RectilinearMesh","page":"API","title":"ClimaCore.Meshes.RectilinearMesh","text":"RectilinearMesh <: AbstractMesh2D\n\nConstructors\n\nRectilinearMesh(domain::RectangleDomain, n1, n2)\n\nConstruct a RectilinearMesh of equally-spaced n1 by n2 elements on domain.\n\nRectilinearMesh(intervalmesh1::IntervalMesh1, intervalmesh2::IntervalMesh2)\n\nConstruct the product mesh of intervalmesh1 and intervalmesh2.\n\n\n\n\n\n","category":"type"},{"location":"api/#ClimaCore.Meshes.AbstractCubedSphere","page":"API","title":"ClimaCore.Meshes.AbstractCubedSphere","text":"AbstractCubedSphere <: AbstractMesh2D\n\nThis is an abstract type of cubed-sphere meshes on SphereDomains. A cubed-sphere mesh has 6 panels, laid out as follows:\n\n                                          :   Panel 1   :\n                            +-------------+-------------+\n                            |     +x1     |     +x1     |\n                            |             |             |\n                            |    Panel    |    Panel    |\n                            |+x3   5   -x3|-x2   6   +x2|\n                            |     -x2     |     -x3     |\n                            |             |             |\n                            |     -x1     |     -x1     |\n              +-------------+-------------+-------------+\n              |     -x2     |     -x2     |\n              |             |             |\n              |    Panel    |    Panel    |\n              |+x1   3   -x1|+x3   4   -x3|\n              |     +x3     |     -x1     |\n              |             |             |\n              |     +x2     |     +x2     |\n+-------------+-------------+-------------+\n|     +x3     |     +x3     |\n|             |             |\n|    Panel    |    Panel    |\n|-x2   1   +x2|+x1   2   -x1|\n|     +x1     |     +x2     |\n|             |             |\n|     -x3     |     -x3     |\n+-------------+-------------+\n:   Panel 6   :\n\nThis is the same panel ordering used by the S2 Geometry library (though we use 1-based instead of 0-based numering).\n\nElements are indexed by a CartesianIndex{3} object, where the components are:\n\nhorizontal element index (left to right) within each panel.\nvertical element index (bottom to top) within each panel.\npanel number\n\nSubtypes should have the following fields:\n\ndomain: a SphereDomain\nne: number of elements across each panel\n\nExternal links\n\nS2Geometry library\nMIT GCM exch2\n\n\n\n\n\n","category":"type"},{"location":"api/#ClimaCore.Meshes.EquiangularCubedSphere","page":"API","title":"ClimaCore.Meshes.EquiangularCubedSphere","text":"EquiangularCubedSphere <: AbstractCubedSphere\n\nAn equiangular gnomonic mesh proposed by [7]. Uses the element indexing convention of AbstractCubedSphere.\n\nConstructors\n\nEquiangularCubedSphere(\n    domain::Domains.SphereDomain,\n    ne::Integer,\n    localelementmap=NormalizedBilinearMap()\n    )\n\nConstuct an EquiangularCubedSphere on domain with ne elements across each panel.\n\n\n\n\n\n","category":"type"},{"location":"api/#ClimaCore.Meshes.EquidistantCubedSphere","page":"API","title":"ClimaCore.Meshes.EquidistantCubedSphere","text":"EquidistantCubedSphere <: AbstractCubedSphere\n\nAn equidistant gnomonic mesh outlined in [8] and [9]. Uses the element indexing convention of AbstractCubedSphere.\n\nConstructors\n\nEquidistantCubedSphere(domain::Domains.SphereDomain, ne::Integer)\n\nConstuct an EquidistantCubedSphere on domain with ne elements across each panel.\n\n\n\n\n\n","category":"type"},{"location":"api/#ClimaCore.Meshes.ConformalCubedSphere","page":"API","title":"ClimaCore.Meshes.ConformalCubedSphere","text":"ConformalCubedSphere <: AbstractCubedSphere\n\nA conformal mesh outlined in [8]. Uses the element indexing convention of AbstractCubedSphere.\n\nConstructors\n\nConformalCubedSphere(domain::Domains.SphereDomain, ne::Integer)\n\nConstuct a ConformalCubedSphere on domain with ne elements across each panel.\n\n\n\n\n\n","category":"type"},{"location":"api/#Local-element-map","page":"API","title":"Local element map","text":"","category":"section"},{"location":"api/","page":"API","title":"API","text":"Meshes.LocalElementMap\nMeshes.IntrinsicMap\nMeshes.NormalizedBilinearMap","category":"page"},{"location":"api/#ClimaCore.Meshes.LocalElementMap","page":"API","title":"ClimaCore.Meshes.LocalElementMap","text":"LocalElementMap\n\nAn abstract type of mappings from the reference element to a physical domain.\n\n\n\n\n\n","category":"type"},{"location":"api/#ClimaCore.Meshes.IntrinsicMap","page":"API","title":"ClimaCore.Meshes.IntrinsicMap","text":"IntrinsicMap()\n\nThis LocalElementMap uses the intrinsic mapping of the cubed sphere to map the reference element to the physical domain.\n\n\n\n\n\n","category":"type"},{"location":"api/#ClimaCore.Meshes.NormalizedBilinearMap","page":"API","title":"ClimaCore.Meshes.NormalizedBilinearMap","text":"NormalizedBilinearMap()\n\nThe LocalElementMap for meshes on spherical domains of [10]. It uses bilinear interpolation between the Cartesian coordinates of the element vertices, then normalizes the result to lie on the sphere.\n\n\n\n\n\n","category":"type"},{"location":"api/#Mesh-stretching","page":"API","title":"Mesh stretching","text":"","category":"section"},{"location":"api/","page":"API","title":"API","text":"Meshes.Uniform\nMeshes.ExponentialStretching\nMeshes.GeneralizedExponentialStretching","category":"page"},{"location":"api/#ClimaCore.Meshes.Uniform","page":"API","title":"ClimaCore.Meshes.Uniform","text":"Uniform()\n\nUse uniformly-sized elements.\n\n\n\n\n\n","category":"type"},{"location":"api/#ClimaCore.Meshes.ExponentialStretching","page":"API","title":"ClimaCore.Meshes.ExponentialStretching","text":"ExponentialStretching(H::FT)\n\nApply exponential stretching to the domain when constructing elements. H is the scale height (a typical atmospheric scale height H ≈ 7.5km).\n\nFor an interval z_0z_1, this makes the elements uniformally spaced in zeta, where\n\nzeta = frac1 - e^-etah1-e^-1h\n\nwhere eta = fracz - z_0z_1-z_0, and h = fracHz_1-z_0 is the non-dimensional scale height. If reverse_mode is true, the smallest element is at the top, and the largest at the bottom (this is typical for land model configurations).\n\nThen, the user can define a stretched mesh via\n\nClimaCore.Meshes.IntervalMesh(interval_domain, ExponentialStretching(H); nelems::Int, reverse_mode = false)\n\n\n\n\n\n","category":"type"},{"location":"api/#ClimaCore.Meshes.GeneralizedExponentialStretching","page":"API","title":"ClimaCore.Meshes.GeneralizedExponentialStretching","text":"GeneralizedExponentialStretching(dz_bottom::FT, dz_top::FT)\n\nApply a generalized form of exponential stretching to the domain when constructing elements. dz_bottom and dz_top are target element grid spacings at the bottom and at the top of the vertical column domain (m). In typical atmosphere configurations, dz_bottom is the smallest grid spacing and dz_top the largest one. On the other hand, for typical land configurations, dz_bottom is the largest grid spacing and dz_top the smallest one.\n\nFor land configurations, use reverse_mode = true (default value false).\n\nThen, the user can define a generalized stretched mesh via\n\nClimaCore.Meshes.IntervalMesh(interval_domain, GeneralizedExponentialStretching(dz_bottom, dz_top); nelems::Int, reverse_mode = false)\n\n\n\n\n\n","category":"type"},{"location":"api/#Mesh-utilities","page":"API","title":"Mesh utilities","text":"","category":"section"},{"location":"api/","page":"API","title":"API","text":"Meshes.truncate_mesh","category":"page"},{"location":"api/#ClimaCore.Meshes.truncate_mesh","page":"API","title":"ClimaCore.Meshes.truncate_mesh","text":"truncate_mesh(\n    parent_mesh::AbstractMesh,\n    trunc_domain::IntervalDomain{CT},\n)\n\nConstructs an IntervalMesh, truncating the given parent_mesh defined on a truncated trunc_domain. The truncation preserves the number of degrees of freedom covering the space from the trunc_domain's z_bottom to z_top, adjusting the stretching.\n\n\n\n\n\n","category":"function"},{"location":"api/#Interfaces-2","page":"API","title":"Interfaces","text":"","category":"section"},{"location":"api/","page":"API","title":"API","text":"Meshes.domain\nMeshes.elements\nMeshes.nelements\nMeshes.is_boundary_face\nMeshes.boundary_face_name\nMeshes.opposing_face\nMeshes.coordinates\nMeshes.containing_element\nMeshes.reference_coordinates\nMeshes.SharedVertices\nMeshes.face_connectivity_matrix\nMeshes.vertex_connectivity_matrix\nMeshes.linearindices\nMeshes.element_horizontal_length_scale","category":"page"},{"location":"api/#ClimaCore.Meshes.domain","page":"API","title":"ClimaCore.Meshes.domain","text":"Meshes.domain(mesh::AbstractMesh)\n\nThe domain (a subtype of  Domains.AbstractDomain) on which the mesh is defined.\n\n\n\n\n\n","category":"function"},{"location":"api/#ClimaCore.Meshes.elements","page":"API","title":"ClimaCore.Meshes.elements","text":"Meshes.elements(mesh::AbstractMesh)\n\nAn iterator over the elements of a mesh. Elements of a mesh can be of any type.\n\n\n\n\n\n","category":"function"},{"location":"api/#ClimaCore.Meshes.nelements","page":"API","title":"ClimaCore.Meshes.nelements","text":"nelements(mesh::AbstractMesh)\n\nThe number of elements in the mesh.\n\n\n\n\n\n","category":"function"},{"location":"api/#ClimaCore.Meshes.is_boundary_face","page":"API","title":"ClimaCore.Meshes.is_boundary_face","text":"Meshes.is_boundary_face(mesh::AbstractMesh, elem, face::Int)::Bool\n\nDetermine whether face face of element elem is on the boundary of mesh.\n\nelem should be an element of elements(mesh).\n\n\n\n\n\n","category":"function"},{"location":"api/#ClimaCore.Meshes.boundary_face_name","page":"API","title":"ClimaCore.Meshes.boundary_face_name","text":"Meshes.boundary_face_name(mesh::AbstractMesh, elem, face::Int)::Union{Symbol,Nothing}\n\nThe name of the boundary facing face of element elem, or nothing if it is not on the boundary.\n\n\n\n\n\n","category":"function"},{"location":"api/#ClimaCore.Meshes.opposing_face","page":"API","title":"ClimaCore.Meshes.opposing_face","text":"opelem, opface, reversed = Meshes.opposing_face(mesh::AbstractMesh, elem, face::Int)\n\nThe element and face (opelem, opface) that oppose face face of element elem.\n\n\n\n\n\n","category":"function"},{"location":"api/#ClimaCore.Meshes.coordinates","page":"API","title":"ClimaCore.Meshes.coordinates","text":"Meshes.coordinates(mesh, elem, vert::Int)\nMeshes.coordinates(mesh, elem, ξ::SVector)\n\nReturn the physical coordinates of a point in an element elem of mesh. The position of the point can either be a vertex number vert or the coordinates ξ in the reference element.\n\n\n\n\n\n","category":"function"},{"location":"api/#ClimaCore.Meshes.containing_element","page":"API","title":"ClimaCore.Meshes.containing_element","text":"elem = Meshes.containing_element(mesh::AbstractMesh, coord)\n\nThe element elem in mesh containing the coordinate coord. If the coordinate falls on the boundary between two or more elements, an arbitrary element is chosen.\n\n\n\n\n\n","category":"function"},{"location":"api/#ClimaCore.Meshes.reference_coordinates","page":"API","title":"ClimaCore.Meshes.reference_coordinates","text":"ξ = Meshes.reference_coordinates(mesh::AbstractMesh, elem, coord)\n\nAn SVector of coordinates in the reference element such that\n\nMeshes.coordinates(mesh, elem, ξ) == coord\n\nThis can be used for interpolation to a specific point.\n\n\n\n\n\n","category":"function"},{"location":"api/#ClimaCore.Meshes.SharedVertices","page":"API","title":"ClimaCore.Meshes.SharedVertices","text":"Meshes.SharedVertices(mesh, elem, vert)\n\nAn iterator over (element, vertex) pairs that are shared with (elem,vert).\n\n\n\n\n\n","category":"type"},{"location":"api/#ClimaCore.Meshes.face_connectivity_matrix","page":"API","title":"ClimaCore.Meshes.face_connectivity_matrix","text":"M = Meshes.face_connectivity_matrix(mesh, elemorder = elements(mesh))\n\nConstruct a Bool-valued SparseCSCMatrix containing the face connections of mesh. Elements are indexed according to elemorder.\n\nNote that M[i,i] == true only if two distinct faces of element i are connected.\n\n\n\n\n\n","category":"function"},{"location":"api/#ClimaCore.Meshes.vertex_connectivity_matrix","page":"API","title":"ClimaCore.Meshes.vertex_connectivity_matrix","text":"M = Meshes.vertex_connectivity_matrix(mesh, elemorder = elements(mesh))\n\nConstruct a Bool-valued SparseCSCMatrix containing the vertex connections of mesh. Elements are indexed according to elemorder.\n\nNote that M[i,i] == true only if two distinct vertices of element i are connected.\n\n\n\n\n\n","category":"function"},{"location":"api/#ClimaCore.Meshes.linearindices","page":"API","title":"ClimaCore.Meshes.linearindices","text":"Meshes.linearindices(elemorder)\n\nGiven a data structure elemorder[i] = elem that orders elements, construct the inverse map from orderindex = linearindices(elemorder) such that orderindex[elem] = i.\n\nThis will try to use the most efficient structure available.\n\n\n\n\n\n","category":"function"},{"location":"api/#ClimaCore.Meshes.element_horizontal_length_scale","page":"API","title":"ClimaCore.Meshes.element_horizontal_length_scale","text":"Meshes.element_horizontal_length_scale(mesh::AbstractMesh)\n\nThe approximate length scale (in units of distance) of the elements of the mesh.\n\n\n\n\n\n","category":"function"},{"location":"api/#Topologies","page":"API","title":"Topologies","text":"","category":"section"},{"location":"api/","page":"API","title":"API","text":"A Topology determines the ordering and connections between elements of a mesh. (Image: Space-filling curve element ordering for a cubed sphere mesh)","category":"page"},{"location":"api/#Types-2","page":"API","title":"Types","text":"","category":"section"},{"location":"api/","page":"API","title":"API","text":"Topologies.AbstractTopology\nTopologies.IntervalTopology\nTopologies.Topology2D\nTopologies.spacefillingcurve\nTopologies.nelems\nTopologies.nneighbors\nTopologies.nsendelems\nTopologies.nghostelems\nTopologies.localelemindex\nTopologies.face_node_index\nTopologies.ghost_faces\nTopologies.vertex_node_index\nTopologies.local_vertices\nTopologies.ghost_vertices\nTopologies.neighbors","category":"page"},{"location":"api/#ClimaCore.Topologies.AbstractTopology","page":"API","title":"ClimaCore.Topologies.AbstractTopology","text":"AbstractTopology\n\nSubtypes of AbstractHorizontalTopology define connectiveness of a mesh in the horizontal domain.\n\nInterfaces\n\nnelems\ndomain(topology::AbstractTopology)\nmesh\nnlocalelems\nnneighbors\nnsendelems\nnghostelems\nlocalelemindex\nvertex_coordinates\nopposing_face\nface_node_index\ninterior_faces\nghost_faces\nvertex_node_index\nlocal_neighboring_elements\nghost_neighboring_elements\nlocal_vertices\nghost_vertices\nneighbors\nboundary_tags\nboundary_tag\nboundary_faces\n\n\n\n\n\n","category":"type"},{"location":"api/#ClimaCore.Topologies.IntervalTopology","page":"API","title":"ClimaCore.Topologies.IntervalTopology","text":"IntervalTopology([context::SingletonCommsContext,] mesh::IntervalMesh)\n\nA sequential topology on an Meshes.IntervalMesh.\n\n\n\n\n\n","category":"type"},{"location":"api/#ClimaCore.Topologies.Topology2D","page":"API","title":"ClimaCore.Topologies.Topology2D","text":"Topology2D(mesh::AbstractMesh2D, elemorder=Mesh.elements(mesh))\n\nThis is a distributed topology for 2D meshes. elemorder is a vector or other linear ordering of the Mesh.elements(mesh). elempid is a sorted vector of the same length as elemorder, each element of which contains the pid of the owning process.\n\nInternally, we can refer to elements in several different ways:\n\nelem: an element of the mesh. Often a CartesianIndex object.\ngidx: \"global index\": an enumeration of all elements:\nelemorder[gidx] == elem\norderindex[elem] == gidx\nlidx: \"local index\": an enumeration of local elements.\nlocal_elem_gidx[lidx] == gidx\nsidx: \"send index\": an index into the send buffer of a local element. A single local element may have multiple sidxs if it needs to be send to multiple processes.\nsend_elem_lidx[sidx] == lidx\nridx: \"receive index\": an index into the receive buffer of a ghost element.\nrecv_elem_gidx[ridx] == gidx\n\n\n\n\n\n","category":"type"},{"location":"api/#ClimaCore.Topologies.spacefillingcurve","page":"API","title":"ClimaCore.Topologies.spacefillingcurve","text":"spacefillingcurve(mesh::Meshes.AbstractCubedSphere)\n\nGenerate element ordering, elemorder, based on a space filling curve for a CubedSphere mesh.\n\n\n\n\n\nspacefillingcurve(mesh::Meshes.RectilinearMesh)\n\nGenerate element ordering, elemorder, based on a space filling curve for a Rectilinear mesh.\n\n\n\n\n\n","category":"function"},{"location":"api/#ClimaCore.Topologies.nelems","page":"API","title":"ClimaCore.Topologies.nelems","text":"nelems(topology)\n\nThe total number of elements in topology.\n\n\n\n\n\n","category":"function"},{"location":"api/#ClimaCore.Topologies.nneighbors","page":"API","title":"ClimaCore.Topologies.nneighbors","text":"nneighbors(topology)\n\nThe number of neighbors of this process in topology.\n\n\n\n\n\n","category":"function"},{"location":"api/#ClimaCore.Topologies.nsendelems","page":"API","title":"ClimaCore.Topologies.nsendelems","text":"nsendelems(topology)\n\nThe number of elements to send to neighbors in topology.\n\n\n\n\n\n","category":"function"},{"location":"api/#ClimaCore.Topologies.nghostelems","page":"API","title":"ClimaCore.Topologies.nghostelems","text":"nghostelems(topology)\n\nThe number of ghost elements in topology.\n\n\n\n\n\n","category":"function"},{"location":"api/#ClimaCore.Topologies.localelemindex","page":"API","title":"ClimaCore.Topologies.localelemindex","text":"localelemindex(topology, elem)\n\nThe local index for the specified element; useful for distributed topologies.\n\n\n\n\n\n","category":"function"},{"location":"api/#ClimaCore.Topologies.face_node_index","page":"API","title":"ClimaCore.Topologies.face_node_index","text":"i,j = face_node_index(face, Nq, q, reversed=false)\n\nThe node indices of the qth node on face face, where Nq is the number of face nodes in each direction.\n\n\n\n\n\n","category":"function"},{"location":"api/#ClimaCore.Topologies.ghost_faces","page":"API","title":"ClimaCore.Topologies.ghost_faces","text":"ghost_faces(topology::AbstractTopology)\n\nAn iterator over the ghost faces of topology. Each element of the iterator is a 5-tuple the form\n\n(elem1, face1, elem2, face2, reversed)\n\nwhere elemX, faceX are the element and face numbers, and reversed indicates whether they have opposing orientations.\n\n\n\n\n\n","category":"function"},{"location":"api/#ClimaCore.Topologies.vertex_node_index","page":"API","title":"ClimaCore.Topologies.vertex_node_index","text":"i,j = vertex_node_index(vertex_num, Nq)\n\nThe node indices of vertex_num, where Nq is the number of face nodes in each direction.\n\n\n\n\n\n","category":"function"},{"location":"api/#ClimaCore.Topologies.local_vertices","page":"API","title":"ClimaCore.Topologies.local_vertices","text":"local_vertices(topology)\n\nAn iterator over the interior vertices of topology. Each vertex is an iterator over (lidx, vert) pairs.\n\n\n\n\n\n","category":"function"},{"location":"api/#ClimaCore.Topologies.ghost_vertices","page":"API","title":"ClimaCore.Topologies.ghost_vertices","text":"ghost_vertices(topology)\n\nAn iterator over the ghost vertices of topology. Each vertex is an iterator over (isghost, lidx/ridx, vert) pairs.\n\n\n\n\n\n","category":"function"},{"location":"api/#ClimaCore.Topologies.neighbors","page":"API","title":"ClimaCore.Topologies.neighbors","text":"neighbors(topology)\n\nReturns an array of the PIDs of the neighbors of this process.\n\n\n\n\n\n","category":"function"},{"location":"api/#Interfaces-3","page":"API","title":"Interfaces","text":"","category":"section"},{"location":"api/","page":"API","title":"API","text":"Topologies.mesh\nTopologies.nlocalelems\nTopologies.vertex_coordinates\nTopologies.opposing_face\nTopologies.interior_faces\nTopologies.boundary_tags\nTopologies.boundary_tag\nTopologies.boundary_faces\nTopologies.local_neighboring_elements\nTopologies.ghost_neighboring_elements","category":"page"},{"location":"api/#ClimaCore.Topologies.mesh","page":"API","title":"ClimaCore.Topologies.mesh","text":"mesh(topology)\n\nReturns the mesh underlying the topology\n\n\n\n\n\n","category":"function"},{"location":"api/#ClimaCore.Topologies.nlocalelems","page":"API","title":"ClimaCore.Topologies.nlocalelems","text":"nlocalelems(topology)\n\nThe number of local elements in topology.\n\n\n\n\n\n","category":"function"},{"location":"api/#ClimaCore.Topologies.vertex_coordinates","page":"API","title":"ClimaCore.Topologies.vertex_coordinates","text":"(c1,c2,c3,c4) = vertex_coordinates(topology, elem)\n\nThe coordinates of the 4 vertices of element elem.\n\n\n\n\n\n","category":"function"},{"location":"api/#ClimaCore.Topologies.opposing_face","page":"API","title":"ClimaCore.Topologies.opposing_face","text":"(opelem, opface, reversed) = opposing_face(topology, elem, face)\n\nThe opposing face of face number face of element elem in topology.\n\nopelem is the opposing element number, 0 for a boundary, negative for a ghost element\nopface is the opposite face number, or boundary face number if a boundary\nreversed indicates whether the opposing face has the opposite orientation.\n\n\n\n\n\n","category":"function"},{"location":"api/#ClimaCore.Topologies.interior_faces","page":"API","title":"ClimaCore.Topologies.interior_faces","text":"interior_faces(topology::AbstractTopology)\n\nAn iterator over the interior faces of topology. Each element of the iterator is a 5-tuple the form\n\n(elem1, face1, elem2, face2, reversed)\n\nwhere elemX, faceX are the element and face numbers, and reversed indicates whether they have opposing orientations.\n\n\n\n\n\n","category":"function"},{"location":"api/#ClimaCore.Topologies.boundary_tags","page":"API","title":"ClimaCore.Topologies.boundary_tags","text":"boundary_tags(topology)\n\nA Tuple or NamedTuple of the boundary tags of the topology. A boundary tag is an integer that uniquely identifies a boundary.\n\n\n\n\n\n","category":"function"},{"location":"api/#ClimaCore.Topologies.boundary_tag","page":"API","title":"ClimaCore.Topologies.boundary_tag","text":"boundary_tag(topology, name::Symbol)\n\nThe boundary tag of the topology for boundary name name. A boundary tag is an integer that uniquely identifies a boundary.\n\n\n\n\n\n","category":"function"},{"location":"api/#ClimaCore.Topologies.boundary_faces","page":"API","title":"ClimaCore.Topologies.boundary_faces","text":"boundary_faces(topology, boundarytag)\n\nAn iterator over the faces of topology which face the boundary with tag boundarytag. Each element of the iterator is an (elem, face) pair.\n\n\n\n\n\n","category":"function"},{"location":"api/#ClimaCore.Topologies.local_neighboring_elements","page":"API","title":"ClimaCore.Topologies.local_neighboring_elements","text":"local_neighboring_elements(topology::AbstractTopology, lidx::Integer)\n\nAn iterator of the local element indices (lidx) of the local elements which are neighbors of the local element lidx in topology (excluding lidx itself).\n\n\n\n\n\n","category":"function"},{"location":"api/#ClimaCore.Topologies.ghost_neighboring_elements","page":"API","title":"ClimaCore.Topologies.ghost_neighboring_elements","text":"ghost_neighboring_elements(topology::AbstractTopology, ridx::Integer)\n\nAn iterator of the receive buffer indices (ridx) of the ghost elements which are neighbors  of the local element lidx in topology.\n\n\n\n\n\n","category":"function"},{"location":"api/#Spaces","page":"API","title":"Spaces","text":"","category":"section"},{"location":"api/","page":"API","title":"API","text":"A Space represents a discretized function space over some domain. Currently two main discretizations are supported: Spectral Element Discretization (both Continuous Galerkin and Discontinuous Galerkin types) and a staggered Finite Difference Discretization. Combination of these two in the horizontal/vertical directions, respectively, is what we call a hybrid space.","category":"page"},{"location":"api/","page":"API","title":"API","text":"Sketch of a 2DX hybrid discretization:","category":"page"},{"location":"api/","page":"API","title":"API","text":"(Image: 3D hybrid discretization in a Cartesian domain)","category":"page"},{"location":"api/","page":"API","title":"API","text":"Spaces\nSpaces.Δz_data","category":"page"},{"location":"api/#ClimaCore.Spaces","page":"API","title":"ClimaCore.Spaces","text":"Meshes\n\ndomain\ntopology\ncoordinates\nmetric terms (inverse partial derivatives)\nquadrature rules and weights\n\nReferences / notes\n\nceed\nQA\n\n\n\n\n\n","category":"module"},{"location":"api/#ClimaCore.Spaces.Δz_data","page":"API","title":"ClimaCore.Spaces.Δz_data","text":"Δz_data(space::AbstractSpace)\n\nA DataLayout containing the Δz on a given space space.\n\n\n\n\n\n","category":"function"},{"location":"api/#Finite-Difference-Spaces","page":"API","title":"Finite Difference Spaces","text":"","category":"section"},{"location":"api/","page":"API","title":"API","text":"ClimaCore.jl supports staggered Finite Difference discretizations. Finite Differences discretize an interval domain by approximating the function by a value at either the center of each element (also referred to as cell) (CenterFiniteDifferenceSpace), or the interfaces (faces in 3D, edges in 2D or points in 1D) between elements (FaceFiniteDifferenceSpace).","category":"page"},{"location":"api/","page":"API","title":"API","text":"Users should construct either the center or face space from the mesh, then construct the other space from the original one: this internally reuses the same data structures, and avoids allocating additional memory.","category":"page"},{"location":"api/#Internals","page":"API","title":"Internals","text":"","category":"section"},{"location":"api/","page":"API","title":"API","text":"Spaces.Δz_metric_component","category":"page"},{"location":"api/#ClimaCore.Spaces.Δz_metric_component","page":"API","title":"ClimaCore.Spaces.Δz_metric_component","text":"Δz_metric_component(::Type{<:Goemetry.AbstractPoint})\n\nThe index of the z-component of an abstract point in an AxisTensor.\n\n\n\n\n\n","category":"function"},{"location":"api/#Spectral-Element-Spaces","page":"API","title":"Spectral Element Spaces","text":"","category":"section"},{"location":"api/","page":"API","title":"API","text":"Spaces.SpectralElementSpace1D\nSpaces.SpectralElementSpace2D\nSpaces.SpectralElementSpaceSlab","category":"page"},{"location":"api/#ClimaCore.Spaces.SpectralElementSpace1D","page":"API","title":"ClimaCore.Spaces.SpectralElementSpace1D","text":"SpectralElementSpace1D(grid::SpectralElementGrid1D)\n\n\n\n\n\n","category":"type"},{"location":"api/#ClimaCore.Spaces.SpectralElementSpace2D","page":"API","title":"ClimaCore.Spaces.SpectralElementSpace2D","text":"SpectralElementSpace2D(grid::SpectralElementGrid1D)\n\n\n\n\n\n","category":"type"},{"location":"api/#ClimaCore.Spaces.SpectralElementSpaceSlab","page":"API","title":"ClimaCore.Spaces.SpectralElementSpaceSlab","text":"SpectralElementSpaceSlab <: AbstractSpace\n\nA view into a SpectralElementSpace2D for a single slab.\n\n\n\n\n\n","category":"type"},{"location":"api/","page":"API","title":"API","text":"Spaces.node_horizontal_length_scale","category":"page"},{"location":"api/#ClimaCore.Spaces.node_horizontal_length_scale","page":"API","title":"ClimaCore.Spaces.node_horizontal_length_scale","text":"Spaces.node_horizontal_length_scale(space::AbstractSpectralElementSpace)\n\nThe approximate length scale of the distance between nodes. This is defined as the length scale of the mesh (see Meshes.element_horizontal_length_scale), divided by the number of unique quadrature points along each dimension.\n\n\n\n\n\n","category":"function"},{"location":"api/#Quadratures","page":"API","title":"Quadratures","text":"","category":"section"},{"location":"api/","page":"API","title":"API","text":"Quadratures.QuadratureStyle\nQuadratures.GLL\nQuadratures.GL\nQuadratures.Uniform\nQuadratures.degrees_of_freedom\nQuadratures.polynomial_degree\nQuadratures.quadrature_points\nQuadratures.barycentric_weights\nQuadratures.interpolation_matrix\nQuadratures.differentiation_matrix\nQuadratures.orthonormal_poly","category":"page"},{"location":"api/#ClimaCore.Quadratures.QuadratureStyle","page":"API","title":"ClimaCore.Quadratures.QuadratureStyle","text":"QuadratureStyle\n\nQuadrature style supertype. See sub-types:\n\nGLL\nGL\nUniform\n\n\n\n\n\n","category":"type"},{"location":"api/#ClimaCore.Quadratures.GLL","page":"API","title":"ClimaCore.Quadratures.GLL","text":"GLL{Nq}()\n\nGauss-Legendre-Lobatto quadrature using Nq quadrature points.\n\n\n\n\n\n","category":"type"},{"location":"api/#ClimaCore.Quadratures.GL","page":"API","title":"ClimaCore.Quadratures.GL","text":"GL{Nq}()\n\nGauss-Legendre quadrature using Nq quadrature points.\n\n\n\n\n\n","category":"type"},{"location":"api/#ClimaCore.Quadratures.Uniform","page":"API","title":"ClimaCore.Quadratures.Uniform","text":"Uniform{Nq}()\n\nUniformly-spaced quadrature.\n\n\n\n\n\n","category":"type"},{"location":"api/#ClimaCore.Quadratures.degrees_of_freedom","page":"API","title":"ClimaCore.Quadratures.degrees_of_freedom","text":"degrees_of_freedom(QuadratureStyle) -> Int\n\nReturns the degreesoffreedom of the QuadratureStyle concrete type\n\n\n\n\n\n","category":"function"},{"location":"api/#ClimaCore.Quadratures.polynomial_degree","page":"API","title":"ClimaCore.Quadratures.polynomial_degree","text":"polynomial_degree(QuadratureStyle) -> Int\n\nReturns the polynomial degree of the QuadratureStyle concrete type\n\n\n\n\n\n","category":"function"},{"location":"api/#ClimaCore.Quadratures.quadrature_points","page":"API","title":"ClimaCore.Quadratures.quadrature_points","text":"points, weights = quadrature_points(::Type{FT}, quadrature_style)\n\nThe points and weights of the quadrature rule in floating point type FT.\n\n\n\n\n\n","category":"function"},{"location":"api/#ClimaCore.Quadratures.barycentric_weights","page":"API","title":"ClimaCore.Quadratures.barycentric_weights","text":"barycentric_weights(x::SVector{Nq}) where {Nq}\n\nThe barycentric weights associated with the array of point locations x:\n\nw_j = frac1prod_k ne j (x_i - x_j)\n\nSee [11], equation 3.2.\n\n\n\n\n\n","category":"function"},{"location":"api/#ClimaCore.Quadratures.interpolation_matrix","page":"API","title":"ClimaCore.Quadratures.interpolation_matrix","text":"interpolation_matrix(x::SVector, r::SVector{Nq})\n\nThe matrix which interpolates the Lagrange polynomial of degree Nq-1 through the points r, to points x. The matrix coefficients are computed using the Barycentric formula of [11], section 4:\n\nI_ij = begincases\n1  textif  x_i = r_j \n0  textif  x_i = r_k text for  k ne j \nfracdisplaystyle fracw_jx_i - r_jdisplaystyle sum_k fracw_kx_i - r_k  textotherwise\nendcases\n\nwhere w_j are the barycentric weights, see barycentric_weights.\n\n\n\n\n\n","category":"function"},{"location":"api/#ClimaCore.Quadratures.differentiation_matrix","page":"API","title":"ClimaCore.Quadratures.differentiation_matrix","text":"differentiation_matrix(r::SVector{Nq, T}) where {Nq, T}\n\nThe spectral differentiation matrix for the Lagrange polynomial of degree Nq-1 interpolating at points r.\n\nThe matrix coefficients are computed using the [11], section 9.3:\n\nD_ij = begincases\n    displaystyle\n    fracw_jw_i (x_i - x_j) text if  i ne j \n    -sum_k ne j D_kj text if  i = j\nendcases\n\nwhere w_j are the barycentric weights, see barycentric_weights.\n\n\n\n\n\ndifferentiation_matrix(FT, quadstyle::QuadratureStyle)\n\nThe spectral differentiation matrix at the quadrature points of quadstyle, using floating point types FT.\n\n\n\n\n\n","category":"function"},{"location":"api/#ClimaCore.Quadratures.orthonormal_poly","page":"API","title":"ClimaCore.Quadratures.orthonormal_poly","text":"V = orthonormal_poly(points, quad)\n\nV_{ij} contains the j-1th Legendre polynomial evaluated at points[i]. i.e. it is the mapping from the modal to the nodal representation.\n\n\n\n\n\n","category":"function"},{"location":"api/#Internals-2","page":"API","title":"Internals","text":"","category":"section"},{"location":"api/","page":"API","title":"API","text":"Topologies.dss_transform\nTopologies.dss_transform!\nTopologies.dss_untransform!\nTopologies.dss_untransform\nTopologies.dss_local_vertices!\nTopologies.dss_local!\nTopologies.dss_local_ghost!\nTopologies.dss_ghost!\nTopologies.create_dss_buffer\nTopologies.fill_send_buffer!\nTopologies.DSSBuffer\nTopologies.load_from_recv_buffer!\nTopologies.dss!\nSpaces.weighted_dss_start!\nSpaces.weighted_dss_internal!\nSpaces.weighted_dss_ghost!\nSpaces.weighted_dss!\nSpaces.unique_nodes","category":"page"},{"location":"api/#ClimaCore.Topologies.dss_transform","page":"API","title":"ClimaCore.Topologies.dss_transform","text":"dss_transform(arg, local_geometry, weight, I...)\n\nTransfrom arg[I...] to a basis for direct stiffness summation (DSS). Transformations only apply to vector quantities.\n\nlocal_geometry[I...] is the relevant LocalGeometry object. If it is nothing, then no transformation is performed\nweight[I...] is the relevant DSS weights. If weight is nothing, then the result is simply summation.\n\nSee ClimaCore.Spaces.weighted_dss!.\n\n\n\n\n\n","category":"function"},{"location":"api/#ClimaCore.Topologies.dss_transform!","page":"API","title":"ClimaCore.Topologies.dss_transform!","text":"function dss_transform!(\n    device::ClimaComms.AbstractDevice,\n    dss_buffer::DSSBuffer,\n    data::Union{DataLayouts.IJFH, DataLayouts.VIJFH},\n    local_geometry::Union{DataLayouts.IJFH, DataLayouts.VIJFH},\n    weight::DataLayouts.IJFH,\n    perimeter::AbstractPerimeter,\n    localelems::Vector{Int},\n)\n\nTransforms vectors from Covariant axes to physical (local axis), weights the data at perimeter nodes,  and stores result in the perimeter_data array. This function calls the appropriate version of  dss_transform! based on the data layout of the input arguments.\n\nArguments:\n\ndss_buffer: DSSBuffer generated by create_dss_buffer function for field data\ndata: field data\nlocal_geometry: local metric information defined at each node\nweight: local dss weights for horizontal space\nperimeter: perimeter iterator\nlocalelems: list of local elements to perform transformation operations on\n\nPart of ClimaCore.Spaces.weighted_dss!.\n\n\n\n\n\nfunction dss_transform!(\n    ::ClimaComms.AbstractCPUDevice,\n    perimeter_data::DataLayouts.VIFH,\n    data::Union{DataLayouts.IJFH, DataLayouts.VIJFH},\n    ∂ξ∂x::Union{DataLayouts.IJFH, DataLayouts.VIJFH},\n    ∂x∂ξ::Union{DataLayouts.VIJFH, DataLayouts.IJFH},\n    weight::DataLayouts.IJFH,\n    perimeter::AbstractPerimeter,\n    scalarfidx::Vector{Int},\n    covariant12fidx::Vector{Int},\n    contravariant12fidx::Vector{Int},\n    localelems::Vector{Int},\n)\n\nTransforms vectors from Covariant axes to physical (local axis), weights the data at perimeter nodes, and stores result in the perimeter_data array.\n\nArguments:\n\nperimeter_data: contains the perimeter field data, represented on the physical axis, corresponding to the full field data in data\ndata: field data\n∂ξ∂x: partial derivatives of the map from x to ξ: ∂ξ∂x[i,j] is ∂ξⁱ/∂xʲ\nweight: local dss weights for horizontal space\nperimeter: perimeter iterator\nscalarfidx: field index for scalar fields in the data layout\ncovariant12fidx: field index for Covariant12 vector fields in the data layout\nlocalelems: list of local elements to perform transformation operations on\n\nPart of ClimaCore.Spaces.weighted_dss!.\n\n\n\n\n\n","category":"function"},{"location":"api/#ClimaCore.Topologies.dss_untransform!","page":"API","title":"ClimaCore.Topologies.dss_untransform!","text":"dss_untransform!(\n    device::ClimaComms.AbstractDevice,\n    dss_buffer::DSSBuffer,\n    data::Union{DataLayouts.IJFH, DataLayouts.VIJFH},\n    local_geometry::Union{DataLayouts.IJFH, DataLayouts.VIJFH},\n    perimeter::AbstractPerimeter,\n)\n\nTransforms the DSS'd local vectors back to Covariant12 vectors, and copies the DSS'd data from the perimeter_data to data. This function calls the appropriate version of dss_transform! function based on the data layout of the input arguments.\n\nArguments:\n\ndss_buffer: DSSBuffer generated by create_dss_buffer function for field data\ndata: field data\nlocal_geometry: local metric information defined at each node\nperimeter: perimeter iterator\nlocalelems: list of local elements to perform transformation operations on\n\nPart of ClimaCore.Spaces.weighted_dss!.\n\n\n\n\n\n","category":"function"},{"location":"api/#ClimaCore.Topologies.dss_untransform","page":"API","title":"ClimaCore.Topologies.dss_untransform","text":"dss_untransform(T, targ, local_geometry, I...)\n\nTransform targ[I...] back to a value of type T after performing direct stiffness summation (DSS).\n\nSee ClimaCore.Spaces.weighted_dss!.\n\n\n\n\n\n","category":"function"},{"location":"api/#ClimaCore.Topologies.dss_local_vertices!","page":"API","title":"ClimaCore.Topologies.dss_local_vertices!","text":"dss_local_vertices!(\n    perimeter_data::DataLayouts.VIFH,\n    perimeter::Perimeter2D,\n    topology::Topology2D,\n)\n\nApply dss to local vertices.\n\n\n\n\n\n","category":"function"},{"location":"api/#ClimaCore.Topologies.dss_local!","page":"API","title":"ClimaCore.Topologies.dss_local!","text":"function dss_local!(\n    ::ClimaComms.AbstractCPUDevice,\n    perimeter_data::DataLayouts.VIFH,\n    perimeter::AbstractPerimeter,\n    topology::AbstractTopology,\n)\n\nPerforms DSS on local vertices and faces.\n\nPart of ClimaCore.Spaces.weighted_dss!.\n\n\n\n\n\n","category":"function"},{"location":"api/#ClimaCore.Topologies.dss_local_ghost!","page":"API","title":"ClimaCore.Topologies.dss_local_ghost!","text":"function dss_local_ghost!(\n    ::ClimaComms.AbstractCPUDevice,\n    perimeter_data::DataLayouts.VIFH,\n    perimeter::AbstractPerimeter,\n    topology::AbstractTopology,\n)\n\nComputes the \"local\" part of ghost vertex dss. (i.e. it computes the summation of all the shared local vertices of a unique ghost vertex and stores the value in each of the local vertex locations in  perimeter_data)\n\nPart of ClimaCore.Spaces.weighted_dss!.\n\n\n\n\n\n","category":"function"},{"location":"api/#ClimaCore.Topologies.dss_ghost!","page":"API","title":"ClimaCore.Topologies.dss_ghost!","text":"dss_ghost!(\n    device::ClimaComms.AbstractCPUDevice,\n    perimeter_data::DataLayouts.VIFH,\n    perimeter::AbstractPerimeter,\n    topology::AbstractTopology,\n)\n\nSets the value for all local vertices of each unique ghost vertex, in perimeter_data, to that of  the representative ghost vertex.\n\nPart of ClimaCore.Spaces.weighted_dss!.\n\n\n\n\n\n","category":"function"},{"location":"api/#ClimaCore.Topologies.create_dss_buffer","page":"API","title":"ClimaCore.Topologies.create_dss_buffer","text":"create_dss_buffer(\n    data::Union{DataLayouts.IJFH, DataLayouts.VIJFH},\n    hspace::AbstractSpectralElementSpace,\n)\n\nCreates a DSSBuffer for the field data corresponding to data\n\n\n\n\n\nSpaces.create_dss_buffer(field::Field)\n\nCreate a buffer for communicating neighbour information of field.\n\n\n\n\n\ncreate_dss_buffer(\n    data::Union{DataLayouts.IJFH{S}, DataLayouts.VIJFH{S}},\n    topology::Topology2D,\n    local_geometry = nothing,\n    local_weights = nothing,\n) where {S}\n\nCreates a DSSBuffer for the field data corresponding to data\n\n\n\n\n\n","category":"function"},{"location":"api/#ClimaCore.Topologies.fill_send_buffer!","page":"API","title":"ClimaCore.Topologies.fill_send_buffer!","text":"fill_send_buffer!(::ClimaComms.AbstractCPUDevice, dss_buffer::DSSBuffer; synchronize=true)\n\nLoads the send buffer from perimeter_data. For unique ghost vertices, only data from the representative vertices which store result of \"ghost local\" DSS are loaded.\n\nPart of ClimaCore.Spaces.weighted_dss!.\n\n\n\n\n\n","category":"function"},{"location":"api/#ClimaCore.Topologies.DSSBuffer","page":"API","title":"ClimaCore.Topologies.DSSBuffer","text":"DSSBuffer{G, D, A, B}\n\nFields\n\ngraph_context: ClimaComms graph context for communication\nperimeter_data: Perimeter DataLayout object: typically a VIFH{TT,Nv,Np,Nh}, where TT is the transformed type, Nv is the number of vertical levels, and Np is the length of the perimeter\n\nsend_data: send buffer AbstractVector{FT}\nrecv_data: recv buffer AbstractVector{FT}\nsend_buf_idx: indexing array for loading send buffer from perimeter_data\nrecv_buf_idx: indexing array for loading (and summing) data from recv buffer to perimeter_data\nscalarfidx: field id for all scalar fields stored in the data array\ncovariant12fidx: field id for all covariant12vector fields stored in the data array\ncontravariant12fidx: field id for all contravariant12vector fields stored in the data array\ninternal_elems: internal local elements (lidx)\nperimeter_elems: local elements (lidx) located on process boundary\n\n\n\n\n\n","category":"type"},{"location":"api/#ClimaCore.Topologies.load_from_recv_buffer!","page":"API","title":"ClimaCore.Topologies.load_from_recv_buffer!","text":"load_from_recv_buffer!(::ClimaComms.AbstractCPUDevice, dss_buffer::DSSBuffer)\n\nAdds data from the recv buffer to the corresponding location in perimeter_data. For ghost vertices, this data is added only to the representative vertices. The values are  then scattered to other local vertices corresponding to each unique ghost vertex in dss_local_ghost.\n\nPart of ClimaCore.Spaces.weighted_dss!.\n\n\n\n\n\n","category":"function"},{"location":"api/#ClimaCore.Topologies.dss!","page":"API","title":"ClimaCore.Topologies.dss!","text":"dss!(data, topology)\n\nComputed unweighted/pure DSS of data.\n\n\n\n\n\n","category":"function"},{"location":"api/#ClimaCore.Spaces.weighted_dss_start!","page":"API","title":"ClimaCore.Spaces.weighted_dss_start!","text":"weighted_dss_start!(\n    data::Union{\n        DataLayouts.IFH,\n        DataLayouts.VIFH,\n        DataLayouts.IJFH,\n        DataLayouts.VIJFH,\n    },\n    space::Union{\n        AbstractSpectralElementSpace,\n        ExtrudedFiniteDifferenceSpace,\n    },\n    dss_buffer::Union{DSSBuffer, Nothing},\n)\n\nIt comprises of the following steps:\n\n1). Apply Spaces.dss_transform! on perimeter elements. This weights and tranforms vector  fields to physical basis if needed. Scalar fields are weighted. The transformed and/or weighted  perimeter data is stored in perimeter_data.\n\n2). Apply Spaces.dss_local_ghost! This computes partial weighted DSS on ghost vertices, using only the information from local vertices.\n\n3). Spaces.fill_send_buffer!  Loads the send buffer from perimeter_data. For unique ghost vertices, only data from the representative ghost vertices which store result of \"ghost local\" DSS are loaded.\n\n4). Start DSS communication with neighboring processes\n\n\n\n\n\n","category":"function"},{"location":"api/#ClimaCore.Spaces.weighted_dss_internal!","page":"API","title":"ClimaCore.Spaces.weighted_dss_internal!","text":"weighted_dss_internal!(\n    data::Union{\n        DataLayouts.IFH,\n        DataLayouts.VIFH,\n        DataLayouts.IJFH,\n        DataLayouts.VIJFH,\n    },\n    space::Union{\n        AbstractSpectralElementSpace,\n        ExtrudedFiniteDifferenceSpace,\n    },\n    dss_buffer::DSSBuffer,\n)\n\n1). Apply Spaces.dss_transform! on interior elements. Local elements are split into interior  and perimeter elements to facilitate overlapping of communication with computation.\n\n2). Probe communication\n\n3). Spaces.dss_local! computes the weighted DSS on local vertices and faces.\n\n\n\n\n\n","category":"function"},{"location":"api/#ClimaCore.Spaces.weighted_dss_ghost!","page":"API","title":"ClimaCore.Spaces.weighted_dss_ghost!","text":"weighted_dss_ghost!(\n    data::Union{\n        DataLayouts.IFH,\n        DataLayouts.VIFH,\n        DataLayouts.IJFH,\n        DataLayouts.VIJFH,\n    },\n    space::Union{\n        AbstractSpectralElementSpace,\n        ExtrudedFiniteDifferenceSpace,\n    },\n    dss_buffer::Union{DSSBuffer, Nothing},\n)\n\n1). Finish communications.\n\n2). Call Spaces.load_from_recv_buffer! After the communication is complete, this adds data from the recv buffer to the corresponding location in  perimeter_data. For ghost vertices, this data is added only to the representative vertices. The values are  then scattered to other local vertices corresponding to each unique ghost vertex in dss_local_ghost.\n\n3). Call Spaces.dss_untransform! on all local elements. This transforms the DSS'd local vectors back to Covariant12 vectors, and copies the DSS'd data from the perimeter_data to data.\n\n\n\n\n\n","category":"function"},{"location":"api/#ClimaCore.Spaces.weighted_dss!","page":"API","title":"ClimaCore.Spaces.weighted_dss!","text":"function weighted_dss!(\n    data::Union{\n        DataLayouts.IFH,\n        DataLayouts.VIFH,\n        DataLayouts.IJFH,\n        DataLayouts.VIJFH,\n    },\n    space::Union{\n        AbstractSpectralElementSpace,\n        ExtrudedFiniteDifferenceSpace,\n    },\n    dss_buffer::Union{DSSBuffer, Nothing},\n)\n\nComputes weighted dss of data. \n\nIt comprises of the following steps:\n\n1). Spaces.weighted_dss_start!\n\n2). Spaces.weighted_dss_internal!\n\n3). Spaces.weighted_dss_ghost!\n\n\n\n\n\nSpaces.weighted_dss!(f::Field[, ghost_buffer = Spaces.create_dss_buffer(field)])\n\nApply weighted direct stiffness summation (DSS) to f. This operates in-place (i.e. it modifies the f). ghost_buffer contains the necessary information for communication in a distributed setting, see Spaces.create_dss_buffer.\n\nThis is a projection operation from the piecewise polynomial space mathcalV_0 to the continuous space mathcalV_1 = mathcalV_0 cap mathcalC_0, defined as the field theta in mathcalV_1 such that for all phi in mathcalV_1\n\nint_Omega phi theta dOmega = int_Omega phi f dOmega\n\nIn matrix form, we define bar theta to be the unique global node representation, and Q to be the \"scatter\" operator which maps to the redundant node representation theta\n\ntheta = Q bar theta\n\nThen the problem can be written as\n\n(Q barphi)^top W J Q bartheta = (Q barphi)^top W J f\n\nwhich reduces to\n\ntheta = Q bartheta = Q (Q^top W J Q)^-1 Q^top W J f\n\n\n\n\n\nSpaces.weighted_dss!(field1 => ghost_buffer1, field2 => ghost_buffer2, ...)\n\nCall Spaces.weighted_dss! on multiple fields at once, overlapping communication as much as possible.\n\n\n\n\n\n","category":"function"},{"location":"api/#ClimaCore.Spaces.unique_nodes","page":"API","title":"ClimaCore.Spaces.unique_nodes","text":"unique_nodes(space::SpectralElementSpace2D)\n\nAn iterator over the unique nodes of space. Each node is represented by the first ((i,j), e) triple.\n\nThis function is experimental, and may change in future.\n\n\n\n\n\n","category":"function"},{"location":"api/#Utilities-2","page":"API","title":"Utilities","text":"","category":"section"},{"location":"api/","page":"API","title":"API","text":"Spaces.area\nSpaces.local_area","category":"page"},{"location":"api/#ClimaCore.Spaces.area","page":"API","title":"ClimaCore.Spaces.area","text":"Spaces.area(space::Spaces.AbstractSpace)\n\nThe length/area/volume of space. This is computed as the sum of the quadrature weights W_i multiplied by the Jacobian determinants J_i:\n\nsum_i W_i J_i approx int_Omega  d Omega\n\nIf space is distributed, this uses a ClimaComms.allreduce operation.\n\n\n\n\n\n","category":"function"},{"location":"api/#ClimaCore.Spaces.local_area","page":"API","title":"ClimaCore.Spaces.local_area","text":"Spaces.local_area(space::Spaces.AbstractSpace)\n\nThe length/area/volume of space local to the current context. See Spaces.area\n\n\n\n\n\n","category":"function"},{"location":"api/#RecursiveApply","page":"API","title":"RecursiveApply","text":"","category":"section"},{"location":"api/","page":"API","title":"API","text":"RecursiveApply","category":"page"},{"location":"api/#ClimaCore.RecursiveApply","page":"API","title":"ClimaCore.RecursiveApply","text":"RecursiveApply\n\nThis module contains operators to recurse over nested Tuples or NamedTuples.\n\nTo extend to another type T, define RecursiveApply.rmap(fn, args::T...)\n\n\n\n\n\n","category":"module"},{"location":"api/#Fields","page":"API","title":"Fields","text":"","category":"section"},{"location":"api/","page":"API","title":"API","text":"Fields.Field\nFields.coordinate_field\nFields.local_geometry_field\nBase.zeros(::Spaces.AbstractSpace)\nBase.ones(::Spaces.AbstractSpace)\nBase.sum(::Fields.Field)\nFields.local_sum\nFields.Statistics.mean(::Fields.Field)\nFields.LinearAlgebra.norm(::Fields.Field)\nFields.set!\nFields.ColumnIndex\nFields.bycolumn\nFields.Δz_field","category":"page"},{"location":"api/#ClimaCore.Fields.Field","page":"API","title":"ClimaCore.Fields.Field","text":"Field(values, space)\n\nA set of values defined at each point of a space.\n\n\n\n\n\n","category":"type"},{"location":"api/#ClimaCore.Fields.coordinate_field","page":"API","title":"ClimaCore.Fields.coordinate_field","text":"coordinate_field(space::AbstractSpace)\n\nConstruct a Field of the coordinates of the space.\n\n\n\n\n\n","category":"function"},{"location":"api/#ClimaCore.Fields.local_geometry_field","page":"API","title":"ClimaCore.Fields.local_geometry_field","text":"local_geometry_field(space::AbstractSpace)\n\nConstruct a Field of the LocalGeometry of the space.\n\n\n\n\n\n","category":"function"},{"location":"api/#Base.zeros-Tuple{ClimaCore.Spaces.AbstractSpace}","page":"API","title":"Base.zeros","text":"zeros(space::AbstractSpace)\n\nConstruct a field on space that is zero everywhere.\n\n\n\n\n\n","category":"method"},{"location":"api/#Base.ones-Tuple{ClimaCore.Spaces.AbstractSpace}","page":"API","title":"Base.ones","text":"ones(space::AbstractSpace)\n\nConstruct a field on space that is one everywhere.\n\n\n\n\n\n","category":"method"},{"location":"api/#Base.sum-Tuple{ClimaCore.Fields.Field}","page":"API","title":"Base.sum","text":"sum([f=identity,] v::Field)\n\nApproximate integration of v or f.(v) over the domain. In an AbstractSpectralElementSpace, an integral over the entire space is computed by summation over the elements of the integrand multiplied by the Jacobian determinants and the quadrature weights at each node within an element. Hence, sum is computed by summation of the field values multiplied by the Jacobian determinants and quadrature weights:\n\nsum_i f(v_i) W_i J_i\napprox\nint_Omega f(v)  d Omega\n\nwhere v_i is the value at each node, and f is the identity function if not specified.\n\nIf v is a distributed field, this uses a ClimaComms.allreduce operation.\n\n\n\n\n\n","category":"method"},{"location":"api/#ClimaCore.Fields.local_sum","page":"API","title":"ClimaCore.Fields.local_sum","text":"Fields.local_sum(v::Field)\n\nCompute the approximate integral of v over the domain local to the current context.\n\nSee sum for the integral over the full domain.\n\n\n\n\n\n","category":"function"},{"location":"api/#Statistics.mean-Tuple{ClimaCore.Fields.Field}","page":"API","title":"Statistics.mean","text":"mean([f=identity, ]v::Field)\n\nThe mean value of field or f.(field) over the domain, weighted by area. Similar to sum, in an AbstractSpectralElementSpace, this is computed by summation of the field values multiplied by the Jacobian determinants and quadrature weights:\n\nfracsum_i f(v_i) W_i J_isum_i W_i J_i\napprox\nfracint_Omega f(v)  d Omegaint_Omega  d Omega\n\nwhere v_i is the Field value at each node, and f is the identity function if not specified.\n\nIf v is a distributed field, this uses a ClimaComms.allreduce operation.\n\n\n\n\n\n","category":"method"},{"location":"api/#LinearAlgebra.norm-Tuple{ClimaCore.Fields.Field}","page":"API","title":"LinearAlgebra.norm","text":"norm(v::Field, p=2; normalize=true)\n\nThe approximate L^p norm of v, where L^p represents the space of measurable functions for which the p-th power of the absolute value is Lebesgue integrable, that is:\n\n v _p = left( int_Omega v^p d Omega right)^1p\n\nwhere v is defined to be the absolute value if v is a scalar-valued Field, or the 2-norm if it is a vector-valued Field or composite Field (see LinearAlgebra.norm). Similar to sum and mean, in an AbstractSpectralElementSpace, this is computed by summation of the field values multiplied by the Jacobian determinants and quadrature weights. If normalize=true (the default), then internally the discrete norm is divided by the sum of the Jacobian determinants and quadrature weights:\n\nleft(fracsum_i v_i^p W_i J_isum_i W_i J_iright)^1p\napprox\nleft(fracint_Omega v^p  d Omegaint_Omega  d Omegaright)^1p\n\nIf p=Inf, then the norm is the maximum of the absolute values\n\nmax_i v_i approx sup_Omega v\n\nConsequently all norms should have the same units for all p (being the same as calling norm on a single value).\n\nIf normalize=false, then the denominator term is omitted, and so the result will be the norm as described above multiplied by the length/area/volume of Omega to the power of 1p.\n\n\n\n\n\n","category":"method"},{"location":"api/#ClimaCore.Fields.set!","page":"API","title":"ClimaCore.Fields.set!","text":"set!(f::Function, field::Field, args = ())\n\nApply function f to populate values in field field. f must have a function signature with signature f(::LocalGeometry[, args...]). Additional arguments may be passed to f with args.\n\n\n\n\n\n","category":"function"},{"location":"api/#ClimaCore.Grids.ColumnIndex","page":"API","title":"ClimaCore.Grids.ColumnIndex","text":"ColumnIndex(ij,h)\n\nAn index into a column of a field. This can be used as an argument to getindex of a Field, to return a field on that column.\n\nExample\n\ncolidx = ColumnIndex((1,1),1)\nfield[colidx]\n\n\n\n\n\n","category":"type"},{"location":"api/#ClimaCore.Fields.bycolumn","page":"API","title":"ClimaCore.Fields.bycolumn","text":"Fields.bycolumn(fn, space)\n\nCall fn(colidx) to every ColumnIndex colidx of space. This can be used to apply multiple column-wise operations in a single pass, making use of multiple threads.\n\nnote: Note\nOn GPUs this will simply evaluate f once with colidx=: (i.e. it doesn't perform evaluation by columns). This may change in future.\n\nExample\n\n∇ = GradientF2C()\ndiv = DivergenceC2F()\n\nbycolumn(axes(f)) do colidx\n    @. ∇f[colidx] = ∇(f[colidx])\n    @. df[colidx] = div(∇f[colidx])\nend\n\n\n\n\n\n","category":"function"},{"location":"api/#ClimaCore.Fields.Δz_field","page":"API","title":"ClimaCore.Fields.Δz_field","text":"Δz_field(field::Field)\nΔz_field(space::AbstractSpace)\n\nA Field containing the Δz values on the same space as the given field.\n\n\n\n\n\n","category":"function"},{"location":"api/#Hypsography","page":"API","title":"Hypsography","text":"","category":"section"},{"location":"api/","page":"API","title":"API","text":"Hypsography.LinearAdaption\nHypsography.SLEVEAdaption\nHypsography.diffuse_surface_elevation!\nHypsography.ref_z_to_physical_z","category":"page"},{"location":"api/#ClimaCore.Hypsography.LinearAdaption","page":"API","title":"ClimaCore.Hypsography.LinearAdaption","text":"LinearAdaption(surface::Field)\n\nLocate the levels by linear interpolation between the surface field and the top of the domain, using the method of [12].\n\n\n\n\n\n","category":"type"},{"location":"api/#ClimaCore.Hypsography.SLEVEAdaption","page":"API","title":"ClimaCore.Hypsography.SLEVEAdaption","text":"SLEVEAdaption(surface::Field, ηₕ::FT, s::FT)\n\nLocate vertical levels using an exponential function between the surface field and the top of the domain, using the method of [13]. This method is modified such no warping is applied above some user defined parameter 0 ≤ ηₕ < 1.0, where the lower and upper bounds represent the domain bottom and top respectively. s governs the decay rate. If the decay-scale is poorly specified (i.e., s * zₜ is lower than the maximum surface elevation), a warning is thrown and s is adjusted such that it szₜ > maximum(z_surface).\n\n\n\n\n\n","category":"type"},{"location":"api/#ClimaCore.Hypsography.diffuse_surface_elevation!","page":"API","title":"ClimaCore.Hypsography.diffuse_surface_elevation!","text":"diffuse_surface_elevation!(f::Field; κ::T, iter::Int, dt::T)\n\nOption for 2nd order diffusive smoothing of generated terrain. Mutate (smooth) a given elevation profile f before assigning the surface elevation to the HypsographyAdaption type. A spectral second-order diffusion operator is applied with forward-Euler updates to generate profiles for each new iteration. Steps to generate smoothed terrain ( represented as a ClimaCore Field) are as follows:\n\nCompute discrete elevation profile f\nCompute diffusesurfaceelevation!(f, κ, iter). f is mutated.\nDefine Hypsography.LinearAdaption(f)\nDefine ExtrudedFiniteDifferenceSpace with new surface elevation.\n\nDefault diffusion parameters are appropriate for spherical arrangements. For zmax-zsfc == 𝒪(10^4), κ == 𝒪(10^8), dt == 𝒪(10⁻¹).\n\n\n\n\n\n","category":"function"},{"location":"api/#ClimaCore.Hypsography.ref_z_to_physical_z","page":"API","title":"ClimaCore.Hypsography.ref_z_to_physical_z","text":"ref_z_to_physical_z(adaption::HypsographyAdaption, z_ref::ZPoint, z_surface::ZPoint, z_top::ZPoint) :: ZPoint\n\nConvert reference zs to physical zs as prescribed by the given adaption.\n\nThis function has to be the inverse of physical_z_to_ref_z.\n\n\n\n\n\n","category":"function"},{"location":"api/#Limiters","page":"API","title":"Limiters","text":"","category":"section"},{"location":"api/","page":"API","title":"API","text":"The limiters supertype is","category":"page"},{"location":"api/","page":"API","title":"API","text":"Limiters.AbstractLimiter","category":"page"},{"location":"api/#ClimaCore.Limiters.AbstractLimiter","page":"API","title":"ClimaCore.Limiters.AbstractLimiter","text":"AbstractLimiter\n\nSupertype for all limiters.\n\nInterfaces\n\napply_limiter!\n\n\n\n\n\n","category":"type"},{"location":"api/","page":"API","title":"API","text":"This class of flux-limiters is applied only in the horizontal direction (on spectral advection operators).","category":"page"},{"location":"api/#Interfaces-4","page":"API","title":"Interfaces","text":"","category":"section"},{"location":"api/","page":"API","title":"API","text":"Limiters.QuasiMonotoneLimiter\nLimiters.compute_bounds!\nLimiters.apply_limiter!","category":"page"},{"location":"api/#ClimaCore.Limiters.QuasiMonotoneLimiter","page":"API","title":"ClimaCore.Limiters.QuasiMonotoneLimiter","text":"QuasiMonotoneLimiter\n\nThis limiter is inspired by the one presented in Guba et al [14]. In the reference paper, it is denoted by OP1, and is outlined in eqs. (37)-(40). Quasimonotone here is meant to be monotone with respect to the spectral element nodal values. This limiter involves solving a constrained optimization problem (a weighted least square problem up to a fixed tolerance) that is completely local to each element.\n\nAs in HOMME, the implementation idea here is the following: we need to find a grid field which is closest to the initial field (in terms of weighted sum), but satisfies the min/max constraints. So, first we find values that do not satisfy constraints and bring these values to a closest constraint. This way we introduce some change in the tracer mass, which we then redistribute so that the l2 error is smallest. This redistribution might violate constraints; thus, we do a few iterations (until abs(Δtracer_mass) <= rtol * tracer_mass).\n\nρq: tracer density Field, where q denotes tracer concentration per unit mass. This can be a scalar field, or a struct-valued field.\nρ: fluid density Field (scalar).\n\nConstructor\n\nlimiter = QuasiMonotoneLimiter(ρq::Field; rtol = eps(eltype(parent(ρq))))\n\nCreates a limiter instance for the field ρq with relative tolerance rtol.\n\nUsage\n\nCall compute_bounds! on the input fields:\n\ncompute_bounds!(limiter, ρq, ρ)\n\nThen call apply_limiter! on the output fields:\n\napply_limiter!(ρq, ρ, limiter)\n\n\n\n\n\n","category":"type"},{"location":"api/#ClimaCore.Limiters.compute_bounds!","page":"API","title":"ClimaCore.Limiters.compute_bounds!","text":"compute_bounds!(limiter::QuasiMonotoneLimiter, ρq::Field, ρ::Field)\n\nCompute the desired bounds for the tracer concentration per unit mass q, based on the tracer density, ρq, and density, ρ, fields.\n\nThis is computed by\n\ncompute_element_bounds!\nstarts the ghost exchange (if distributed)\ncompute_neighbor_bounds_local!\ncompletes the ghost exchange (if distributed)\ncompute_neighbor_bounds_ghost! (if distributed)\n\n\n\n\n\n","category":"function"},{"location":"api/#ClimaCore.Limiters.apply_limiter!","page":"API","title":"ClimaCore.Limiters.apply_limiter!","text":"apply_limiter!(ρq, ρ, limiter::QuasiMonotoneLimiter)\n\nApply the limiter on the tracer density  ρq, using the computed desired bounds on the concentration q and density ρ as an optimal weight. This iterates over each element, calling apply_limit_slab!. If the limiter fails to converge for any element, a warning is issued.\n\n\n\n\n\n","category":"function"},{"location":"api/#Internals-3","page":"API","title":"Internals","text":"","category":"section"},{"location":"api/","page":"API","title":"API","text":"Limiters.compute_element_bounds!\nLimiters.compute_neighbor_bounds_local!\nLimiters.compute_neighbor_bounds_ghost!\nLimiters.apply_limit_slab!","category":"page"},{"location":"api/#ClimaCore.Limiters.compute_element_bounds!","page":"API","title":"ClimaCore.Limiters.compute_element_bounds!","text":"compute_element_bounds!(limiter::QuasiMonotoneLimiter, ρq, ρ)\n\nGiven two fields ρq and ρ, computes the min and max of q in each element, storing it in limiter.q_bounds.\n\nPart of compute_bounds!.\n\n\n\n\n\n","category":"function"},{"location":"api/#ClimaCore.Limiters.compute_neighbor_bounds_local!","page":"API","title":"ClimaCore.Limiters.compute_neighbor_bounds_local!","text":"compute_neighbor_bounds_local!(limiter::QuasiMonotoneLimiter, topology)\n\nUpdate the field limiter.q_bounds_nbr based on limiter.q_bounds in the local neighbors.\n\nPart of compute_bounds!.\n\n\n\n\n\n","category":"function"},{"location":"api/#ClimaCore.Limiters.compute_neighbor_bounds_ghost!","page":"API","title":"ClimaCore.Limiters.compute_neighbor_bounds_ghost!","text":"compute_neighbor_bounds_ghost!(limiter::QuasiMonotoneLimiter, topology)\n\nUpdate the field limiter.q_bounds_nbr based on limiter.q_bounds in the ghost neighbors. This should be called after the ghost exchange has completed.\n\nPart of compute_bounds!.\n\n\n\n\n\n","category":"function"},{"location":"api/#ClimaCore.Limiters.apply_limit_slab!","page":"API","title":"ClimaCore.Limiters.apply_limit_slab!","text":"apply_limit_slab!(slab_ρq, slab_ρ, slab_WJ, slab_q_bounds, rtol)\n\nApply the computed bounds of the tracer concentration (slab_q_bounds) in the limiter to slab_ρq, given the total mass slab_ρ, metric terms slab_WJ, and relative tolerance rtol. Return whether the tolerance condition could be satisfied.\n\n\n\n\n\n","category":"function"},{"location":"api/#InputOutput","page":"API","title":"InputOutput","text":"","category":"section"},{"location":"api/#Writers","page":"API","title":"Writers","text":"","category":"section"},{"location":"api/","page":"API","title":"API","text":"InputOutput.HDF5Writer\nInputOutput.write!","category":"page"},{"location":"api/#ClimaCore.InputOutput.HDF5Writer","page":"API","title":"ClimaCore.InputOutput.HDF5Writer","text":"HDF5Writer(filename::AbstractString[, context::ClimaComms.AbstractCommsContext];\n           overwrite::Bool = true)\n\nAn AbstractWriter for writing to HDF5-formatted files using the ClimaCore storage conventions. An internal cache is used to avoid writing duplicate domains, meshes, topologies and spaces to the file. Use HDF5Reader to load the data from the file.\n\nThe optional context can be used for writing distributed fields: in this case, the MPICommsContext used passed as an argument: this must match the context used for distributing the Field.\n\nThe writer overwrites or appends to existing files depending on the value of the overwrite keyword argument. When overwrite is false, the writer appends to filename if the file already exists, otherwise it creates a new one.\n\nnote: Note\nThe default Julia HDF5 binaries are not built with MPI support. To use the distributed functionality, you will need to configure HDF5.jl with an MPI-enabled HDF5 library, see the HDF5.jl documentation.\n\nInterface\n\nwrite!\n\nUsage\n\nwriter = InputOutput.HDF5Writer(filename)\nInputOutput.write!(writer, Y, \"Y\")\nclose(writer)\n\n\n\n\n\n","category":"type"},{"location":"api/#ClimaCore.InputOutput.write!","page":"API","title":"ClimaCore.InputOutput.write!","text":"write!(writer::AbstractWriter, obj[, preferredname])\n\nWrite the object obj using writer. An optional preferredname can be provided, otherwise defaultname will be used to generate a name. The name of the object will be returned.\n\nA cache of domains, meshes, topologies and spaces is kept: if one of these objects has already been written, then the file will not be modified: instead the name under which the object was first written will be returned. Note that Fields and FieldVectors are not cached, and so can be written multiple times.\n\n\n\n\n\nwrite!(writer::HDF5Writer, name => value...)\n\nWrite one or more name => value pairs to writer.\n\n\n\n\n\nwrite!(filename::AbstractString, name => value...)\n\nWrite one or more name => value pairs to the HDF5 file filename.\n\n\n\n\n\n","category":"function"},{"location":"api/#Readers","page":"API","title":"Readers","text":"","category":"section"},{"location":"api/","page":"API","title":"API","text":"InputOutput.HDF5Reader\nInputOutput.read_domain\nInputOutput.read_mesh\nInputOutput.read_topology\nInputOutput.read_space\nInputOutput.read_field\nInputOutput.defaultname","category":"page"},{"location":"api/#ClimaCore.InputOutput.HDF5Reader","page":"API","title":"ClimaCore.InputOutput.HDF5Reader","text":"HDF5Reader(filename::AbstractString[, context::ClimaComms.AbstractCommsContext])\n\nAn AbstractReader for reading from HDF5 files created by HDF5Writer. The reader object contains an internal cache of domains, meshes, topologies and spaces that are read so that duplicate objects are not created.\n\nThe optional context can be used for reading distributed fields: in this case, the MPICommsContext used passed as an argument: resulting Fields will be distributed using this context. As with HDF5Writer, this requires a HDF5 library with MPI support.\n\nInterface\n\nread_domain\nread_mesh\nread_topology\nread_space\nread_field\n\nUsage\n\nreader = InputOutput.HDF5Reader(filename)\nY = read_field(reader, \"Y\")\nY.c |> propertynames\nY.f |> propertynames\nρ_field = read_field(reader, \"Y.c.ρ\")\nw_field = read_field(reader, \"Y.f.w\")\nclose(reader)\n\nTo explore the contents of the reader, use either\n\njulia> reader |> propertynames\n\ne.g, to explore the components of the space, \n\njulia> reader.space_cache\nDict{Any, Any} with 3 entries:\n  \"center_extruded_finite_difference_space\" => CenterExtrudedFiniteDifferenceSpace:…\n  \"horizontal_space\"                        => SpectralElementSpace2D:…\n  \"face_extruded_finite_difference_space\"   => FaceExtrudedFiniteDifferenceSpace:…\n\nOnce \"unpacked\" as shown above, ClimaCorePlots or ClimaCoreMakie can be used to visualise fields. ClimaCoreTempestRemap supports interpolation onto user-specified grids if necessary.\n\n\n\n\n\n","category":"type"},{"location":"api/#ClimaCore.InputOutput.read_domain","page":"API","title":"ClimaCore.InputOutput.read_domain","text":"read_domain(reader::AbstractReader, name)\n\nReads a domain named name from reader. Domain objects are cached in the reader to avoid creating duplicate objects.\n\n\n\n\n\n","category":"function"},{"location":"api/#ClimaCore.InputOutput.read_mesh","page":"API","title":"ClimaCore.InputOutput.read_mesh","text":"read_mesh(reader::AbstractReader, name)\n\nReads a mesh named name from reader, or from the reader cache if it has already been read.\n\n\n\n\n\n","category":"function"},{"location":"api/#ClimaCore.InputOutput.read_topology","page":"API","title":"ClimaCore.InputOutput.read_topology","text":"read_topology(reader::AbstractReader, name)\n\nReads a topology named name from reader, or from the reader cache if it has already been read.\n\n\n\n\n\n","category":"function"},{"location":"api/#ClimaCore.InputOutput.read_space","page":"API","title":"ClimaCore.InputOutput.read_space","text":"read_space(reader::AbstractReader, name)\n\nReads a space named name from reader, or from the reader cache if it has already been read.\n\n\n\n\n\n","category":"function"},{"location":"api/#ClimaCore.InputOutput.read_field","page":"API","title":"ClimaCore.InputOutput.read_field","text":"read_field(reader, name)\n\nReads a Field or FieldVector named name from reader. Fields are not cached, so that reading the same field multiple times will create multiple distinct objects.\n\n\n\n\n\n","category":"function"},{"location":"api/#ClimaCore.InputOutput.defaultname","page":"API","title":"ClimaCore.InputOutput.defaultname","text":"defaultname(obj)\n\nDefault name of object for InputOutput writers.\n\n\n\n\n\n","category":"function"},{"location":"api/#Remapping","page":"API","title":"Remapping","text":"","category":"section"},{"location":"api/","page":"API","title":"API","text":"Remapping.interpolate_array\nRemapping.interpolate","category":"page"},{"location":"api/#ClimaCore.Remapping.interpolate_array","page":"API","title":"ClimaCore.Remapping.interpolate_array","text":"interpolate_array(field, xpts, ypts)\ninterpolate_array(field, xpts, ypts, zpts)\n\nInterpolate a field to a regular array using pointwise interpolation.\n\nThis is primarily used for plotting and diagnostics.\n\nExamples\n\nlongpts = range(Geometry.LongPoint(-180.0), Geometry.LongPoint(180.0), length = 21)\nlatpts = range(Geometry.LatPoint(-80.0), Geometry.LatPoint(80.0), length = 21)\nzpts = range(Geometry.ZPoint(0.0), Geometry.ZPoint(1000.0), length = 21)\n\ninterpolate_array(field, longpts, latpts, zpts)\n\nnote: Note\nHypsography is not currently handled correctly.\n\n\n\n\n\n","category":"function"},{"location":"api/#ClimaCore.Remapping.interpolate","page":"API","title":"ClimaCore.Remapping.interpolate","text":"interpolate(remapper::Remapper, fields)    interpolate!(dest, remapper::Remapper, fields)\n\nInterpolate the given field(s) as prescribed by remapper.\n\nThe optimal number of fields passed is the buffer_length of the remapper. If more fields are passed, the remapper will batch work with size up to its buffer_length.\n\nThis call mutates the internal (private) state of the remapper.\n\nHorizontally, interpolation is performed with the barycentric formula in [11], equation (3.2). Vertical interpolation is linear except in the boundary elements where it is 0th order.\n\ninterpolate! writes the output to the given destiniation. dest is expected to be defined on the root process and to be nothing for the other processes.\n\nNote: interpolate allocates new arrays and has some internal type-instability, interpolate! is non-allocating and type-stable.\n\nWhen using interpolate!, the destination has to be the same array type as the device in use (e.g., CuArray for CUDA runs).\n\nExample\n\nGiven field1,field2, two Field defined on a cubed sphere.\n\nlongpts = range(-180.0, 180.0, 21)\nlatpts = range(-80.0, 80.0, 21)\nzpts = range(0.0, 1000.0, 21)\n\nhcoords = [Geometry.LatLongPoint(lat, long) for long in longpts, lat in latpts]\nzcoords = [Geometry.ZPoint(z) for z in zpts]\n\nspace = axes(field1)\n\nremapper = Remapper(space, hcoords, zcoords)\n\nint1 = interpolate(remapper, field1)\nint2 = interpolate(remapper, field2)\n\n# Or\nint12 = interpolate(remapper, [field1, field2])\n# With int1 = int12[1, :, :, :]\n\n\n\n\n\n   interpolate(field::ClimaCore.Fields, target_hcoords, target_zcoords)\n\nInterpolate the given fields on the Cartesian product of target_hcoords with target_zcoords (if not empty).\n\nCoordinates have to be ClimaCore.Geometry.Points.\n\nNote: do not use this method when performance is important. Instead, define a Remapper and call interpolate(remapper, fields). Different Fields defined on the same Space can share a Remapper, so that interpolation can be optimized.\n\nExample\n\nGiven field, a Field defined on a cubed sphere.\n\nlongpts = range(-180.0, 180.0, 21)\nlatpts = range(-80.0, 80.0, 21)\nzpts = range(0.0, 1000.0, 21)\n\nhcoords = [Geometry.LatLongPoint(lat, long) for long in longpts, lat in latpts]\nzcoords = [Geometry.ZPoint(z) for z in zpts]\n\ninterpolate(field, hcoords, zcoords)\n\n\n\n\n\n","category":"function"},{"location":"code_of_conduct/#Code-of-Conduct","page":"Code of Conduct","title":"Code of Conduct","text":"","category":"section"},{"location":"code_of_conduct/#Our-Pledge","page":"Code of Conduct","title":"Our Pledge","text":"","category":"section"},{"location":"code_of_conduct/","page":"Code of Conduct","title":"Code of Conduct","text":"We as members, contributors, and leaders pledge to make participation in our community a harassment-free experience for everyone, regardless of age, body size, visible or invisible disability, ethnicity, sex characteristics, gender identity and expression, level of experience, education, socio-economic status, nationality, personal appearance, race, religion, or sexual identity and orientation.","category":"page"},{"location":"code_of_conduct/","page":"Code of Conduct","title":"Code of Conduct","text":"We pledge to act and interact in ways that contribute to an open, welcoming, diverse, inclusive, and healthy community.","category":"page"},{"location":"code_of_conduct/#Our-Standards","page":"Code of Conduct","title":"Our Standards","text":"","category":"section"},{"location":"code_of_conduct/","page":"Code of Conduct","title":"Code of Conduct","text":"Examples of behavior that contributes to a positive environment for our community include:","category":"page"},{"location":"code_of_conduct/","page":"Code of Conduct","title":"Code of Conduct","text":"Demonstrating empathy and kindness toward other people\nBeing respectful of differing opinions, viewpoints, and experiences\nGiving and gracefully accepting constructive feedback\nAccepting responsibility and apologizing to those affected by our mistakes, and learning from the experience\nFocusing on what is best not just for us as individuals, but for the overall community","category":"page"},{"location":"code_of_conduct/","page":"Code of Conduct","title":"Code of Conduct","text":"Examples of unacceptable behavior include:","category":"page"},{"location":"code_of_conduct/","page":"Code of Conduct","title":"Code of Conduct","text":"The use of sexualized language or imagery, and sexual attention or advances of any kind\nTrolling, insulting or derogatory comments, and personal or political attacks\nPublic or private harassment\nPublishing others' private information, such as a physical or email address, without their explicit permission\nOther conduct which could reasonably be considered inappropriate in a professional setting","category":"page"},{"location":"code_of_conduct/#Enforcement-Responsibilities","page":"Code of Conduct","title":"Enforcement Responsibilities","text":"","category":"section"},{"location":"code_of_conduct/","page":"Code of Conduct","title":"Code of Conduct","text":"Community leaders are responsible for clarifying and enforcing our standards of acceptable behavior and will take appropriate and fair corrective action in response to any behavior that they deem inappropriate, threatening, offensive, or harmful.","category":"page"},{"location":"code_of_conduct/","page":"Code of Conduct","title":"Code of Conduct","text":"Community leaders have the right and responsibility to remove, edit, or reject comments, commits, code, wiki edits, issues, and other contributions that are not aligned to this Code of Conduct, and will communicate reasons for moderation decisions when appropriate.","category":"page"},{"location":"code_of_conduct/#Enforcement","page":"Code of Conduct","title":"Enforcement","text":"","category":"section"},{"location":"code_of_conduct/","page":"Code of Conduct","title":"Code of Conduct","text":"Instances of abusive, harassing, or otherwise unacceptable behavior may be reported to the community leaders responsible for enforcement (group leader Tapio Schneider and project manager Cheikh Mbengue), but also anyone who you feel comforatable with interacting in our project and GitHub community. All complaints will be reviewed and investigated promptly and fairly.","category":"page"},{"location":"code_of_conduct/","page":"Code of Conduct","title":"Code of Conduct","text":"All community leaders are obligated to respect the privacy and security of the reporter of any incident.","category":"page"},{"location":"code_of_conduct/#Attribution-and-Credits","page":"Code of Conduct","title":"Attribution and Credits","text":"","category":"section"},{"location":"code_of_conduct/","page":"Code of Conduct","title":"Code of Conduct","text":"This Code of Conduct is heavily based on the excellent libCEED's Code of Conduct, which in turn is adapted from the Contributor Covenant, including version 2.0. For answers to common questions about the code of conduct, see the Contributor Covenant FAQ. Translations are also available.","category":"page"},{"location":"geometry/#Geometry","page":"Geometry","title":"Geometry","text":"","category":"section"},{"location":"geometry/","page":"Geometry","title":"Geometry","text":"CurrentModule = ClimaCore.Geometry","category":"page"},{"location":"geometry/","page":"Geometry","title":"Geometry","text":"mul_with_projection\nrmul_with_projection\nmul_return_type\nrmul_return_type","category":"page"},{"location":"geometry/#ClimaCore.Geometry.mul_with_projection","page":"Geometry","title":"ClimaCore.Geometry.mul_with_projection","text":"mul_with_projection(x, y, lg)\n\nSimilar to x * y, except that this version automatically projects y to avoid DimensionMismatch errors for AxisTensors. For example, if x is a covector along the Covariant3Axis (e.g., Covariant3Vector(1)'), then y will be projected onto the Contravariant3Axis. In general, the first axis of y will be projected onto the dual of the last axis of x.\n\n\n\n\n\n","category":"function"},{"location":"geometry/#ClimaCore.Geometry.rmul_with_projection","page":"Geometry","title":"ClimaCore.Geometry.rmul_with_projection","text":"rmul_with_projection(x, y, lg)\n\nSimilar to rmul(x, y), except that this version calls mul_with_projection instead of *.\n\n\n\n\n\n","category":"function"},{"location":"geometry/#ClimaCore.Geometry.mul_return_type","page":"Geometry","title":"ClimaCore.Geometry.mul_return_type","text":"mul_return_type(X, Y)\n\nComputes the return type of mul_with_projection(x, y, lg), where x isa X and y isa Y. This can also be used to obtain the return type of x * y, although x * y will throw an error when projection is necessary.\n\nNote that this is equivalent to calling the internal function _return_type: Base._return_type(mul_with_projection, Tuple{X, Y, LG}), where lg isa LG.\n\n\n\n\n\n","category":"function"},{"location":"geometry/#ClimaCore.Geometry.rmul_return_type","page":"Geometry","title":"ClimaCore.Geometry.rmul_return_type","text":"rmul_return_type(X, Y)\n\nComputes the return type of rmul_with_projection(x, y, lg), where x isa X and y isa Y. This can also be used to obtain the return type of rmul(x, y), although rmul(x, y) will throw an error when projection is necessary.\n\nNote that this is equivalent to calling the internal function _return_type: Base._return_type(rmul_with_projection, Tuple{X, Y, LG}), where lg isa LG.\n\n\n\n\n\n","category":"function"},{"location":"math_framework/#Mathematical-Framework","page":"Mathematical Framework","title":"Mathematical Framework","text":"","category":"section"},{"location":"math_framework/","page":"Mathematical Framework","title":"Mathematical Framework","text":"In this section we are going to introduce some mathematical concepts and their representations in ClimaCore.jl.","category":"page"},{"location":"math_framework/#Vectors-and-Vector-Fields","page":"Mathematical Framework","title":"Vectors and Vector Fields","text":"","category":"section"},{"location":"math_framework/","page":"Mathematical Framework","title":"Mathematical Framework","text":"Vector can mean a few things depending on context:","category":"page"},{"location":"math_framework/","page":"Mathematical Framework","title":"Mathematical Framework","text":"In Julia, a Vector is just an ordered collection of values (i.e., a container).\nIn mathematics, a vector is an element of a vector space: a set of objects, which may be added together and multiplied by a scalar.\nIn physics, a vector typically refers to a directional quantity: that something with both a direction and a magnitude. This is the best way to think of vectors in ClimaCore.jl.","category":"page"},{"location":"math_framework/","page":"Mathematical Framework","title":"Mathematical Framework","text":"A vector field is then a vector-valued field: that is an assignment of a vector to each point in a space. For instance, a vector field in the plane can be visualised as a collection of arrows with a given magnitude and direction, each attached to a point in the plane.","category":"page"},{"location":"math_framework/","page":"Mathematical Framework","title":"Mathematical Framework","text":"In a coordinate system, a vector field on a domain in n-dimensional Euclidean space can be represented as a vector-valued function that associates an n-tuple of real numbers to each point of the domain. This representation of a vector field depends on the coordinate system, and there are transformation laws for passing from one coordinate system to the other.","category":"page"},{"location":"math_framework/","page":"Mathematical Framework","title":"Mathematical Framework","text":"ClmaCore supports different coordinate systems and, therefore, vector representations. In fact, one of the key requirements of ClimaCore is to support vectors specified in orthogonal (Cartesian) and curvilinear coordinate systems.","category":"page"},{"location":"math_framework/#LocalVector:-UVector,-UVVector,-and-UVWVector,-etc;-a-\"universal\"-basis","page":"Mathematical Framework","title":"LocalVector: UVector, UVVector, and UVWVector, etc; a \"universal\" basis","text":"","category":"section"},{"location":"math_framework/","page":"Mathematical Framework","title":"Mathematical Framework","text":"The easiest basis to use is the \"UVW\" basis, which can be defined in both Cartesian or spherical domains:","category":"page"},{"location":"math_framework/","page":"Mathematical Framework","title":"Mathematical Framework","text":"in a Cartesian domain, it is the usual Cartesian orthogonal vector basis (U along the X-axis, V along the Y-axis, W along the Z-axis).\nin a spherical domain, it is the orthogonal basis relative to spherical (curvilinear) coordinates:\nU is the zonal (eastward) component\nV is the meridonal (northward) component\nW is the radial component","category":"page"},{"location":"math_framework/","page":"Mathematical Framework","title":"Mathematical Framework","text":"It has some nice properties which make it convenient:","category":"page"},{"location":"math_framework/","page":"Mathematical Framework","title":"Mathematical Framework","text":"it's an orthonormal basis:\nit is easy to decompose a vector (take the projection along the basis)\nthe components are easy to interpret (they have unit scale)\nallow us to write code across domains\nU and V are always horizontal, W is vertical","category":"page"},{"location":"math_framework/","page":"Mathematical Framework","title":"Mathematical Framework","text":"We can define \"generic\" vectors via UVector, UVVector, and UVWVector that can be equally defined on Cartesian or spherical spaces.","category":"page"},{"location":"math_framework/","page":"Mathematical Framework","title":"Mathematical Framework","text":"But if users need to compute with them, or feed differential operators with them, then may want to consider different bases, as not all operators accept all bases.","category":"page"},{"location":"math_framework/#Covariant-and-Contravariant-bases","page":"Mathematical Framework","title":"Covariant and Contravariant bases","text":"","category":"section"},{"location":"math_framework/","page":"Mathematical Framework","title":"Mathematical Framework","text":"(Image: Different bases supported in ClimaCore.jl)","category":"page"},{"location":"math_framework/","page":"Mathematical Framework","title":"Mathematical Framework","text":"Covariance and contravariance describe how the quantitative description of certain geometric or physical entities changes with a change of basis.","category":"page"},{"location":"math_framework/","page":"Mathematical Framework","title":"Mathematical Framework","text":"In ClimaCore.jl, the covariant basis is specified by the partial derivative of the transformation from the reference element xi in -11^d (where d is the dimensionality of the domain Omega) to x in the physical space:","category":"page"},{"location":"math_framework/","page":"Mathematical Framework","title":"Mathematical Framework","text":"mathbfe_i = fracpartial xpartial xi^i","category":"page"},{"location":"math_framework/","page":"Mathematical Framework","title":"Mathematical Framework","text":"while the contravariant basis is the opposite: gradient in x of the coordinate (the inverse map)","category":"page"},{"location":"math_framework/","page":"Mathematical Framework","title":"Mathematical Framework","text":"mathbfe^i = nabla_x xi^i","category":"page"},{"location":"math_framework/","page":"Mathematical Framework","title":"Mathematical Framework","text":"Note:","category":"page"},{"location":"math_framework/","page":"Mathematical Framework","title":"Mathematical Framework","text":"these are specific to a given element: you generally can't compare covariant or contravariant component from one element with that in another\nin this case, you need to first convert them to UVW basis (e.g. we do this for DSS operations)\nwe choose the coordinates of the reference element so that xi^1 and xi^2 are horizontal, and xi^3 is vertical\nin a Cartesian domain, this means that covariant and contravariant components are just rescaled versions of the UVW components.\n\nthings get a little more complicated in the presence of terrain, but xi^3 is radially aligned\nthe 3rd covariant component is aligned with W, but the 3rd contravariant component may not be (e.g. at the surface it is normal to the boundary).","category":"page"},{"location":"math_framework/#Cartesian-bases","page":"Mathematical Framework","title":"Cartesian bases","text":"","category":"section"},{"location":"math_framework/","page":"Mathematical Framework","title":"Mathematical Framework","text":"Analogously to CartesianPoints, in ClimaCore, there are also CartesianVectors: these allow conversion to a global Cartesian basis. It is intended mainly for visualization purposes.","category":"page"},{"location":"math_framework/#Conversions","page":"Mathematical Framework","title":"Conversions","text":"","category":"section"},{"location":"math_framework/","page":"Mathematical Framework","title":"Mathematical Framework","text":"To convert between different vector bases, you need a LocalGeometry object: this contains all the necessary information (coordinates, metric terms, etc) to do the conversion. These are constructed as part of the Space.","category":"page"},{"location":"math_framework/#Introduction-to-the-Finite/Spectral-Element-Method","page":"Mathematical Framework","title":"Introduction to the Finite/Spectral Element Method","text":"","category":"section"},{"location":"math_framework/","page":"Mathematical Framework","title":"Mathematical Framework","text":"In finite element formulations, the weak form of a Partial Differential Equation (PDE)–-which involves integrating all terms in the PDE over the domain–-is evaluated on a subdomain Omega_e (element) and the local results are composed into a larger system of equations that models the entire problem on the global domain Omega.","category":"page"},{"location":"math_framework/","page":"Mathematical Framework","title":"Mathematical Framework","text":"A spectral element space is a function space in which each function is approximated with a finite-dimensional polynomial interpolation in each element. Hence, we use polynomials as basis functions to approximate a given function (e.g., solution state). There are different ways of defininig basis functions: nodal basis functions and modal basis functions. We use nodal basis functions (e.g. by using Lagrange interpolation), which are defined via the values of the polynomials at particular nodal points in each element (termed Finite Element nodes). Even though the basis functions can interpolate globally, it’s better to limit each function to interpolate locally within each element, so to avoid a dense matrix system of equations when adding up the element contributions on the global domain Omega.","category":"page"},{"location":"math_framework/","page":"Mathematical Framework","title":"Mathematical Framework","text":"The Finite Element nodes can be chosen to coincide with those of a particular quadrature rule, (this is referred to as using collocated nodes) which allows us to integrate functions over the domain.","category":"page"},{"location":"math_framework/","page":"Mathematical Framework","title":"Mathematical Framework","text":"Let us give a concrete example of strong and weak form of a PDE. A Poisson's problem (in strong form) is given by","category":"page"},{"location":"math_framework/","page":"Mathematical Framework","title":"Mathematical Framework","text":"   nabla cdot nabla u = f textrm for   mathbfx in Omega ","category":"page"},{"location":"math_framework/","page":"Mathematical Framework","title":"Mathematical Framework","text":"To obtain the weak form, let us multiply all terms by a test function v and integrate by parts (i.e., apply the divergence theorem in multiple dimensions):","category":"page"},{"location":"math_framework/","page":"Mathematical Framework","title":"Mathematical Framework","text":"   int_Omega nabla v cdot nabla u  dV - int_partial Omega v nabla u cdot hatmathbf n dS = int_Omega  v f  dV ","category":"page"},{"location":"math_framework/","page":"Mathematical Framework","title":"Mathematical Framework","text":"Often, we choose to represent a field (say, the velocity field) such that nabla u cdot hatmathbf n = 0, so that we're only left with the volumetric parts of the equation above.","category":"page"},{"location":"math_framework/","page":"Mathematical Framework","title":"Mathematical Framework","text":"The only supported choice for now in ClimaCore.jl is a Gauss-Legendre-Lobatto rule and nodes.","category":"page"},{"location":"matrix_fields/#MatrixFields","page":"MatrixFields","title":"MatrixFields","text":"","category":"section"},{"location":"matrix_fields/","page":"MatrixFields","title":"MatrixFields","text":"CurrentModule = ClimaCore.MatrixFields","category":"page"},{"location":"matrix_fields/","page":"MatrixFields","title":"MatrixFields","text":"MatrixFields","category":"page"},{"location":"matrix_fields/#ClimaCore.MatrixFields","page":"MatrixFields","title":"ClimaCore.MatrixFields","text":"MatrixFields\n\nThis module adds support for defining and manipulating Fields that represent matrices. Specifically, it adds the BandMatrixRow type, which can be used to store the entries of a band matrix. A Field of BandMatrixRows on a FiniteDifferenceSpace can be interpreted as a band matrix by vertically concatenating the BandMatrixRows. Similarly, a Field of BandMatrixRows on an ExtrudedFiniteDifferenceSpace can be interpreted as a collection of band matrices, one for each column of the Field. Such Fields are called ColumnwiseBandMatrixFields, and this module adds the following functionality for them:\n\nConstructors, e.g., matrix_field = @. BidiagonalMatrixRow(field1, field2)\nLinear combinations, e.g., @. 3 * matrix_field1 + matrix_field2 / 3\nMatrix-vector multiplication, e.g., @. matrix_field ⋅ field\nMatrix-matrix multiplication, e.g., @. matrix_field1 ⋅ matrix_field2\nCompatibility with LinearAlgebra.I, e.g., @. matrix_field = (4I,) or   @. matrix_field - (4I,)\nIntegration with RecursiveApply, e.g., the entries of matrix_field can be   Tuples or NamedTuples instead of single values, which allows   matrix_field to represent multiple band matrices at the same time\nIntegration with Operators, e.g., the matrix_field that gets applied to   the argument of any FiniteDifferenceOperator op can be obtained using   the FiniteDifferenceOperator operator_matrix(op)\nConversions to native array types, e.g., field2arrays(matrix_field) can   convert each column of matrix_field into a BandedMatrix from   BandedMatrices.jl\nCustom printing, e.g., matrix_field gets displayed as a BandedMatrix,   specifically, as the BandedMatrix that corresponds to its first column\n\nThis module also adds support for defining and manipulating sparse block matrices of Fields. Specifically, it adds the FieldMatrix type, which is a dictionary that maps pairs of FieldNames to ColumnwiseBandMatrixFields or multiples of LinearAlgebra.I. This comes with the following functionality:\n\nAddition and subtraction, e.g., @. field_matrix1 + field_matrix2\nMatrix-vector multiplication, e.g., @. field_matrix * field_vector\nMatrix-matrix multiplication, e.g., @. field_matrix1 * field_matrix2\nIntegration with RecursiveApply, e.g., the entries of field_matrix can be   specified either as matrix Fields of Tuples or NamedTuples, or as   separate matrix Fields of single values\nThe ability to solve linear equations using FieldMatrixSolver, which is a   generalization of ldiv! that is designed to optimize solver performance\n\n\n\n\n\n","category":"module"},{"location":"matrix_fields/#Matrix-Field-Element-Type","page":"MatrixFields","title":"Matrix Field Element Type","text":"","category":"section"},{"location":"matrix_fields/","page":"MatrixFields","title":"MatrixFields","text":"BandMatrixRow","category":"page"},{"location":"matrix_fields/#ClimaCore.MatrixFields.BandMatrixRow","page":"MatrixFields","title":"ClimaCore.MatrixFields.BandMatrixRow","text":"BandMatrixRow{ld}(entries...)\n\nStores the nonzero entries in a row of a band matrix, starting with the lowest diagonal, which has index ld. Supported operations include accessing the entry on the diagonal with index d by calling row[d], taking linear combinations with other band matrix rows (and with LinearAlgebra.I), and checking for equality with other band matrix rows (and with LinearAlgebra.I). There are several aliases for commonly used subtypes of BandMatrixRow:\n\nDiagonalMatrixRow(entry_1)\nBidiagonalMatrixRow(entry_1, entry_2)\nTridiagonalMatrixRow(entry_1, entry_2, entry_3)\nQuaddiagonalMatrixRow(entry_1, entry_2, entry_3, entry_4)\nPentadiagonalMatrixRow(entry_1, entry_2, entry_3, entry_4, entry_5)\n\n\n\n\n\n","category":"type"},{"location":"matrix_fields/#Matrix-Field-Multiplication","page":"MatrixFields","title":"Matrix Field Multiplication","text":"","category":"section"},{"location":"matrix_fields/","page":"MatrixFields","title":"MatrixFields","text":"MultiplyColumnwiseBandMatrixField","category":"page"},{"location":"matrix_fields/#ClimaCore.MatrixFields.MultiplyColumnwiseBandMatrixField","page":"MatrixFields","title":"ClimaCore.MatrixFields.MultiplyColumnwiseBandMatrixField","text":"MultiplyColumnwiseBandMatrixField()\n\nAn operator that multiplies a ColumnwiseBandMatrixField by another Field, i.e., matrix-vector or matrix-matrix multiplication. The ⋅ symbol is an alias for MultiplyColumnwiseBandMatrixField().\n\nWhat follows is a derivation of the algorithm used by this operator with single-column Fields. For Fields on multiple columns, the same computation is done for each column.\n\nIn this derivation, we will use M_1 and M_2 to denote two ColumnwiseBandMatrixFields, and we will use V to denote a regular (vector-like) Field. For both M_1 and M_2, we will use the array-like index notation Mrow col to denote Mrowcol-row, i.e., the entry in the BandMatrixRow Mrow located on the diagonal with index col - row. We will also use outer_indices(space) to denote the tuple (left_idx(space)right_idx(space)).\n\n1. Matrix-Vector Multiplication\n\nFrom the definition of matrix-vector multiplication,\n\n(M_1  V)i = sum_k M_1i k * Vk\n\nTo establish bounds on the values of k, let us define the following values:\n\nli_1 ri_1 =outer_indices(column_axes(M_1))\nld_1 ud_1 =outer_diagonals(eltype(M_1))\n\nSince M_1i k is only well-defined if k is a valid column index and k - i is a valid diagonal index, we know that\n\nli_1 leq k leq ri_1 quad textand quad ld_1 leq k - i leq ud_1\n\nCombining these into a single inequality gives us\n\ntextmax(li_1 i + ld_1) leq k leq textmin(ri_1 i + ud_1)\n\nSo, we can rewrite the expression for (M_1  V)i as\n\n(M_1  V)i =\n    sum_k = textmax(li_1 i + ld_1)^textmin(ri_1 i + ud_1)\n    M_1i k * Vk\n\nIf we replace the variable k with d = k - i and switch from array-like indexing to Field indexing, we find that\n\n(M_1  V)i =\n    sum_d = textmax(li_1 - i ld_1)^textmin(ri_1 - i ud_1)\n    M_1id * Vi + d\n\n1.1 Interior vs. Boundary Indices\n\nNow, suppose that the row index i is such that\n\nli_1 - ld_1 leq i leq ri_1 - ud_1\n\nIf this is the case, then the bounds on d can be simplified to\n\ntextmax(li_1 - i ld_1) = ld_1 quad textand quad\ntextmin(ri_1 - i ud_1) = ud_1\n\nThe expression for (M_1  V)i then becomes\n\n(M_1  V)i = sum_d = ld_1^ud_1 M_1id * Vi + d\n\nThe values of i in this range are considered to be in the \"interior\" of the operator, while those not in this range (for which we cannot make the above simplification) are considered to be on the \"boundary\".\n\n2. Matrix-Matrix Multiplication\n\nFrom the definition of matrix-matrix multiplication,\n\n(M_1  M_2)i j = sum_k M_1i k * M_2k j\n\nTo establish bounds on the values of j and k, let us define the following values:\n\nli_1 ri_1 =outer_indices(column_axes(M_1))\nld_1 ud_1 =outer_diagonals(eltype(M_1))\nli_2 ri_2 =outer_indices(column_axes(M_2))\nld_2 ud_2 =outer_diagonals(eltype(M_2))\n\nIn addition, let ld_prod and ud_prod denote the outer diagonal indices of the product matrix M_1  M_2. We will derive the values of ld_prod and ud_prod in the last section.\n\nSince M_1i k is only well-defined if k is a valid column index and k - i is a valid diagonal index, we know that\n\nli_1 leq k leq ri_1 quad textand quad ld_1 leq k - i leq ud_1\n\nSince M_2k j is only well-defined if j is a valid column index and j - k is a valid diagonal index, we also know that\n\nli_2 leq j leq ri_2 quad textand quad ld_2 leq j - k leq ud_2\n\nFinally, (M_1  M_2)i j is only well-defined if j - i is a valid diagonal index, so\n\nld_prod leq j - i leq ud_prod\n\nThese inequalities can be combined to obtain\n\nbegingather*\ntextmax(li_2 i + ld_prod) leq j leq\ntextmin(ri_2 i + ud_prod) \ntextand \ntextmax(li_1 i + ld_1 j - ud_2) leq k leq\ntextmin(ri_1 i + ud_1 j - ld_2)\nendgather*\n\nSo, we can rewrite the expression for (M_1  M_2)i j as\n\nbegingather*\n(M_1  M_2)i j =\n    sum_\n        k = textmax(li_1 i + ld_1 j - ud_2)\n    ^textmin(ri_1 i + ud_1 j - ld_2)\n    M_1i k * M_2k j text where 05em\ntextmax(li_2 i + ld_prod) leq j leq textmin(ri_2 i + ud_prod)\nendgather*\n\nIf we replace the variable k with d = k - i, replace the variable j with d_prod = j - i, and switch from array-like indexing to Field indexing, we find that\n\nbegingather*\n(M_1  M_2)id_prod =\n    sum_\n        d = textmax(li_1 - i ld_1 d_prod - ud_2)\n    ^textmin(ri_1 - i ud_1 d_prod - ld_2)\n    M_1id * M_2i + dd_prod - d text where 05em\ntextmax(li_2 - i ld_prod) leq d_prod leq\n    textmin(ri_2 - i ud_prod)\nendgather*\n\n2.1 Interior vs. Boundary Indices\n\nNow, suppose that the row index i is such that\n\ntextmax(li_1 - ld_1 li_2 - ld_prod) leq i leq\n    textmin(ri_1 - ud_1 ri_2 - ud_prod)\n\nIf this is the case, then the bounds on d_prod can be simplified to\n\ntextmax(li_2 - i ld_prod) = ld_prod quad textand quad\ntextmin(ri_2 - i ud_prod) = ud_prod\n\nSimilarly, the bounds on d can be simplified using the fact that\n\ntextmax(li_1 - i ld_1) = ld_1 quad textand quad\ntextmin(ri_1 - i ud_1) = ud_1\n\nThe expression for (M_1  M_2)id_prod then becomes\n\nbegingather*\n(M_1  M_2)id_prod =\n    sum_\n        d = textmax(ld_1 d_prod - ud_2)\n    ^textmin(ud_1 d_prod - ld_2)\n    M_1id * M_2i + dd_prod - d text where 05em\nld_prod leq d_prod leq ud_prod\nendgather*\n\nThe values of i in this range are considered to be in the \"interior\" of the operator, while those not in this range (for which we cannot make these simplifications) are considered to be on the \"boundary\".\n\n2.2 ld_prod and ud_prod\n\nWe only need to compute (M_1  M_2)id_prod for values of d_prod that correspond to a nonempty sum in the interior, i.e, those for which\n\ntextmax(ld_1 d_prod - ud_2) leq textmin(ud_1 d_prod - ld_2)\n\nThis can be broken down into the four inequalities\n\nld_1 leq ud_1 qquad ld_1 leq d_prod - ld_2 qquad\nd_prod - ud_2 leq ud_1 quad textand quad\nd_prod - ud_2 leq d_prod - ld_2\n\nBy definition, ld_1 leq ud_1 and ld_2 leq ud_2, so the first and last inequality are always true. Rearranging the remaining two inequalities tells us that\n\nld_1 + ld_2 leq d_prod leq ud_1 + ud_2\n\nIn other words, the outer diagonal indices of M_1  M_2 are\n\nld_prod = ld_1 + ld_2 quad textand quad ud_prod = ud_1 + ud_2\n\nThis means that we can express the bounds on the interior values of i as\n\ntextmax(li_1 li_2 - ld_2) - ld_1 leq i leq\n    textmin(ri_1 ri_2 - ud_2) - ud_1\n\n\n\n\n\n","category":"type"},{"location":"matrix_fields/#Operator-Matrices","page":"MatrixFields","title":"Operator Matrices","text":"","category":"section"},{"location":"matrix_fields/","page":"MatrixFields","title":"MatrixFields","text":"operator_matrix","category":"page"},{"location":"matrix_fields/#ClimaCore.MatrixFields.operator_matrix","page":"MatrixFields","title":"ClimaCore.MatrixFields.operator_matrix","text":"operator_matrix(op)\n\nConstructs a new operator (or operator-like object) that generates the matrix applied by op to its final argument. If op_matrix = operator_matrix(op), we can use the following identities:\n\nWhen op takes one argument, @. op(arg) == @. op_matrix() ⋅ arg.\nWhen op takes multiple arguments,   @. op(args..., arg) == @. op_matrix(args...) ⋅ arg.\n\nWhen op takes more than one argument, operator_matrix(op) constructs a FiniteDifferenceOperator that generates the operator matrix. When op only takes one argument, it instead constructs an AbstractLazyOperator, which is internally converted into a FiniteDifferenceOperator when used in a broadcast expression. Implementing op_matrix as a lazy operator allows us to add an argument to the expression op_matrix.(), and we then use this argument to infer the space and element type of the operator matrix.\n\nAs an example, the InterpolateF2C() operator on a space with n cell centers applies an n times (n + 1) bidiagonal matrix:\n\ntextrminterp(arg) = beginbmatrix\n    05      05        0  cdots        0        0        0 \n      0      05      05  cdots        0        0        0 \n      0        0      05  cdots        0        0        0 \nvdots  vdots  vdots  ddots  vdots  vdots  vdots \n      0        0        0  cdots      05      05        0 \n      0        0        0  cdots        0      05      05\nendbmatrix  arg\n\nThe GradientF2C() operator applies a similar matrix, but with different entries:\n\ntextrmgrad(arg) = beginbmatrix\n-textbfe^3   textbfe^3               0  cdots               0               0              0 \n             0  -textbfe^3   textbfe^3  cdots               0               0              0 \n             0               0  -textbfe^3  cdots               0               0              0 \n       vdots         vdots         vdots  ddots         vdots         vdots        vdots \n             0               0               0  cdots  -textbfe^3   textbfe^3              0 \n             0               0               0  cdots               0  -textbfe^3  textbfe^3\nendbmatrix  arg\n\nThe unit vector textbfe^3, which can also be thought of as the differential along the third coordinate axis (textrmdxi^3), is implemented as a Geometry.Covariant3Vector(1).\n\nNot all operators have well-defined operator matrices. For example, the operator GradientC2F(; bottom = SetGradient(grad_b), top = SetGradient(grad_t)) applies an affine transformation:\n\ntextrmgrad(arg) = beginbmatrix\ngrad_b  0  0  vdots  0  0  grad_t\nendbmatrix + beginbmatrix\n             0               0               0  cdots               0              0 \n-textbfe^3   textbfe^3               0  cdots               0              0 \n             0  -textbfe^3   textbfe^3  cdots               0              0 \n       vdots         vdots         vdots  ddots         vdots        vdots \n             0               0               0  cdots   textbfe^3              0 \n             0               0               0  cdots  -textbfe^3  textbfe^3 \n             0               0               0  cdots               0              0\nendbmatrix  arg\n\nHowever, this simplifies to a linear transformation when grad_b and grad_t are both 0:\n\ntextrmgrad(arg) = beginbmatrix\n             0               0               0  cdots               0              0 \n-textbfe^3   textbfe^3               0  cdots               0              0 \n             0  -textbfe^3   textbfe^3  cdots               0              0 \n       vdots         vdots         vdots  ddots         vdots        vdots \n             0               0               0  cdots   textbfe^3              0 \n             0               0               0  cdots  -textbfe^3  textbfe^3 \n             0               0               0  cdots               0              0\nendbmatrix  arg\n\nIn general, when op has nonzero boundary conditions that make it apply an affine transformation, operator_matrix(op) will print out a warning and zero out the boundary conditions before computing the operator matrix.\n\nIn addition to affine transformations, there are also some operators that apply nonlinear transformations to their arguments; that is, transformations which cannot be accurately approximated without using more terms of the form\n\ntextrmop(textbf0) +\ntextrmop(textbf0)  arg +\ntextrmop(textbf0)  arg  arg +\nldots\n\nWhen op is such an operator, operator_matrix(op) will throw an error. In the future, we may want to modify operator_matrix(op) so that it will instead return textrmop(textbf0), where textbf0 =zero.(arg).\n\n\n\n\n\n","category":"function"},{"location":"matrix_fields/#Linear-Solvers","page":"MatrixFields","title":"Linear Solvers","text":"","category":"section"},{"location":"matrix_fields/","page":"MatrixFields","title":"MatrixFields","text":"FieldMatrixSolverAlgorithm\nFieldMatrixSolver\nFieldMatrixWithSolver\nfield_matrix_solve!\nBlockDiagonalSolve\nBlockLowerTriangularSolve\nBlockArrowheadSolve\nSchurComplementReductionSolve\nLazyFieldMatrixSolverAlgorithm\nStationaryIterativeSolve\nApproximateBlockArrowheadIterativeSolve","category":"page"},{"location":"matrix_fields/#ClimaCore.MatrixFields.FieldMatrixSolverAlgorithm","page":"MatrixFields","title":"ClimaCore.MatrixFields.FieldMatrixSolverAlgorithm","text":"FieldMatrixSolverAlgorithm\n\nDescription of how to solve an equation of the form A * x = b for x, where A is a FieldMatrix and where x and b are both FieldVectors. Different algorithms can be nested inside each other, enabling the construction of specialized linear solvers that fully utilize the sparsity pattern of A.\n\nInterface\n\nEvery subtype of FieldMatrixSolverAlgorithm must implement methods for the following functions:\n\nfield_matrix_solver_cache\ncheck_field_matrix_solver\nrun_field_matrix_solver!\n\n\n\n\n\n","category":"type"},{"location":"matrix_fields/#ClimaCore.MatrixFields.FieldMatrixSolver","page":"MatrixFields","title":"ClimaCore.MatrixFields.FieldMatrixSolver","text":"FieldMatrixSolver(alg, A, b)\n\nCombination of a FieldMatrixSolverAlgorithm alg and the cache it requires to solve the equation A * x = b for x. The values of A and b that get passed to this constructor should be similar to the ones that get passed to field_matrix_solve! in order to ensure that the cache gets allocated correctly.\n\n\n\n\n\n","category":"type"},{"location":"matrix_fields/#ClimaCore.MatrixFields.FieldMatrixWithSolver","page":"MatrixFields","title":"ClimaCore.MatrixFields.FieldMatrixWithSolver","text":"FieldMatrixWithSolver(A, b, [alg])\n\nA wrapper that combines a FieldMatrix A with a FieldMatrixSolver that can be used to solve the equation A * x = b for x, where x and b are both FieldVectors. Similar to a LinearAlgebra.Factorization, this wrapper can be passed to ldiv!, whereas a regular FieldMatrix cannot be passed to ldiv!.\n\nBy default, the FieldMatrixSolverAlgorithm alg is set to a BlockDiagonalSolve, so a custom alg must be specified when A is not a block diagonal matrix.\n\n\n\n\n\n","category":"type"},{"location":"matrix_fields/#ClimaCore.MatrixFields.field_matrix_solve!","page":"MatrixFields","title":"ClimaCore.MatrixFields.field_matrix_solve!","text":"field_matrix_solve!(solver, x, A, b)\n\nSolves the equation A * x = b for x using the FieldMatrixSolver solver.\n\n\n\n\n\n","category":"function"},{"location":"matrix_fields/#ClimaCore.MatrixFields.BlockDiagonalSolve","page":"MatrixFields","title":"ClimaCore.MatrixFields.BlockDiagonalSolve","text":"BlockDiagonalSolve()\n\nA FieldMatrixSolverAlgorithm for a block diagonal matrix:\n\nA = beginbmatrix\n     A_11  mathbf0  mathbf0  cdots  mathbf0 \nmathbf0       A_22  mathbf0  cdots  mathbf0 \nmathbf0  mathbf0       A_33  cdots  mathbf0 \n    vdots      vdots      vdots  ddots      vdots \nmathbf0  mathbf0  mathbf0  cdots       A_NN\nendbmatrix\n\nThis algorithm solves the N block equations Aₙₙ * xₙ = bₙ in sequence (though we might want to parallelize it in the future).\n\nIf Aₙₙ is a diagonal matrix, the equation Aₙₙ * xₙ = bₙ is solved by making a single pass over the data, setting each xₙ[i] to inv(Aₙₙ[i, i]) * bₙ[i].\n\nOtherwise, the equation Aₙₙ * xₙ = bₙ is solved using Gaussian elimination (without pivoting), which makes two passes over the data. This is currently only implemented for tri-diagonal and penta-diagonal matrices Aₙₙ. In Gaussian elimination, Aₙₙ is effectively factorized into the product Lₙ * Dₙ * Uₙ, where Dₙ is a diagonal matrix, and where Lₙ and Uₙ are unit lower and upper triangular matrices, respectively. The first pass multiplies both sides of the equation by inv(Lₙ * Dₙ), replacing Aₙₙ with Uₙ and bₙ with Uₙxₙ, which is referred to as putting Aₙₙ into \"reduced row echelon form\". The second pass solves Uₙ * xₙ = Uₙxₙ for xₙ with a unit upper triangular matrix solver, which is referred to as \"back substitution\". These operations can become numerically unstable when Aₙₙ has entries with large disparities in magnitude, but avoiding this would require swapping the rows of Aₙₙ (i.e., replacing Dₙ with a partial pivoting matrix).\n\n\n\n\n\n","category":"type"},{"location":"matrix_fields/#ClimaCore.MatrixFields.BlockLowerTriangularSolve","page":"MatrixFields","title":"ClimaCore.MatrixFields.BlockLowerTriangularSolve","text":"BlockLowerTriangularSolve(names₁...; [alg₁], [alg₂])\n\nA FieldMatrixSolverAlgorithm for a 2×2 block lower triangular matrix:\n\nA = beginbmatrix A_11  mathbf0  A_21  A_22 endbmatrix\n\nThe FieldNames in names₁ correspond to the subscript ₁, while all other FieldNames correspond to the subscript ₂. This algorithm has 2 steps:\n\nSolve A₁₁ * x₁ = b₁ for x₁ using the algorithm alg₁, which is set to a BlockDiagonalSolve by default.\nSolve A₂₂ * x₂ = b₂ - A₂₁ * x₁ for x₂ using the algorithm alg₂, which is also set to a BlockDiagonalSolve by default.\n\n\n\n\n\n","category":"type"},{"location":"matrix_fields/#ClimaCore.MatrixFields.BlockArrowheadSolve","page":"MatrixFields","title":"ClimaCore.MatrixFields.BlockArrowheadSolve","text":"BlockArrowheadSolve(names₁...; [alg₂])\n\nA FieldMatrixSolverAlgorithm for a 2×2 block arrowhead matrix:\n\nA = beginbmatrix A_11  A_12  A_21  A_22 endbmatrix quad\ntextwhere  A_11 text is a diagonal matrix\n\nThe FieldNames in names₁ correspond to the subscript ₁, while all other FieldNames correspond to the subscript ₂. This algorithm has only 1 step:\n\nSolve (A₂₂ - A₂₁ * inv(A₁₁) * A₁₂) * x₂ = b₂ - A₂₁ * inv(A₁₁) * b₁ for x₂ using the algorithm alg₂, which is set to a BlockDiagonalSolve by default, and set x₁ to inv(A₁₁) * (b₁ - A₁₂ * x₂).\n\nSince A₁₁ is a diagonal matrix, inv(A₁₁) is easy to compute, which means that the Schur complement of A₁₁ in A, A₂₂ - A₂₁ * inv(A₁₁) * A₁₂, as well as the vectors b₂ - A₂₁ * inv(A₁₁) * b₁ and inv(A₁₁) * (b₁ - A₁₂ * x₂), are also easy to compute.\n\nThis algorithm is equivalent to block Gaussian elimination with all operations inlined into a single step.\n\n\n\n\n\n","category":"type"},{"location":"matrix_fields/#ClimaCore.MatrixFields.SchurComplementReductionSolve","page":"MatrixFields","title":"ClimaCore.MatrixFields.SchurComplementReductionSolve","text":"SchurComplementReductionSolve(names₁...; [alg₁], alg₂)\n\nA FieldMatrixSolverAlgorithm for any 2×2 block matrix:\n\nA = beginbmatrix A_11  A_12  A_21  A_22 endbmatrix\n\nThe FieldNames in names₁ correspond to the subscript ₁, while all other FieldNames correspond to the subscript ₂. This algorithm has 3 steps:\n\nSolve A₁₁ * x₁′ = b₁ for x₁′ using the algorithm alg₁, which is set to a BlockDiagonalSolve by default.\nSolve (A₂₂ - A₂₁ * inv(A₁₁) * A₁₂) * x₂ = b₂ - A₂₁ * x₁′ for x₂ using the algorithm alg₂.\nSolve A₁₁ * x₁ = b₁ - A₁₂ * x₂ for x₁ using the algorithm alg₁.\n\nSince A₁₁ is not necessarily a diagonal matrix, inv(A₁₁) will generally be a dense matrix, which means that the Schur complement of A₁₁ in A, A₂₂ - A₂₁ * inv(A₁₁) * A₁₂, cannot be computed efficiently. So, alg₂ must be set to a LazyFieldMatrixSolverAlgorithm, which can evaluate the matrix-vector product (A₂₂ - A₂₁ * inv(A₁₁) * A₁₂) * x₂ without actually computing the Schur complement matrix. This involves representing the Schur complement matrix by a LazySchurComplement, which uses alg₁ to invert A₁₁ when computing the matrix-vector product.\n\nThis algorithm is equivalent to block Gaussian elimination, where steps 1 and 2 put A into reduced row echelon form, and step 3 performs back substitution. For more information on this algorithm, see Section 5 of Numerical solution of saddle point problems.\n\n\n\n\n\n","category":"type"},{"location":"matrix_fields/#ClimaCore.MatrixFields.LazyFieldMatrixSolverAlgorithm","page":"MatrixFields","title":"ClimaCore.MatrixFields.LazyFieldMatrixSolverAlgorithm","text":"LazyFieldMatrixSolverAlgorithm\n\nA FieldMatrixSolverAlgorithm that does not require A to be a FieldMatrix, i.e., a \"matrix-free\" algorithm. Internally, a FieldMatrixSolverAlgorithm (for example, SchurComplementReductionSolve) might run a LazyFieldMatrixSolverAlgorithm on a \"lazy\" representation of a FieldMatrix (like a LazySchurComplement).\n\nThe only operations used by a LazyFieldMatrixSolverAlgorithm that depend on A are lazy_mul and, when required, lazy_preconditioner. These and other lazy operations are used to minimize the number of calls to Base.materialize!, since each call comes with a small performance penalty.\n\n\n\n\n\n","category":"type"},{"location":"matrix_fields/#ClimaCore.MatrixFields.StationaryIterativeSolve","page":"MatrixFields","title":"ClimaCore.MatrixFields.StationaryIterativeSolve","text":"StationaryIterativeSolve(; [kwargs...])\n\nA LazyFieldMatrixSolverAlgorithm that solves A * x = b by setting x to some initial value x[0] (usually just the zero vector, mathbf0) and then iteratively updating it to\n\nxn = xn - 1 + textrminv(P) * (b - A * xn - 1)\n\nThe matrix P is called a \"left preconditioner\" for A. In general, this algorithm converges more quickly when P is a close approximation of A, although more complicated approximations often come with a performance penalty.\n\nBackground\n\nLet x' denote the value of x for which A * x = b. Replacing b with A * x' in the formula for x[n] tells us that\n\nxn = x + (I - textrminv(P) * A) * (xn - 1 - x)\n\nIn other words, the error on iteration n, x[n] - x', can be expressed in terms of the error on the previous iteration, x[n - 1] - x', as\n\nxn - x = (I - textrminv(P) * A) * (xn - 1 - x)\n\nBy induction, this means that the error on iteration n is\n\nxn - x = (I - textrminv(P) * A)^n * (x0 - x)\n\nIf we pick some norm cdot, we find that the norm of the error is bounded by\n\nxn - x  (I - textrminv(P) * A)^n * x0 - x\n\nFor any matrix M, the spectral radius of M is defined as\n\nrho(M) = maxλ  λ text is an eigenvalue of  M\n\nThe spectral radius has the property that\n\nM^n sim rho(M)^n quad textie quad\nlim_n to infty fracM^nrho(M)^n = 1\n\nSo, as the value of n increases, the norm of the error becomes bounded by\n\nxn - x leq rho(I - textrminv(P) * A)^n * x0 - x\n\nThis indicates that x[n] will converge to x' (i.e., that the norm of the error will converge to 0) when ρ(I - inv(P) * A) < 1, and that the convergence rate is roughly bounded by ρ(I - inv(P) * A) for large values of n. More precisely, it can be shown that x[n] will converge to x' if and only if ρ(I - inv(P) * A) < 1. In practice, though, the convergence eventually stops due to the limits of floating point precision.\n\nAlso, if we assume that x[n] ≈ x', we can use the formula for x[n] to approximate the error on the previous iteration as\n\nxn - 1 - x  xn - 1 - xn = textrminv(P) * (A * xn - 1 - b)\n\nDebugging\n\nThis algorithm has support for 2 debugging message group names, which can be passed to the environment variable JULIA_DEBUG:\n\nerror_norm: prints ||x[n] - x'||₂ on every iteration, approximating the error x[n] - x' as described above\nspectral_radius: prints ρ(I - inv(P) * A), approximating this value with the eigsolve function from KrylovKit.jl\n\nBecause the eigsolve function is not compatible with CUDA, debugging the spectral radius is currently not possible on GPUs.\n\nKeyword Arguments\n\nThere are 4 values that can be included in kwargs...:\n\nP_alg = nothing: a PreconditionerAlgorithm that specifies how to compute P and solve P * x = b for x, or nothing if preconditioning is not required (in which case P is effectively set to one(A))\nn_iters = 1: the number of iterations\ncorrelated_solves = false: whether to set x[0] to a value of x that was generated during an earlier call to field_matrix_solve!, instead of setting it to mathbf0 (it is always set to mathbf0 on the first call to field_matrix_solve!)\neigsolve_kwargs = (;): keyword arguments for the eigsolve function that can be used to tune its accuracy and speed (only applicable when debugging the spectral radius)\ndebug = nothing: keyword argument for printing debug information to @debug. By default, debug is set to true if \"error_norm\" or \"spectral_radius\" is in ENV[\"JULIA_DEBUG\"], which must be set by users.\n\n\n\n\n\n","category":"type"},{"location":"matrix_fields/#ClimaCore.MatrixFields.ApproximateBlockArrowheadIterativeSolve","page":"MatrixFields","title":"ClimaCore.MatrixFields.ApproximateBlockArrowheadIterativeSolve","text":"ApproximateBlockArrowheadIterativeSolve(names₁...; [P_alg₁], [alg₁], [alg₂], [kwargs...])\n\nShorthand for constructing a SchurComplementReductionSolve whose alg₂ is set to a StationaryIterativeSolve with a BlockArrowheadSchurComplementPreconditioner. The keyword argument alg₁ is passed to the constructor for SchurComplementReductionSolve, the keyword arguments P_alg₁ and alg₂ are passed to the constructor for BlockArrowheadSchurComplementPreconditioner, and all other keyword arguments are passed to the constructor for StationaryIterativeSolve.\n\nThis algorithm is somewhat similar to a StationaryIterativeSolve with a BlockArrowheadPreconditioner, but it usually converges much more quickly, i.e., the spectral radius of its iteration matrix (I - inv(P) * A) tends to be significantly smaller. Roughly speaking, this is because it runs the iterative solver on an equation with fewer variables (the Schur complement equation, (A₂₂ - A₂₁ * inv(A₁₁) * A₁₂) * x₂ = b₂′), which means that, on each iteration, it accumulates less error due to coupling between variables. However, even though it converges more quickly, its iterations take longer because they involve using alg₁ to invert A₁₁. So, when only a few iterations are needed, a StationaryIterativeSolve with a BlockArrowheadPreconditioner might be more performant.\n\nThis algorithm is an example of a \"segregated\" solve, in contrast to the alternative \"coupled\" solve. In the context of computational fluid dynamics, this algorithm can also be viewed as a \"SIMPLE\" (Semi-Implicit Method for Pressure-Linked Equations) scheme.  For more information, see Sections 4, 5, and 10 of Numerical solution of saddle point problems.\n\n\n\n\n\n","category":"function"},{"location":"matrix_fields/#Preconditioners","page":"MatrixFields","title":"Preconditioners","text":"","category":"section"},{"location":"matrix_fields/","page":"MatrixFields","title":"MatrixFields","text":"PreconditionerAlgorithm\nMainDiagonalPreconditioner\nBlockDiagonalPreconditioner\nBlockArrowheadPreconditioner\nBlockArrowheadSchurComplementPreconditioner\nWeightedPreconditioner\nCustomPreconditioner","category":"page"},{"location":"matrix_fields/#ClimaCore.MatrixFields.PreconditionerAlgorithm","page":"MatrixFields","title":"ClimaCore.MatrixFields.PreconditionerAlgorithm","text":"PreconditionerAlgorithm\n\nDescription of how to approximate a FieldMatrix or something similar like a LazySchurComplement with a preconditioner P for which P * x = b is easy to solve for x. If P is a diagonal matrix, then x can be computed as @. inv(P) * b; otherwise, the PreconditionerAlgorithm must specify a FieldMatrixSolverAlgorithm that can be used to solve P * x = b for x.\n\nInterface\n\nEvery subtype of PreconditionerAlgorithm must implement methods for the following functions:\n\nsolver_algorithm\nlazy_preconditioner\n\n\n\n\n\n","category":"type"},{"location":"matrix_fields/#ClimaCore.MatrixFields.MainDiagonalPreconditioner","page":"MatrixFields","title":"ClimaCore.MatrixFields.MainDiagonalPreconditioner","text":"MainDiagonalPreconditioner()\n\nA PreconditionerAlgorithm that sets P to the main diagonal of A. This is also called a \"Jacobi\" preconditioner.\n\n\n\n\n\n","category":"type"},{"location":"matrix_fields/#ClimaCore.MatrixFields.BlockDiagonalPreconditioner","page":"MatrixFields","title":"ClimaCore.MatrixFields.BlockDiagonalPreconditioner","text":"BlockDiagonalPreconditioner()\n\nA PreconditionerAlgorithm that sets P to the block diagonal entries of A. This is also called a \"block Jacobi\" preconditioner.\n\n\n\n\n\n","category":"type"},{"location":"matrix_fields/#ClimaCore.MatrixFields.BlockArrowheadPreconditioner","page":"MatrixFields","title":"ClimaCore.MatrixFields.BlockArrowheadPreconditioner","text":"BlockArrowheadPreconditioner(names₁...; [P_alg₁], [alg₂])\n\nA PreconditionerAlgorithm for a 2×2 block matrix:\n\nA = beginbmatrix A_11  A_12  A_21  A_22 endbmatrix\n\nThe FieldNames in names₁ correspond to the subscript ₁, while all other FieldNames correspond to the subscript ₂. The preconditioner P is set to the following matrix:\n\nP = beginbmatrix P_11  A_12  A_21  A_22 endbmatrix quad\ntextwhere  P_11 text is a diagonal matrix\n\nThe internal preconditioner P₁₁ is generated by the PreconditionerAlgorithm P_alg₁, which is set to a MainDiagonalPreconditioner by default. The Schur complement of P₁₁ in P, A₂₂ - A₂₁ * inv(P₁₁) * A₁₂, is inverted using the FieldMatrixSolverAlgorithm alg₂, which is set to a BlockDiagonalSolve by default.\n\n\n\n\n\n","category":"type"},{"location":"matrix_fields/#ClimaCore.MatrixFields.BlockArrowheadSchurComplementPreconditioner","page":"MatrixFields","title":"ClimaCore.MatrixFields.BlockArrowheadSchurComplementPreconditioner","text":"BlockArrowheadSchurComplementPreconditioner(; [P_alg₁], [alg₂])\n\nA PreconditionerAlgorithm that is equivalent to a BlockArrowheadPreconditioner, but only applied to the Schur complement of A₁₁ in A, A₂₂ - A₂₁ * inv(A₁₁) * A₁₂, which is represented by a LazySchurComplement. Specifically, the preconditioner this generates is the Schur complement of P₁₁ in P, A₂₂ - A₂₁ * inv(P₁₁) * A₁₂, where P₁₁ is generated by P_alg₁. Unlike the BlockArrowheadPreconditioner constructor, this constructor does not require names₁ because the block structure of A can be inferred from the LazySchurComplement.\n\n\n\n\n\n","category":"type"},{"location":"matrix_fields/#ClimaCore.MatrixFields.WeightedPreconditioner","page":"MatrixFields","title":"ClimaCore.MatrixFields.WeightedPreconditioner","text":"WeightedPreconditioner(M, unweighted_P_alg)\n\nA PreconditionerAlgorithm that sets P to M * P′, where M is a diagonal FieldMatrix and P′ is the preconditioner generated by unweighted_P_alg. When the entries of M are larger than 1, this is called \"relaxation\" or \"damping\"; when the entries are smaller than 1, this is called \"extrapolation\".\n\n\n\n\n\n","category":"type"},{"location":"matrix_fields/#ClimaCore.MatrixFields.CustomPreconditioner","page":"MatrixFields","title":"ClimaCore.MatrixFields.CustomPreconditioner","text":"CustomPreconditioner(M, alg)\n\nA PreconditionerAlgorithm that sets P to the FieldMatrix M and inverts P using the FieldMatrixSolverAlgorithm alg.\n\n\n\n\n\n","category":"type"},{"location":"matrix_fields/#Internals","page":"MatrixFields","title":"Internals","text":"","category":"section"},{"location":"matrix_fields/","page":"MatrixFields","title":"MatrixFields","text":"outer_diagonals\nband_matrix_row_type\nmatrix_shape\ncolumn_axes\nAbstractLazyOperator\nreplace_lazy_operator\nFieldName\n@name\nFieldNameTree\nFieldNameSet\nFieldNameDict\nfield_vector_view\nconcrete_field_vector\nis_lazy\nlazy_main_diagonal\nlazy_mul\nLazySchurComplement\nfield_matrix_solver_cache\ncheck_field_matrix_solver\nrun_field_matrix_solver!\nsolver_algorithm\nlazy_preconditioner\npreconditioner_cache\ncheck_preconditioner\nlazy_or_concrete_preconditioner\napply_preconditioner","category":"page"},{"location":"matrix_fields/#ClimaCore.MatrixFields.outer_diagonals","page":"MatrixFields","title":"ClimaCore.MatrixFields.outer_diagonals","text":"outer_diagonals(::Type{<:BandMatrixRow})\n\nGets the indices of the lower and upper diagonals, ld and ud, of the given subtype of BandMatrixRow.\n\n\n\n\n\n","category":"function"},{"location":"matrix_fields/#ClimaCore.MatrixFields.band_matrix_row_type","page":"MatrixFields","title":"ClimaCore.MatrixFields.band_matrix_row_type","text":"band_matrix_row_type(ld, ud, T)\n\nA shorthand for getting the subtype of BandMatrixRow that has entries of type T on the diagonals with indices in the range ld:ud.\n\n\n\n\n\n","category":"function"},{"location":"matrix_fields/#ClimaCore.MatrixFields.matrix_shape","page":"MatrixFields","title":"ClimaCore.MatrixFields.matrix_shape","text":"matrix_shape(matrix_field, [matrix_space])\n\nReturns either Square(), FaceToCenter(), or CenterToFace(), depending on whether the diagonal indices of matrix_field are Ints or PlusHalfs and whether matrix_space is on cell centers or cell faces. By default, matrix_space is set to axes(matrix_field).\n\n\n\n\n\n","category":"function"},{"location":"matrix_fields/#ClimaCore.MatrixFields.column_axes","page":"MatrixFields","title":"ClimaCore.MatrixFields.column_axes","text":"column_axes(matrix_field, [matrix_space])\n\nReturns the space that corresponds to the columns of matrix_field, i.e., the axes of the Fields by which matrix_field can be multiplied. The matrix_space, on the other hand, is the space that corresponds to the rows of matrix_field. By default, matrix_space is set to axes(matrix_field).\n\n\n\n\n\n","category":"function"},{"location":"matrix_fields/#ClimaCore.MatrixFields.AbstractLazyOperator","page":"MatrixFields","title":"ClimaCore.MatrixFields.AbstractLazyOperator","text":"AbstractLazyOperator\n\nSupertype for \"lazy operators\", i.e., operators that can be called without any arguments by users, as long as they appear in broadcast expressions that contain at least one Field. If lazy_op is an AbstractLazyOperator, the expression lazy_op.() will internally be translated to non_lazy_op.(fields...), as long as it appears in a broadcast expression with at least one Field. This translation is done by the function replace_lazy_operator(space, lazy_op), which must be implemented by every subtype of AbstractLazyOperator.\n\n\n\n\n\n","category":"type"},{"location":"matrix_fields/#ClimaCore.MatrixFields.replace_lazy_operator","page":"MatrixFields","title":"ClimaCore.MatrixFields.replace_lazy_operator","text":"replace_lazy_operator(space, lazy_op)\n\nGenerates an instance of Base.AbstractBroadcasted that corresponds to the expression lazy_op.(), where the broadcast in which this expression appears is being evaluated on the given space. Note that the staggering (CellCenter or CellFace) of this space depends on the specifics of the broadcast and is not predetermined.\n\n\n\n\n\n","category":"function"},{"location":"matrix_fields/#ClimaCore.MatrixFields.FieldName","page":"MatrixFields","title":"ClimaCore.MatrixFields.FieldName","text":"FieldName(name_chain...)\n\nA singleton type that represents a chain of getproperty calls, which can be used to access a property or sub-property of an object x using the function get_field(x, name). The entire object x can also be accessed with the empty FieldName().\n\n\n\n\n\n","category":"type"},{"location":"matrix_fields/#ClimaCore.MatrixFields.@name","page":"MatrixFields","title":"ClimaCore.MatrixFields.@name","text":"@name(expr)\n\nShorthand for constructing a FieldName. Some examples include\n\nname = @name(), in which case get_field(x, name) returns x\nname = @name(a), in which case get_field(x, name) returns x.a\nname = @name(a.b.c), in which case get_field(x, name) returns x.a.b.c\nname = @name(a.b.c.:(1).d), in which case get_field(x, name) returns x.a.b.c.:(1).d\n\nThis macro is preferred over the FieldName constructor because it checks whether expr is a syntactically valid chain of getproperty calls before calling the constructor.\n\n\n\n\n\n","category":"macro"},{"location":"matrix_fields/#ClimaCore.MatrixFields.FieldNameTree","page":"MatrixFields","title":"ClimaCore.MatrixFields.FieldNameTree","text":"FieldNameTree(x)\n\nTree of FieldNames that can be used to access x with get_field(x, name). Check whether a name is valid by calling is_valid_name(name, tree), and extract the children of name by calling child_names(name, tree).\n\n\n\n\n\n","category":"type"},{"location":"matrix_fields/#ClimaCore.MatrixFields.FieldNameSet","page":"MatrixFields","title":"ClimaCore.MatrixFields.FieldNameSet","text":"FieldNameSet{T}(values, [name_tree])\n\nAn AbstractSet that contains values of type T, which serves as an analogue of a KeySet for a FieldNameDict. There are two subtypes of FieldNameSet:\n\nFieldVectorKeys, for which T is set to FieldName\nFieldMatrixKeys, for which T is set to Tuple{FieldName, FieldName}; each tuple of type T represents a pair of row-column indices\n\nSince FieldNames are singleton types, the result of almost any FieldNameSet operation can be inferred during compilation. So, with the exception of map, foreach, and set_string, functions of FieldNameSets do not have any performance cost at runtime (as long as their arguments are inferrable).\n\nUnlike other AbstractSets, FieldNameSet has special behavior for overlapping values. For example, the FieldNames @name(a.b) and @name(a.b.c) overlap, so any set operation needs to first decompose @name(a.b) into its child values before combining it with @name(a.b.c). In order to support this (and also to support the ability to compute set complements), FieldNameSet stores a FieldNameTree name_tree, which it uses to infer child values. If name_tree is not specified, it gets set to nothing by default, which causes some FieldNameSet operations to become disabled. For binary operations like union or setdiff, only one set needs to specify a name_tree; if two sets both specify a name_tree, the name_trees must be identical.\n\n\n\n\n\n","category":"type"},{"location":"matrix_fields/#ClimaCore.MatrixFields.FieldNameDict","page":"MatrixFields","title":"ClimaCore.MatrixFields.FieldNameDict","text":"FieldNameDict(keys, entries)\nFieldNameDict{T}(key_entry_pairs...)\n\nAn AbstractDict with keys of type T that are stored as a FieldNameSet{T}. There are two subtypes of FieldNameDict:\n\nFieldMatrix, which maps a set of FieldMatrixKeys to either ColumnwiseBandMatrixFields or multiples of LinearAlgebra.I; this is the only user-facing subtype of FieldNameDict\nFieldVectorView, which maps a set of FieldVectorKeys to Fields; this subtype is automatically generated when a FieldVector is used in the same operation as a FieldMatrix (e.g., when both appear in the same broadcast expression, or when both are passed to a FieldMatrixSolver)\n\nA FieldNameDict can also be \"lazy\", which means that it can store AbstractBroadcasted objects that become Fields when they are materialized. Many internal operations generate lazy FieldNameDicts to reduce the number of calls to materialize!, since each call comes with a small performance penalty.\n\nThe entry at a specific key can be extracted by calling dict[key], and the entries that correspond to all the keys in a FieldNameSet can be extracted by calling dict[set]. If dict is a FieldMatrix, the corresponding identity matrix can be computed by calling one(dict).\n\nWhen broadcasting over FieldNameDicts, the following operations are supported:\n\nAddition and subtraction\nMultiplication, where the first argument must be a FieldMatrix\nInversion, where the argument must be a diagonal FieldMatrix, i.e., one in which every entry is either a ColumnwiseBandMatrixField of DiagonalMatrixRows or a multiple of LinearAlgebra.I\n\n\n\n\n\n","category":"type"},{"location":"matrix_fields/#ClimaCore.MatrixFields.field_vector_view","page":"MatrixFields","title":"ClimaCore.MatrixFields.field_vector_view","text":"field_vector_view(x, [name_tree])\n\nConstructs a FieldVectorView that contains all of the Fields in the FieldVector x. The default name_tree is FieldNameTree(x), but this can be modified if needed.\n\n\n\n\n\n","category":"function"},{"location":"matrix_fields/#ClimaCore.MatrixFields.concrete_field_vector","page":"MatrixFields","title":"ClimaCore.MatrixFields.concrete_field_vector","text":"concrete_field_vector(vector)\n\nConverts the FieldVectorView vector back into a FieldVector.\n\n\n\n\n\n","category":"function"},{"location":"matrix_fields/#ClimaCore.MatrixFields.is_lazy","page":"MatrixFields","title":"ClimaCore.MatrixFields.is_lazy","text":"is_lazy(dict)\n\nChecks whether the FieldNameDict dict contains any un-materialized AbstractBroadcasted entries.\n\n\n\n\n\n","category":"function"},{"location":"matrix_fields/#ClimaCore.MatrixFields.lazy_main_diagonal","page":"MatrixFields","title":"ClimaCore.MatrixFields.lazy_main_diagonal","text":"lazy_main_diagonal(matrix)\n\nConstructs a lazy FieldMatrix that contains the main diagonal of matrix.\n\n\n\n\n\n","category":"function"},{"location":"matrix_fields/#ClimaCore.MatrixFields.lazy_mul","page":"MatrixFields","title":"ClimaCore.MatrixFields.lazy_mul","text":"lazy_mul(A, args...)\n\nConstructs a lazy FieldMatrix that represents the product @. *(A, args...). This involves regular broadcasting when A is a FieldMatrix, but it has more complex behavior for other objects like the LazySchurComplement.\n\n\n\n\n\n","category":"function"},{"location":"matrix_fields/#ClimaCore.MatrixFields.LazySchurComplement","page":"MatrixFields","title":"ClimaCore.MatrixFields.LazySchurComplement","text":"LazySchurComplement(A₁₁, A₁₂, A₂₁, A₂₂, [alg₁, cache₁, A₁₂_x₂, invA₁₁_A₁₂_x₂])\n\nAn analogue of a FieldMatrix that represents the Schur complement of A₁₁ in A, A₂₂ - A₂₁ * inv(A₁₁) * A₁₂. Since inv(A₁₁) will generally be a dense matrix, it would not be efficient to directly compute the Schur complement. So, this object only supports the \"lazy\" functions lazy_mul, which allows it to be multiplied by the vector x₂, and lazy_preconditioner, which allows it to be approximated with a FieldMatrix.\n\nThe values alg₁, cache₁, A₁₂_x₂, and invA₁₁_A₁₂_x₂ need to be specified in order for lazy_mul to be able to compute inv(A₁₁) * A₁₂ * x₂. When a LazySchurComplement is not passed to lazy_mul, these values can be omitted.\n\n\n\n\n\n","category":"type"},{"location":"matrix_fields/#ClimaCore.MatrixFields.field_matrix_solver_cache","page":"MatrixFields","title":"ClimaCore.MatrixFields.field_matrix_solver_cache","text":"field_matrix_solver_cache(alg, A, b)\n\nAllocates the cache required by the FieldMatrixSolverAlgorithm alg to solve the equation A * x = b.\n\n\n\n\n\n","category":"function"},{"location":"matrix_fields/#ClimaCore.MatrixFields.check_field_matrix_solver","page":"MatrixFields","title":"ClimaCore.MatrixFields.check_field_matrix_solver","text":"check_field_matrix_solver(alg, cache, A, b)\n\nChecks that the sparsity structure of A is supported by the FieldMatrixSolverAlgorithm alg, and that A is compatible with b in the equation A * x = b.\n\n\n\n\n\n","category":"function"},{"location":"matrix_fields/#ClimaCore.MatrixFields.run_field_matrix_solver!","page":"MatrixFields","title":"ClimaCore.MatrixFields.run_field_matrix_solver!","text":"run_field_matrix_solver!(alg, cache, x, A, b)\n\nSets x to the value that solves the equation A * x = b using the FieldMatrixSolverAlgorithm alg.\n\n\n\n\n\n","category":"function"},{"location":"matrix_fields/#ClimaCore.MatrixFields.solver_algorithm","page":"MatrixFields","title":"ClimaCore.MatrixFields.solver_algorithm","text":"solver_algorithm(P_alg)\n\nA FieldMatrixSolverAlgorithm that can be used to solve P * x = b for x, where P is the preconditioner generated by the PreconditionerAlgorithm P_alg. If P_alg is nothing instead of a PreconditionerAlgorithm, or if P is a diagonal matrix (and no solver is required to invert it), this returns nothing.\n\n\n\n\n\n","category":"function"},{"location":"matrix_fields/#ClimaCore.MatrixFields.lazy_preconditioner","page":"MatrixFields","title":"ClimaCore.MatrixFields.lazy_preconditioner","text":"lazy_preconditioner(P_alg, A)\n\nConstructs a lazy FieldMatrix (or a concrete one when possible) that approximates A according to the PreconditionerAlgorithm P_alg. If P_alg is nothing instead of a PreconditionerAlgorithm, this returns one(A).\n\n\n\n\n\n","category":"function"},{"location":"matrix_fields/#ClimaCore.MatrixFields.preconditioner_cache","page":"MatrixFields","title":"ClimaCore.MatrixFields.preconditioner_cache","text":"preconditioner_cache(P_alg, A, b)\n\nAllocates the cache required to solve the equation P * x = b, where P is the preconditioner generated by the PreconditionerAlgorithm P_alg for A.\n\n\n\n\n\n","category":"function"},{"location":"matrix_fields/#ClimaCore.MatrixFields.check_preconditioner","page":"MatrixFields","title":"ClimaCore.MatrixFields.check_preconditioner","text":"check_preconditioner(P_alg, P_cache, A, b)\n\nChecks that P is compatible with b in the equation P * x = b, where P is the preconditioner generated by the PreconditionerAlgorithm P_alg for A. If P_alg requires a FieldMatrixSolverAlgorithm alg to solve the equation, this also calls check_field_matrix_solver on alg.\n\n\n\n\n\n","category":"function"},{"location":"matrix_fields/#ClimaCore.MatrixFields.lazy_or_concrete_preconditioner","page":"MatrixFields","title":"ClimaCore.MatrixFields.lazy_or_concrete_preconditioner","text":"lazy_or_concrete_preconditioner(P_alg, P_cache, A)\n\nA wrapper for lazy_preconditioner that turns the lazy FieldMatrix P into a concrete FieldMatrix when the PreconditionerAlgorithm P_alg requires a FieldMatrixSolverAlgorithm to invert it.\n\n\n\n\n\n","category":"function"},{"location":"matrix_fields/#ClimaCore.MatrixFields.apply_preconditioner","page":"MatrixFields","title":"ClimaCore.MatrixFields.apply_preconditioner","text":"apply_preconditioner(P_alg, P_cache, P, lazy_b)\n\nConstructs a lazy FieldMatrix (or a concrete one when possible) that represents the product @. inv(P) * b. Here, lazy_b is a (possibly lazy) FieldVectorView that represents b.\n\n\n\n\n\n","category":"function"},{"location":"matrix_fields/#Utilities","page":"MatrixFields","title":"Utilities","text":"","category":"section"},{"location":"matrix_fields/","page":"MatrixFields","title":"MatrixFields","text":"column_field2array\ncolumn_field2array_view\nfield2arrays\nfield2arrays_view","category":"page"},{"location":"matrix_fields/#ClimaCore.MatrixFields.column_field2array","page":"MatrixFields","title":"ClimaCore.MatrixFields.column_field2array","text":"column_field2array(field)\n\nConverts a field defined on a FiniteDifferenceSpace into either a Vector or a BandedMatrix, depending on whether the elements of the field are single values or BandMatrixRows. This involves copying the data stored in the field. Because BandedMatrix does not currently support operations with CuArrays, all GPU data is copied to the CPU.\n\n\n\n\n\n","category":"function"},{"location":"matrix_fields/#ClimaCore.MatrixFields.column_field2array_view","page":"MatrixFields","title":"ClimaCore.MatrixFields.column_field2array_view","text":"column_field2array_view(field)\n\nSimilar to column_field2array(field), except that this version avoids copying the data stored in the field.\n\n\n\n\n\n","category":"function"},{"location":"matrix_fields/#ClimaCore.MatrixFields.field2arrays","page":"MatrixFields","title":"ClimaCore.MatrixFields.field2arrays","text":"field2arrays(field)\n\nConverts a field defined on a FiniteDifferenceSpace or on an ExtrudedFiniteDifferenceSpace into a collection of arrays, each of which corresponds to a column of the field. This is done by calling column_field2array on each of the field's columns.\n\n\n\n\n\n","category":"function"},{"location":"matrix_fields/#ClimaCore.MatrixFields.field2arrays_view","page":"MatrixFields","title":"ClimaCore.MatrixFields.field2arrays_view","text":"field2arrays_view(field)\n\nSimilar to field2arrays(field), except that this version calls column_field2array_view instead of column_field2array.\n\n\n\n\n\n","category":"function"},{"location":"tutorials/introduction/","page":"Introduction to ClimaCore.jl","title":"Introduction to ClimaCore.jl","text":"EditURL = \"../../tutorials/introduction.jl\"","category":"page"},{"location":"tutorials/introduction/#Introduction-to-ClimaCore.jl","page":"Introduction to ClimaCore.jl","title":"Introduction to ClimaCore.jl","text":"","category":"section"},{"location":"tutorials/introduction/","page":"Introduction to ClimaCore.jl","title":"Introduction to ClimaCore.jl","text":"This tutorial is available as a Jupyter notebook.","category":"page"},{"location":"tutorials/introduction/#What-is-ClimaCore?","page":"Introduction to ClimaCore.jl","title":"What is ClimaCore?","text":"","category":"section"},{"location":"tutorials/introduction/","page":"Introduction to ClimaCore.jl","title":"Introduction to ClimaCore.jl","text":"A suite of tools for constructing spatial discretizations","category":"page"},{"location":"tutorials/introduction/","page":"Introduction to ClimaCore.jl","title":"Introduction to ClimaCore.jl","text":"primarily aimed at climate and weather models\ninitial aim:\nspectral element discretization in the horizontal\nstaggered finite difference in the vertical\ncurrently under development","category":"page"},{"location":"tutorials/introduction/","page":"Introduction to ClimaCore.jl","title":"Introduction to ClimaCore.jl","text":"using ClimaComms,\n    ClimaCore,\n    ClimaCorePlots,\n    LinearAlgebra,\n    IntervalSets,\n    Plots,\n    OrdinaryDiffEq","category":"page"},{"location":"tutorials/introduction/#1.-Constructing-a-discretization","page":"Introduction to ClimaCore.jl","title":"1. Constructing a discretization","text":"","category":"section"},{"location":"tutorials/introduction/#1.1-Domains","page":"Introduction to ClimaCore.jl","title":"1.1 Domains","text":"","category":"section"},{"location":"tutorials/introduction/","page":"Introduction to ClimaCore.jl","title":"Introduction to ClimaCore.jl","text":"A domain is a region of space (think of a mathematical domain).","category":"page"},{"location":"tutorials/introduction/","page":"Introduction to ClimaCore.jl","title":"Introduction to ClimaCore.jl","text":"column_domain = ClimaCore.Domains.IntervalDomain(\n    ClimaCore.Geometry.ZPoint(0.0) .. ClimaCore.Geometry.ZPoint(10.0),\n    boundary_names = (:bottom, :top),\n)","category":"page"},{"location":"tutorials/introduction/","page":"Introduction to ClimaCore.jl","title":"Introduction to ClimaCore.jl","text":"rectangle_domain = ClimaCore.Domains.RectangleDomain(\n    ClimaCore.Geometry.XPoint(-2π) .. ClimaCore.Geometry.XPoint(2π),\n    ClimaCore.Geometry.YPoint(-2π) .. ClimaCore.Geometry.YPoint(2π),\n    x1periodic = true,\n    x2periodic = true,\n)","category":"page"},{"location":"tutorials/introduction/#1.2-Meshes","page":"Introduction to ClimaCore.jl","title":"1.2 Meshes","text":"","category":"section"},{"location":"tutorials/introduction/","page":"Introduction to ClimaCore.jl","title":"Introduction to ClimaCore.jl","text":"A mesh is a division of a domain into elements","category":"page"},{"location":"tutorials/introduction/","page":"Introduction to ClimaCore.jl","title":"Introduction to ClimaCore.jl","text":"column_mesh = ClimaCore.Meshes.IntervalMesh(column_domain, nelems = 32)","category":"page"},{"location":"tutorials/introduction/","page":"Introduction to ClimaCore.jl","title":"Introduction to ClimaCore.jl","text":"rectangle_mesh = ClimaCore.Meshes.RectilinearMesh(rectangle_domain, 16, 16)","category":"page"},{"location":"tutorials/introduction/#1.3-Topologies","page":"Introduction to ClimaCore.jl","title":"1.3 Topologies","text":"","category":"section"},{"location":"tutorials/introduction/","page":"Introduction to ClimaCore.jl","title":"Introduction to ClimaCore.jl","text":"A topology determines the ordering and connections between elements of a mesh","category":"page"},{"location":"tutorials/introduction/","page":"Introduction to ClimaCore.jl","title":"Introduction to ClimaCore.jl","text":"At the moment, this is only required for 2D meshes","category":"page"},{"location":"tutorials/introduction/","page":"Introduction to ClimaCore.jl","title":"Introduction to ClimaCore.jl","text":"device = ClimaComms.device()\nrectangle_topology = ClimaCore.Topologies.Topology2D(\n    ClimaComms.SingletonCommsContext(device),\n    rectangle_mesh,\n)","category":"page"},{"location":"tutorials/introduction/#1.4-Spaces","page":"Introduction to ClimaCore.jl","title":"1.4 Spaces","text":"","category":"section"},{"location":"tutorials/introduction/","page":"Introduction to ClimaCore.jl","title":"Introduction to ClimaCore.jl","text":"A space represents a discretized function space over some domain. Currently two discretizations are supported.","category":"page"},{"location":"tutorials/introduction/#1.4.1-Staggered-finite-difference-discretization","page":"Introduction to ClimaCore.jl","title":"1.4.1 Staggered finite difference discretization","text":"","category":"section"},{"location":"tutorials/introduction/","page":"Introduction to ClimaCore.jl","title":"Introduction to ClimaCore.jl","text":"This discretizes an interval domain by approximating the function by a value at either the center of each element (CenterFiniteDifferenceSpace), or the faces between elements (FaceFiniteDifferenceSpace).","category":"page"},{"location":"tutorials/introduction/","page":"Introduction to ClimaCore.jl","title":"Introduction to ClimaCore.jl","text":"You can construct either the center or face space from the mesh, then construct the opposite space from the original one (this is to avoid allocating additional memory).","category":"page"},{"location":"tutorials/introduction/","page":"Introduction to ClimaCore.jl","title":"Introduction to ClimaCore.jl","text":"column_center_space =\n    ClimaCore.Spaces.CenterFiniteDifferenceSpace(device, column_mesh)\n# construct the face space from the center one\ncolumn_face_space =\n    ClimaCore.Spaces.FaceFiniteDifferenceSpace(column_center_space)","category":"page"},{"location":"tutorials/introduction/#1.4.2-Spectral-element-discretization","page":"Introduction to ClimaCore.jl","title":"1.4.2 Spectral element discretization","text":"","category":"section"},{"location":"tutorials/introduction/","page":"Introduction to ClimaCore.jl","title":"Introduction to ClimaCore.jl","text":"A spectral element space approximates the function with polynomials in each element. The polynomials are represented using a nodal discretization, which stores the values of the polynomials at particular points in each element (termed nodes or degrees of freedom).","category":"page"},{"location":"tutorials/introduction/","page":"Introduction to ClimaCore.jl","title":"Introduction to ClimaCore.jl","text":"These nodes are chosen by a particular quadrature rule, which allows us to integrate functions over the domain. The only supported choice for now is a Gauss-Legendre-Lobatto rule.","category":"page"},{"location":"tutorials/introduction/","page":"Introduction to ClimaCore.jl","title":"Introduction to ClimaCore.jl","text":"# Gauss-Legendre-Lobatto quadrature with 4 nodes in each direction, so 16 in each element\nquad = ClimaCore.Quadratures.GLL{4}()\nrectangle_space =\n    ClimaCore.Spaces.SpectralElementSpace2D(rectangle_topology, quad)","category":"page"},{"location":"tutorials/introduction/#1.5-Fields","page":"Introduction to ClimaCore.jl","title":"1.5 Fields","text":"","category":"section"},{"location":"tutorials/introduction/","page":"Introduction to ClimaCore.jl","title":"Introduction to ClimaCore.jl","text":"Finally, we can construct a field: a function in a space. A field is simply a space and the values at each node in the space.","category":"page"},{"location":"tutorials/introduction/","page":"Introduction to ClimaCore.jl","title":"Introduction to ClimaCore.jl","text":"The easiest field to construct is the coordinate field","category":"page"},{"location":"tutorials/introduction/","page":"Introduction to ClimaCore.jl","title":"Introduction to ClimaCore.jl","text":"coord = ClimaCore.Fields.coordinate_field(rectangle_space)","category":"page"},{"location":"tutorials/introduction/","page":"Introduction to ClimaCore.jl","title":"Introduction to ClimaCore.jl","text":"This is a struct-value field: it contains coordinates in a struct at each point. We can extract just the x coordinate, to get a scalar field:","category":"page"},{"location":"tutorials/introduction/","page":"Introduction to ClimaCore.jl","title":"Introduction to ClimaCore.jl","text":"x = coord.x","category":"page"},{"location":"tutorials/introduction/","page":"Introduction to ClimaCore.jl","title":"Introduction to ClimaCore.jl","text":"Although you can't index directly into a field, it can be used in some other ways similar to a Julia Array. For example, broadcasting can be used to define new fields in terms of other ones:","category":"page"},{"location":"tutorials/introduction/","page":"Introduction to ClimaCore.jl","title":"Introduction to ClimaCore.jl","text":"sinx = sin.(x)","category":"page"},{"location":"tutorials/introduction/","page":"Introduction to ClimaCore.jl","title":"Introduction to ClimaCore.jl","text":"Fields can be easily vizualized with Plots.jl:","category":"page"},{"location":"tutorials/introduction/","page":"Introduction to ClimaCore.jl","title":"Introduction to ClimaCore.jl","text":"import Plots\nPlots.plot(sinx)","category":"page"},{"location":"tutorials/introduction/","page":"Introduction to ClimaCore.jl","title":"Introduction to ClimaCore.jl","text":"If you're using the terminal, UnicodePlots is also supported.","category":"page"},{"location":"tutorials/introduction/","page":"Introduction to ClimaCore.jl","title":"Introduction to ClimaCore.jl","text":"This works similarly for finite difference discretizations","category":"page"},{"location":"tutorials/introduction/","page":"Introduction to ClimaCore.jl","title":"Introduction to ClimaCore.jl","text":"column_center_coords = ClimaCore.Fields.coordinate_field(column_center_space)\ncolumn_face_coords = ClimaCore.Fields.coordinate_field(column_face_space)","category":"page"},{"location":"tutorials/introduction/","page":"Introduction to ClimaCore.jl","title":"Introduction to ClimaCore.jl","text":"plot(sin.(column_center_coords.z), ylim = (0.0, 10.0))\nplot!(cos.(column_face_coords.z), ylim = (0.0, 10.0))","category":"page"},{"location":"tutorials/introduction/","page":"Introduction to ClimaCore.jl","title":"Introduction to ClimaCore.jl","text":"Reduction operations are defined anologously:","category":"page"},{"location":"tutorials/introduction/","page":"Introduction to ClimaCore.jl","title":"Introduction to ClimaCore.jl","text":"sum will give the integral of the function","category":"page"},{"location":"tutorials/introduction/","page":"Introduction to ClimaCore.jl","title":"Introduction to ClimaCore.jl","text":"int_D f(x) dx","category":"page"},{"location":"tutorials/introduction/","page":"Introduction to ClimaCore.jl","title":"Introduction to ClimaCore.jl","text":"norm will give the L² function norm","category":"page"},{"location":"tutorials/introduction/","page":"Introduction to ClimaCore.jl","title":"Introduction to ClimaCore.jl","text":"sqrtint_D f(x)^2 dx","category":"page"},{"location":"tutorials/introduction/","page":"Introduction to ClimaCore.jl","title":"Introduction to ClimaCore.jl","text":"sum(sinx) ## integral","category":"page"},{"location":"tutorials/introduction/","page":"Introduction to ClimaCore.jl","title":"Introduction to ClimaCore.jl","text":"norm(sinx) ## L² norm","category":"page"},{"location":"tutorials/introduction/#1.6-Vectors-and-vector-fields","page":"Introduction to ClimaCore.jl","title":"1.6 Vectors and vector fields","text":"","category":"section"},{"location":"tutorials/introduction/","page":"Introduction to ClimaCore.jl","title":"Introduction to ClimaCore.jl","text":"A vector field is a field with vector-valued quantity, i.e. at every point in space, you have a vector.","category":"page"},{"location":"tutorials/introduction/","page":"Introduction to ClimaCore.jl","title":"Introduction to ClimaCore.jl","text":"However one of the key requirements of ClimaCore is to support vectors specified in curvilinear or non-Cartesian coordinates. We will discuss this in a bit further, but for now, you can define a 2-dimensional vector field using Geometry.UVVector:","category":"page"},{"location":"tutorials/introduction/","page":"Introduction to ClimaCore.jl","title":"Introduction to ClimaCore.jl","text":"v = ClimaCore.Geometry.UVVector.(coord.y, .-coord.x)","category":"page"},{"location":"tutorials/introduction/#2.-Operators","page":"Introduction to ClimaCore.jl","title":"2. Operators","text":"","category":"section"},{"location":"tutorials/introduction/","page":"Introduction to ClimaCore.jl","title":"Introduction to ClimaCore.jl","text":"Operators can compute spatial derivative operations.","category":"page"},{"location":"tutorials/introduction/","page":"Introduction to ClimaCore.jl","title":"Introduction to ClimaCore.jl","text":"for performance reasons, we need to be able to \"fuse\" multiple operators and function applications\nJulia provides a tool for this: broadcasting, with a very flexible API","category":"page"},{"location":"tutorials/introduction/","page":"Introduction to ClimaCore.jl","title":"Introduction to ClimaCore.jl","text":"Can think of operators are \"pseudo-functions\": can't be called directly, but act similar to functions in the context of broadcasting.","category":"page"},{"location":"tutorials/introduction/#2.1-Spectral-element-operators","page":"Introduction to ClimaCore.jl","title":"2.1 Spectral element operators","text":"","category":"section"},{"location":"tutorials/introduction/","page":"Introduction to ClimaCore.jl","title":"Introduction to ClimaCore.jl","text":"The Gradient operator takes the gradient of a scalar field, and returns a vector field.","category":"page"},{"location":"tutorials/introduction/","page":"Introduction to ClimaCore.jl","title":"Introduction to ClimaCore.jl","text":"grad = ClimaCore.Operators.Gradient()\n∇sinx = grad.(sinx)","category":"page"},{"location":"tutorials/introduction/","page":"Introduction to ClimaCore.jl","title":"Introduction to ClimaCore.jl","text":"plot(∇sinx.components.data.:1, clim = (-1, 1))","category":"page"},{"location":"tutorials/introduction/","page":"Introduction to ClimaCore.jl","title":"Introduction to ClimaCore.jl","text":"This returns the gradient in covariant coordinates","category":"page"},{"location":"tutorials/introduction/","page":"Introduction to ClimaCore.jl","title":"Introduction to ClimaCore.jl","text":"(nabla f)_i = fracpartial fpartial xi^i","category":"page"},{"location":"tutorials/introduction/","page":"Introduction to ClimaCore.jl","title":"Introduction to ClimaCore.jl","text":"where (xi^1xi^2) are the coordinates in the reference element: a square -11^2.","category":"page"},{"location":"tutorials/introduction/","page":"Introduction to ClimaCore.jl","title":"Introduction to ClimaCore.jl","text":"This can be converted to a local orthogonal basis by multiplying by the partial derivative matrix","category":"page"},{"location":"tutorials/introduction/","page":"Introduction to ClimaCore.jl","title":"Introduction to ClimaCore.jl","text":"fracpartial xipartial x","category":"page"},{"location":"tutorials/introduction/","page":"Introduction to ClimaCore.jl","title":"Introduction to ClimaCore.jl","text":"This can be done calling ClimaCore.Geometry.LocalVector:","category":"page"},{"location":"tutorials/introduction/","page":"Introduction to ClimaCore.jl","title":"Introduction to ClimaCore.jl","text":"∇sinx_cart = ClimaCore.Geometry.LocalVector.(∇sinx)","category":"page"},{"location":"tutorials/introduction/","page":"Introduction to ClimaCore.jl","title":"Introduction to ClimaCore.jl","text":"plot(∇sinx_cart.components.data.:1, clim = (-1, 1))","category":"page"},{"location":"tutorials/introduction/","page":"Introduction to ClimaCore.jl","title":"Introduction to ClimaCore.jl","text":"plot(∇sinx_cart.components.data.:2, clim = (-1, 1))","category":"page"},{"location":"tutorials/introduction/","page":"Introduction to ClimaCore.jl","title":"Introduction to ClimaCore.jl","text":"∇sinx_ref = ClimaCore.Geometry.UVVector.(cos.(x), 0.0)\nnorm(∇sinx_cart .- ∇sinx_ref)","category":"page"},{"location":"tutorials/introduction/","page":"Introduction to ClimaCore.jl","title":"Introduction to ClimaCore.jl","text":"Similarly, the Divergence operator takes the divergence of vector field, and returns a scalar field.","category":"page"},{"location":"tutorials/introduction/","page":"Introduction to ClimaCore.jl","title":"Introduction to ClimaCore.jl","text":"If we take the divergence of a gradient, we can get a Laplacian:","category":"page"},{"location":"tutorials/introduction/","page":"Introduction to ClimaCore.jl","title":"Introduction to ClimaCore.jl","text":"div = ClimaCore.Operators.Divergence()\n∇²sinx = div.(grad.(sinx))\nplot(∇²sinx)","category":"page"},{"location":"tutorials/introduction/","page":"Introduction to ClimaCore.jl","title":"Introduction to ClimaCore.jl","text":"Note: In curvilinear coordinates, the divergence is defined in terms of the contravariant components u^i:","category":"page"},{"location":"tutorials/introduction/","page":"Introduction to ClimaCore.jl","title":"Introduction to ClimaCore.jl","text":"nabla cdot u = frac1J sum_i fracpartialpartial xi^i (J u^i)","category":"page"},{"location":"tutorials/introduction/","page":"Introduction to ClimaCore.jl","title":"Introduction to ClimaCore.jl","text":"The Divergence operator handles this conversion internally.","category":"page"},{"location":"tutorials/introduction/#2.1.1-Direct-stiffness-summation","page":"Introduction to ClimaCore.jl","title":"2.1.1 Direct stiffness summation","text":"","category":"section"},{"location":"tutorials/introduction/","page":"Introduction to ClimaCore.jl","title":"Introduction to ClimaCore.jl","text":"Spectral element operators only operate within a single element, and so the result may be discontinuous. To address this, the usual fix is direct stiffness summation (DSS), which averages the values at the element boundaries.","category":"page"},{"location":"tutorials/introduction/","page":"Introduction to ClimaCore.jl","title":"Introduction to ClimaCore.jl","text":"This corresponds to the L^2 projection onto the subset of continuous functions in our function space.","category":"page"},{"location":"tutorials/introduction/","page":"Introduction to ClimaCore.jl","title":"Introduction to ClimaCore.jl","text":"∇²sinx_dss = ClimaCore.Spaces.weighted_dss!(copy(∇²sinx))\nplot(∇²sinx_dss)","category":"page"},{"location":"tutorials/introduction/","page":"Introduction to ClimaCore.jl","title":"Introduction to ClimaCore.jl","text":"plot(∇²sinx_dss .- ∇²sinx)","category":"page"},{"location":"tutorials/introduction/#2.2-Finite-difference-operators","page":"Introduction to ClimaCore.jl","title":"2.2 Finite difference operators","text":"","category":"section"},{"location":"tutorials/introduction/","page":"Introduction to ClimaCore.jl","title":"Introduction to ClimaCore.jl","text":"Finite difference operators are similar with some subtle differences:","category":"page"},{"location":"tutorials/introduction/","page":"Introduction to ClimaCore.jl","title":"Introduction to ClimaCore.jl","text":"they can change staggering (center to face, or vice versa)\nthey can span multiple elements\nno DSS is required\nboundary handling may be required","category":"page"},{"location":"tutorials/introduction/","page":"Introduction to ClimaCore.jl","title":"Introduction to ClimaCore.jl","text":"We use the following convention:","category":"page"},{"location":"tutorials/introduction/","page":"Introduction to ClimaCore.jl","title":"Introduction to ClimaCore.jl","text":"centers are indexed by integers 1, 2, ..., n\nfaces are indexed by half integers ½, 1+½, ..., n+½","category":"page"},{"location":"tutorials/introduction/","page":"Introduction to ClimaCore.jl","title":"Introduction to ClimaCore.jl","text":"Face to center gradient","category":"page"},{"location":"tutorials/introduction/","page":"Introduction to ClimaCore.jl","title":"Introduction to ClimaCore.jl","text":"An finite-difference operator defines a stencil. For example, the gradient operator","category":"page"},{"location":"tutorials/introduction/","page":"Introduction to ClimaCore.jl","title":"Introduction to ClimaCore.jl","text":"nablathetai = fractheta i+tfrac12 - thetai-tfrac12Delta z","category":"page"},{"location":"tutorials/introduction/","page":"Introduction to ClimaCore.jl","title":"Introduction to ClimaCore.jl","text":"(actually, a little more complicated as it gives a vector in a covariant basis)","category":"page"},{"location":"tutorials/introduction/","page":"Introduction to ClimaCore.jl","title":"Introduction to ClimaCore.jl","text":"        ...\n      /\nθ[2+½]\n      \\\n        ∇θ[2]\n      /\nθ[1+½]\n      \\\n        ∇θ[1]\n      /\nθ[½]","category":"page"},{"location":"tutorials/introduction/","page":"Introduction to ClimaCore.jl","title":"Introduction to ClimaCore.jl","text":"Every center value is well-defined, so boundary handling is optional.","category":"page"},{"location":"tutorials/introduction/","page":"Introduction to ClimaCore.jl","title":"Introduction to ClimaCore.jl","text":"cosz = cos.(column_face_coords.z)\ngradf2c = ClimaCore.Operators.GradientF2C()\n∇cosz = gradf2c.(cosz)","category":"page"},{"location":"tutorials/introduction/","page":"Introduction to ClimaCore.jl","title":"Introduction to ClimaCore.jl","text":"plot(map(x -> x.w, ClimaCore.Geometry.WVector.(∇cosz)), ylim = (0, 10))","category":"page"},{"location":"tutorials/introduction/","page":"Introduction to ClimaCore.jl","title":"Introduction to ClimaCore.jl","text":"Center to face gradient","category":"page"},{"location":"tutorials/introduction/","page":"Introduction to ClimaCore.jl","title":"Introduction to ClimaCore.jl","text":"Uses the same stencil, but doesn't work directly:","category":"page"},{"location":"tutorials/introduction/","page":"Introduction to ClimaCore.jl","title":"Introduction to ClimaCore.jl","text":"sinz = sin.(column_center_coords.z)\ngradc2f = ClimaCore.Operators.GradientC2F()\n# ∇sinz = gradc2f.(sinz) ## this would throw an error","category":"page"},{"location":"tutorials/introduction/","page":"Introduction to ClimaCore.jl","title":"Introduction to ClimaCore.jl","text":"This throws an error because face values at the boundary are not well-defined:","category":"page"},{"location":"tutorials/introduction/","page":"Introduction to ClimaCore.jl","title":"Introduction to ClimaCore.jl","text":"...\n      \\\n        ∇θ[2+½]\n      /\nθ[2]\n      \\\n        ∇θ[1+½]\n      /\nθ[1]\n      \\\n        ????","category":"page"},{"location":"tutorials/introduction/","page":"Introduction to ClimaCore.jl","title":"Introduction to ClimaCore.jl","text":"To handle boundaries we need to modify the stencil. Two options:","category":"page"},{"location":"tutorials/introduction/","page":"Introduction to ClimaCore.jl","title":"Introduction to ClimaCore.jl","text":"provide the value theta^* of theta at the boundary:","category":"page"},{"location":"tutorials/introduction/","page":"Introduction to ClimaCore.jl","title":"Introduction to ClimaCore.jl","text":"nablathetatfrac12 = fractheta1 - theta^*Delta z 2","category":"page"},{"location":"tutorials/introduction/","page":"Introduction to ClimaCore.jl","title":"Introduction to ClimaCore.jl","text":"provide the gradient nablatheta^* of theta at the boundary:","category":"page"},{"location":"tutorials/introduction/","page":"Introduction to ClimaCore.jl","title":"Introduction to ClimaCore.jl","text":"nablathetatfrac12 = nablatheta^*","category":"page"},{"location":"tutorials/introduction/","page":"Introduction to ClimaCore.jl","title":"Introduction to ClimaCore.jl","text":"These modified stencils are provided as keyword arguments to the operator (based on the boundary label names):","category":"page"},{"location":"tutorials/introduction/","page":"Introduction to ClimaCore.jl","title":"Introduction to ClimaCore.jl","text":"sinz = sin.(column_center_coords.z)\ngradc2f = ClimaCore.Operators.GradientC2F(\n    bottom = ClimaCore.Operators.SetValue(sin(0.0)),\n    top = ClimaCore.Operators.SetGradient(\n        ClimaCore.Geometry.WVector(cos(10.0)),\n    ),\n)\n∇sinz = gradc2f.(sinz)","category":"page"},{"location":"tutorials/introduction/","page":"Introduction to ClimaCore.jl","title":"Introduction to ClimaCore.jl","text":"plot(map(x -> x.w, ClimaCore.Geometry.WVector.(∇sinz)), ylim = (0, 10))","category":"page"},{"location":"tutorials/introduction/","page":"Introduction to ClimaCore.jl","title":"Introduction to ClimaCore.jl","text":"As before, multiple operators (or functions) can be fused together with broadcasting.","category":"page"},{"location":"tutorials/introduction/","page":"Introduction to ClimaCore.jl","title":"Introduction to ClimaCore.jl","text":"One extra advantage of this is that boundaries of the inner operators only need to be specified if they would affect the final result.","category":"page"},{"location":"tutorials/introduction/","page":"Introduction to ClimaCore.jl","title":"Introduction to ClimaCore.jl","text":"Consider the center-to-center Laplacian:","category":"page"},{"location":"tutorials/introduction/","page":"Introduction to ClimaCore.jl","title":"Introduction to ClimaCore.jl","text":"...\n      \\       /\n        ∇θ[2+½]\n      /       \\\nθ[2]            ∇⋅∇θ[2]\n      \\       /\n        ∇θ[1+½]\n      /       \\\nθ[1]            ∇⋅∇θ[1]\n              /\n         ∇θ*","category":"page"},{"location":"tutorials/introduction/","page":"Introduction to ClimaCore.jl","title":"Introduction to ClimaCore.jl","text":"sinz = sin.(column_center_coords.z)\n# we don't need to specify boundaries, as the stencil won't reach that far\ngradc2f = ClimaCore.Operators.GradientC2F()\ndivf2c = ClimaCore.Operators.DivergenceF2C(\n    bottom = ClimaCore.Operators.SetValue(ClimaCore.Geometry.WVector(cos(0.0))),\n    top = ClimaCore.Operators.SetValue(ClimaCore.Geometry.WVector(cos(10.0))),\n)\n∇∇sinz = divf2c.(gradc2f.(sinz))","category":"page"},{"location":"tutorials/introduction/","page":"Introduction to ClimaCore.jl","title":"Introduction to ClimaCore.jl","text":"plot(∇∇sinz, ylim = (0, 10))","category":"page"},{"location":"tutorials/introduction/#3.-Solving-PDEs","page":"Introduction to ClimaCore.jl","title":"3. Solving PDEs","text":"","category":"section"},{"location":"tutorials/introduction/","page":"Introduction to ClimaCore.jl","title":"Introduction to ClimaCore.jl","text":"ClimaCore can be used for spatial discretizations of PDEs. For temporal discretization, we can use the OrdinaryDiffEq package, which we aim to be compatibile with.","category":"page"},{"location":"tutorials/introduction/","page":"Introduction to ClimaCore.jl","title":"Introduction to ClimaCore.jl","text":"using OrdinaryDiffEq","category":"page"},{"location":"tutorials/introduction/#3.1-Heat-equation-using-finite-differences","page":"Introduction to ClimaCore.jl","title":"3.1 Heat equation using finite differences","text":"","category":"section"},{"location":"tutorials/introduction/","page":"Introduction to ClimaCore.jl","title":"Introduction to ClimaCore.jl","text":"We will use a cell-center discretization of the heat equation:","category":"page"},{"location":"tutorials/introduction/","page":"Introduction to ClimaCore.jl","title":"Introduction to ClimaCore.jl","text":"fracpartial ypartial t = alpha nabla cdot nabla y","category":"page"},{"location":"tutorials/introduction/","page":"Introduction to ClimaCore.jl","title":"Introduction to ClimaCore.jl","text":"At the bottom we will use a Dirichlet condition y(0) = 1 at the bottom: since we don't actually have a value located at the bottom, we will use a SetValue boundary modifier on the inner gradient.","category":"page"},{"location":"tutorials/introduction/","page":"Introduction to ClimaCore.jl","title":"Introduction to ClimaCore.jl","text":"At the top we will use a Neumann condition fracpartial ypartial z(10) = 0. We can do this two equivalent ways:","category":"page"},{"location":"tutorials/introduction/","page":"Introduction to ClimaCore.jl","title":"Introduction to ClimaCore.jl","text":"a SetGradient on the gradient operator\na SetValue on the divergence operator","category":"page"},{"location":"tutorials/introduction/","page":"Introduction to ClimaCore.jl","title":"Introduction to ClimaCore.jl","text":"either will work.","category":"page"},{"location":"tutorials/introduction/","page":"Introduction to ClimaCore.jl","title":"Introduction to ClimaCore.jl","text":"y0 = zeros(column_center_space)\n\n# define the tendency function\nfunction heat_fd_tendency!(dydt, y, α, t)\n    gradc2f = ClimaCore.Operators.GradientC2F(\n        bottom = ClimaCore.Operators.SetValue(1.0),\n        top = ClimaCore.Operators.SetGradient(ClimaCore.Geometry.WVector(0.0)),\n    )\n    divf2c = ClimaCore.Operators.DivergenceF2C()\n    # the @. macro \"dots\" the whole expression\n    # i.e.  dydt .= α .* divf2c.(gradc2f.(y))\n    @. dydt = α * divf2c(gradc2f(y))\nend\n\nheat_fd_prob = ODEProblem(heat_fd_tendency!, y0, (0.0, 5.0), 0.1)\nheat_fd_sol = solve(heat_fd_prob, SSPRK33(), dt = 0.1, saveat = 0.25)","category":"page"},{"location":"tutorials/introduction/","page":"Introduction to ClimaCore.jl","title":"Introduction to ClimaCore.jl","text":"anim = Plots.@animate for u in heat_fd_sol.u\n    plot(u, xlim = (0, 1), ylim = (0, 10))\nend\nmp4(anim)","category":"page"},{"location":"tutorials/introduction/#3.2-Heat-equation-using-continuous-Galerkin-(CG)-spectral-element","page":"Introduction to ClimaCore.jl","title":"3.2 Heat equation using continuous Galerkin (CG) spectral element","text":"","category":"section"},{"location":"tutorials/introduction/","page":"Introduction to ClimaCore.jl","title":"Introduction to ClimaCore.jl","text":"function heat_cg_tendency!(dydt, y, α, t)\n    grad = ClimaCore.Operators.Gradient()\n    wdiv = ClimaCore.Operators.WeakDivergence()\n    # apply element operators\n    @. dydt = α * wdiv(grad(y))\n\n    # direct stiffness summation (DSS): project to continuous function space\n    ClimaCore.Spaces.weighted_dss!(dydt)\n    return dydt\nend\n\ny0 = exp.(.-(coord.y .^ 2 .+ coord.x .^ 2) ./ 2)\n\nheat_cg_prob = ODEProblem(heat_cg_tendency!, y0, (0.0, 5.0), 0.1)\nheat_cg_sol = solve(heat_cg_prob, SSPRK33(), dt = 0.1, saveat = 0.5)","category":"page"},{"location":"tutorials/introduction/","page":"Introduction to ClimaCore.jl","title":"Introduction to ClimaCore.jl","text":"anim = Plots.@animate for u in heat_cg_sol.u\n    Plots.plot(u, c = :thermal)\nend\nmp4(anim)","category":"page"},{"location":"tutorials/introduction/#3.3-Shallow-water-equations","page":"Introduction to ClimaCore.jl","title":"3.3 Shallow water equations","text":"","category":"section"},{"location":"tutorials/introduction/","page":"Introduction to ClimaCore.jl","title":"Introduction to ClimaCore.jl","text":"The shallow water equations in vector invariant form can be written as","category":"page"},{"location":"tutorials/introduction/","page":"Introduction to ClimaCore.jl","title":"Introduction to ClimaCore.jl","text":"beginalign*\n    fracpartial rhopartial t + nabla cdot (rho u) = 0\n    fracpartial u_ipartial t + nabla (Phi + tfrac12u^2)_i  = J (u times (nabla times u))_i\nendalign*","category":"page"},{"location":"tutorials/introduction/","page":"Introduction to ClimaCore.jl","title":"Introduction to ClimaCore.jl","text":"where J is the Jacobian determinant, and Phi = g rho.","category":"page"},{"location":"tutorials/introduction/","page":"Introduction to ClimaCore.jl","title":"Introduction to ClimaCore.jl","text":"Note that the velocity u is specified in covariant coordinates u_i.","category":"page"},{"location":"tutorials/introduction/","page":"Introduction to ClimaCore.jl","title":"Introduction to ClimaCore.jl","text":"For vizualization purposes, we can model a passive tracer theta as","category":"page"},{"location":"tutorials/introduction/","page":"Introduction to ClimaCore.jl","title":"Introduction to ClimaCore.jl","text":"fracpartial rho thetapartial t + nabla cdot (rho theta u) = 0","category":"page"},{"location":"tutorials/introduction/","page":"Introduction to ClimaCore.jl","title":"Introduction to ClimaCore.jl","text":"using ClimaCore.Geometry\n\nparameters = (\n    ϵ = 0.1,  ## perturbation size for initial condition\n    l = 0.5, ## Gaussian width\n    k = 0.5, ## Sinusoidal wavenumber\n    ρ₀ = 1.0, ## reference density\n    c = 2,\n    g = 10,\n    D₄ = 1e-4, ## hyperdiffusion coefficient\n)\n\nfunction init_state(local_geometry, p)\n    coord = local_geometry.coordinates\n    (; x, y) = coord\n    # set initial state\n    ρ = p.ρ₀\n\n    # set initial velocity\n    U₁ = cosh(y)^(-2)\n\n    # Ψ′ = exp(-(x2 + p.l / 10)^2 / 2p.l^2) * cos(p.k * x) * cos(p.k * y)\n    # Vortical velocity fields (u₁′, u₂′) = (-∂²Ψ′, ∂¹Ψ′)\n    ϕ = exp(-(y + p.l / 10)^2 / 2p.l^2)\n    u₁′ = ϕ * (y + p.l / 10) / p.l^2 * cos(p.k * x) * cos(p.k * y)\n    u₁′ += p.k * ϕ * cos(p.k * x) * sin(p.k * y)\n    u₂′ = -p.k * ϕ * sin(p.k * x) * cos(p.k * y)\n\n    u = Geometry.Covariant12Vector(\n        Geometry.UVVector(U₁ + p.ϵ * u₁′, p.ϵ * u₂′),\n        local_geometry,\n    )\n\n    # set initial tracer\n    θ = sin(p.k * y)\n    return (ρ = ρ, u = u, ρθ = ρ * θ)\nend\n\n\ny0 =\n    init_state.(\n        ClimaCore.Fields.local_geometry_field(rectangle_space),\n        Ref(parameters),\n    )\n\n# plot initial tracer\nPlots.plot(y0.ρθ)","category":"page"},{"location":"tutorials/introduction/","page":"Introduction to ClimaCore.jl","title":"Introduction to ClimaCore.jl","text":"function shallow_water_tendency!(dydt, y, _, t)\n\n    (; D₄, g) = parameters\n\n    sdiv = ClimaCore.Operators.Divergence()\n    wdiv = ClimaCore.Operators.WeakDivergence()\n    grad = ClimaCore.Operators.Gradient()\n    wgrad = ClimaCore.Operators.WeakGradient()\n    curl = ClimaCore.Operators.Curl()\n    wcurl = ClimaCore.Operators.WeakCurl()\n\n\n    # compute hyperviscosity first\n    @. dydt.u =\n        wgrad(sdiv(y.u)) -\n        Geometry.Covariant12Vector(wcurl(Geometry.Covariant3Vector(curl(y.u))))\n    @. dydt.ρθ = wdiv(grad(y.ρθ))\n\n    ClimaCore.Spaces.weighted_dss!(dydt)\n\n    @. dydt.u =\n        -D₄ * (\n            wgrad(sdiv(dydt.u)) - Geometry.Covariant12Vector(\n                wcurl(Geometry.Covariant3Vector(curl(dydt.u))),\n            )\n        )\n    @. dydt.ρθ = -D₄ * wdiv(grad(dydt.ρθ))\n\n    # comute rest of tendency\n    @. begin\n        dydt.ρ = -wdiv(y.ρ * y.u)\n        dydt.u += -grad(g * y.ρ + norm(y.u)^2 / 2) + y.u × curl(y.u)\n        dydt.ρθ += -wdiv(y.ρθ * y.u)\n    end\n    ClimaCore.Spaces.weighted_dss!(dydt)\n    return dydt\nend","category":"page"},{"location":"tutorials/introduction/","page":"Introduction to ClimaCore.jl","title":"Introduction to ClimaCore.jl","text":"shallow_water_prob = ODEProblem(shallow_water_tendency!, y0, (0.0, 20.0))\n@time shallow_water_sol =\n    solve(shallow_water_prob, SSPRK33(), dt = 0.05, saveat = 1.0)\nanim = Plots.@animate for u in shallow_water_sol.u\n    Plots.plot(u.ρθ, clim = (-1, 1))\nend\nmp4(anim)","category":"page"},{"location":"tutorials/introduction/","page":"Introduction to ClimaCore.jl","title":"Introduction to ClimaCore.jl","text":"","category":"page"},{"location":"tutorials/introduction/","page":"Introduction to ClimaCore.jl","title":"Introduction to ClimaCore.jl","text":"This page was generated using Literate.jl.","category":"page"},{"location":"lib/ClimaCoreTempestRemap/#ClimaCoreTempestRemap.jl","page":"ClimaCoreTempestRemap.jl","title":"ClimaCoreTempestRemap.jl","text":"","category":"section"},{"location":"lib/ClimaCoreTempestRemap/","page":"ClimaCoreTempestRemap.jl","title":"ClimaCoreTempestRemap.jl","text":"CurrentModule = ClimaCoreTempestRemap","category":"page"},{"location":"lib/ClimaCoreTempestRemap/","page":"ClimaCoreTempestRemap.jl","title":"ClimaCoreTempestRemap.jl","text":"ClimaCoreTempestRemap.jl provides an interfaces for using ClimaCore data with the TempestRemap remapping package, by Paul Ullrich.","category":"page"},{"location":"lib/ClimaCoreTempestRemap/#Interface","page":"ClimaCoreTempestRemap.jl","title":"Interface","text":"","category":"section"},{"location":"lib/ClimaCoreTempestRemap/#Online-remap","page":"ClimaCoreTempestRemap.jl","title":"Online remap","text":"","category":"section"},{"location":"lib/ClimaCoreTempestRemap/","page":"ClimaCoreTempestRemap.jl","title":"ClimaCoreTempestRemap.jl","text":"LinearMap\ngenerate_map\nremap!\nremap","category":"page"},{"location":"lib/ClimaCoreTempestRemap/#ClimaCoreTempestRemap.LinearMap","page":"ClimaCoreTempestRemap.jl","title":"ClimaCoreTempestRemap.LinearMap","text":"LinearMap{S, T, W, I, V}\n\nstores information on the TempestRemap map and the source and target data:\n\nwhere:\n\nsource_space and target_space are ClimaCore's 2D spaces.\nweights is a vector of remapping weights. (length = number of overlap-mesh nodes).\nsource_local_idxs a 3-element Tuple with 3 index vectors, representing local (i,j,elem) indices on the source mesh. (length of each index vector = number of overlap-mesh nodes)\ntarget_local_idxs is the same as source_local_idxs but for the target mesh.\nrow_indices are the target row indices from TempestRemap. (length = number of overlap-mesh nodes)\nout_type string that defines the output type.\n\n\n\n\n\n","category":"type"},{"location":"lib/ClimaCoreTempestRemap/#ClimaCoreTempestRemap.generate_map","page":"ClimaCoreTempestRemap.jl","title":"ClimaCoreTempestRemap.generate_map","text":"generate_map(target_space, source_space; in_type=\"cgll\", out_type=\"cgll\")\n\nGenerate the remapping weights from TempestRemap, returning a LinearMap object. This should only be called once.\n\n\n\n\n\n","category":"function"},{"location":"lib/ClimaCoreTempestRemap/#ClimaCoreTempestRemap.remap!","page":"ClimaCoreTempestRemap.jl","title":"ClimaCoreTempestRemap.remap!","text":"remap!(target::IJFH{S, Nqt}, R::LinearMap, source::IJFH{S, Nqs})\nremap!(target::Fields.Field, R::LinearMap, source::Fields.Field)\n\nApplies the remapping R to a source Field and stores the result in target.\n\n\n\n\n\n","category":"function"},{"location":"lib/ClimaCoreTempestRemap/#ClimaCoreTempestRemap.remap","page":"ClimaCoreTempestRemap.jl","title":"ClimaCoreTempestRemap.remap","text":"remap(R::LinearMap, source::Field)\n\nApplies the remapping R to a source Field, allocating a new field in the output.\n\n\n\n\n\n","category":"function"},{"location":"lib/ClimaCoreTempestRemap/#Mesh-export","page":"ClimaCoreTempestRemap.jl","title":"Mesh export","text":"","category":"section"},{"location":"lib/ClimaCoreTempestRemap/","page":"ClimaCoreTempestRemap.jl","title":"ClimaCoreTempestRemap.jl","text":"write_exodus","category":"page"},{"location":"lib/ClimaCoreTempestRemap/#ClimaCoreTempestRemap.write_exodus","page":"ClimaCoreTempestRemap.jl","title":"ClimaCoreTempestRemap.write_exodus","text":"write_exodus(filename, topology::Topology2D; normalize_coordinates=true)\n\nWrite the topology to an Exodus-formatted NetCDF file.\n\nIt tries to adhere to the Exodus II specification, but it is primarily intended for use with TempestRemap.\n\nNote: the generated meshes will use a different ordering of nodes and elements than those generated by TempestRemap itself.\n\nWhen using this function with a distributed topology input for MPI, it should only be called on a single process.\n\nOptions:\n\nnormalize_coordinates: if true, the coordinates are normalized to be on the unit sphere (this is required for use with TempestRemap)\n\nReferences\n\nEXODUS II: A finite element data model: https://www.osti.gov/biblio/10102115-exodus-ii-finite-element-data-model\n\n\n\n\n\n","category":"function"},{"location":"lib/ClimaCoreTempestRemap/#NetCDF-data-export","page":"ClimaCoreTempestRemap.jl","title":"NetCDF data export","text":"","category":"section"},{"location":"lib/ClimaCoreTempestRemap/","page":"ClimaCoreTempestRemap.jl","title":"ClimaCoreTempestRemap.jl","text":"def_time_coord\ndef_space_coord\nNCDatasets.defVar(::NCDatasets.NCDataset, ::NCDatasets.SymbolOrString, field::Fields.Field)\nBase.setindex!(::NCDatasets.CFVariable, ::Fields.Field, ::Colon)","category":"page"},{"location":"lib/ClimaCoreTempestRemap/#ClimaCoreTempestRemap.def_time_coord","page":"ClimaCoreTempestRemap.jl","title":"ClimaCoreTempestRemap.def_time_coord","text":"def_time_coord(nc::NCDataset, length=Inf, eltype=Float64;\n    units = \"seconds since 2020-01-01 00:00:00\"\n    kwargs...\n)\n\nDeine a time coordinate (dimension + variable) \"time\" in the NetCDF dataset nc. By default its length is set to be unlimited. The variable corresponding to the coordinate is returned.\n\nAdditional attributes can be added as keyword arguments.\n\nExample\n\ntimevar = add_time_coord!(nc; units = \"seconds since 2020-01-01 00:00:00\",)\ntimevar[:] = collect(0.0:0.5:60)\n\n\n\n\n\n","category":"function"},{"location":"lib/ClimaCoreTempestRemap/#ClimaCoreTempestRemap.def_space_coord","page":"ClimaCoreTempestRemap.jl","title":"ClimaCoreTempestRemap.def_space_coord","text":"def_space_coord(nc::NCDataset, space::Spaces.AbstractSpace; type = \"dgll\")\n\nAdd spatial dimensions for space in the NetCDF dataset nc, compatible with the type used by remap_weights.\n\nIf a compatible dimension already exists, it will be reused.\n\n\n\n\n\n","category":"function"},{"location":"lib/ClimaCoreTempestRemap/#CommonDataModel.defVar-Tuple{NCDatasets.NCDataset, Union{AbstractString, Symbol}, ClimaCore.Fields.Field}","page":"ClimaCoreTempestRemap.jl","title":"CommonDataModel.defVar","text":"NCDatasets.defVar(nc::NCDataset, name, field::Field, extradims=())\n\nDefine a new variable in nc named name of suitable for storing field, along with any further dimensions specified in extradims. The new variable is returned.\n\nnote: Note\nThis does not write any data to the variable.\n\n\n\n\n\n","category":"method"},{"location":"lib/ClimaCoreTempestRemap/#Base.setindex!-Tuple{CommonDataModel.CFVariable, ClimaCore.Fields.Field, Colon}","page":"ClimaCoreTempestRemap.jl","title":"Base.setindex!","text":"var[:, extraidx...] = field\n\nWrite the data in field to a NetCDF variable var. extraidx are any extra indices of var.\n\nAppropriate spatial dimensions should already be defined by defVar.\n\n# Given a collection of fields U, write them as a single array to a NetCDF file.\ndef_space_coord(nc, space)\nnc_time = def_time_coord(nc)\nnc_u = defVar(nc, \"u\", Float64, space, (\"time\",))\nfor (i,t) in enumerate(times)\n    nc_time[i] = t\n    nc_u[:,i] = U[i]\nend\n\n\n\n\n\n","category":"method"},{"location":"lib/ClimaCoreTempestRemap/#Wrapper-functions","page":"ClimaCoreTempestRemap.jl","title":"Wrapper functions","text":"","category":"section"},{"location":"lib/ClimaCoreTempestRemap/","page":"ClimaCoreTempestRemap.jl","title":"ClimaCoreTempestRemap.jl","text":"rll_mesh\noverlap_mesh\nremap_weights\napply_remap","category":"page"},{"location":"lib/ClimaCoreTempestRemap/#ClimaCoreTempestRemap.rll_mesh","page":"ClimaCoreTempestRemap.jl","title":"ClimaCoreTempestRemap.rll_mesh","text":"rll_mesh(filename::AbstractString; nlat=90, nlon = round(Int, nlat * 1.6); verbose=false)\n\nCreate a regular latitude-longitude (RLL) mesh and write it to filename in Exodus format. nlat is the number of latitudinal cells, and nlon is the number of longitudinal cells.\n\nSet verbose=true to print information.\n\nSee Tempest remap: mesh generation\n\n\n\n\n\n","category":"function"},{"location":"lib/ClimaCoreTempestRemap/#ClimaCoreTempestRemap.overlap_mesh","page":"ClimaCoreTempestRemap.jl","title":"ClimaCoreTempestRemap.overlap_mesh","text":"overlap_mesh(outfile::AbstractString, meshfile_a::AbstractString, meshfile_b::AbstractString; verbose=false)\n\nCreate the overlap mesh of meshfile_a and meshfile_b and write it to outfile. All files should be in Exodus format.\n\nSet verbose=true to print information.\n\nSee Tempest remap: mesh generation\n\n\n\n\n\n","category":"function"},{"location":"lib/ClimaCoreTempestRemap/#ClimaCoreTempestRemap.remap_weights","page":"ClimaCoreTempestRemap.jl","title":"ClimaCoreTempestRemap.remap_weights","text":"remap_weights(\n    weightfile::AbstractString,\n    meshfile_in::AbstractString,\n    meshfile_out::AbstractString,\n    meshfile_overlap::AbstractString;\n    verbose=false,\n    kwargs...\n)\n\nCreate a file weightfile in SCRIP format containing the remapping weights from meshfile_in to meshfile_out, where meshfile_overlap is constructed via overlap_mesh.\n\nKeyword arguments are passed as command-line options. These include:\n\nin_type / out_type: the type of the input and output mesh:\n\"fv\" (default): finite volume (one value per element)\n\"cgll\": continuous GLL finite element method (a single value for colocated nodes)\n\"dgll\": discontinuous GLL finite element method (duplicate values for colocated nodes)\n'innp'/'outnp': Order of input and output meshes\n'mono': Monotonicity of remapping\n\nSet mono = true for monotone remapping Set verbose=true to print information.\n\nSee Tempest remap: offline map generation\n\n\n\n\n\n","category":"function"},{"location":"lib/ClimaCoreTempestRemap/#ClimaCoreTempestRemap.apply_remap","page":"ClimaCoreTempestRemap.jl","title":"ClimaCoreTempestRemap.apply_remap","text":"apply_remap(outfile::AbstractString, infile::AbstractString, weightfile::AbstractString, vars; verbose=false)\n\nRemap the NetCDF file infile to outfile, using the remapping weights weightfile constructed via remap_weights. vars should be a collection of variable names to remap.\n\nSet verbose=true to print information.\n\nSee Tempest remap: offline map application\n\n\n\n\n\n","category":"function"},{"location":"lib/ClimaCoreTempestRemap/#Example","page":"ClimaCoreTempestRemap.jl","title":"Example","text":"","category":"section"},{"location":"lib/ClimaCoreTempestRemap/","page":"ClimaCoreTempestRemap.jl","title":"ClimaCoreTempestRemap.jl","text":"The following example converts an OrdinaryDiffEq solution object sol to a netcdf file, and remaps it to an regular latitude-longitude (RLL) grid.","category":"page"},{"location":"lib/ClimaCoreTempestRemap/","page":"ClimaCoreTempestRemap.jl","title":"ClimaCoreTempestRemap.jl","text":"using ClimaCore: Geometry, Meshes, Domains, Topologies, Spaces, Quadratures\nusing NCDatasets, ClimaCoreTempestRemap\n\n# sol is the integrator solution\n# cspace is the center extrduded space\n# fspace is the face extruded space\n\n# the issue is that the Space types changed since this changed\n# we can reconstruct it by digging around a bit\nNq = Quadratures.degrees_of_freedom(Spaces.quadrature_style(cspace))\n\ndatafile_cc = \"test.nc\"\nNCDataset(datafile_cc, \"c\") do nc\n    # defines the appropriate dimensions and variables for a space coordinate\n    def_space_coord(nc, cspace, type = \"cgll\")\n    def_space_coord(nc, fspace, type = \"cgll\")\n    # defines the appropriate dimensions and variables for a time coordinate (by default, unlimited size)\n    nc_time = def_time_coord(nc)\n\n    # define variables\n    nc_rho = defVar(nc, \"rho\", Float64, cspace, (\"time\",))\n    nc_theta = defVar(nc, \"theta\", Float64, cspace, (\"time\",))\n    nc_u = defVar(nc, \"u\", Float64, cspace, (\"time\",))\n    nc_v = defVar(nc, \"v\", Float64, cspace, (\"time\",))\n    nc_w = defVar(nc, \"w\", Float64, fspace, (\"time\",))\n\n    # write data to netcdf file\n    for i = 1:length(sol.u)\n        nc_time[i] = sol.t[i]\n\n        # extract fields and convert to orthogonal coordinates\n        Yc = sol.u[i].Yc\n        uₕ = Geometry.UVVector.(sol.u[i].uₕ)\n        w = Geometry.WVector.(sol.u[i].w)\n\n        # write fields to file\n        nc_rho[:,i] = Yc.ρ\n        nc_theta[:,i] = Yc.ρθ ./ Yc.ρ\n        nc_u[:,i] = map(u -> u.u, uₕ)\n        nc_v[:,i] = map(u -> u.v, uₕ)\n        nc_w[:,i] = map(u -> u.w, w)\n    end\nend\n\n# write out our cubed sphere mesh\nmeshfile_cc = \"mesh_cubedsphere.g\"\nwrite_exodus(meshfile_cc, Spaces.topology(Spaces.horizontal_space(cspace)))\n\n# write out RLL mesh\nnlat = 90\nnlon = 180\nmeshfile_rll = \"mesh_rll.g\"\nrll_mesh(meshfile_rll; nlat = nlat, nlon = nlon)\n\n# construct overlap mesh\nmeshfile_overlap = \"mesh_overlap.g\"\noverlap_mesh(meshfile_overlap, meshfile_cc, meshfile_rll)\n\n# construct remap weight file\nweightfile = \"remap_weights.nc\"\nremap_weights(\n    weightfile,\n    meshfile_cc,\n    meshfile_rll,\n    meshfile_overlap;\n    in_type = \"cgll\",\n    in_np = Quadratures.degrees_of_freedom(Spaces.quadrature_style(cspace)),\n)\n\n# apply remap\ndatafile_rll = \"data_rll.nc\"\napply_remap(datafile_rll, datafile_cc, weightfile, [\"rho\", \"theta\", \"u\", \"v\", \"w\"])","category":"page"},{"location":"operators/#Operators","page":"Operators","title":"Operators","text":"","category":"section"},{"location":"operators/","page":"Operators","title":"Operators","text":"CurrentModule = ClimaCore.Operators","category":"page"},{"location":"operators/","page":"Operators","title":"Operators","text":"Operators can compute spatial derivative operations.","category":"page"},{"location":"operators/","page":"Operators","title":"Operators","text":"for performance reasons, we need to be able to \"fuse\" multiple operators and function applications\nJulia provides a tool for this: broadcasting, with a very flexible API","category":"page"},{"location":"operators/","page":"Operators","title":"Operators","text":"Can think of operators are \"pseudo-functions\": can't be called directly, but act similar to functions in the context of broadcasting. They are matrix-free, in the sense that we define the action of the operator directly on a field, without explicitly assembling the matrix representing the discretized operator.","category":"page"},{"location":"operators/#Spectral-element-operators","page":"Operators","title":"Spectral element operators","text":"","category":"section"},{"location":"operators/#Differential-Operators","page":"Operators","title":"Differential Operators","text":"","category":"section"},{"location":"operators/","page":"Operators","title":"Operators","text":"Gradient\nDivergence\nWeakDivergence\nWeakGradient\nCurl\nWeakCurl","category":"page"},{"location":"operators/#ClimaCore.Operators.Gradient","page":"Operators","title":"ClimaCore.Operators.Gradient","text":"grad = Gradient()\ngrad.(f)\n\nCompute the (strong) gradient of f on each element, returning a CovariantVector-field.\n\nThe ith covariant component of the gradient is the partial derivative with respect to the reference element:\n\n(nabla f)_i = fracpartial fpartial xi^i\n\nDiscretely, this can be written in matrix form as\n\nD_i f\n\nwhere D_i is the derivative matrix along the ith dimension.\n\nReferences\n\n[1], equation 16\n\n\n\n\n\n","category":"type"},{"location":"operators/#ClimaCore.Operators.Divergence","page":"Operators","title":"ClimaCore.Operators.Divergence","text":"div = Divergence()\ndiv.(u)\n\nComputes the per-element spectral (strong) divergence of a vector field u.\n\nThe divergence of a vector field u is defined as\n\nnabla cdot u = sum_i frac1J fracpartial (J u^i)partial xi^i\n\nwhere J is the Jacobian determinant, u^i is the ith contravariant component of u.\n\nThis is discretized by\n\nsum_i I leftfrac1J fracpartial (IJ u^i)partial xi^i right\n\nwhere Ix is the interpolation operator that projects to the unique polynomial interpolating x at the quadrature points. In matrix form, this can be written as\n\nJ^-1 sum_i D_i J u^i\n\nwhere D_i is the derivative matrix along the ith dimension\n\nReferences\n\n[1], equation 15\n\n\n\n\n\n","category":"type"},{"location":"operators/#ClimaCore.Operators.WeakDivergence","page":"Operators","title":"ClimaCore.Operators.WeakDivergence","text":"wdiv = WeakDivergence()\nwdiv.(u)\n\nComputes the \"weak divergence\" of a vector field u.\n\nThis is defined as the scalar field theta in mathcalV_0 such that for all phiin mathcalV_0\n\nint_Omega phi theta  d Omega\n=\n- int_Omega (nabla phi) cdot u d Omega\n\nwhere mathcalV_0 is the space of u.\n\nThis arises as the contribution of the volume integral after by applying integration by parts to the weak form expression of the divergence\n\nint_Omega phi (nabla cdot u)  d Omega\n=\n- int_Omega (nabla phi) cdot u d Omega\n+ oint_partial Omega phi (u cdot n) d sigma\n\nIt can be written in matrix form as\n\nϕ^top WJ θ = - sum_i (D_i ϕ)^top WJ u^i\n\nwhich reduces to\n\nθ = -(WJ)^-1 sum_i D_i^top WJ u^i\n\nwhere\n\nJ is the diagonal Jacobian matrix\nW is the diagonal matrix of quadrature weights\nD_i is the derivative matrix along the ith dimension\n\n\n\n\n\n","category":"type"},{"location":"operators/#ClimaCore.Operators.WeakGradient","page":"Operators","title":"ClimaCore.Operators.WeakGradient","text":"wgrad = WeakGradient()\nwgrad.(f)\n\nCompute the \"weak gradient\" of f on each element.\n\nThis is defined as the the vector field theta in mathcalV_0 such that for all phi in mathcalV_0\n\nint_Omega phi cdot theta  d Omega\n=\n- int_Omega (nabla cdot phi) f  dOmega\n\nwhere mathcalV_0 is the space of f.\n\nThis arises from the contribution of the volume integral after by applying integration by parts to the weak form expression of the gradient\n\nint_Omega phi cdot (nabla f)  d Omega\n=\n- int_Omega f (nabla cdot phi)  dOmega\n+ oint_partial Omega f (phi cdot n)  d sigma\n\nIn matrix form, this becomes\n\nphi^i^top W J theta_i = - ( J^-1 D_i J phi^i )^top W J f\n\nwhich reduces to\n\ntheta_i = -W^-1 D_i^top W f\n\nwhere D_i is the derivative matrix along the ith dimension.\n\n\n\n\n\n","category":"type"},{"location":"operators/#ClimaCore.Operators.Curl","page":"Operators","title":"ClimaCore.Operators.Curl","text":"curl = Curl()\ncurl.(u)\n\nComputes the per-element spectral (strong) curl of a covariant vector field u.\n\nNote: The vector field u needs to be excliclty converted to a CovaraintVector, as then the Curl is independent of the local metric tensor.\n\nThe curl of a vector field u is a vector field with contravariant components\n\n(nabla times u)^i = frac1J sum_jk epsilon^ijk fracpartial u_kpartial xi^j\n\nwhere J is the Jacobian determinant, u_k is the kth covariant component of u, and epsilon^ijk are the Levi-Civita symbols. In other words\n\nbeginbmatrix\n  (nabla times u)^1 \n  (nabla times u)^2 \n  (nabla times u)^3\nendbmatrix\n=\nfrac1J beginbmatrix\n  fracpartial u_3partial xi^2 - fracpartial u_2partial xi^3 \n  fracpartial u_1partial xi^3 - fracpartial u_3partial xi^1 \n  fracpartial u_2partial xi^1 - fracpartial u_1partial xi^2\nendbmatrix\n\nIn matrix form, this becomes\n\nepsilon^ijk J^-1 D_j u_k\n\nNote that unused dimensions will be dropped: e.g. the 2D curl of a Covariant12Vector-field will return a Contravariant3Vector.\n\nReferences\n\n[1], equation 17\n\n\n\n\n\n","category":"type"},{"location":"operators/#ClimaCore.Operators.WeakCurl","page":"Operators","title":"ClimaCore.Operators.WeakCurl","text":"wcurl = WeakCurl()\nwcurl.(u)\n\nComputes the \"weak curl\" on each element of a covariant vector field u.\n\nNote: The vector field u needs to be excliclty converted to a CovaraintVector, as then the WeakCurl is independent of the local metric tensor.\n\nThis is defined as the vector field theta in mathcalV_0 such that for all phi in mathcalV_0\n\nint_Omega phi cdot theta  d Omega\n=\nint_Omega (nabla times phi) cdot u d Omega\n\nwhere mathcalV_0 is the space of f.\n\nThis arises from the contribution of the volume integral after by applying integration by parts to the weak form expression of the curl\n\nint_Omega phi cdot (nabla times u) dOmega\n=\nint_Omega (nabla times phi) cdot u d Omega\n- oint_partial Omega (phi times u) cdot n dsigma\n\nIn matrix form, this becomes\n\nphi_i^top W J theta^i = (J^-1 epsilon^kji D_j phi_i)^top W J u_k\n\nwhich, by using the anti-symmetry of the Levi-Civita symbol, reduces to\n\ntheta^i = - epsilon^ijk (WJ)^-1 D_j^top W u_k\n\n\n\n\n\n","category":"type"},{"location":"operators/#Interpolation-Operators","page":"Operators","title":"Interpolation Operators","text":"","category":"section"},{"location":"operators/","page":"Operators","title":"Operators","text":"Interpolate\nRestrict","category":"page"},{"location":"operators/#ClimaCore.Operators.Interpolate","page":"Operators","title":"ClimaCore.Operators.Interpolate","text":"i = Interpolate(space)\ni.(f)\n\nInterpolates f to the space. If space has equal or higher polynomial degree as the space of f, this is exact, otherwise it will be lossy.\n\nIn matrix form, it is the linear operator\n\nI = bigotimes_i I_i\n\nwhere I_i is the barycentric interpolation matrix in the ith dimension.\n\nSee also Restrict.\n\n\n\n\n\n","category":"type"},{"location":"operators/#ClimaCore.Operators.Restrict","page":"Operators","title":"ClimaCore.Operators.Restrict","text":"r = Restrict(space)\nr.(f)\n\nComputes the projection of a field f on mathcalV_0 to a lower degree polynomial space space (mathcalV_0^*). space must be on the same topology as the space of f, but have a lower polynomial degree.\n\nIt is defined as the field theta in mathcalV_0^* such that for all phi in mathcalV_0^*\n\nint_Omega phi theta dOmega = int_Omega phi f dOmega\n\nIn matrix form, this is\n\nphi^top W^* J^* theta = (I phi)^top WJ f\n\nwhere W^* and J^* are the quadrature weights and Jacobian determinant of mathcalV_0^*, and I is the interpolation operator (see Interpolate) from mathcalV_0^* to mathcalV_0. This reduces to\n\ntheta = (W^* J^*)^-1 I^top WJ f\n\n\n\n\n\n","category":"type"},{"location":"operators/#Finite-difference-operators","page":"Operators","title":"Finite difference operators","text":"","category":"section"},{"location":"operators/","page":"Operators","title":"Operators","text":"Finite difference operators are similar with some subtle differences:","category":"page"},{"location":"operators/","page":"Operators","title":"Operators","text":"they can change staggering (center to face, or vice versa)\nthey can span multiple elements\nno DSS is required\nboundary handling may be required","category":"page"},{"location":"operators/","page":"Operators","title":"Operators","text":"We use the following convention:","category":"page"},{"location":"operators/","page":"Operators","title":"Operators","text":"centers are indexed by integers 1, 2, ..., n\nfaces are indexed by half integers half, 1+half, ..., n+half","category":"page"},{"location":"operators/","page":"Operators","title":"Operators","text":"FiniteDifferenceOperator","category":"page"},{"location":"operators/#ClimaCore.Operators.FiniteDifferenceOperator","page":"Operators","title":"ClimaCore.Operators.FiniteDifferenceOperator","text":"FiniteDifferenceOperator\n\nAn abstract type for finite difference operators. Instances of this should define:\n\nreturn_eltype\nreturn_space\nstencil_interior_width\nstencil_interior\n\nSee also AbstractBoundaryCondition for how to define the boundaries.\n\n\n\n\n\n","category":"type"},{"location":"operators/#Interpolation-operators","page":"Operators","title":"Interpolation operators","text":"","category":"section"},{"location":"operators/","page":"Operators","title":"Operators","text":"InterpolateC2F\nInterpolateF2C\nWeightedInterpolateC2F\nWeightedInterpolateF2C\nUpwindBiasedProductC2F\nUpwind3rdOrderBiasedProductC2F\nFCTBorisBook\nFCTZalesak\nLeftBiasedC2F\nRightBiasedC2F\nLeftBiasedF2C\nRightBiasedF2C","category":"page"},{"location":"operators/#ClimaCore.Operators.InterpolateC2F","page":"Operators","title":"ClimaCore.Operators.InterpolateC2F","text":"I = InterpolateC2F(;boundaries..)\nI.(x)\n\nInterpolate a center-valued field x to faces, using the stencil\n\nI(x)i = frac12 (xi+tfrac12 + xi-tfrac12)\n\nSupported boundary conditions are:\n\nSetValue(x₀): set the value at the boundary face to be x₀. On the left boundary the stencil is\n\nI(x)tfrac12 = x₀\n\nSetGradient(v): set the value at the boundary such that the gradient is v. At the left boundary the stencil is\n\nI(x)tfrac12 = x1 - frac12 v³\n\nExtrapolate: use the closest interior point as the boundary value. At the left boundary the stencil is\n\nI(x)tfrac12 = x1\n\n\n\n\n\n","category":"type"},{"location":"operators/#ClimaCore.Operators.InterpolateF2C","page":"Operators","title":"ClimaCore.Operators.InterpolateF2C","text":"InterpolateF2C()\n\nInterpolate from face to center mesh. No boundary conditions are required (or supported).\n\n\n\n\n\n","category":"type"},{"location":"operators/#ClimaCore.Operators.WeightedInterpolateC2F","page":"Operators","title":"ClimaCore.Operators.WeightedInterpolateC2F","text":"WI = WeightedInterpolateC2F(; boundaries)\nWI.(w, x)\n\nInterpolate a center-valued field x to faces, weighted by a center-valued field w, using the stencil\n\nWI(w x)i = frac\n    wi+tfrac12 xi+tfrac12 +  wi-tfrac12 xi-tfrac12)\n\n    wi+tfrac12 + wi-tfrac12\n\n\nSupported boundary conditions are:\n\nSetValue(val): set the value at the boundary face to be val.\nSetGradient: set the value at the boundary such that the gradient is val.\nExtrapolate: use the closest interior point as the boundary value.\n\nThese have the same stencil as in InterpolateC2F.\n\n\n\n\n\n","category":"type"},{"location":"operators/#ClimaCore.Operators.WeightedInterpolateF2C","page":"Operators","title":"ClimaCore.Operators.WeightedInterpolateF2C","text":"WI = WeightedInterpolateF2C(; boundaries)\nWI.(w, x)\n\nInterpolate a face-valued field x to centers, weighted by a face-valued field w, using the stencil\n\nWI(w x)i = frac\n        wi+tfrac12 xi+tfrac12 +  wi-tfrac12 xi-tfrac12)\n    \n        wi+tfrac12 + wi-tfrac12\n    \n\nNo boundary conditions are required (or supported)\n\n\n\n\n\n","category":"type"},{"location":"operators/#ClimaCore.Operators.UpwindBiasedProductC2F","page":"Operators","title":"ClimaCore.Operators.UpwindBiasedProductC2F","text":"U = UpwindBiasedProductC2F(;boundaries)\nU.(v, x)\n\nCompute the product of the face-valued vector field v and a center-valued field x at cell faces by upwinding x according to the direction of v.\n\nMore precisely, it is computed based on the sign of the 3rd contravariant component, and it returns a Contravariant3Vector:\n\nU(boldsymbolvx)i = begincases\n  v^3i xi-tfrac12boldsymbole_3 textrm if  v^3i  0 \n  v^3i xi+tfrac12boldsymbole_3 textrm if  v^3i  0\n  endcases\n\nwhere boldsymbole_3 is the 3rd covariant basis vector.\n\nSupported boundary conditions are:\n\nSetValue(x₀): set the value of x to be x₀ in a hypothetical ghost cell on the other side of the boundary. On the left boundary the stencil is\nU(boldsymbolvx)tfrac12 = begincases\n  v^3tfrac12 x_0  boldsymbole_3 textrm if   v^3tfrac12  0 \n  v^3tfrac12 x1 boldsymbole_3 textrm if   v^3tfrac12  0\n  endcases\nExtrapolate(): set the value of x to be the same as the closest interior point. On the left boundary, the stencil is\nU(boldsymbolvx)tfrac12 = U(boldsymbolvx)1 + tfrac12\n\n\n\n\n\n","category":"type"},{"location":"operators/#ClimaCore.Operators.Upwind3rdOrderBiasedProductC2F","page":"Operators","title":"ClimaCore.Operators.Upwind3rdOrderBiasedProductC2F","text":"U = Upwind3rdOrderBiasedProductC2F(;boundaries)\nU.(v, x)\n\nCompute the product of a face-valued vector field v and a center-valued field x at cell faces by upwinding x, to third-order of accuracy, according to v\n\nU(vx)i = begincases\n  vi left(-2 xi-tfrac32 + 10 xi-tfrac12 + 4 xi+tfrac12 right)  12  textrm if  vi  0 \n  vi left(4 xi-tfrac12 + 10 xi+tfrac12 -2 xi+tfrac32  right)  12  textrm if  vi  0\n  endcases\n\nThis stencil is based on [2], eq. 4(a).\n\nSupported boundary conditions are:\n\nFirstOrderOneSided(x₀): uses the first-order downwind scheme to compute x on the left boundary, and the first-order upwind scheme to compute x on the right boundary.\nThirdOrderOneSided(x₀): uses the third-order downwind reconstruction to compute x on the left boundary,\n\nand the third-order upwind reconstruction to compute x on the right boundary.\n\nnote: Note\nThese boundary conditions do not define the value at the actual boundary faces, and so this operator cannot be materialized directly: it needs to be composed with another operator that does not make use of this value, e.g. a DivergenceF2C operator, with a SetValue boundary.\n\n\n\n\n\n","category":"type"},{"location":"operators/#ClimaCore.Operators.FCTBorisBook","page":"Operators","title":"ClimaCore.Operators.FCTBorisBook","text":"U = FCTBorisBook(;boundaries)\nU.(v, x)\n\nCorrect the flux using the flux-corrected transport formulation by Boris and Book [3].\n\nInput arguments:\n\na face-valued vector field v\na center-valued field x\n\nAc(vx)i =\n  si max left0 min left vi  si left( xi+tfrac32 - xi+tfrac12  right)   si left( xi-tfrac12 - xi-tfrac32  right) right right\n\nwhere si = +1 if  vi geq 0 and si = -1 if  vi leq 0, and Ac represents the resulting corrected antidiffusive flux. This formulation is based on [3], as reported in [4] section 5.4.1.\n\nSupported boundary conditions are:\n\nFirstOrderOneSided(x₀): uses the first-order downwind reconstruction to compute x on the left boundary, and the first-order upwind reconstruction to compute x on the right boundary.\n\nnote: Note\nSimilar to the Upwind3rdOrderBiasedProductC2F operator, these boundary conditions do not define the value at the actual boundary faces, and so this operator cannot be materialized directly: it needs to be composed with another operator that does not make use of this value, e.g. a DivergenceF2C operator, with a SetValue boundary.\n\n\n\n\n\n","category":"type"},{"location":"operators/#ClimaCore.Operators.FCTZalesak","page":"Operators","title":"ClimaCore.Operators.FCTZalesak","text":"U = FCTZalesak(;boundaries)\nU.(A, Φ, Φᵗᵈ)\n\nCorrect the flux using the flux-corrected transport formulation by Zalesak [5].\n\nInput arguments:\n\na face-valued vector field A\na center-valued field Φ\na center-valued field Φᵗᵈ\n\nΦ_j^n+1 = Φ_j^td - (C_j+frac12A_j+frac12 - C_j-frac12A_j-frac12)\n\nThis stencil is based on [5], as reported in [4] section 5.4.2, where C denotes the corrected antidiffusive flux.\n\nSupported boundary conditions are:\n\nFirstOrderOneSided(x₀): uses the first-order downwind reconstruction to compute x on the left boundary, and the first-order upwind reconstruction to compute x on the right boundary.\n\nnote: Note\nSimilar to the Upwind3rdOrderBiasedProductC2F operator, these boundary conditions do not define the value at the actual boundary faces, and so this operator cannot be materialized directly: it needs to be composed with another operator that does not make use of this value, e.g. a DivergenceF2C operator, with a SetValue boundary.\n\n\n\n\n\n","category":"type"},{"location":"operators/#ClimaCore.Operators.LeftBiasedC2F","page":"Operators","title":"ClimaCore.Operators.LeftBiasedC2F","text":"L = LeftBiasedC2F(;boundaries)\nL.(x)\n\nInterpolate a center-value field to a face-valued field from the left.\n\nL(x)i = xi-tfrac12\n\nOnly the left boundary condition should be set. Currently supported is:\n\nSetValue(x₀): set the value to be x₀ on the boundary.\n\nL(x)tfrac12 = x_0\n\n\n\n\n\n","category":"type"},{"location":"operators/#ClimaCore.Operators.RightBiasedC2F","page":"Operators","title":"ClimaCore.Operators.RightBiasedC2F","text":"R = RightBiasedC2F(;boundaries)\nR.(x)\n\nInterpolate a center-valued field to a face-valued field from the right.\n\nR(x)i = xi+tfrac12\n\nOnly the right boundary condition should be set. Currently supported is:\n\nSetValue(x₀): set the value to be x₀ on the boundary.\n\nR(x)n+tfrac12 = x_0\n\n\n\n\n\n","category":"type"},{"location":"operators/#ClimaCore.Operators.LeftBiasedF2C","page":"Operators","title":"ClimaCore.Operators.LeftBiasedF2C","text":"L = LeftBiasedF2C(;boundaries)\nL.(x)\n\nInterpolate a face-value field to a center-valued field from the left.\n\nL(x)i+tfrac12 = xi\n\nOnly the left boundary condition should be set. Currently supported is:\n\nSetValue(x₀): set the value to be x₀ on the boundary.\n\nL(x)1 = x_0\n\n\n\n\n\n","category":"type"},{"location":"operators/#ClimaCore.Operators.RightBiasedF2C","page":"Operators","title":"ClimaCore.Operators.RightBiasedF2C","text":"R = RightBiasedF2C(;boundaries)\nR.(x)\n\nInterpolate a face-valued field to a center-valued field from the right.\n\nR(x)i = xi+tfrac12\n\nOnly the right boundary condition should be set. Currently supported is:\n\nSetValue(x₀): set the value to be x₀ on the boundary.\n\nR(x)n+tfrac12 = x_0\n\n\n\n\n\n","category":"type"},{"location":"operators/#Derivative-operators","page":"Operators","title":"Derivative operators","text":"","category":"section"},{"location":"operators/","page":"Operators","title":"Operators","text":"GradientF2C\nGradientC2F\nAdvectionF2F\nAdvectionC2C\nDivergenceF2C\nDivergenceC2F\nCurlC2F","category":"page"},{"location":"operators/#ClimaCore.Operators.GradientF2C","page":"Operators","title":"ClimaCore.Operators.GradientF2C","text":"G = GradientF2C(;boundaryname=boundarycondition...)\nG.(x)\n\nCompute the gradient of a face-valued field x, returning a center-valued Covariant3 vector field, using the stencil:\n\nG(x)i^3 = xi+tfrac12 - xi-tfrac12\n\nWe note that the usual division factor 1  Delta z that appears in a first-order finite difference operator is accounted for in the LocalVector basis. Hence, users need to cast the output of the GradientF2C to a UVector, VVector or WVector, according to the type of domain on which the operator is defined.\n\nThe following boundary conditions are supported:\n\nby default, the value of x at the boundary face will be used.\nSetValue(x₀): calculate the gradient assuming the value at the boundary is x₀. For the left boundary, this becomes:\n\nG(x)1³ = x1+tfrac12 - x₀\n\nExtrapolate(): set the value at the center closest to the boundary\n\nto be the same as the neighbouring interior value. For the left boundary, this becomes:\n\nG(x)1³ = G(x)2³\n\n\n\n\n\n","category":"type"},{"location":"operators/#ClimaCore.Operators.GradientC2F","page":"Operators","title":"ClimaCore.Operators.GradientC2F","text":"G = GradientC2F(;boundaryname=boundarycondition...)\nG.(x)\n\nCompute the gradient of a center-valued field x, returning a face-valued Covariant3 vector field, using the stencil:\n\nG(x)i^3 = xi+tfrac12 - xi-tfrac12\n\nThe following boundary conditions are supported:\n\nSetValue(x₀): calculate the gradient assuming the value at the boundary is x₀. For the left boundary, this becomes:\nG(x)tfrac12³ = 2 (x1 - x₀)\nSetGradient(v₀): set the value of the gradient at the boundary to be v₀. For the left boundary, this becomes:\nG(x)tfrac12 = v₀\n\n\n\n\n\n","category":"type"},{"location":"operators/#ClimaCore.Operators.AdvectionF2F","page":"Operators","title":"ClimaCore.Operators.AdvectionF2F","text":"A = AdvectionF2F(;boundaries)\nA.(v, θ)\n\nVertical advection operator at cell faces, for a face-valued velocity field v and face-valued variables θ, approximating v^3 partial_3 theta.\n\nIt uses the following stencil\n\nA(vθ)i = frac12 (θi+1 - θi-1) v³i\n\nNo boundary conditions are currently supported.\n\n\n\n\n\n","category":"type"},{"location":"operators/#ClimaCore.Operators.AdvectionC2C","page":"Operators","title":"ClimaCore.Operators.AdvectionC2C","text":"A = AdvectionC2C(;boundaries)\nA.(v, θ)\n\nVertical advection operator at cell centers, for cell face velocity field v cell center variables θ, approximating v^3 partial_3 theta.\n\nIt uses the following stencil\n\nA(vθ)i = frac12  (θi+1 - θi) v³i+tfrac12 + (θi - θi-1)v³i-tfrac12\n\nSupported boundary conditions:\n\nSetValue(θ₀): set the value of θ at the boundary face to be θ₀. At the lower boundary, this is:\n\nA(vθ)1 = frac12  (θ2 - θ1) v³1 + tfrac12 + (θ1 - θ₀)v³tfrac12\n\nExtrapolate: use the closest interior point as the boundary value. At the lower boundary, this is:\n\nA(vθ)1 = (θ2 - θ1) v³1 + tfrac12 \n\n\n\n\n\n","category":"type"},{"location":"operators/#ClimaCore.Operators.DivergenceF2C","page":"Operators","title":"ClimaCore.Operators.DivergenceF2C","text":"D = DivergenceF2C(;boundaryname=boundarycondition...)\nD.(v)\n\nCompute the vertical contribution to the divergence of a face-valued field vector v, returning a center-valued scalar field, using the stencil\n\nD(v)i = (Jv³i+tfrac12 - Jv³i-tfrac12)  Ji\n\nwhere Jv³ is the Jacobian multiplied by the third contravariant component of v.\n\nThe following boundary conditions are supported:\n\nby default, the value of v at the boundary face will be used.\nSetValue(v₀): calculate the divergence assuming the value at the boundary is v₀. For the left boundary, this becomes:\n\nD(v)1 = (Jv³1+tfrac12 - Jv³₀)  Ji\n\nExtrapolate(): set the value at the center closest to the boundary to be the same as the neighbouring interior value. For the left boundary, this becomes:\n\nD(v)1³ = D(v)2³\n\n\n\n\n\n","category":"type"},{"location":"operators/#ClimaCore.Operators.DivergenceC2F","page":"Operators","title":"ClimaCore.Operators.DivergenceC2F","text":"D = DivergenceC2F(;boundaryname=boundarycondition...)\nD.(v)\n\nCompute the vertical contribution to the divergence of a center-valued field vector v, returning a face-valued scalar field, using the stencil\n\nD(v)i = (Jv³i+tfrac12 - Jv³i-tfrac12)  Ji\n\nwhere Jv³ is the Jacobian multiplied by the third contravariant component of v.\n\nThe following boundary conditions are supported:\n\nSetValue(v₀): calculate the divergence assuming the value at the  boundary is v₀. For the left boundary, this becomes:\nD(v)tfrac12 = frac12 (Jv³1 - Jv³₀)  Ji\nSetDivergence(x): set the value of the divergence at the boundary to be x.\nD(v)tfrac12 = x\n\n\n\n\n\n","category":"type"},{"location":"operators/#ClimaCore.Operators.CurlC2F","page":"Operators","title":"ClimaCore.Operators.CurlC2F","text":"C = CurlC2F(;boundaryname=boundarycondition...)\nC.(v)\n\nCompute the vertical-derivative contribution to the curl of a center-valued covariant vector field v. It acts on the horizontal covariant components of v (that is it only depends on v₁ and v₂), and will return a face-valued horizontal contravariant vector field (that is C(v)³ = 0).\n\nSpecifically it approximates:\n\nbeginalign*\nC(v)^1 = -frac1J fracpartial v_2partial xi^3  \nC(v)^2 = frac1J fracpartial v_1partial xi^3 \nendalign*\n\nusing the stencils\n\nbeginalign*\nC(v)i^1 = - frac1Ji (v₂i+tfrac12 - v₂i-tfrac12) \nC(v)i^2 = frac1Ji  (v₁i+tfrac12 - v₁i-tfrac12)\nendalign*\n\nwhere v₁ and v₂ are the 1st and 2nd covariant components of v, and J is the Jacobian determinant.\n\nThe following boundary conditions are supported:\n\nSetValue(v₀): calculate the curl assuming the value of v at the  boundary is v₀. For the left boundary, this becomes:\nC(v)tfrac12^1 = -frac2Ji (v_21 - (v₀)_2)\nC(v)tfrac12^2 = frac2Ji (v_11 - (v₀)_1)\nSetCurl(v⁰): enforce the curl operator output at the boundary to be the contravariant vector v⁰.\n\n\n\n\n\n","category":"type"},{"location":"operators/#Other","page":"Operators","title":"Other","text":"","category":"section"},{"location":"operators/","page":"Operators","title":"Operators","text":"SetBoundaryOperator\nFirstOrderOneSided\nThirdOrderOneSided","category":"page"},{"location":"operators/#ClimaCore.Operators.SetBoundaryOperator","page":"Operators","title":"ClimaCore.Operators.SetBoundaryOperator","text":"SetBoundaryOperator(;boundaries...)\n\nThis operator only modifies the values at the boundary:\n\nSetValue(val): set the value to be val on the boundary.\n\n\n\n\n\n","category":"type"},{"location":"operators/#ClimaCore.Operators.FirstOrderOneSided","page":"Operators","title":"ClimaCore.Operators.FirstOrderOneSided","text":"FirstOrderOneSided()\n\nUse a first-order up/down-wind scheme to compute the value at the boundary.\n\n\n\n\n\n","category":"type"},{"location":"operators/#ClimaCore.Operators.ThirdOrderOneSided","page":"Operators","title":"ClimaCore.Operators.ThirdOrderOneSided","text":"ThirdOrderOneSided()\n\nUse a third-order up/down-wind scheme to compute the value at the boundary.\n\n\n\n\n\n","category":"type"},{"location":"operators/#Finite-difference-boundary-conditions","page":"Operators","title":"Finite difference boundary conditions","text":"","category":"section"},{"location":"operators/","page":"Operators","title":"Operators","text":"AbstractBoundaryCondition\nSetCurl\nSetValue\nSetGradient\nSetDivergence\nExtrapolate","category":"page"},{"location":"operators/#ClimaCore.Operators.AbstractBoundaryCondition","page":"Operators","title":"ClimaCore.Operators.AbstractBoundaryCondition","text":"AbstractBoundaryCondition\n\nAn abstract type for boundary conditions for FiniteDifferenceOperators.\n\nSubtypes should define:\n\nboundary_width\nstencil_left_boundary\nstencil_right_boundary\n\n\n\n\n\n","category":"type"},{"location":"operators/#ClimaCore.Operators.SetCurl","page":"Operators","title":"ClimaCore.Operators.SetCurl","text":"SetCurl(val)\n\nSet the curl at the boundary to be val.\n\n\n\n\n\n","category":"type"},{"location":"operators/#ClimaCore.Operators.SetValue","page":"Operators","title":"ClimaCore.Operators.SetValue","text":"SetValue(val)\n\nSet the value at the boundary to be val. In the case of gradient operators, this will set the input value from which the gradient is computed.\n\n\n\n\n\n","category":"type"},{"location":"operators/#ClimaCore.Operators.SetGradient","page":"Operators","title":"ClimaCore.Operators.SetGradient","text":"SetGradient(val)\n\nSet the gradient at the boundary to be val. In the case of gradient operators this will set the output value of the gradient.\n\n\n\n\n\n","category":"type"},{"location":"operators/#ClimaCore.Operators.SetDivergence","page":"Operators","title":"ClimaCore.Operators.SetDivergence","text":"SetDivergence(val)\n\nSet the divergence at the boundary to be val.\n\n\n\n\n\n","category":"type"},{"location":"operators/#ClimaCore.Operators.Extrapolate","page":"Operators","title":"ClimaCore.Operators.Extrapolate","text":"Extrapolate()\n\nSet the value at the boundary to be the same as the closest interior point.\n\n\n\n\n\n","category":"type"},{"location":"operators/#Integrals","page":"Operators","title":"Integrals","text":"","category":"section"},{"location":"operators/","page":"Operators","title":"Operators","text":"column_integral_definite!\ncolumn_integral_indefinite!\ncolumn_mapreduce!","category":"page"},{"location":"operators/#ClimaCore.Operators.column_integral_definite!","page":"Operators","title":"ClimaCore.Operators.column_integral_definite!","text":"column_integral_definite!(∫field::Field, ᶜfield::Field)\n\nSets ∫field= int_0^z_maxᶜfield(z)dz, where z_max is the value of z at the top of the domain. The input ᶜfield must lie on a cell-center space, and the output ∫field must lie on the corresponding horizontal space.\n\n\n\n\n\n","category":"function"},{"location":"operators/#ClimaCore.Operators.column_integral_indefinite!","page":"Operators","title":"ClimaCore.Operators.column_integral_indefinite!","text":"column_integral_indefinite!(ᶠ∫field::Field, ᶜfield::Field)\n\nSets ᶠ∫field(z) = int_0^zᶜfield(z)dz. The input ᶜfield must lie on a cell-center space, and the output ᶠ∫field must lie on the corresponding cell-face space.\n\ncolumn_integral_indefinite!(\n    f::Function,\n    ᶠ∫field::Fields.ColumnField,\n    ϕ₀ = 0,\n    average = (ϕ⁻, ϕ⁺) -> (ϕ⁻ + ϕ⁺) / 2,\n)\n\nThe indefinite integral ᶠ∫field = ϕ(z) = ∫ f(ϕ,z) dz given:\n\nf the integral integrand function (which may be a function)\nᶠ∫field the resulting (scalar) field ϕ(z)\nϕ₀ (optional) the boundary condition\naverage (optional) a function to compute the cell center  average between two cell faces (ϕ⁻, ϕ⁺).\n\n\n\n\n\n","category":"function"},{"location":"operators/#ClimaCore.Operators.column_mapreduce!","page":"Operators","title":"ClimaCore.Operators.column_mapreduce!","text":"column_mapreduce!(fn, op, reduced_field::Field, fields::Field...)\n\nApplies mapreduce along the vertical direction. The input fields must all lie on the same space, and the output reduced_field must lie on the corresponding horizontal space. The function fn is mapped over every input, and the function op is used to reduce the outputs of fn.\n\n\n\n\n\n","category":"function"},{"location":"operators/#Internal-APIs","page":"Operators","title":"Internal APIs","text":"","category":"section"},{"location":"operators/","page":"Operators","title":"Operators","text":"return_eltype\nreturn_space\nstencil_interior_width\nstencil_interior\nboundary_width\nstencil_left_boundary\nstencil_right_boundary\nleft_interior_idx\nright_interior_idx","category":"page"},{"location":"operators/#ClimaCore.Operators.return_eltype","page":"Operators","title":"ClimaCore.Operators.return_eltype","text":"return_eltype(::Op, fields...)\n\nDefines the element type of the result of operator Op\n\n\n\n\n\n","category":"function"},{"location":"operators/#ClimaCore.Operators.return_space","page":"Operators","title":"ClimaCore.Operators.return_space","text":"return_space(::Op, spaces...)\n\nDefines the space upon which the operator Op returns given arguments on input spaces.\n\n\n\n\n\n","category":"function"},{"location":"operators/#ClimaCore.Operators.stencil_interior_width","page":"Operators","title":"ClimaCore.Operators.stencil_interior_width","text":"stencil_interior_width(::Op, args...)\n\nDefines the width of the interior stencil for the operator Op with the given arguments. Returns a tuple of 2-tuples: each 2-tuple should be the lower and upper bounds of the index offsets of the stencil for each argument in the stencil.\n\nExample\n\nstencil(::Op, arg1, arg2) = ((-half, 1+half), (0,0))\n\nimplies that at index i, the stencil accesses arg1 at i-half, i+half and i+1+half, and arg2 at index i.\n\n\n\n\n\n","category":"function"},{"location":"operators/#ClimaCore.Operators.stencil_interior","page":"Operators","title":"ClimaCore.Operators.stencil_interior","text":"stencil_interior(::Op, loc, space, idx, args...)\n\nDefines the stencil of the operator Op in the interior of the domain at idx; args are the input arguments.\n\n\n\n\n\n","category":"function"},{"location":"operators/#ClimaCore.Operators.boundary_width","page":"Operators","title":"ClimaCore.Operators.boundary_width","text":"boundary_width(::Op, ::BC, args...)\n\nDefines the width of a boundary condition BC on an operator Op. This is the number of locations that are used in a modified stencil. Either this function, or left_interior_idx and right_interior_idx should be defined for a specific Op/BC combination.\n\n\n\n\n\n","category":"function"},{"location":"operators/#ClimaCore.Operators.stencil_left_boundary","page":"Operators","title":"ClimaCore.Operators.stencil_left_boundary","text":"stencil_left_boundary(::Op, ::BC, loc, idx, args...)\n\nDefines the stencil of operator Op at idx near the left boundary, with boundary condition BC.\n\n\n\n\n\n","category":"function"},{"location":"operators/#ClimaCore.Operators.stencil_right_boundary","page":"Operators","title":"ClimaCore.Operators.stencil_right_boundary","text":"stencil_right_boundary(::Op, ::BC, loc, idx, args...)\n\nDefines the stencil of operator Op at idx near the right boundary, with boundary condition BC.\n\n\n\n\n\n","category":"function"},{"location":"operators/#ClimaCore.Operators.left_interior_idx","page":"Operators","title":"ClimaCore.Operators.left_interior_idx","text":"left_interior_idx(space::AbstractSpace, op::FiniteDifferenceOperator, bc::AbstractBoundaryCondition, args..)\n\nThe index of the left-most interior point of the operator op with boundary bc when used with arguments args.... By default, this is\n\nleft_idx(space) + boundary_width(op, bc)\n\nbut can be overwritten for specific stencil types (e.g. if the stencil is assymetric).\n\n\n\n\n\n","category":"function"},{"location":"operators/#ClimaCore.Operators.right_interior_idx","page":"Operators","title":"ClimaCore.Operators.right_interior_idx","text":"right_interior_idx(space::AbstractSpace, op::FiniteDifferenceOperator, bc::AbstractBoundaryCondition, args..)\n\nThe index of the right-most interior point of the operator op with boundary bc when used with arguments args.... By default, this is\n\nright_idx(space) + boundary_width(op, bc)\n\nbut can be overwritten for specific stencil types (e.g. if the stencil is assymetric).\n\n\n\n\n\n","category":"function"},{"location":"examples/#Examples","page":"Examples","title":"Examples","text":"","category":"section"},{"location":"examples/#1D-Column-examples","page":"Examples","title":"1D Column examples","text":"","category":"section"},{"location":"examples/#2D-Cartesian-examples","page":"Examples","title":"2D Cartesian examples","text":"","category":"section"},{"location":"examples/#Flux-Limiters-advection","page":"Examples","title":"Flux Limiters advection","text":"","category":"section"},{"location":"examples/","page":"Examples","title":"Examples","text":"The 2D Cartesian advection/transport example in examples/plane/limiters_advection.jl demonstrates the application of flux limiters in the horizontal direction, namely QuasiMonotoneLimiter, in a 2D Cartesian domain.","category":"page"},{"location":"examples/#Equations-and-discretizations","page":"Examples","title":"Equations and discretizations","text":"","category":"section"},{"location":"examples/#Mass","page":"Examples","title":"Mass","text":"","category":"section"},{"location":"examples/","page":"Examples","title":"Examples","text":"Follows the continuity equation","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"beginequation\n  fracpartialpartial t rho = - nabla cdot(rho boldsymbolu) \nlabeleq2d-plane-advection-lim-continuity\nendequation","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"This is discretized using the following","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"beginequation\n  fracpartialpartial t rho approx - wD rho boldsymbolu \nlabeleq2d-plane-advection-lim-discrete-continuity\nendequation","category":"page"},{"location":"examples/#Tracers","page":"Examples","title":"Tracers","text":"","category":"section"},{"location":"examples/","page":"Examples","title":"Examples","text":"For the tracer concentration per unit mass q, the tracer density (scalar) rho q follows the advection/transport equation","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"beginequation\n  fracpartialpartial t rho q = - nabla cdot(rho q boldsymbolu)  + g(rho q)\nlabeleq2d-plane-advection-lim-tracers\nendequation","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"This is discretized using the following","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"beginequation\nfracpartialpartial t rho q approx - wD rho q boldsymbolu + g(rho q)\nlabeleq2d-plane-advection-lim-discrete-tracers\nendequation","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"where g(rho q) = - nu_4 nabla^4_h (rho q) represents the horizontal hyperdiffusion operator, with nu_4 (measured in m^4/s) the hyperviscosity constant coefficient (set equal to zero by default in the example).","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"Currently tracers are only treated explicitly in the time discretization.","category":"page"},{"location":"examples/#Prognostic-variables","page":"Examples","title":"Prognostic variables","text":"","category":"section"},{"location":"examples/","page":"Examples","title":"Examples","text":"rho: density measured in kg/m³.\nboldsymbolu velocity, a vector measured in m/s. Since this is a 2D problem, boldsymbolu equiv boldsymbolu_h.\nrho q: the tracer density scalar, where q is the tracer concentration per unit mass.","category":"page"},{"location":"examples/#Differentiation-operators","page":"Examples","title":"Differentiation operators","text":"","category":"section"},{"location":"examples/","page":"Examples","title":"Examples","text":"Because this is a purely 2D problem, there is no staggered vertical discretization, hence, there is no need of specifying variables at cell centers, faces or to reconstruct from faces to centers and vice versa.","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"wD is the discrete horizontal weak spectral divergence, called wdiv in the example code.\nG is the discrete horizontal strong spectral gradient, called grad in the example code.","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"To discretize the hyperdiffusion operator, g(rho q) = - nu_4 nabla^4 (rho q), in the horizontal direction, we compose the horizontal weak divergence, wD, and the horizontal gradient operator, G_h, twice, with an intermediate call to weighted_dss! between the two compositions, as in g_2(rho g) circ DSS(rho q) circ g_1(rho q), with:","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"g_1(rho q) = wD(G_h(q))\nDSS(rho q) = DSS(g_1(rho q))\ng_2(rho q) = -nu_4 wD(rho G_h(rho q))\nwith nu_4 the hyperviscosity coefficient.","category":"page"},{"location":"examples/#Problem-flow-and-set-up","page":"Examples","title":"Problem flow and set-up","text":"","category":"section"},{"location":"examples/","page":"Examples","title":"Examples","text":"This test case is set up in a Cartesian planar domain -2 pi 2 pi^2, doubly periodic.","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"The flow was chosen to be a horizontal uniform rotation. Moreover, the flow is reversed halfway through the time period so that the tracer blobs go back to its initial configuration (using the same speed scaling constant which was derived to account for the distance travelled in all directions in a half period).","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"beginalign\n    u = -u_0 (y - c_y) cos(pi t  T_f) nonumber \n    v = u_0 (x - c_x) cos(pi t  T_f)\nlabeleq2d-plane-advection-lim-flow\nendalign","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"where u_0 = pi  2 is the speed scaling factor to have the flow reversed halfway through the time period, boldsymbolc = (c_x c_y) is the center of the rotational flow, which coincides with the center of the domain, and T_f = 2 pi is the final simulation time, which coincides with the temporal period to have a full rotation.","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"This example is set up to run with three possible initial conditions:","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"cosine_bells\ngaussian_bells\ncylinders: two 2D slotted cylinders (test case available in the literature, cfr: [14]).","category":"page"},{"location":"examples/#Application-of-Flux-Limiters","page":"Examples","title":"Application of Flux Limiters","text":"","category":"section"},{"location":"examples/","page":"Examples","title":"Examples","text":"Because this is a fully 2D problem, the application of limiters does not affect the order of operations, which is implemented as follows:","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"Horizontal trasport with hyperdiffusion (with weak divergence wD)\nHorizontal flux limiters\nDSS","category":"page"},{"location":"examples/#3D-Cartesian-examples","page":"Examples","title":"3D Cartesian examples","text":"","category":"section"},{"location":"examples/#Flux-Limiters-advection-2","page":"Examples","title":"Flux Limiters advection","text":"","category":"section"},{"location":"examples/","page":"Examples","title":"Examples","text":"The 3D Cartesian advection/transport example in examples/hybrid/box/limiters_advection.jl demonstrates the application of flux limiters in the horizontal direction, namely QuasiMonotoneLimiter, in a hybrid Cartesian domain. It also demonstrates the usage of the high-order upwinding scheme in the vertical direction, called Upwind3rdOrderBiasedProductC2F.","category":"page"},{"location":"examples/#Equations-and-discretizations-2","page":"Examples","title":"Equations and discretizations","text":"","category":"section"},{"location":"examples/#Mass-2","page":"Examples","title":"Mass","text":"","category":"section"},{"location":"examples/","page":"Examples","title":"Examples","text":"Follows the continuity equation","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"beginequation\n  fracpartialpartial t rho = - nabla cdot(rho boldsymbolu) \nlabeleq3d-box-advection-lim-continuity\nendequation","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"This is discretized using the following","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"beginequation\n  fracpartialpartial t rho approx - D_h rho (boldsymbolu_h + I^c(boldsymbolu_v)) - D^c_vI^f(rho boldsymbolu_h)) + I^f(rho) boldsymbolu_v) \nlabeleq3d-box-advection-lim-discrete-continuity\nendequation","category":"page"},{"location":"examples/#Tracers-2","page":"Examples","title":"Tracers","text":"","category":"section"},{"location":"examples/","page":"Examples","title":"Examples","text":"For the tracer concentration per unit mass q, the tracer density (scalar) rho q follows the advection/transport equation","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"beginequation\n  fracpartialpartial t rho q = - nabla cdot(rho q boldsymbolu)  + g(rho q)\nlabeleq3d-box-advection-lim-tracers\nendequation","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"This is discretized using the following","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"beginequation\nfracpartialpartial t rho q approx\n- D_h rho q (boldsymbolu_h + I^c(boldsymbolu_v))\n- D^c_vleftI^f(rho q) U^fleft(I^f(boldsymbolu_h) + boldsymbolu_v fracrho qrho right) right + g(rho q)\nlabeleq3d-box-advection-lim-discrete-tracers\nendequation","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"where g(rho q) = - nu_4 nabla^4_h (rho q) represents the horizontal hyperdiffusion operator, with nu_4 (measured in m^4/s) the hyperviscosity constant coefficient.","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"Currently tracers are only treated explicitly in the time discretization.","category":"page"},{"location":"examples/#Prognostic-variables-2","page":"Examples","title":"Prognostic variables","text":"","category":"section"},{"location":"examples/","page":"Examples","title":"Examples","text":"rho: density measured in kg/m³. This is discretized at cell centers.\nboldsymbolu velocity, a vector measured in m/s. This is discretized via boldsymbolu = boldsymbolu_h + boldsymbolu_v where\nboldsymbolu_h = u_1 boldsymbole^1 + u_2 boldsymbole^2 is the projection onto horizontal covariant components (covariance here means with respect to the reference element), stored at cell centers.\nboldsymbolu_v = u_3 boldsymbole^3 is the projection onto the vertical covariant components, stored at cell faces.\nrho q: the tracer density scalar, where q is the tracer concentration per unit mass, is stored at cell centers.","category":"page"},{"location":"examples/#Operators","page":"Examples","title":"Operators","text":"","category":"section"},{"location":"examples/","page":"Examples","title":"Examples","text":"We make use of the following operators","category":"page"},{"location":"examples/#Reconstructions","page":"Examples","title":"Reconstructions","text":"","category":"section"},{"location":"examples/","page":"Examples","title":"Examples","text":"I^c is the face-to-center reconstruction operator, called first_order_If2c in the example code.\nI^f is the center-to-face reconstruction operator, called first_order_Ic2f in the example code.\nCurrently this is just the arithmetic mean, but we will need to use a weighted version with stretched vertical grids.\nU^f is the center-to-face upwind product operator, called third_order_upwind_c2f in the example code\nThis operator is of third-order of accuracy (when used with a constant vertical velocity and some reduced, but still high-order for non constant vertical velocity).","category":"page"},{"location":"examples/#Differentiation-operators-2","page":"Examples","title":"Differentiation operators","text":"","category":"section"},{"location":"examples/","page":"Examples","title":"Examples","text":"D_h is the discrete horizontal strong spectral divergence, called hdiv in the example code.\nwD_h is the discrete horizontal weak spectral divergence, called hwdiv in the example code.\nD^c_v is the face-to-center vertical divergence, called vdivf2c in the example code.\nThis example uses advective fluxes equal to zero at the top and bottom boundaries.\nG_h is the discrete horizontal spectral gradient, called hgrad in the example code.","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"To discretize the hyperdiffusion operator, g(rho q) = - nu_4 nabla^4 (rho q), in the horizontal direction, we compose the horizontal weak divergence, wD_h, and the horizontal gradient operator, G_h, twice, with an intermediate call to weighted_dss! between the two compositions, as in g_2(rho g) circ DSS(rho q) circ g_1(rho q), with:","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"g_1(rho q) = wD_h(G_h(q))\nDSS(rho q) = DSS(g_1(rho q))\ng_2(rho q) = -nu_4 wD_h(rho G_h(rho q))\nwith nu_4 the hyperviscosity coefficient.","category":"page"},{"location":"examples/#Application-of-Flux-Limiters-2","page":"Examples","title":"Application of Flux Limiters","text":"","category":"section"},{"location":"examples/","page":"Examples","title":"Examples","text":"note: Note\nSince we use flux limiters that limit only operators defined in the spectral space (i.e., they are applied level-wise in the horizontal direction), the application of limiters has to follow a precise order in the sequence of operations that specifies the total tendency.","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"The order of operations should be the following:","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"Horizontal transport (with strong divergence D_h)\nHorizontal Flux Limiters\nHorizontal hyperdiffusion (with weak divergence wD_h)\nVertical transport\nDSS","category":"page"},{"location":"examples/#Problem-flow-and-set-up-2","page":"Examples","title":"Problem flow and set-up","text":"","category":"section"},{"location":"examples/","page":"Examples","title":"Examples","text":"This test case is set up in a Cartesian (box) domain -2 pi 2 pi^2 times 0 4 pi textrmm^3, doubly periodic in the horizontal direction, but not in the vertical direction.","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"The flow was chosen to be a spiral, i.e., so to have a horizontal uniform rotation, and a vertical velocity boldsymbolu_v equiv w = 0 at the top and bottom boundaries, and boldsymbolu_v equiv w = 1 in the center of the domain. Moreover, the flow is reversed in all directions halfway through the time period so that the tracer blobs go back to its initial configuration (using the same speed scaling constant which was derived to account for the distance travelled in all directions in a half period).","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"beginalign\n    u = -u_0 (y - c_y) cos(pi t  T_f) nonumber \n    v = u_0 (x - c_x) cos(pi t  T_f) nonumber \n    w = u_0 sin(pi z  z_m) cos(pi t  T_f) nonumber\nlabeleq3d-box-advection-lim-flow\nendalign","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"where u_0 = pi  2 is the speed scaling factor to have the flow reversed halfway through the time period, boldsymbolc = (c_x c_y) is the center of the rotational flow, which coincides with the center of the domain,  z_m = 4 pi is the maximum height of the domain, and T_f = 2 pi is the final simulation time, which coincides with the temporal period to have a full rotation in the horizontal direction.","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"This example is set up to run with three possible initial conditions:","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"cosine_bells\ngaussian_bells\nslotted_spheres: a slight modification of the 2D slotted cylinder test case available in the literature (cfr: [14]).","category":"page"},{"location":"examples/#Application-of-Flux-Limiters-3","page":"Examples","title":"Application of Flux Limiters","text":"","category":"section"},{"location":"examples/","page":"Examples","title":"Examples","text":"Because this is a Cartesian 3D problem, the application of limiters does not affect the order of operations, which is implemented as follows:","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"Horizontal transport + hyperdiffusion (with weak divergence wD_h)\nHorizontal flux limiters\nVertical transport\nDSS","category":"page"},{"location":"examples/#2D-Sphere-examples","page":"Examples","title":"2D Sphere examples","text":"","category":"section"},{"location":"examples/#Flux-Limiters-advection-3","page":"Examples","title":"Flux Limiters advection","text":"","category":"section"},{"location":"examples/","page":"Examples","title":"Examples","text":"The 2D sphere advection/transport example in examples/sphere/limiters_advection.jl demonstrates the application of flux limiters in the horizontal direction, namely QuasiMonotoneLimiter, in a 2D spherical domain.","category":"page"},{"location":"examples/#Equations-and-discretizations-3","page":"Examples","title":"Equations and discretizations","text":"","category":"section"},{"location":"examples/#Mass-3","page":"Examples","title":"Mass","text":"","category":"section"},{"location":"examples/","page":"Examples","title":"Examples","text":"Follows the continuity equation","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"beginequation\n  fracpartialpartial t rho = - nabla cdot(rho boldsymbolu) \nlabeleq2d-sphere-advection-lim-continuity\nendequation","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"This is discretized using the following","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"beginequation\n  fracpartialpartial t rho approx - wD rho boldsymbolu \nlabeleq2d-sphere-advection-lim-discrete-continuity\nendequation","category":"page"},{"location":"examples/#Tracers-3","page":"Examples","title":"Tracers","text":"","category":"section"},{"location":"examples/","page":"Examples","title":"Examples","text":"For the tracer concentration per unit mass q, the tracer density (scalar) rho q follows the advection/transport equation","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"beginequation\n  fracpartialpartial t rho q = - nabla cdot(rho q boldsymbolu)  + g(rho q)\nlabeleq2d-sphere-advection-lim-tracers\nendequation","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"This is discretized using the following","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"beginequation\nfracpartialpartial t rho q approx - wD rho q boldsymbolu + g(rho q)\nlabeleq2d-sphere-advection-lim-discrete-tracers\nendequation","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"where g(rho q) = - nu_4 nabla^4_h (rho q) represents the horizontal hyperdiffusion operator, with nu_4 (measured in m^4/s) the hyperviscosity constant coefficient.","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"Currently tracers are only treated explicitly in the time discretization.","category":"page"},{"location":"examples/#Prognostic-variables-3","page":"Examples","title":"Prognostic variables","text":"","category":"section"},{"location":"examples/","page":"Examples","title":"Examples","text":"rho: density measured in kg/m³.\nboldsymbolu velocity, a vector measured in m/s. Since this is a 2D problem, boldsymbolu equiv boldsymbolu_h.\nrho q: the tracer density scalar, where q is the tracer concentration per unit mass.","category":"page"},{"location":"examples/#Differentiation-operators-3","page":"Examples","title":"Differentiation operators","text":"","category":"section"},{"location":"examples/","page":"Examples","title":"Examples","text":"Because this is a purely 2D problem, there is no staggered vertical discretization, hence, there is no need of specifying variables at cell centers, faces or to reconstruct from faces to centers and vice versa.","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"wD is the discrete horizontal weak spectral divergence, called wdiv in the example code.\nG is the discrete horizontal strong spectral gradient, called grad in the example code.","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"To discretize the hyperdiffusion operator, g(rho q) = - nu_4 nabla^4 (rho q), in the horizontal direction, we compose the horizontal weak divergence, wD, and the horizontal gradient operator, G_h, twice, with an intermediate call to weighted_dss! between the two compositions, as in g_2(rho g) circ DSS(rho q) circ g_1(rho q), with:","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"g_1(rho q) = wD(G_h(q))\nDSS(rho q) = DSS(g_1(rho q))\ng_2(rho q) = -nu_4 wD(rho G_h(rho q))\nwith nu_4 the hyperviscosity coefficient.","category":"page"},{"location":"examples/#Problem-flow-and-set-up-3","page":"Examples","title":"Problem flow and set-up","text":"","category":"section"},{"location":"examples/","page":"Examples","title":"Examples","text":"This test case is set up in a Cartesian planar domain -2 pi 2 pi^2, doubly periodic.","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"The flow was chosen to be a horizontal uniform rotation. Moreover, the flow is reversed halfway through the time period so that the tracer blobs go back to its initial configuration (using the same speed scaling constant which was derived to account for the distance travelled in all directions in a half period).","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"beginalign\n    u = k sin (lambda)^2  sin (2  phi)  cos(pi  t  T_f) +\n       frac2 piT_f cos (phi) nonumber \n    v = k sin (2  lambda) cos (phi) cos(pi t  T_f)\nlabeleq2d-sphere-lim-flow\nendalign","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"where u_0 = 2 pi R  T_f is the speed scaling factor to have the flow reversed halfway through the time period, T_f = 86400 * 12 (i.e., 12 days in seconds) is the final simulation time, which coincides with the temporal period to have a full rotation around the sphere of radius R.","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"This example is set up to run with three possible initial conditions:","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"cosine_bells\ngaussian_bells\ncylinders: two 2D slotted cylinders (test case available in the literature, cfr: [14]).","category":"page"},{"location":"examples/#Application-of-Flux-Limiters-4","page":"Examples","title":"Application of Flux Limiters","text":"","category":"section"},{"location":"examples/","page":"Examples","title":"Examples","text":"Because this is a fully 2D problem, the application of limiters does not affect the order of operations, which is implemented as follows:","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"Horizontal trasport with hyperdiffusion (with weak divergence wD)\nHorizontal flux limiters\nDSS","category":"page"},{"location":"examples/#Shallow-water-equations","page":"Examples","title":"Shallow-water equations","text":"","category":"section"},{"location":"examples/","page":"Examples","title":"Examples","text":"The shallow water equations in the so-called vector invariant form from [15] are:","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"beginalign\n  fracpartial hpartial t + nabla cdot (h u) = 0\n  fracpartial u_ipartial t + nabla (Phi + tfrac12u^2)_i  = (boldsymbolu times (f + nabla times boldsymbolu))_i\nlabeleqshallow-water\nendalign","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"where f is the Coriolis term and Phi = g(h+h_s), with g the gravitational accelration constant, h the (free) height of the fluid and  h_s a non-uniform reference surface.","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"To the above set of equations, we allow the uset to add a hyperdiffusion operator, g(h boldsymbolu) = - nu_4 nabla^4 (h boldsymbolu), with nu_4 (measured in m^4/s) the hyperviscosity constant coefficient. In the hyperdiffusion expression, nabla^4 represents a biharmonic operator, and it assumes a different formulation on curvilinear reference systems, depending on it being applied to a scalar field, such as h, or a vector field, such as boldsymbolu.","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"The governing equations then become:","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"beginalign\n  fracpartial hpartial t + nabla cdot (h u) = g(h boldsymbolu)\n  fracpartial u_ipartial t + nabla (Phi + tfrac12u^2)_i  = (boldsymbolu times (f + nabla times boldsymbolu))_i + g(h boldsymbolu)\nlabeleqshallow-water-with-hyperdiff\nendalign","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"Since this is a 2D problem (with related 2D vector field), the curl is defined to be","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"beginalign\n omega^i = (nabla times u)^i =\n    begincases\n        0 text if i =12\n        frac1J left fracpartial u_2partial xi^1 - fracpartial u_1partial xi^2 right text if i=3\n    endcases\nlabeleq2Dvorticity\nendalign","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"where we have used the coordinate system in each 2D reference element, i.e., (xi^1 xi^2) in -11times-11. Similarly, if additionally v^1 = v^2 = 0, then","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"beginalign\n   (boldsymbolu times boldsymbolv)_i =\n    begincases\n          J u^2 v^3 text if i=1\n        - J u^1 v^3 text if i=2\n        0 text if i=3\n    endcases\nendalign","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"Hence, we can rewrite equations \\eqref{eq:shallow-water} using the velocity representation in covariant coordinates, in this case u = u_1 boldsymbolb^1 + u_2 boldsymbolb^2 + 0boldsymbolb^3, and g(h boldsymbolu) = 0 for simplicity, as:","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"beginalign\n    fracpartial hpartial t + frac1Jfracpartialpartial xi^jBig(h J u^jBig) = 0\n    fracpartial u_ipartial t + fracpartialpartial xi^i (Phi + tfrac12u^2)  = E_ijku^j (f^k + omega^k) \nlabeleqcovariant-shallow-water\nendalign","category":"page"},{"location":"examples/#Prognostic-variables-4","page":"Examples","title":"Prognostic variables","text":"","category":"section"},{"location":"examples/","page":"Examples","title":"Examples","text":"h: scalar height field of the fluid, measured in m.\nboldsymbolu velocity, a 2D vector measured in m/s.","category":"page"},{"location":"examples/#Differentiation-operators-4","page":"Examples","title":"Differentiation operators","text":"","category":"section"},{"location":"examples/","page":"Examples","title":"Examples","text":"Because this is a purely 2D problem, there is no staggered vertical discretization, hence, there is no need of specifying variables at cell centers, faces or to reconstruct from faces to centers and vice versa.","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"D is the discrete horizontal strong spectral divergence, called div in the example code.\nwD is the discrete horizontal weak spectral divergence, called wdiv in the example code.\nG is the discrete horizontal strong spectral gradient, called grad in the example code.\nwG is the discrete horizontal weak spectral gradient, called wgrad in the example code.\nCurl is the discrete curl, called curl in the example code.\nwCurl is the discrete weak curl, called wcurl in the example code.","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"To discretize the hyperdiffusion operator, g(h boldsymbolu) = - nu_4 nabla^4 (h boldsymbolu), in the horizontal direction, we compose the weak divergence, wD, and the gradient operator, G, twice, with an intermediate call to weighted_dss! between the two compositions, as in g_2(h boldsymbolu) circ DSS(h boldsymbolu) circ g_1(h boldsymbolu). Moreover, when g(h boldsymbolu) = - nu_4 nabla^4 (h), i.e., the operator is applied to a scalar field only, it is discretized composing the following operations:","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"g_1(h) = wD(G(h))\nDSS(g_1(h))\ng_2(h) = -nu_4 wD(G(h))","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"whereas, when the operator is applied to a vector field, i.e., g(h boldsymbolu) = - nu_4 nabla^4 (boldsymbolu), it is discretized as:","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"g_1(h boldsymbolu) = wG(D(boldsymbolu)) - wCurl(Curl(boldsymbolu))\nDSS(h boldsymbolu) = DSS(g_1(h boldsymbolu))\ng_2(h boldsymbolu) = -nu_4 left wG(D(boldsymbolu)) - wCurl(Curl(boldsymbolu)) right","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"In both cases, nu_4 is the hyperviscosity coefficient.","category":"page"},{"location":"examples/#Problem-flow-and-set-up-4","page":"Examples","title":"Problem flow and set-up","text":"","category":"section"},{"location":"examples/","page":"Examples","title":"Examples","text":"This test case is set up on a 2D (surface) spherical domain represented by a cubed-sphere manifold.","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"This suite of examples contains five different test cases:","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"One, invoked via the command-line argument steady_state, which reproduces Test Case 2 in [16]. This test case gives the steady-state solution to the non-linear shallow water equations. It consists of a solid body rotation or zonal flow with the corresponding geostrophic height field. The Coriolis parameter is a function of latitude and longitude so the flow can be specified with the spherical coordinate poles not necessarily coincident with Earth's rotation axis. Hence, this test case can be run with a specified command-line argument for the angle alpha that represents the angle between the north pole and the center of the top cube panel of the cubed-sphere geometry.\nA second one, invoked via the command-line argument steady_state_compact, reproduces Test Case 3 in [16]. This test case gives the steady-state solution to the non-linear shallow water equations with nonlinear zonal geostrophic flow with compact support.\nA third one, invoked via the command-line argument mountain, reproduces Test Case 5 in [16]. It represents a zonal flow over an isolated mountain, where the governing equations describe a global steady-state nonlinear zonal geostrophic flow, with a corresponding geostrophic height field over a non-uniform reference surface h_s.\nA fourth one, invoked via the command-line argument rossby_haurwitz, reproduces Test Case 6 in [16]. It represents the solution of the nonlinear barotropic vorticity equation on the sphere.\nA fifth one, invoked via the command-line argument barotropic_instability, reproduces the test case in [17] (also in Sec. 7.6 in [18]). This test case consists of a zonal jet with compact support at a latitude of 45. A small height disturbance is then added, which causes the jet to become unstable and collapse into a highly vortical structure.","category":"page"},{"location":"examples/#3D-Sphere-examples","page":"Examples","title":"3D Sphere examples","text":"","category":"section"},{"location":"examples/#Deformation-Flow-with-Flux-Limiters","page":"Examples","title":"Deformation Flow with Flux Limiters","text":"","category":"section"},{"location":"examples/","page":"Examples","title":"Examples","text":"The 3D sphere advection/transport example in examples/hybrid/sphere/deformation_flow.jl demonstrates the application of flux limiters in the horziontal direction, namely QuasiMonotoneLimiter, in a hybrid 3D spherical domain. It also demonstrates the usage of the flux-corrected transport in the vertical direction; by default, it uses FCTZalesak.","category":"page"},{"location":"examples/#Equations-and-discretizations-4","page":"Examples","title":"Equations and discretizations","text":"","category":"section"},{"location":"examples/","page":"Examples","title":"Examples","text":"The original test case (without limiters or flux-corrected transport) is specified in Section 1.1 of [19].","category":"page"},{"location":"examples/#Mass-4","page":"Examples","title":"Mass","text":"","category":"section"},{"location":"examples/","page":"Examples","title":"Examples","text":"Follows the continuity equation","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"beginequation\n  fracpartialpartial t rho = - nabla cdot(rho boldsymbolu) \nlabeleq3d-sphere-lim-continuity\nendequation","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"This is discretized using the following","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"beginequation\n  fracpartialpartial t rho approx - D_hrho boldsymbolu^c - D^c_vI^f(rho) boldsymbolu^f\nlabeleq3d-sphere-lim-discrete-continuity\nendequation","category":"page"},{"location":"examples/#Tracers-4","page":"Examples","title":"Tracers","text":"","category":"section"},{"location":"examples/","page":"Examples","title":"Examples","text":"This test case has five different tracer concentrations per unit mass q_i, hence five different tracer densities (scalar) rho q_i. They all follow the same advection/transport equation","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"beginequation\n  fracpartialpartial t rho q = - nabla cdot(rho q boldsymbolu)  + g(rho q)\nlabeleq3d-sphere-lim-tracers\nendequation","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"This is discretized using the following","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"beginequation\nfracpartialpartial t rho q approx\n- D_h rho q boldsymbolu^c\n- D^c_vleftI^f(rho q) * boldsymbolu^f_h + FCT^fleft( boldsymbolu^f_v fracrho qrho right) right + g(rho q)\nlabeleq3d-sphere-lim-discrete-tracers\nendequation","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"where g(rho q) = - nu_4 nabla^4_h (rho q) represents the horizontal hyperdiffusion operator, with nu_4 (measured in m^4/s) the hyperviscosity constant coefficient.","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"Currently tracers are only treated explicitly in the time discretization.","category":"page"},{"location":"examples/#Prognostic-variables-5","page":"Examples","title":"Prognostic variables","text":"","category":"section"},{"location":"examples/","page":"Examples","title":"Examples","text":"rho: density measured in kg/m³. This is discretized at cell centers.\nboldsymbolu velocity, a vector measured in m/s. This is discretized via boldsymbolu = boldsymbolu_h + boldsymbolu_v where\nboldsymbolu_h = u_1 boldsymbole^1 + u_2 boldsymbole^2 is the projection onto horizontal covariant components (covariance here means with respect to the reference element), stored at cell centers.\nboldsymbolu_v = u_3 boldsymbole^3 is the projection onto the vertical covariant components, stored at cell faces.\nrho q_i: tracer density scalars, where q_i is a tracer concentration per unit mass, are stored at cell centers.","category":"page"},{"location":"examples/#Operators-2","page":"Examples","title":"Operators","text":"","category":"section"},{"location":"examples/","page":"Examples","title":"Examples","text":"We make use of the following operators","category":"page"},{"location":"examples/#Reconstructions-2","page":"Examples","title":"Reconstructions","text":"","category":"section"},{"location":"examples/","page":"Examples","title":"Examples","text":"I^c is the face-to-center reconstruction operator, called If2c in the example code.\nI^f is the center-to-face reconstruction operator, called Ic2f in the example code.\nCurrently this is just the arithmetic mean, but we will need to use a weighted version with stretched vertical grids.\nFCT^f denotes either the center-to-face upwind product operator (which represents no flux-corrected transport), the center-to-face Boris & Book FCT operator, or the center-to-face Zalesak FCT operator.","category":"page"},{"location":"examples/#Differentiation-operators-5","page":"Examples","title":"Differentiation operators","text":"","category":"section"},{"location":"examples/","page":"Examples","title":"Examples","text":"D_h is the discrete horizontal strong spectral divergence, called hdiv in the example code.\nwD_h is the discrete horizontal weak spectral divergence, called hwdiv in the example code.\nD^c_v is the face-to-center vertical divergence, called vdivf2c in the example code.\nThis example uses advective fluxes equal to zero at the top and bottom boundaries.\nG_h is the discrete horizontal spectral gradient, called hgrad in the example code.","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"To discretize the hyperdiffusion operator for each tracer concentration, g(rho q_i) = - nu_4 nabla^4 (rho q_i), in the horizontal direction, we compose the horizontal weak divergence, wD_h, and the horizontal gradient operator, G_h, twice, with an intermediate call to weighted_dss! between the two compositions, as in g_2(rho g) circ DSS(rho q) circ g_1(rho q_i), with:","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"g_1(rho q_i) = wD_h(G_h(q_i))\nDSS(rho q_i) = DSS(g_1(rho q_i))\ng_2(rho q_i) = -nu_4 wD_h(rho G_h(rho q_i))\nwith nu_4 the hyperviscosity coefficient.","category":"page"},{"location":"examples/#Application-of-Flux-Limiters-5","page":"Examples","title":"Application of Flux Limiters","text":"","category":"section"},{"location":"examples/","page":"Examples","title":"Examples","text":"note: Note\nSince we use flux limiters that limit only operators defined in the spectral space (i.e., they are applied level-wise in the horizontal direction), the application of limiters has to follow a precise order in the sequence of operations that specifies the total tendency.","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"The order of operations should be the following:","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"Horizontal transport (with strong divergence D_h)\nHorizontal flux limiters\nHorizontal hyperdiffusion (with weak divergence wD_h)\nVertical transport\nDSS","category":"page"},{"location":"examples/#Problem-flow-and-set-up-5","page":"Examples","title":"Problem flow and set-up","text":"","category":"section"},{"location":"examples/","page":"Examples","title":"Examples","text":"This test case is set up in a 3D (shell) spherical domain where the elevation goes from z=0textrmm (i.e., from the radius of the sphere R = 637122 10^6textrmm) to z_textrmtop = 12000textrmm.","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"The flow (reversed halfway through the time period) is specified as boldsymbolu = boldsymbolu_a + boldsymbolu_d, where the components are defined as follows:","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"beginalign\n  u_a = k sin (lambda)^2  sin (2  phi)  cos(pi  t  tau) +\n      frac2 pi Rtau cos (phi) nonumber \n  v_a = k sin (2  lambda) cos (phi) cos(pi t  tau) nonumber \n  u_d = fracomega_0  R b  p_textrmtop cos (lambda) cos(phi)^2 cos(2 pi t  tau) left-exp left( frac(p - p_0) b p_textrmtop right) + exp left( frac(p_textrmtop - p(zc))b p_textrmtop right) right nonumber\nlabeleq3d-sphere-lim-flow\nendalign","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"where all values of the parameters can be found in Table 1.1 in the reference [19].","category":"page"},{"location":"#ClimaCore.jl","page":"Home","title":"ClimaCore.jl","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"ClimaCore.jl constitutes the dynamical core (dycore) of the atmosphere and land models for CliMA's Earth System Model (ESM). ClimaCore.jl provides flexible and composable discretization tools to solve the governing equations of the ESM component models. In fact, ClimaCore.jl's high-level application programming interface (API) facilitates modularity and composition of differential operators and the definition of flexible discretizations. This, in turn, is coupled with low-level APIs that support different data layouts, specialized implementations, and flexible models for threading, to better face high-performance optimization, data storage, and scalability challenges on modern HPC architectures.","category":"page"}]
}
