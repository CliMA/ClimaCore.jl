<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>API · ClimaCore.jl</title><script data-outdated-warner src="../assets/warner.js"></script><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.045/juliamono.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.4/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.4/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.4/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.13.24/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL=".."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../assets/documenter.js"></script><script src="../siteinfo.js"></script><script src="../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><a class="docs-logo" href="../"><img src="../assets/logo.png" alt="ClimaCore.jl logo"/></a><div class="docs-package-name"><span class="docs-autofit"><a href="../">ClimaCore.jl</a></span></div><form class="docs-search" action="../search/"><input class="docs-search-query" id="documenter-search-query" name="q" type="text" placeholder="Search docs"/></form><ul class="docs-menu"><li><a class="tocitem" href="../">Home</a></li><li><a class="tocitem" href="../intro/">Introduction</a></li><li><a class="tocitem" href="../math_framework/">Mathematical Framework</a></li><li><a class="tocitem" href="../installation_instructions/">Installation and How-to Guides</a></li><li><a class="tocitem" href="../operators/">Operators</a></li><li><a class="tocitem" href="../matrix_fields/">MatrixFields</a></li><li class="is-active"><a class="tocitem" href>API</a><ul class="internal"><li><a class="tocitem" href="#DataLayouts"><span>DataLayouts</span></a></li><li><a class="tocitem" href="#Geometry"><span>Geometry</span></a></li><li><a class="tocitem" href="#Domains"><span>Domains</span></a></li><li><a class="tocitem" href="#Meshes"><span>Meshes</span></a></li><li><a class="tocitem" href="#Topologies"><span>Topologies</span></a></li><li><a class="tocitem" href="#Spaces"><span>Spaces</span></a></li><li><a class="tocitem" href="#RecursiveApply"><span>RecursiveApply</span></a></li><li><a class="tocitem" href="#Fields"><span>Fields</span></a></li><li><a class="tocitem" href="#Hypsography"><span>Hypsography</span></a></li><li><a class="tocitem" href="#Limiters"><span>Limiters</span></a></li><li><a class="tocitem" href="#InputOutput"><span>InputOutput</span></a></li><li><a class="tocitem" href="#Remapping"><span>Remapping</span></a></li></ul></li><li><input class="collapse-toggle" id="menuitem-8" type="checkbox"/><label class="tocitem" for="menuitem-8"><span class="docs-label">Developer docs</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../performance_tips/">Performance tips</a></li></ul></li><li><input class="collapse-toggle" id="menuitem-9" type="checkbox"/><label class="tocitem" for="menuitem-9"><span class="docs-label">Tutorials</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../tutorials/introduction/">Introduction to ClimaCore.jl</a></li></ul></li><li><a class="tocitem" href="../examples/">Examples</a></li><li><input class="collapse-toggle" id="menuitem-11" type="checkbox"/><label class="tocitem" for="menuitem-11"><span class="docs-label">Libraries</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../lib/ClimaCorePlots/">ClimaCorePlots.jl</a></li><li><a class="tocitem" href="../lib/ClimaCoreMakie/">ClimaCoreMakie.jl</a></li><li><a class="tocitem" href="../lib/ClimaCoreVTK/">ClimaCoreVTK.jl</a></li><li><a class="tocitem" href="../lib/ClimaCoreTempestRemap/">ClimaCoreTempestRemap.jl</a></li><li><a class="tocitem" href="../lib/ClimaCoreSpectra/">ClimaCoreSpectra.jl</a></li></ul></li><li><a class="tocitem" href="../Contributing/">Contributing guide</a></li><li><a class="tocitem" href="../code_of_conduct/">Code of Conduct</a></li><li><a class="tocitem" href="../references/">References</a></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><nav class="breadcrumb"><ul class="is-hidden-mobile"><li class="is-active"><a href>API</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>API</a></li></ul></nav><div class="docs-right"><a class="docs-edit-link" href="https://github.com/CliMA/ClimaCore.jl/blob/main/docs/src/api.md" title="Edit on GitHub"><span class="docs-icon fab"></span><span class="docs-label is-hidden-touch">Edit on GitHub</span></a><a class="docs-settings-button fas fa-cog" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-sidebar-button fa fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a></div></header><article class="content" id="documenter-page"><h1 id="API"><a class="docs-heading-anchor" href="#API">API</a><a id="API-1"></a><a class="docs-heading-anchor-permalink" href="#API" title="Permalink"></a></h1><h2 id="DataLayouts"><a class="docs-heading-anchor" href="#DataLayouts">DataLayouts</a><a id="DataLayouts-1"></a><a class="docs-heading-anchor-permalink" href="#DataLayouts" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-binding" id="ClimaCore.DataLayouts" href="#ClimaCore.DataLayouts"><code>ClimaCore.DataLayouts</code></a> — <span class="docstring-category">Module</span></header><section><div><pre><code class="language-julia hljs">ClimaCore.DataLayouts</code></pre><p>Notation:</p><ul><li><code>i,j</code> are horizontal node indices within an element</li><li><code>k</code> is the vertical node index within an element</li><li><code>f</code> is the field index (1 if field is scalar, &gt;1 if it is a vector field)</li><li><code>v</code> is the vertical element index in a stack</li><li><code>h</code> is the element stack index</li></ul><p>Data layout is specified by the order in which they appear, e.g. <code>IJKFVH</code> indexes the underlying array as <code>[i,j,k,f,v,h]</code></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/CliMA/ClimaCore.jl/blob/a889c473979567e2e318739ae773325f39b0d156/src/DataLayouts/DataLayouts.jl#L1-L14">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="ClimaCore.DataLayouts.DataF" href="#ClimaCore.DataLayouts.DataF"><code>ClimaCore.DataLayouts.DataF</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">DataF{S, A} &lt;: Data0D{S}</code></pre><p>Backing <code>DataLayout</code> for 0D point data.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/CliMA/ClimaCore.jl/blob/a889c473979567e2e318739ae773325f39b0d156/src/DataLayouts/DataLayouts.jl#L530-L534">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="ClimaCore.DataLayouts.IF" href="#ClimaCore.DataLayouts.IF"><code>ClimaCore.DataLayouts.IF</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">IF{S, Ni, A} &lt;: DataSlab1D{S, Ni}</code></pre><p>Backing <code>DataLayout</code> for 1D spectral element slab data.</p><p>Nodal element data (I) are contiguous for each <code>S</code> datatype struct field (F) for a single element slab.</p><p>A <code>DataSlab1D</code> view can be returned from other <code>Data1D</code> objects by calling <code>slab(data, idx...)</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/CliMA/ClimaCore.jl/blob/a889c473979567e2e318739ae773325f39b0d156/src/DataLayouts/DataLayouts.jl#L788-L796">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="ClimaCore.DataLayouts.IJF" href="#ClimaCore.DataLayouts.IJF"><code>ClimaCore.DataLayouts.IJF</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">IJF{S, Nij, A} &lt;: DataSlab2D{S, Nij}</code></pre><p>Backing <code>DataLayout</code> for 2D spectral element slab data.</p><p>Nodal element data (I,J) are contiguous for each <code>S</code> datatype struct field (F) for a single element slab.</p><p>A <code>DataSlab2D</code> view can be returned from other <code>Data2D</code> objects by calling <code>slab(data, idx...)</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/CliMA/ClimaCore.jl/blob/a889c473979567e2e318739ae773325f39b0d156/src/DataLayouts/DataLayouts.jl#L649-L657">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="ClimaCore.DataLayouts.VF" href="#ClimaCore.DataLayouts.VF"><code>ClimaCore.DataLayouts.VF</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">VF{S, A} &lt;: DataColumn{S}</code></pre><p>Backing <code>DataLayout</code> for 1D FV column data.</p><p>Column level data (V) are contiguous for each <code>S</code> datatype struct field (F).</p><p>A <code>DataColumn</code> view can be returned from other <code>Data1DX</code>, <code>Data2DX</code> objects by calling <code>column(data, idx...)</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/CliMA/ClimaCore.jl/blob/a889c473979567e2e318739ae773325f39b0d156/src/DataLayouts/DataLayouts.jl#L886-L894">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="ClimaCore.DataLayouts.IFH" href="#ClimaCore.DataLayouts.IFH"><code>ClimaCore.DataLayouts.IFH</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">IFH{S, Ni, A} &lt;: Data1D{S, Ni}</code></pre><p>Backing <code>DataLayout</code> for 1D spectral element slabs.</p><p>Element nodal point (I) data is contiguous for each datatype <code>S</code> struct field (F), for each 1D mesh element (H).</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/CliMA/ClimaCore.jl/blob/a889c473979567e2e318739ae773325f39b0d156/src/DataLayouts/DataLayouts.jl#L398-L405">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="ClimaCore.DataLayouts.IJFH" href="#ClimaCore.DataLayouts.IJFH"><code>ClimaCore.DataLayouts.IJFH</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">IJFH{S, Nij, A} &lt;: Data2D{S, Nij}</code></pre><p>Backing <code>DataLayout</code> for 2D spectral element slabs.</p><p>Element nodal point (I,J) data is contiguous for each datatype <code>S</code> struct field (F), for each 2D mesh element slab (H).</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/CliMA/ClimaCore.jl/blob/a889c473979567e2e318739ae773325f39b0d156/src/DataLayouts/DataLayouts.jl#L242-L249">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="ClimaCore.DataLayouts.VIFH" href="#ClimaCore.DataLayouts.VIFH"><code>ClimaCore.DataLayouts.VIFH</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">VIFH{S, Ni, A} &lt;: Data1DX{S, Ni}</code></pre><p>Backing <code>DataLayout</code> for 1D spectral element slab + extruded 1D FV column data.</p><p>Column levels (V) are contiguous for every element nodal point (I) for each datatype <code>S</code> struct field (F), for each 1D mesh element slab (H).</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/CliMA/ClimaCore.jl/blob/a889c473979567e2e318739ae773325f39b0d156/src/DataLayouts/DataLayouts.jl#L1175-L1182">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="ClimaCore.DataLayouts.VIJFH" href="#ClimaCore.DataLayouts.VIJFH"><code>ClimaCore.DataLayouts.VIJFH</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">VIJFH{S, Nij, A} &lt;: Data2DX{S, Nij}</code></pre><p>Backing <code>DataLayout</code> for 2D spectral element slab + extruded 1D FV column data.</p><p>Column levels (V) are contiguous for every element nodal point (I, J) for each <code>S</code> datatype struct field (F), for each 2D mesh element slab (H).</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/CliMA/ClimaCore.jl/blob/a889c473979567e2e318739ae773325f39b0d156/src/DataLayouts/DataLayouts.jl#L1008-L1015">source</a></section></article><h2 id="Geometry"><a class="docs-heading-anchor" href="#Geometry">Geometry</a><a id="Geometry-1"></a><a class="docs-heading-anchor-permalink" href="#Geometry" title="Permalink"></a></h2><h3 id="Coordinates"><a class="docs-heading-anchor" href="#Coordinates">Coordinates</a><a id="Coordinates-1"></a><a class="docs-heading-anchor-permalink" href="#Coordinates" title="Permalink"></a></h3><article class="docstring"><header><a class="docstring-binding" id="ClimaCore.Geometry.AbstractPoint" href="#ClimaCore.Geometry.AbstractPoint"><code>ClimaCore.Geometry.AbstractPoint</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">AbstractPoint</code></pre><p>Represents a point in space.</p><p>The following types are supported:</p><ul><li><code>XPoint(x)</code></li><li><code>YPoint(y)</code></li><li><code>ZPoint(z)</code></li><li><code>XYPoint(x, y)</code></li><li><code>XZPoint(x, z)</code></li><li><code>XYZPoint(x, y, z)</code></li><li><code>LatPoint(lat)</code></li><li><code>LongPoint(long)</code></li><li><code>LatLongPoint(lat, long)</code></li><li><code>LatLongZPoint(lat, long, z)</code></li><li><code>Cartesian1Point(x1)</code></li><li><code>Cartesian2Point(x2)</code></li><li><code>Cartesian3Point(x3)</code></li><li><code>Cartesian12Point(x1, x2)</code></li><li><code>Cartesian13Point(x1, x3)</code></li><li><code>Cartesian123Point(x1, x2, x3)</code></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/CliMA/ClimaCore.jl/blob/a889c473979567e2e318739ae773325f39b0d156/src/Geometry/coordinates.jl#L1-L23">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="ClimaCore.Geometry.float_type" href="#ClimaCore.Geometry.float_type"><code>ClimaCore.Geometry.float_type</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">float_type(T)</code></pre><p>Return the floating point type backing <code>T</code>: <code>T</code> can either be an object or a type.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/CliMA/ClimaCore.jl/blob/a889c473979567e2e318739ae773325f39b0d156/src/Geometry/coordinates.jl#L26-L30">source</a></section></article><p>Points represent <em>locations</em> in space, specified by coordinates in a given coordinate system (Cartesian, spherical, etc), whereas vectors, on the other hand, represent <em>displacements</em> in space.</p><p>An analogy with time works well: times (also called instants or datetimes) are <em>locations</em> in time, while, durations are <em>displacements</em> in time.</p><p><strong>Note 1</strong>: Latitude and longitude are specified via angles (and, therefore, trigonometric functions: <code>cosd</code>, <code>sind</code>, <code>acosd</code>, <code>asind</code>, <code>tand</code>,...) in degrees, not in radians. Moreover, <code>lat</code> (usually denoted by <span>$\theta$</span>) <span>$\in [-90.0, 90.0]$</span>, and <code>long</code> (usually denoted by <span>$\lambda$</span>) <span>$\in [-180.0, 180.0]$</span>.</p><p><strong>Note 2:</strong>: In a <code>Geometry.LatLongZPoint(lat, long, z)</code>, <code>z</code> represents the elevation above the surface of the sphere with radius R (implicitly accounted for in the geoemtry).</p><p><strong>Note 3</strong>: There are also a set of specific Cartesian points (<code>Cartesian1Point(x1)</code>, <code>Cartesian2Point(x2)</code>, etc). These are occasionally useful for converting everything to a full Cartesian domain (e.g. for visualization purposes). These are distinct from <code>XYZPoint</code> as <code>ZPoint</code> can mean different things in different domains.</p><h2 id="Domains"><a class="docs-heading-anchor" href="#Domains">Domains</a><a id="Domains-1"></a><a class="docs-heading-anchor-permalink" href="#Domains" title="Permalink"></a></h2><h3 id="Types"><a class="docs-heading-anchor" href="#Types">Types</a><a id="Types-1"></a><a class="docs-heading-anchor-permalink" href="#Types" title="Permalink"></a></h3><article class="docstring"><header><a class="docstring-binding" id="ClimaCore.Domains.AbstractDomain" href="#ClimaCore.Domains.AbstractDomain"><code>ClimaCore.Domains.AbstractDomain</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">AbstractDomain</code></pre><p>A domain represents a region of space.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/CliMA/ClimaCore.jl/blob/a889c473979567e2e318739ae773325f39b0d156/src/Domains/Domains.jl#L7-L11">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="ClimaCore.Domains.IntervalDomain" href="#ClimaCore.Domains.IntervalDomain"><code>ClimaCore.Domains.IntervalDomain</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">IntervalDomain(coord⁻, coord⁺; periodic=true)
IntervalDomain(coord⁻, coord⁺; boundary_names::Tuple{Symbol,Symbol})</code></pre><p>Construct a <code>IntervalDomain</code>, the closed interval is given by <code>coord⁻</code>, <code>coord⁺</code> coordinate arguments.</p><p>Either a <code>periodic</code> or <code>boundary_names</code> keyword argument is required.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/CliMA/ClimaCore.jl/blob/a889c473979567e2e318739ae773325f39b0d156/src/Domains/Domains.jl#L38-L45">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="ClimaCore.Domains.RectangleDomain" href="#ClimaCore.Domains.RectangleDomain"><code>ClimaCore.Domains.RectangleDomain</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">RectangleDomain(x1::ClosedInterval, x2::ClosedInterval;
    x1boundary::Tuple{Symbol,Symbol},
    x2boundary::Tuple{Symbol,Symbol},
    x1periodic = false,
    x2periodic = false,
)</code></pre><p>Construct a <code>RectangularDomain</code> in the horizontal. If a given x1 or x2 boundary is not periodic, then <code>x1boundary</code> or <code>x2boundary</code> boundary name keyword arguments must be supplied.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/CliMA/ClimaCore.jl/blob/a889c473979567e2e318739ae773325f39b0d156/src/Domains/Domains.jl#L94-L104">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="ClimaCore.Domains.SphereDomain" href="#ClimaCore.Domains.SphereDomain"><code>ClimaCore.Domains.SphereDomain</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">SphereDomain(radius)</code></pre><p>A domain representing the surface of a sphere with radius <code>radius</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/CliMA/ClimaCore.jl/blob/a889c473979567e2e318739ae773325f39b0d156/src/Domains/Domains.jl#L135-L139">source</a></section></article><h3 id="Interfaces"><a class="docs-heading-anchor" href="#Interfaces">Interfaces</a><a id="Interfaces-1"></a><a class="docs-heading-anchor-permalink" href="#Interfaces" title="Permalink"></a></h3><article class="docstring"><header><a class="docstring-binding" id="ClimaCore.Domains.boundary_names" href="#ClimaCore.Domains.boundary_names"><code>ClimaCore.Domains.boundary_names</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">boundary_names(obj::Union{AbstractDomain, AbstractMesh, AbstractTopology})</code></pre><p>A tuple or vector of unique boundary names of a spatial domain.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/CliMA/ClimaCore.jl/blob/a889c473979567e2e318739ae773325f39b0d156/src/Domains/Domains.jl#L18-L22">source</a></section></article><h2 id="Meshes"><a class="docs-heading-anchor" href="#Meshes">Meshes</a><a id="Meshes-1"></a><a class="docs-heading-anchor-permalink" href="#Meshes" title="Permalink"></a></h2><p>A <code>Mesh</code> is a division of a domain into elements.</p><h3 id="Mesh-types"><a class="docs-heading-anchor" href="#Mesh-types">Mesh types</a><a id="Mesh-types-1"></a><a class="docs-heading-anchor-permalink" href="#Mesh-types" title="Permalink"></a></h3><article class="docstring"><header><a class="docstring-binding" id="ClimaCore.Meshes.AbstractMesh" href="#ClimaCore.Meshes.AbstractMesh"><code>ClimaCore.Meshes.AbstractMesh</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">AbstractMesh{dim}</code></pre><p>A <code>Mesh</code> is an object which represents how we discretize a domain into elements.</p><p>It should be lightweight (i.e. exists on all MPI ranks), e.g for meshes stored in a file, it would contain the filename.</p><p><strong>Face and vertex numbering</strong></p><p>In 1D, faces and vertices are the same, and both are numbered <code>[1,2]</code>.</p><p>In 2D, a face is a line segment between to vertices, and both are numbered <code>[1,2,3,4]</code>, in a counter-clockwise direction.</p><pre><code class="nohighlight hljs"> v4        f3        v3
   o-----------------o
   |                 |	    face    vertices
   |                 |	      f1 =&gt;  v1 v2
f4 |                 | f2     f2 =&gt;  v2 v3
   |                 |	      f3 =&gt;  v3 v4
   |                 |        f4 =&gt;  v4 v1
   |                 |
   o-----------------o
  v1       f1        v2</code></pre><p><strong>Interface</strong></p><p>A subtype of <code>AbstractMesh</code> should define the following methods:</p><ul><li><a href="#ClimaCore.Meshes.domain"><code>domain(mesh)</code></a></li><li><a href="#ClimaCore.Meshes.elements"><code>elements(mesh)</code></a></li><li><a href="#ClimaCore.Meshes.is_boundary_face"><code>is_boundary_face(mesh, elem, face)</code></a></li><li><a href="#ClimaCore.Meshes.boundary_face_name"><code>boundary_face_name(mesh, elem, face)</code></a></li><li><a href="#ClimaCore.Meshes.opposing_face"><code>opposing_face(mesh, elem, face)</code></a></li><li><a href="#ClimaCore.Meshes.coordinates"><code>coordinates(mesh, elem, vert)</code></a></li><li><a href="#ClimaCore.Meshes.containing_element"><code>containing_element</code></a> (optional)</li></ul><p>The following types/methods are provided by <code>AbstractMesh</code>:</p><ul><li><a href="#ClimaCore.Meshes.SharedVertices"><code>SharedVertices(mesh, elem, vert)</code></a></li><li><a href="#ClimaCore.Meshes.face_connectivity_matrix"><code>face_connectivity_matrix(mesh[,elemorder])</code></a></li><li><a href="#ClimaCore.Meshes.vertex_connectivity_matrix"><code>vertex_connectivity_matrix(mesh[,elemorder])</code></a></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/CliMA/ClimaCore.jl/blob/a889c473979567e2e318739ae773325f39b0d156/src/Meshes/Meshes.jl#L24-L66">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="ClimaCore.Meshes.IntervalMesh" href="#ClimaCore.Meshes.IntervalMesh"><code>ClimaCore.Meshes.IntervalMesh</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">IntervalMesh &lt;: AbstractMesh</code></pre><p>A 1D mesh on an <code>IntervalDomain</code>.</p><p><strong>Constuctors</strong></p><pre><code class="nohighlight hljs">IntervalMesh(domain::IntervalDomain, faces::AbstractVector)</code></pre><p>Construct a 1D mesh with face locations at <code>faces</code>.</p><pre><code class="nohighlight hljs">IntervalMesh(domain::IntervalDomain[, stretching=Uniform()]; nelems=)</code></pre><p>Constuct a 1D mesh on <code>domain</code> with <code>nelems</code> elements, using <code>stretching</code>. Possible values of <code>stretching</code> are:</p><ul><li><a href="#ClimaCore.Meshes.Uniform"><code>Uniform()</code></a></li><li><a href="#ClimaCore.Meshes.ExponentialStretching"><code>ExponentialStretching(H)</code></a></li><li><a href="#ClimaCore.Meshes.GeneralizedExponentialStretching"><code>GeneralizedExponentialStretching(dz_bottom, dz_top)</code></a></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/CliMA/ClimaCore.jl/blob/a889c473979567e2e318739ae773325f39b0d156/src/Meshes/interval.jl#L1-L19">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="ClimaCore.Meshes.RectilinearMesh" href="#ClimaCore.Meshes.RectilinearMesh"><code>ClimaCore.Meshes.RectilinearMesh</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">RectilinearMesh &lt;: AbstractMesh2D</code></pre><p><strong>Constructors</strong></p><pre><code class="nohighlight hljs">RectilinearMesh(domain::RectangleDomain, n1, n2)</code></pre><p>Construct a <code>RectilinearMesh</code> of equally-spaced <code>n1</code> by <code>n2</code> elements on <code>domain</code>.</p><pre><code class="nohighlight hljs">RectilinearMesh(intervalmesh1::IntervalMesh1, intervalmesh2::IntervalMesh2)</code></pre><p>Construct the product mesh of <code>intervalmesh1</code> and <code>intervalmesh2</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/CliMA/ClimaCore.jl/blob/a889c473979567e2e318739ae773325f39b0d156/src/Meshes/rectangle.jl#L1-L13">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="ClimaCore.Meshes.AbstractCubedSphere" href="#ClimaCore.Meshes.AbstractCubedSphere"><code>ClimaCore.Meshes.AbstractCubedSphere</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">AbstractCubedSphere &lt;: AbstractMesh2D</code></pre><p>This is an abstract type of cubed-sphere meshes on <code>SphereDomain</code>s. A cubed-sphere mesh has 6 panels, laid out as follows:</p><pre><code class="nohighlight hljs">                                          :   Panel 1   :
                            +-------------+-------------+
                            |     +x1     |     +x1     |
                            |             |             |
                            |    Panel    |    Panel    |
                            |+x3   5   -x3|-x2   6   +x2|
                            |     -x2     |     -x3     |
                            |             |             |
                            |     -x1     |     -x1     |
              +-------------+-------------+-------------+
              |     -x2     |     -x2     |
              |             |             |
              |    Panel    |    Panel    |
              |+x1   3   -x1|+x3   4   -x3|
              |     +x3     |     -x1     |
              |             |             |
              |     +x2     |     +x2     |
+-------------+-------------+-------------+
|     +x3     |     +x3     |
|             |             |
|    Panel    |    Panel    |
|-x2   1   +x2|+x1   2   -x1|
|     +x1     |     +x2     |
|             |             |
|     -x3     |     -x3     |
+-------------+-------------+
:   Panel 6   :</code></pre><p>This is the same panel ordering used by the S2 Geometry library (though we use 1-based instead of 0-based numering).</p><p>Elements are indexed by a <code>CartesianIndex{3}</code> object, where the components are:</p><ul><li>horizontal element index (left to right) within each panel.</li><li>vertical element index (bottom to top) within each panel.</li><li>panel number</li></ul><p>Subtypes should have the following fields:</p><ul><li><code>domain</code>: a <code>SphereDomain</code></li><li><code>ne</code>: number of elements across each panel</li></ul><p><strong>External links</strong></p><ul><li><a href="https://s2geometry.io/devguide/s2cell_hierarchy">S2Geometry library</a></li><li><a href="https://mitgcm.readthedocs.io/en/latest/phys_pkgs/exch2.html?highlight=cube%20sphere#fig-48tile">MIT GCM exch2</a></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/CliMA/ClimaCore.jl/blob/a889c473979567e2e318739ae773325f39b0d156/src/Meshes/cubedsphere.jl#L1-L51">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="ClimaCore.Meshes.EquiangularCubedSphere" href="#ClimaCore.Meshes.EquiangularCubedSphere"><code>ClimaCore.Meshes.EquiangularCubedSphere</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">EquiangularCubedSphere &lt;: AbstractCubedSphere</code></pre><p>An equiangular gnomonic mesh proposed by <a href="../references/#Ronchi1996">C. Ronchi, R. Iacono, P. S. Paolucci (1996)</a>. Uses the element indexing convention of <a href="#ClimaCore.Meshes.AbstractCubedSphere"><code>AbstractCubedSphere</code></a>.</p><p><strong>Constructors</strong></p><pre><code class="nohighlight hljs">EquiangularCubedSphere(
    domain::Domains.SphereDomain,
    ne::Integer,
    localelementmap=NormalizedBilinearMap()
    )</code></pre><p>Constuct an <code>EquiangularCubedSphere</code> on <code>domain</code> with <code>ne</code> elements across each panel.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/CliMA/ClimaCore.jl/blob/a889c473979567e2e318739ae773325f39b0d156/src/Meshes/cubedsphere.jl#L343-L359">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="ClimaCore.Meshes.EquidistantCubedSphere" href="#ClimaCore.Meshes.EquidistantCubedSphere"><code>ClimaCore.Meshes.EquidistantCubedSphere</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">EquidistantCubedSphere &lt;: AbstractCubedSphere</code></pre><p>An equidistant gnomonic mesh outlined in <a href="../references/#Rancic1996">M. Rančić, R. J. Purser, F. Mesinger (1996)</a> and <a href="../references/#Nair2005">Ramachandran D Nair, Stephen J Thomas, Richard D Loft (2005)</a>. Uses the element indexing convention of <a href="#ClimaCore.Meshes.AbstractCubedSphere"><code>AbstractCubedSphere</code></a>.</p><p><strong>Constructors</strong></p><pre><code class="nohighlight hljs">EquidistantCubedSphere(domain::Domains.SphereDomain, ne::Integer)</code></pre><p>Constuct an <code>EquidistantCubedSphere</code> on <code>domain</code> with <code>ne</code> elements across each panel.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/CliMA/ClimaCore.jl/blob/a889c473979567e2e318739ae773325f39b0d156/src/Meshes/cubedsphere.jl#L394-L406">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="ClimaCore.Meshes.ConformalCubedSphere" href="#ClimaCore.Meshes.ConformalCubedSphere"><code>ClimaCore.Meshes.ConformalCubedSphere</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">ConformalCubedSphere &lt;: AbstractCubedSphere</code></pre><p>A conformal mesh outlined in <a href="../references/#Rancic1996">M. Rančić, R. J. Purser, F. Mesinger (1996)</a>. Uses the element indexing convention of <a href="#ClimaCore.Meshes.AbstractCubedSphere"><code>AbstractCubedSphere</code></a>.</p><p><strong>Constructors</strong></p><pre><code class="nohighlight hljs">ConformalCubedSphere(domain::Domains.SphereDomain, ne::Integer)</code></pre><p>Constuct a <code>ConformalCubedSphere</code> on <code>domain</code> with <code>ne</code> elements across each panel.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/CliMA/ClimaCore.jl/blob/a889c473979567e2e318739ae773325f39b0d156/src/Meshes/cubedsphere.jl#L432-L444">source</a></section></article><h3 id="Local-element-map"><a class="docs-heading-anchor" href="#Local-element-map">Local element map</a><a id="Local-element-map-1"></a><a class="docs-heading-anchor-permalink" href="#Local-element-map" title="Permalink"></a></h3><article class="docstring"><header><a class="docstring-binding" id="ClimaCore.Meshes.LocalElementMap" href="#ClimaCore.Meshes.LocalElementMap"><code>ClimaCore.Meshes.LocalElementMap</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">LocalElementMap</code></pre><p>An abstract type of mappings from the reference element to a physical domain.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/CliMA/ClimaCore.jl/blob/a889c473979567e2e318739ae773325f39b0d156/src/Meshes/cubedsphere.jl#L54-L58">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="ClimaCore.Meshes.IntrinsicMap" href="#ClimaCore.Meshes.IntrinsicMap"><code>ClimaCore.Meshes.IntrinsicMap</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">IntrinsicMap()</code></pre><p>This <a href="#ClimaCore.Meshes.LocalElementMap"><code>LocalElementMap</code></a> uses the intrinsic mapping of the cubed sphere to map the reference element to the physical domain.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/CliMA/ClimaCore.jl/blob/a889c473979567e2e318739ae773325f39b0d156/src/Meshes/cubedsphere.jl#L61-L66">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="ClimaCore.Meshes.NormalizedBilinearMap" href="#ClimaCore.Meshes.NormalizedBilinearMap"><code>ClimaCore.Meshes.NormalizedBilinearMap</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">NormalizedBilinearMap()</code></pre><p>The <a href="#ClimaCore.Meshes.LocalElementMap"><code>LocalElementMap</code></a> for meshes on spherical domains of <a href="../references/#Guba2014">O. Guba, M. A. Taylor, P. A. Ullrich, J. R. Overfelt, M. N. Levy (2014)</a>. It uses bilinear interpolation between the Cartesian coordinates of the element vertices, then normalizes the result to lie on the sphere.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/CliMA/ClimaCore.jl/blob/a889c473979567e2e318739ae773325f39b0d156/src/Meshes/cubedsphere.jl#L69-L76">source</a></section></article><h3 id="Mesh-stretching"><a class="docs-heading-anchor" href="#Mesh-stretching">Mesh stretching</a><a id="Mesh-stretching-1"></a><a class="docs-heading-anchor-permalink" href="#Mesh-stretching" title="Permalink"></a></h3><article class="docstring"><header><a class="docstring-binding" id="ClimaCore.Meshes.Uniform" href="#ClimaCore.Meshes.Uniform"><code>ClimaCore.Meshes.Uniform</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">Uniform()</code></pre><p>Use uniformly-sized elements.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/CliMA/ClimaCore.jl/blob/a889c473979567e2e318739ae773325f39b0d156/src/Meshes/interval.jl#L96-L100">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="ClimaCore.Meshes.ExponentialStretching" href="#ClimaCore.Meshes.ExponentialStretching"><code>ClimaCore.Meshes.ExponentialStretching</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">ExponentialStretching(H::FT)</code></pre><p>Apply exponential stretching to the domain when constructing elements. <code>H</code> is the scale height (a typical atmospheric scale height <code>H ≈ 7.5</code>km).</p><p>For an interval <span>$[z_0,z_1]$</span>, this makes the elements uniformally spaced in <span>$\zeta$</span>, where</p><p class="math-container">\[\zeta = \frac{1 - e^{-\eta/h}}{1-e^{-1/h}},\]</p><p>where <span>$\eta = \frac{z - z_0}{z_1-z_0}$</span>, and <span>$h = \frac{H}{z_1-z_0}$</span> is the non-dimensional scale height. If <code>reverse_mode</code> is <code>true</code>, the smallest element is at the top, and the largest at the bottom (this is typical for land model configurations).</p><p>Then, the user can define a stretched mesh via</p><pre><code class="nohighlight hljs">ClimaCore.Meshes.IntervalMesh(interval_domain, ExponentialStretching(H); nelems::Int, reverse_mode = false)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/CliMA/ClimaCore.jl/blob/a889c473979567e2e318739ae773325f39b0d156/src/Meshes/interval.jl#L117-L136">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="ClimaCore.Meshes.GeneralizedExponentialStretching" href="#ClimaCore.Meshes.GeneralizedExponentialStretching"><code>ClimaCore.Meshes.GeneralizedExponentialStretching</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">GeneralizedExponentialStretching(dz_bottom::FT, dz_top::FT)</code></pre><p>Apply a generalized form of exponential stretching to the domain when constructing elements. <code>dz_bottom</code> and <code>dz_top</code> are target element grid spacings at the bottom and at the top of the vertical column domain (m). In typical atmosphere configurations, <code>dz_bottom</code> is the smallest grid spacing and <code>dz_top</code> the largest one. On the other hand, for typical land configurations, <code>dz_bottom</code> is the largest grid spacing and <code>dz_top</code> the smallest one.</p><p>For land configurations, use <code>reverse_mode</code> = <code>true</code> (default value <code>false</code>).</p><p>Then, the user can define a generalized stretched mesh via</p><pre><code class="nohighlight hljs">ClimaCore.Meshes.IntervalMesh(interval_domain, GeneralizedExponentialStretching(dz_bottom, dz_top); nelems::Int, reverse_mode = false)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/CliMA/ClimaCore.jl/blob/a889c473979567e2e318739ae773325f39b0d156/src/Meshes/interval.jl#L170-L184">source</a></section></article><h3 id="Mesh-utilities"><a class="docs-heading-anchor" href="#Mesh-utilities">Mesh utilities</a><a id="Mesh-utilities-1"></a><a class="docs-heading-anchor-permalink" href="#Mesh-utilities" title="Permalink"></a></h3><article class="docstring"><header><a class="docstring-binding" id="ClimaCore.Meshes.truncate_mesh" href="#ClimaCore.Meshes.truncate_mesh"><code>ClimaCore.Meshes.truncate_mesh</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">truncate_mesh(
    parent_mesh::AbstractMesh,
    trunc_domain::IntervalDomain{CT},
)</code></pre><p>Constructs an <code>IntervalMesh</code>, truncating the given <code>parent_mesh</code> defined on a truncated <code>trunc_domain</code>. The truncation preserves the number of degrees of freedom covering the space from the <code>trunc_domain</code>&#39;s <code>z_bottom</code> to <code>z_top</code>, adjusting the stretching.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/CliMA/ClimaCore.jl/blob/a889c473979567e2e318739ae773325f39b0d156/src/Meshes/interval.jl#L290-L299">source</a></section></article><h3 id="Interfaces-2"><a class="docs-heading-anchor" href="#Interfaces-2">Interfaces</a><a class="docs-heading-anchor-permalink" href="#Interfaces-2" title="Permalink"></a></h3><article class="docstring"><header><a class="docstring-binding" id="ClimaCore.Meshes.domain" href="#ClimaCore.Meshes.domain"><code>ClimaCore.Meshes.domain</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">Meshes.domain(mesh::AbstractMesh)</code></pre><p>The domain (a subtype of  <a href="#ClimaCore.Domains.AbstractDomain"><code>Domains.AbstractDomain</code></a>) on which the mesh is defined.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/CliMA/ClimaCore.jl/blob/a889c473979567e2e318739ae773325f39b0d156/src/Meshes/Meshes.jl#L72-L76">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="ClimaCore.Meshes.elements" href="#ClimaCore.Meshes.elements"><code>ClimaCore.Meshes.elements</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">Meshes.elements(mesh::AbstractMesh)</code></pre><p>An iterator over the elements of a mesh. Elements of a mesh can be of any type.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/CliMA/ClimaCore.jl/blob/a889c473979567e2e318739ae773325f39b0d156/src/Meshes/Meshes.jl#L79-L83">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="ClimaCore.Meshes.nelements" href="#ClimaCore.Meshes.nelements"><code>ClimaCore.Meshes.nelements</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">nelements(mesh::AbstractMesh)</code></pre><p>The number of elements in the mesh.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/CliMA/ClimaCore.jl/blob/a889c473979567e2e318739ae773325f39b0d156/src/Meshes/common.jl#L4-L8">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="ClimaCore.Meshes.is_boundary_face" href="#ClimaCore.Meshes.is_boundary_face"><code>ClimaCore.Meshes.is_boundary_face</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">Meshes.is_boundary_face(mesh::AbstractMesh, elem, face::Int)::Bool</code></pre><p>Determine whether face <code>face</code> of element <code>elem</code> is on the boundary of <code>mesh</code>.</p><p><code>elem</code> should be an element of <a href="#ClimaCore.Meshes.elements"><code>elements(mesh)</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/CliMA/ClimaCore.jl/blob/a889c473979567e2e318739ae773325f39b0d156/src/Meshes/Meshes.jl#L86-L92">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="ClimaCore.Meshes.boundary_face_name" href="#ClimaCore.Meshes.boundary_face_name"><code>ClimaCore.Meshes.boundary_face_name</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">Meshes.boundary_face_name(mesh::AbstractMesh, elem, face::Int)::Union{Symbol,Nothing}</code></pre><p>The name of the boundary facing <code>face</code> of element <code>elem</code>, or <code>nothing</code> if it is not on the boundary.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/CliMA/ClimaCore.jl/blob/a889c473979567e2e318739ae773325f39b0d156/src/Meshes/Meshes.jl#L95-L100">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="ClimaCore.Meshes.opposing_face" href="#ClimaCore.Meshes.opposing_face"><code>ClimaCore.Meshes.opposing_face</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">opelem, opface, reversed = Meshes.opposing_face(mesh::AbstractMesh, elem, face::Int)</code></pre><p>The element and face (<code>opelem</code>, <code>opface</code>) that oppose face <code>face</code> of element <code>elem</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/CliMA/ClimaCore.jl/blob/a889c473979567e2e318739ae773325f39b0d156/src/Meshes/Meshes.jl#L103-L107">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="ClimaCore.Meshes.coordinates" href="#ClimaCore.Meshes.coordinates"><code>ClimaCore.Meshes.coordinates</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">Meshes.coordinates(mesh, elem, vert::Int)
Meshes.coordinates(mesh, elem, ξ::SVector)</code></pre><p>Return the physical coordinates of a point in an element <code>elem</code> of <code>mesh</code>. The position of the point can either be a vertex number <code>vert</code> or the coordinates <code>ξ</code> in the reference element.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/CliMA/ClimaCore.jl/blob/a889c473979567e2e318739ae773325f39b0d156/src/Meshes/common.jl#L164-L171">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="ClimaCore.Meshes.containing_element" href="#ClimaCore.Meshes.containing_element"><code>ClimaCore.Meshes.containing_element</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">elem = Meshes.containing_element(mesh::AbstractMesh, coord)</code></pre><p>The element <code>elem</code> in <code>mesh</code> containing the coordinate <code>coord</code>. If the coordinate falls on the boundary between two or more elements, an arbitrary element is chosen.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/CliMA/ClimaCore.jl/blob/a889c473979567e2e318739ae773325f39b0d156/src/Meshes/common.jl#L181-L187">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="ClimaCore.Meshes.reference_coordinates" href="#ClimaCore.Meshes.reference_coordinates"><code>ClimaCore.Meshes.reference_coordinates</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">ξ = Meshes.reference_coordinates(mesh::AbstractMesh, elem, coord)</code></pre><p>An <code>SVector</code> of coordinates in the reference element such that</p><pre><code class="nohighlight hljs">Meshes.coordinates(mesh, elem, ξ) == coord</code></pre><p>This can be used for interpolation to a specific point.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/CliMA/ClimaCore.jl/blob/a889c473979567e2e318739ae773325f39b0d156/src/Meshes/common.jl#L190-L198">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="ClimaCore.Meshes.SharedVertices" href="#ClimaCore.Meshes.SharedVertices"><code>ClimaCore.Meshes.SharedVertices</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">Meshes.SharedVertices(mesh, elem, vert)</code></pre><p>An iterator over (element, vertex) pairs that are shared with <code>(elem,vert)</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/CliMA/ClimaCore.jl/blob/a889c473979567e2e318739ae773325f39b0d156/src/Meshes/common.jl#L28-L32">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="ClimaCore.Meshes.face_connectivity_matrix" href="#ClimaCore.Meshes.face_connectivity_matrix"><code>ClimaCore.Meshes.face_connectivity_matrix</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">M = Meshes.face_connectivity_matrix(mesh, elemorder = elements(mesh))</code></pre><p>Construct a <code>Bool</code>-valued <code>SparseCSCMatrix</code> containing the face connections of <code>mesh</code>. Elements are indexed according to <code>elemorder</code>.</p><p>Note that <code>M[i,i] == true</code> only if two distinct faces of element <code>i</code> are connected.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/CliMA/ClimaCore.jl/blob/a889c473979567e2e318739ae773325f39b0d156/src/Meshes/common.jl#L101-L108">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="ClimaCore.Meshes.vertex_connectivity_matrix" href="#ClimaCore.Meshes.vertex_connectivity_matrix"><code>ClimaCore.Meshes.vertex_connectivity_matrix</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">M = Meshes.vertex_connectivity_matrix(mesh, elemorder = elements(mesh))</code></pre><p>Construct a <code>Bool</code>-valued <code>SparseCSCMatrix</code> containing the vertex connections of <code>mesh</code>. Elements are indexed according to <code>elemorder</code>.</p><p>Note that <code>M[i,i] == true</code> only if two distinct vertices of element <code>i</code> are connected.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/CliMA/ClimaCore.jl/blob/a889c473979567e2e318739ae773325f39b0d156/src/Meshes/common.jl#L132-L139">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="ClimaCore.Meshes.linearindices" href="#ClimaCore.Meshes.linearindices"><code>ClimaCore.Meshes.linearindices</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">Meshes.linearindices(elemorder)</code></pre><p>Given a data structure <code>elemorder[i] = elem</code> that orders elements, construct the inverse map from <code>orderindex = linearindices(elemorder)</code> such that <code>orderindex[elem] = i</code>.</p><p>This will try to use the most efficient structure available.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/CliMA/ClimaCore.jl/blob/a889c473979567e2e318739ae773325f39b0d156/src/Meshes/common.jl#L75-L83">source</a></section></article><h2 id="Topologies"><a class="docs-heading-anchor" href="#Topologies">Topologies</a><a id="Topologies-1"></a><a class="docs-heading-anchor-permalink" href="#Topologies" title="Permalink"></a></h2><p>A <code>Topology</code> determines the ordering and connections between elements of a mesh. <img src="../cubedsphere_spacefillingcurve.png" alt="Space-filling curve element ordering for a cubed sphere mesh"/></p><h3 id="Types-2"><a class="docs-heading-anchor" href="#Types-2">Types</a><a class="docs-heading-anchor-permalink" href="#Types-2" title="Permalink"></a></h3><article class="docstring"><header><a class="docstring-binding" id="ClimaCore.Topologies.AbstractTopology" href="#ClimaCore.Topologies.AbstractTopology"><code>ClimaCore.Topologies.AbstractTopology</code></a> — <span class="docstring-category">Type</span></header><section><div><p>AbstractTopology</p><p>Subtypes of <code>AbstractHorizontalTopology</code> define connectiveness of a mesh in the horizontal domain.</p><p><strong>Interfaces</strong></p><ul><li><a href="@ref"><code>nelems</code></a></li><li><a href="#ClimaCore.Meshes.domain"><code>domain(topology::AbstractTopology)</code></a></li><li><a href="#ClimaCore.Topologies.mesh"><code>mesh</code></a></li><li><a href="#ClimaCore.Topologies.nlocalelems"><code>nlocalelems</code></a></li><li><a href="@ref"><code>nneighbors</code></a></li><li><a href="@ref"><code>nsendelems</code></a></li><li><a href="@ref"><code>nghostelems</code></a></li><li><a href="@ref"><code>localelemindex</code></a></li><li><a href="#ClimaCore.Topologies.vertex_coordinates"><code>vertex_coordinates</code></a></li><li><a href="#ClimaCore.Topologies.opposing_face"><code>opposing_face</code></a></li><li><a href="@ref"><code>face_node_index</code></a></li><li><a href="#ClimaCore.Topologies.interior_faces"><code>interior_faces</code></a></li><li><a href="@ref"><code>ghost_faces</code></a></li><li><a href="@ref"><code>vertex_node_index</code></a></li><li><a href="#ClimaCore.Topologies.local_neighboring_elements"><code>local_neighboring_elements</code></a></li><li><a href="#ClimaCore.Topologies.ghost_neighboring_elements"><code>ghost_neighboring_elements</code></a></li><li><a href="@ref"><code>local_vertices</code></a></li><li><a href="@ref"><code>ghost_vertices</code></a></li><li><a href="@ref"><code>neighbors</code></a></li><li><a href="#ClimaCore.Topologies.boundary_tags"><code>boundary_tags</code></a></li><li><a href="#ClimaCore.Topologies.boundary_tag"><code>boundary_tag</code></a></li><li><a href="#ClimaCore.Topologies.boundary_faces"><code>boundary_faces</code></a></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/CliMA/ClimaCore.jl/blob/a889c473979567e2e318739ae773325f39b0d156/src/Topologies/Topologies.jl#L12-L43">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="ClimaCore.Topologies.IntervalTopology" href="#ClimaCore.Topologies.IntervalTopology"><code>ClimaCore.Topologies.IntervalTopology</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">IntervalTopology([context::SingletonCommsContext,] mesh::IntervalMesh)</code></pre><p>A sequential topology on an <a href="#ClimaCore.Meshes.IntervalMesh"><code>Meshes.IntervalMesh</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/CliMA/ClimaCore.jl/blob/a889c473979567e2e318739ae773325f39b0d156/src/Topologies/interval.jl#L3-L7">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="ClimaCore.Topologies.Topology2D" href="#ClimaCore.Topologies.Topology2D"><code>ClimaCore.Topologies.Topology2D</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">Topology2D(mesh::AbstractMesh2D, elemorder=Mesh.elements(mesh))</code></pre><p>This is a distributed topology for 2D meshes. <code>elemorder</code> is a vector or other linear ordering of the <code>Mesh.elements(mesh)</code>. <code>elempid</code> is a sorted vector of the same length as <code>elemorder</code>, each element of which contains the <code>pid</code> of the owning process.</p><p>Internally, we can refer to elements in several different ways:</p><ul><li><code>elem</code>: an element of the <code>mesh</code>. Often a <code>CartesianIndex</code> object.</li><li><code>gidx</code>: &quot;global index&quot;: an enumeration of all elements:<ul><li><code>elemorder[gidx] == elem</code></li><li><code>orderindex[elem] == gidx</code></li></ul></li><li><code>lidx</code>: &quot;local index&quot;: an enumeration of local elements.<ul><li><code>local_elem_gidx[lidx] == gidx</code></li></ul></li><li><code>sidx</code>: &quot;send index&quot;: an index into the send buffer of a local element. A single local element may have multiple <code>sidx</code>s if it needs to be send to multiple processes.<ul><li><code>send_elem_lidx[sidx] == lidx</code></li></ul></li><li><code>ridx</code>: &quot;receive index&quot;: an index into the receive buffer of a ghost element.<ul><li><code>recv_elem_gidx[ridx] == gidx</code></li></ul></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/CliMA/ClimaCore.jl/blob/a889c473979567e2e318739ae773325f39b0d156/src/Topologies/topology2d.jl#L4-L25">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="ClimaCore.Topologies.spacefillingcurve" href="#ClimaCore.Topologies.spacefillingcurve"><code>ClimaCore.Topologies.spacefillingcurve</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">spacefillingcurve(mesh::Meshes.AbstractCubedSphere)</code></pre><p>Generate element ordering, <code>elemorder</code>, based on a space filling curve for a <code>CubedSphere</code> mesh.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/CliMA/ClimaCore.jl/blob/a889c473979567e2e318739ae773325f39b0d156/src/Topologies/topology2d.jl#L130-L136">source</a></section><section><div><pre><code class="nohighlight hljs">spacefillingcurve(mesh::Meshes.RectilinearMesh)</code></pre><p>Generate element ordering, <code>elemorder</code>, based on a space filling curve for a <code>Rectilinear</code> mesh.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/CliMA/ClimaCore.jl/blob/a889c473979567e2e318739ae773325f39b0d156/src/Topologies/topology2d.jl#L153-L159">source</a></section></article><h3 id="Interfaces-3"><a class="docs-heading-anchor" href="#Interfaces-3">Interfaces</a><a class="docs-heading-anchor-permalink" href="#Interfaces-3" title="Permalink"></a></h3><article class="docstring"><header><a class="docstring-binding" id="ClimaCore.Topologies.mesh" href="#ClimaCore.Topologies.mesh"><code>ClimaCore.Topologies.mesh</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">mesh(topology)</code></pre><p>Returns the mesh underlying the <code>topology</code></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/CliMA/ClimaCore.jl/blob/a889c473979567e2e318739ae773325f39b0d156/src/Topologies/Topologies.jl#L51-L55">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="ClimaCore.Topologies.nlocalelems" href="#ClimaCore.Topologies.nlocalelems"><code>ClimaCore.Topologies.nlocalelems</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">nlocalelems(topology)</code></pre><p>The number of local elements in <code>topology</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/CliMA/ClimaCore.jl/blob/a889c473979567e2e318739ae773325f39b0d156/src/Topologies/Topologies.jl#L65-L69">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="ClimaCore.Topologies.vertex_coordinates" href="#ClimaCore.Topologies.vertex_coordinates"><code>ClimaCore.Topologies.vertex_coordinates</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">(c1,c2,c3,c4) = vertex_coordinates(topology, elem)</code></pre><p>The coordinates of the 4 vertices of element <code>elem</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/CliMA/ClimaCore.jl/blob/a889c473979567e2e318739ae773325f39b0d156/src/Topologies/Topologies.jl#L105-L109">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="ClimaCore.Topologies.opposing_face" href="#ClimaCore.Topologies.opposing_face"><code>ClimaCore.Topologies.opposing_face</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">(opelem, opface, reversed) = opposing_face(topology, elem, face)</code></pre><p>The opposing face of face number <code>face</code> of element <code>elem</code> in <code>topology</code>.</p><ul><li><code>opelem</code> is the opposing element number, 0 for a boundary, negative for a ghost element</li><li><code>opface</code> is the opposite face number, or boundary face number if a boundary</li><li><code>reversed</code> indicates whether the opposing face has the opposite orientation.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/CliMA/ClimaCore.jl/blob/a889c473979567e2e318739ae773325f39b0d156/src/Topologies/Topologies.jl#L112-L120">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="ClimaCore.Topologies.interior_faces" href="#ClimaCore.Topologies.interior_faces"><code>ClimaCore.Topologies.interior_faces</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">interior_faces(topology::AbstractTopology)</code></pre><p>An iterator over the interior faces of <code>topology</code>. Each element of the iterator is a 5-tuple the form</p><pre><code class="nohighlight hljs">(elem1, face1, elem2, face2, reversed)</code></pre><p>where <code>elemX, faceX</code> are the element and face numbers, and <code>reversed</code> indicates whether they have opposing orientations.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/CliMA/ClimaCore.jl/blob/a889c473979567e2e318739ae773325f39b0d156/src/Topologies/Topologies.jl#L144-L154">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="ClimaCore.Topologies.boundary_tags" href="#ClimaCore.Topologies.boundary_tags"><code>ClimaCore.Topologies.boundary_tags</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">boundary_tags(topology)</code></pre><p>A <code>Tuple</code> or <code>NamedTuple</code> of the boundary tags of the topology. A boundary tag is an integer that uniquely identifies a boundary.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/CliMA/ClimaCore.jl/blob/a889c473979567e2e318739ae773325f39b0d156/src/Topologies/Topologies.jl#L281-L286">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="ClimaCore.Topologies.boundary_tag" href="#ClimaCore.Topologies.boundary_tag"><code>ClimaCore.Topologies.boundary_tag</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">boundary_tag(topology, name::Symbol)</code></pre><p>The boundary tag of the topology for boundary name <code>name</code>. A boundary tag is an integer that uniquely identifies a boundary.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/CliMA/ClimaCore.jl/blob/a889c473979567e2e318739ae773325f39b0d156/src/Topologies/Topologies.jl#L289-L294">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="ClimaCore.Topologies.boundary_faces" href="#ClimaCore.Topologies.boundary_faces"><code>ClimaCore.Topologies.boundary_faces</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">boundary_faces(topology, boundarytag)</code></pre><p>An iterator over the faces of <code>topology</code> which face the boundary with tag <code>boundarytag</code>. Each element of the iterator is an <code>(elem, face)</code> pair.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/CliMA/ClimaCore.jl/blob/a889c473979567e2e318739ae773325f39b0d156/src/Topologies/Topologies.jl#L297-L302">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="ClimaCore.Topologies.local_neighboring_elements" href="#ClimaCore.Topologies.local_neighboring_elements"><code>ClimaCore.Topologies.local_neighboring_elements</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">local_neighboring_elements(topology::AbstractTopology, lidx::Integer)</code></pre><p>An iterator of the local element indices (lidx) of the local elements which are neighbors of the local element <code>lidx</code> in <code>topology</code> (excluding <code>lidx</code> itself).</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/CliMA/ClimaCore.jl/blob/a889c473979567e2e318739ae773325f39b0d156/src/Topologies/Topologies.jl#L180-L185">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="ClimaCore.Topologies.ghost_neighboring_elements" href="#ClimaCore.Topologies.ghost_neighboring_elements"><code>ClimaCore.Topologies.ghost_neighboring_elements</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">ghost_neighboring_elements(topology::AbstractTopology, ridx::Integer)</code></pre><p>An iterator of the receive buffer indices (ridx) of the ghost elements which are neighbors  of the local element <code>lidx</code> in <code>topology</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/CliMA/ClimaCore.jl/blob/a889c473979567e2e318739ae773325f39b0d156/src/Topologies/Topologies.jl#L188-L193">source</a></section></article><h2 id="Spaces"><a class="docs-heading-anchor" href="#Spaces">Spaces</a><a id="Spaces-1"></a><a class="docs-heading-anchor-permalink" href="#Spaces" title="Permalink"></a></h2><p>A <code>Space</code> represents a discretized function space over some domain. Currently two main discretizations are supported: Spectral Element Discretization (both Continuous Galerkin and Discontinuous Galerkin types) and a staggered Finite Difference Discretization. Combination of these two in the horizontal/vertical directions, respectively, is what we call a <em>hybrid</em> space.</p><p>Sketch of a 2DX hybrid discretization:</p><p><img src="../DiscretizationSketch.png" alt="3D hybrid discretization in a Cartesian domain"/></p><article class="docstring"><header><a class="docstring-binding" id="ClimaCore.Spaces" href="#ClimaCore.Spaces"><code>ClimaCore.Spaces</code></a> — <span class="docstring-category">Module</span></header><section><div><pre><code class="language-julia hljs">Meshes</code></pre><ul><li>domain</li><li>topology</li><li>coordinates</li><li>metric terms (inverse partial derivatives)</li><li>quadrature rules and weights</li></ul><p><strong>References / notes</strong></p><ul><li><a href="https://ceed.exascaleproject.org/ceed-code/">ceed</a></li><li><a href="https://github.com/CliMA/ClimateMachine.jl/blob/ans/sphere/test/Numerics/DGMethods/compressible_navier_stokes_equations/sphere/sphere_helper_functions.jl">QA</a></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/CliMA/ClimaCore.jl/blob/a889c473979567e2e318739ae773325f39b0d156/src/Spaces/Spaces.jl#L1-L14">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="ClimaCore.Spaces.Δz_data" href="#ClimaCore.Spaces.Δz_data"><code>ClimaCore.Spaces.Δz_data</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">Δz_data(space::AbstractSpace)</code></pre><p>A DataLayout containing the <code>Δz</code> on a given space <code>space</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/CliMA/ClimaCore.jl/blob/a889c473979567e2e318739ae773325f39b0d156/src/Spaces/finitedifference.jl#L186-L190">source</a></section></article><h3 id="Finite-Difference-Spaces"><a class="docs-heading-anchor" href="#Finite-Difference-Spaces">Finite Difference Spaces</a><a id="Finite-Difference-Spaces-1"></a><a class="docs-heading-anchor-permalink" href="#Finite-Difference-Spaces" title="Permalink"></a></h3><p>ClimaCore.jl supports staggered Finite Difference discretizations. Finite Differences discretize an interval domain by approximating the function by a value at either the center of each element (also referred to as <em>cell</em>) (<code>CenterFiniteDifferenceSpace</code>), or the interfaces (faces in 3D, edges in 2D or points in 1D) between elements (<code>FaceFiniteDifferenceSpace</code>).</p><p>Users should construct either the center or face space from the mesh, then construct the other space from the original one: this internally reuses the same data structures, and avoids allocating additional memory.</p><h4 id="Internals"><a class="docs-heading-anchor" href="#Internals">Internals</a><a id="Internals-1"></a><a class="docs-heading-anchor-permalink" href="#Internals" title="Permalink"></a></h4><article class="docstring"><header><a class="docstring-binding" id="ClimaCore.Spaces.Δz_metric_component" href="#ClimaCore.Spaces.Δz_metric_component"><code>ClimaCore.Spaces.Δz_metric_component</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">Δz_metric_component(::Type{&lt;:Goemetry.AbstractPoint})</code></pre><p>The index of the z-component of an abstract point in an <code>AxisTensor</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/CliMA/ClimaCore.jl/blob/a889c473979567e2e318739ae773325f39b0d156/src/Spaces/finitedifference.jl#L170-L175">source</a></section></article><h3 id="Spectral-Element-Spaces"><a class="docs-heading-anchor" href="#Spectral-Element-Spaces">Spectral Element Spaces</a><a id="Spectral-Element-Spaces-1"></a><a class="docs-heading-anchor-permalink" href="#Spectral-Element-Spaces" title="Permalink"></a></h3><article class="docstring"><header><a class="docstring-binding" id="ClimaCore.Spaces.SpectralElementSpace1D" href="#ClimaCore.Spaces.SpectralElementSpace1D"><code>ClimaCore.Spaces.SpectralElementSpace1D</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">SpectralElementSpace1D &lt;: AbstractSpace</code></pre><p>A one-dimensional space: within each element the space is represented as a polynomial.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/CliMA/ClimaCore.jl/blob/a889c473979567e2e318739ae773325f39b0d156/src/Spaces/spectralelement.jl#L75-L79">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="ClimaCore.Spaces.SpectralElementSpace2D" href="#ClimaCore.Spaces.SpectralElementSpace2D"><code>ClimaCore.Spaces.SpectralElementSpace2D</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">SpectralElementSpace2D &lt;: AbstractSpace</code></pre><p>A two-dimensional space: within each element the space is represented as a polynomial.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/CliMA/ClimaCore.jl/blob/a889c473979567e2e318739ae773325f39b0d156/src/Spaces/spectralelement.jl#L161-L165">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="ClimaCore.Spaces.SpectralElementSpace2D-Tuple{Any, Any}" href="#ClimaCore.Spaces.SpectralElementSpace2D-Tuple{Any, Any}"><code>ClimaCore.Spaces.SpectralElementSpace2D</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">SpectralElementSpace2D(topology, quadrature_style; enable_bubble)</code></pre><p>Construct a <code>SpectralElementSpace2D</code> instance given a <code>topology</code> and <code>quadrature</code>. The flag <code>enable_bubble</code> enables the <code>bubble correction</code> for more accurate element areas.</p><p><strong>Input arguments:</strong></p><ul><li>topology: Topology2D</li><li>quadrature_style: QuadratureStyle</li><li>enable_bubble: Bool</li></ul><p>The idea behind the so-called <code>bubble_correction</code> is that the numerical area of the domain (e.g., the sphere) is given by the sum of nodal integration weights times their corresponding Jacobians. However, this discrete sum is not exactly equal to the exact geometric area  (4pi*radius^2 for the sphere). To make these equal, the &quot;epsilon bubble&quot; approach modifies the inner weights in each element so that geometric and numerical areas of each element match.</p><p>Let <span>$\Delta A^e := A^e_{exact} - A^e_{approx}$</span>, then, in the case of linear elements, we correct <span>$W_{i,j} J^e_{i,j}$</span> by:</p><p class="math-container">\[\widehat{W_{i,j} J^e}_{i,j} = W_{i,j} J^e_{i,j} + \Delta A^e * W_{i,j} / Nq^2 .\]</p><p>and the case of non linear elements, by</p><p class="math-container">\[\widehat{W_{i,j} J^e}_{i,j} = W_{i,j} J^e_{i,j} \left( 1 + \tilde{A}^e \right) ,\]</p><p>where <span>$\tilde{A}^e$</span> is the approximated area given by the sum of the interior nodal integration weights.</p><p>Note: This is accurate only for cubed-spheres of the <a href="#ClimaCore.Meshes.EquiangularCubedSphere"><code>Meshes.EquiangularCubedSphere</code></a> and <a href="#ClimaCore.Meshes.EquidistantCubedSphere"><code>Meshes.EquidistantCubedSphere</code></a> type, not for <a href="#ClimaCore.Meshes.ConformalCubedSphere"><code>Meshes.ConformalCubedSphere</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/CliMA/ClimaCore.jl/blob/a889c473979567e2e318739ae773325f39b0d156/src/Spaces/spectralelement.jl#L201-L232">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="ClimaCore.Spaces.SpectralElementSpaceSlab" href="#ClimaCore.Spaces.SpectralElementSpaceSlab"><code>ClimaCore.Spaces.SpectralElementSpaceSlab</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">SpectralElementSpaceSlab &lt;: AbstractSpace</code></pre><p>A view into a <code>SpectralElementSpace2D</code> for a single slab.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/CliMA/ClimaCore.jl/blob/a889c473979567e2e318739ae773325f39b0d156/src/Spaces/spectralelement.jl#L613-L617">source</a></section></article><h3 id="Quadratures"><a class="docs-heading-anchor" href="#Quadratures">Quadratures</a><a id="Quadratures-1"></a><a class="docs-heading-anchor-permalink" href="#Quadratures" title="Permalink"></a></h3><article class="docstring"><header><a class="docstring-binding" id="ClimaCore.Spaces.Quadratures.QuadratureStyle" href="#ClimaCore.Spaces.Quadratures.QuadratureStyle"><code>ClimaCore.Spaces.Quadratures.QuadratureStyle</code></a> — <span class="docstring-category">Type</span></header><section><div><p>QuadratureStyle</p><p>Quadrature style supertype. See sub-types:</p><ul><li><a href="#ClimaCore.Spaces.Quadratures.GLL"><code>GLL</code></a></li><li><a href="#ClimaCore.Spaces.Quadratures.GL"><code>GL</code></a></li><li><a href="#ClimaCore.Spaces.Quadratures.Uniform"><code>Uniform</code></a></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/CliMA/ClimaCore.jl/blob/a889c473979567e2e318739ae773325f39b0d156/src/Spaces/quadrature.jl#L11-L18">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="ClimaCore.Spaces.Quadratures.GLL" href="#ClimaCore.Spaces.Quadratures.GLL"><code>ClimaCore.Spaces.Quadratures.GLL</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">GLL{Nq}()</code></pre><p>Gauss-Legendre-Lobatto quadrature using <code>Nq</code> quadrature points.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/CliMA/ClimaCore.jl/blob/a889c473979567e2e318739ae773325f39b0d156/src/Spaces/quadrature.jl#L44-L48">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="ClimaCore.Spaces.Quadratures.GL" href="#ClimaCore.Spaces.Quadratures.GL"><code>ClimaCore.Spaces.Quadratures.GL</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">GL{Nq}()</code></pre><p>Gauss-Legendre quadrature using <code>Nq</code> quadrature points.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/CliMA/ClimaCore.jl/blob/a889c473979567e2e318739ae773325f39b0d156/src/Spaces/quadrature.jl#L59-L63">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="ClimaCore.Spaces.Quadratures.Uniform" href="#ClimaCore.Spaces.Quadratures.Uniform"><code>ClimaCore.Spaces.Quadratures.Uniform</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">Uniform{Nq}()</code></pre><p>Uniformly-spaced quadrature.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/CliMA/ClimaCore.jl/blob/a889c473979567e2e318739ae773325f39b0d156/src/Spaces/quadrature.jl#L74-L78">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="ClimaCore.Spaces.Quadratures.degrees_of_freedom" href="#ClimaCore.Spaces.Quadratures.degrees_of_freedom"><code>ClimaCore.Spaces.Quadratures.degrees_of_freedom</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">degrees_of_freedom(QuadratureStyle) -&gt; Int</code></pre><p>Returns the degrees<em>of</em>freedom of the <code>QuadratureStyle</code> concrete type</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/CliMA/ClimaCore.jl/blob/a889c473979567e2e318739ae773325f39b0d156/src/Spaces/quadrature.jl#L29-L33">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="ClimaCore.Spaces.Quadratures.polynomial_degree" href="#ClimaCore.Spaces.Quadratures.polynomial_degree"><code>ClimaCore.Spaces.Quadratures.polynomial_degree</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">polynomial_degree(QuadratureStyle) -&gt; Int</code></pre><p>Returns the polynomial degree of the <code>QuadratureStyle</code> concrete type</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/CliMA/ClimaCore.jl/blob/a889c473979567e2e318739ae773325f39b0d156/src/Spaces/quadrature.jl#L21-L25">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="ClimaCore.Spaces.Quadratures.quadrature_points" href="#ClimaCore.Spaces.Quadratures.quadrature_points"><code>ClimaCore.Spaces.Quadratures.quadrature_points</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">points, weights = quadrature_points(::Type{FT}, quadrature_style)</code></pre><p>The points and weights of the quadrature rule in floating point type <code>FT</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/CliMA/ClimaCore.jl/blob/a889c473979567e2e318739ae773325f39b0d156/src/Spaces/quadrature.jl#L36-L40">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="ClimaCore.Spaces.Quadratures.barycentric_weights" href="#ClimaCore.Spaces.Quadratures.barycentric_weights"><code>ClimaCore.Spaces.Quadratures.barycentric_weights</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">barycentric_weights(x::SVector{Nq}) where {Nq}</code></pre><p>The barycentric weights associated with the array of point locations <code>x</code>:</p><p class="math-container">\[w_j = \frac{1}{\prod_{k \ne j} (x_i - x_j)}\]</p><p>See <a href="../references/#Berrut2004">Jean-Paul Berrut, Lloyd N Trefethen (2004)</a>, equation 3.2.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/CliMA/ClimaCore.jl/blob/a889c473979567e2e318739ae773325f39b0d156/src/Spaces/quadrature.jl#L114-L124">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="ClimaCore.Spaces.Quadratures.interpolation_matrix" href="#ClimaCore.Spaces.Quadratures.interpolation_matrix"><code>ClimaCore.Spaces.Quadratures.interpolation_matrix</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">interpolation_matrix(x::SVector, r::SVector{Nq})</code></pre><p>The matrix which interpolates the Lagrange polynomial of degree <code>Nq-1</code> through the points <code>r</code>, to points <code>x</code>. The matrix coefficients are computed using the Barycentric formula of <a href="../references/#Berrut2004">Jean-Paul Berrut, Lloyd N Trefethen (2004)</a>, section 4:</p><p class="math-container">\[I_{ij} = \begin{cases}
1 &amp; \text{if } x_i = r_j, \\
0 &amp; \text{if } x_i = r_k \text{ for } k \ne j, \\
\frac{\displaystyle \frac{w_j}{x_i - r_j}}{\displaystyle \sum_k \frac{w_k}{x_i - r_k}} &amp; \text{otherwise,}
\end{cases}\]</p><p>where <span>$w_j$</span> are the barycentric weights, see <a href="#ClimaCore.Spaces.Quadratures.barycentric_weights"><code>barycentric_weights</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/CliMA/ClimaCore.jl/blob/a889c473979567e2e318739ae773325f39b0d156/src/Spaces/quadrature.jl#L143-L157">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="ClimaCore.Spaces.Quadratures.differentiation_matrix" href="#ClimaCore.Spaces.Quadratures.differentiation_matrix"><code>ClimaCore.Spaces.Quadratures.differentiation_matrix</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">differentiation_matrix(r::SVector{Nq, T}) where {Nq, T}</code></pre><p>The spectral differentiation matrix for the Lagrange polynomial of degree <code>Nq-1</code> interpolating at points <code>r</code>.</p><p>The matrix coefficients are computed using the <a href="../references/#Berrut2004">Jean-Paul Berrut, Lloyd N Trefethen (2004)</a>, section 9.3:</p><p class="math-container">\[D_{ij} = \begin{cases}
    \displaystyle
    \frac{w_j}{w_i (x_i - x_j)} &amp;\text{ if } i \ne j \\
    -\sum_{k \ne j} D_{kj} &amp;\text{ if } i = j
\end{cases}\]</p><p>where <span>$w_j$</span> are the barycentric weights, see <a href="#ClimaCore.Spaces.Quadratures.barycentric_weights"><code>barycentric_weights</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/CliMA/ClimaCore.jl/blob/a889c473979567e2e318739ae773325f39b0d156/src/Spaces/quadrature.jl#L231-L246">source</a></section><section><div><pre><code class="nohighlight hljs">differentiation_matrix(FT, quadstyle::QuadratureStyle)</code></pre><p>The spectral differentiation matrix at the quadrature points of <code>quadstyle</code>, using floating point types <code>FT</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/CliMA/ClimaCore.jl/blob/a889c473979567e2e318739ae773325f39b0d156/src/Spaces/quadrature.jl#L266-L271">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="ClimaCore.Spaces.Quadratures.orthonormal_poly" href="#ClimaCore.Spaces.Quadratures.orthonormal_poly"><code>ClimaCore.Spaces.Quadratures.orthonormal_poly</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">V = orthonormal_poly(points, quad)</code></pre><p><code>V_{ij}</code> contains the <code>j-1</code>th Legendre polynomial evaluated at <code>points[i]</code>. i.e. it is the mapping from the modal to the nodal representation.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/CliMA/ClimaCore.jl/blob/a889c473979567e2e318739ae773325f39b0d156/src/Spaces/quadrature.jl#L195-L200">source</a></section></article><h4 id="Internals-2"><a class="docs-heading-anchor" href="#Internals-2">Internals</a><a class="docs-heading-anchor-permalink" href="#Internals-2" title="Permalink"></a></h4><article class="docstring"><header><a class="docstring-binding" id="ClimaCore.Spaces.dss_transform" href="#ClimaCore.Spaces.dss_transform"><code>ClimaCore.Spaces.dss_transform</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">dss_transform(arg, local_geometry, weight, I...)</code></pre><p>Transfrom <code>arg[I...]</code> to a basis for direct stiffness summation (DSS). Transformations only apply to vector quantities.</p><ul><li><code>local_geometry[I...]</code> is the relevant <code>LocalGeometry</code> object. If it is <code>nothing</code>, then no transformation is performed</li><li><code>weight[I...]</code> is the relevant DSS weights. If <code>weight</code> is <code>nothing</code>, then the result is simply summation.</li></ul><p>See <a href="#ClimaCore.Spaces.weighted_dss!"><code>Spaces.weighted_dss!</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/CliMA/ClimaCore.jl/blob/a889c473979567e2e318739ae773325f39b0d156/src/Spaces/dss_transform.jl#L4-L14">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="ClimaCore.Spaces.dss_untransform" href="#ClimaCore.Spaces.dss_untransform"><code>ClimaCore.Spaces.dss_untransform</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">dss_untransform(T, targ, local_geometry, I...)</code></pre><p>Transform <code>targ[I...]</code> back to a value of type <code>T</code> after performing direct stiffness summation (DSS).</p><p>See <a href="#ClimaCore.Spaces.weighted_dss!"><code>Spaces.weighted_dss!</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/CliMA/ClimaCore.jl/blob/a889c473979567e2e318739ae773325f39b0d156/src/Spaces/dss_transform.jl#L144-L150">source</a></section></article><div class="admonition is-warning"><header class="admonition-header">Missing docstring.</header><div class="admonition-body"><p>Missing docstring for <code>Spaces.dss_interior_faces!</code>. Check Documenter&#39;s build log for details.</p></div></div><div class="admonition is-warning"><header class="admonition-header">Missing docstring.</header><div class="admonition-body"><p>Missing docstring for <code>Spaces.dss_local_vertices!</code>. Check Documenter&#39;s build log for details.</p></div></div><div class="admonition is-warning"><header class="admonition-header">Missing docstring.</header><div class="admonition-body"><p>Missing docstring for <code>Spaces.dss_ghost_faces!</code>. Check Documenter&#39;s build log for details.</p></div></div><div class="admonition is-warning"><header class="admonition-header">Missing docstring.</header><div class="admonition-body"><p>Missing docstring for <code>Spaces.dss_ghost_vertices!</code>. Check Documenter&#39;s build log for details.</p></div></div><article class="docstring"><header><a class="docstring-binding" id="ClimaCore.Spaces.dss_local!" href="#ClimaCore.Spaces.dss_local!"><code>ClimaCore.Spaces.dss_local!</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">function dss_local!(
    ::ClimaComms.AbstractCPUDevice,
    perimeter_data::DataLayouts.VIFH,
    perimeter::AbstractPerimeter,
    topology::Topologies.AbstractTopology,
)</code></pre><p>Performs DSS on local vertices and faces.</p><p>Part of <a href="#ClimaCore.Spaces.weighted_dss!"><code>Spaces.weighted_dss!</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/CliMA/ClimaCore.jl/blob/a889c473979567e2e318739ae773325f39b0d156/src/Spaces/dss.jl#L803-L814">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="ClimaCore.Spaces.dss_local_ghost!" href="#ClimaCore.Spaces.dss_local_ghost!"><code>ClimaCore.Spaces.dss_local_ghost!</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">function dss_local_ghost!(
    ::ClimaComms.AbstractCPUDevice,
    perimeter_data::DataLayouts.VIFH,
    perimeter::AbstractPerimeter,
    topology::Topologies.AbstractTopology,
)</code></pre><p>Computes the &quot;local&quot; part of ghost vertex dss. (i.e. it computes the summation of all the shared local vertices of a unique ghost vertex and stores the value in each of the local vertex locations in  <code>perimeter_data</code>)</p><p>Part of <a href="#ClimaCore.Spaces.weighted_dss!"><code>Spaces.weighted_dss!</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/CliMA/ClimaCore.jl/blob/a889c473979567e2e318739ae773325f39b0d156/src/Spaces/dss.jl#L880-L893">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="ClimaCore.Spaces.dss_ghost!" href="#ClimaCore.Spaces.dss_ghost!"><code>ClimaCore.Spaces.dss_ghost!</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">dss_ghost!(
    device::ClimaComms.AbstractCPUDevice,
    perimeter_data::DataLayouts.VIFH,
    perimeter::AbstractPerimeter,
    topology::Topologies.AbstractTopology,
)</code></pre><p>Sets the value for all local vertices of each unique ghost vertex, in <code>perimeter_data</code>, to that of  the representative ghost vertex.</p><p>Part of <a href="#ClimaCore.Spaces.weighted_dss!"><code>Spaces.weighted_dss!</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/CliMA/ClimaCore.jl/blob/a889c473979567e2e318739ae773325f39b0d156/src/Spaces/dss.jl#L935-L947">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="ClimaCore.Spaces.create_dss_buffer" href="#ClimaCore.Spaces.create_dss_buffer"><code>ClimaCore.Spaces.create_dss_buffer</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">create_dss_buffer(
    data::Union{DataLayouts.IJFH{S, Nij}, DataLayouts.VIJFH{S, Nij}},
    hspace::AbstractSpectralElementSpace,
) where {S, Nij}</code></pre><p>Creates a <a href="#ClimaCore.Spaces.DSSBuffer"><code>DSSBuffer</code></a> for the field data corresponding to <code>data</code></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/CliMA/ClimaCore.jl/blob/a889c473979567e2e318739ae773325f39b0d156/src/Spaces/dss.jl#L34-L41">source</a></section><section><div><pre><code class="nohighlight hljs">Spaces.create_dss_buffer(field::Field)</code></pre><p>Create a buffer for communicating neighbour information of <code>field</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/CliMA/ClimaCore.jl/blob/a889c473979567e2e318739ae773325f39b0d156/src/Fields/Fields.jl#L399-L403">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="ClimaCore.Spaces.DSSBuffer" href="#ClimaCore.Spaces.DSSBuffer"><code>ClimaCore.Spaces.DSSBuffer</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">DSSBuffer{G, D, A, B}</code></pre><p><strong>Fields</strong></p><ul><li><p><code>graph_context</code>: ClimaComms graph context for communication</p></li><li><p><code>perimeter_data</code>: Array for storing perimeter data</p></li><li><p><code>send_data</code>: send buffer</p></li><li><p><code>recv_data</code>: recv buffer</p></li><li><p><code>send_buf_idx</code>: indexing array for loading send buffer from <code>perimeter_data</code></p></li><li><p><code>recv_buf_idx</code>: indexing array for loading (and summing) data from recv buffer to <code>perimeter_data</code></p></li><li><p><code>scalarfidx</code>: field id for all scalar fields stored in the <code>data</code> array</p></li><li><p><code>covariant12fidx</code>: field id for all covariant12vector fields stored in the <code>data</code> array</p></li><li><p><code>contravariant12fidx</code>: field id for all contravariant12vector fields stored in the <code>data</code> array</p></li><li><p><code>internal_elems</code>: internal local elements (lidx)</p></li><li><p><code>perimeter_elems</code>: local elements (lidx) located on process boundary</p></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/CliMA/ClimaCore.jl/blob/a889c473979567e2e318739ae773325f39b0d156/src/Spaces/dss.jl#L3-L8">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="ClimaCore.Spaces.weighted_dss_start!" href="#ClimaCore.Spaces.weighted_dss_start!"><code>ClimaCore.Spaces.weighted_dss_start!</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">weighted_dss_start!(
    data::Union{
        DataLayouts.IFH,
        DataLayouts.VIFH,
        DataLayouts.IJFH,
        DataLayouts.VIJFH,
    },
    space::Union{
        AbstractSpectralElementSpace,
        ExtrudedFiniteDifferenceSpace,
    },
    dss_buffer::Union{DSSBuffer, Nothing},
)</code></pre><p>It comprises of the following steps:</p><p>1). Apply <a href="@ref"><code>Spaces.dss_transform!</code></a> on perimeter elements. This weights and tranforms vector  fields to physical basis if needed. Scalar fields are weighted. The transformed and/or weighted  perimeter <code>data</code> is stored in <code>perimeter_data</code>.</p><p>2). Apply <a href="#ClimaCore.Spaces.dss_local_ghost!"><code>Spaces.dss_local_ghost!</code></a> This computes partial weighted DSS on ghost vertices, using only the information from <code>local</code> vertices.</p><p>3). <a href="@ref"><code>Spaces.fill_send_buffer!</code></a>  Loads the send buffer from <code>perimeter_data</code>. For unique ghost vertices, only data from the representative ghost vertices which store result of &quot;ghost local&quot; DSS are loaded.</p><p>4). Start DSS communication with neighboring processes</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/CliMA/ClimaCore.jl/blob/a889c473979567e2e318739ae773325f39b0d156/src/Spaces/dss.jl#L241-L270">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="ClimaCore.Spaces.weighted_dss_internal!" href="#ClimaCore.Spaces.weighted_dss_internal!"><code>ClimaCore.Spaces.weighted_dss_internal!</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">weighted_dss_internal!(
    data::Union{
        DataLayouts.IFH,
        DataLayouts.VIFH,
        DataLayouts.IJFH,
        DataLayouts.VIJFH,
    },
    space::Union{
        AbstractSpectralElementSpace,
        ExtrudedFiniteDifferenceSpace,
    },
    dss_buffer::DSSBuffer,
)</code></pre><p>1). Apply <a href="@ref"><code>Spaces.dss_transform!</code></a> on interior elements. Local elements are split into interior  and perimeter elements to facilitate overlapping of communication with computation.</p><p>2). Probe communication</p><p>3). <a href="#ClimaCore.Spaces.dss_local!"><code>Spaces.dss_local!</code></a> computes the weighted DSS on local vertices and faces.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/CliMA/ClimaCore.jl/blob/a889c473979567e2e318739ae773325f39b0d156/src/Spaces/dss.jl#L315-L336">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="ClimaCore.Spaces.weighted_dss_ghost!" href="#ClimaCore.Spaces.weighted_dss_ghost!"><code>ClimaCore.Spaces.weighted_dss_ghost!</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">weighted_dss_ghost!(
    data::Union{
        DataLayouts.IFH,
        DataLayouts.VIFH,
        DataLayouts.IJFH,
        DataLayouts.VIJFH,
    },
    space::Union{
        AbstractSpectralElementSpace,
        ExtrudedFiniteDifferenceSpace,
    },
    dss_buffer::Union{DSSBuffer, Nothing},
)</code></pre><p>1). Finish communications.</p><p>2). Call <a href="@ref"><code>Spaces.load_from_recv_buffer!</code></a> After the communication is complete, this adds data from the recv buffer to the corresponding location in  <code>perimeter_data</code>. For ghost vertices, this data is added only to the representative vertices. The values are  then scattered to other local vertices corresponding to each unique ghost vertex in <code>dss_local_ghost</code>.</p><p>3). Call <a href="@ref"><code>Spaces.dss_untransform!</code></a> on all local elements. This transforms the DSS&#39;d local vectors back to Covariant12 vectors, and copies the DSS&#39;d data from the <code>perimeter_data</code> to <code>data</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/CliMA/ClimaCore.jl/blob/a889c473979567e2e318739ae773325f39b0d156/src/Spaces/dss.jl#L396-L421">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="ClimaCore.Spaces.weighted_dss!" href="#ClimaCore.Spaces.weighted_dss!"><code>ClimaCore.Spaces.weighted_dss!</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">function weighted_dss!(
    data::Union{
        DataLayouts.IFH,
        DataLayouts.VIFH,
        DataLayouts.IJFH,
        DataLayouts.VIJFH,
    },
    space::Union{
        AbstractSpectralElementSpace,
        ExtrudedFiniteDifferenceSpace,
    },
    dss_buffer::Union{DSSBuffer, Nothing},
)</code></pre><p>Computes weighted dss of <code>data</code>. </p><p>It comprises of the following steps:</p><p>1). <a href="#ClimaCore.Spaces.weighted_dss_start!"><code>Spaces.weighted_dss_start!</code></a></p><p>2). <a href="#ClimaCore.Spaces.weighted_dss_internal!"><code>Spaces.weighted_dss_internal!</code></a></p><p>3). <a href="#ClimaCore.Spaces.weighted_dss_ghost!"><code>Spaces.weighted_dss_ghost!</code></a></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/CliMA/ClimaCore.jl/blob/a889c473979567e2e318739ae773325f39b0d156/src/Spaces/dss.jl#L200-L224">source</a></section><section><div><pre><code class="nohighlight hljs">Spaces.weighted_dss!(f::Field[, ghost_buffer = Spaces.create_dss_buffer(field)])</code></pre><p>Apply weighted direct stiffness summation (DSS) to <code>f</code>. This operates in-place (i.e. it modifies the <code>f</code>). <code>ghost_buffer</code> contains the necessary information for communication in a distributed setting, see <a href="../operators/#ClimaCore.Spaces.create_ghost_buffer"><code>Spaces.create_ghost_buffer</code></a>.</p><p>This is a projection operation from the piecewise polynomial space <span>$\mathcal{V}_0$</span> to the continuous space <span>$\mathcal{V}_1 = \mathcal{V}_0 \cap \mathcal{C}_0$</span>, defined as the field <span>$\theta \in \mathcal{V}_1$</span> such that for all <span>$\phi \in \mathcal{V}_1$</span></p><p class="math-container">\[\int_\Omega \phi \theta \,d\Omega = \int_\Omega \phi f \,d\Omega\]</p><p>In matrix form, we define <span>$\bar \theta$</span> to be the unique global node representation, and <span>$Q$</span> to be the &quot;scatter&quot; operator which maps to the redundant node representation <span>$\theta$</span></p><p class="math-container">\[\theta = Q \bar \theta\]</p><p>Then the problem can be written as</p><p class="math-container">\[(Q \bar\phi)^\top W J Q \bar\theta = (Q \bar\phi)^\top W J f\]</p><p>which reduces to</p><p class="math-container">\[\theta = Q \bar\theta = Q (Q^\top W J Q)^{-1} Q^\top W J f\]</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/CliMA/ClimaCore.jl/blob/a889c473979567e2e318739ae773325f39b0d156/src/Fields/Fields.jl#L346-L375">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="ClimaCore.Spaces.dss!" href="#ClimaCore.Spaces.dss!"><code>ClimaCore.Spaces.dss!</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">dss!(data, topology, quadrature_style)</code></pre><p>Computed unweighted/pure DSS of <code>data</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/CliMA/ClimaCore.jl/blob/a889c473979567e2e318739ae773325f39b0d156/src/Spaces/dss.jl#L1039-L1043">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="ClimaCore.Spaces.unique_nodes" href="#ClimaCore.Spaces.unique_nodes"><code>ClimaCore.Spaces.unique_nodes</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">unique_nodes(space::SpectralElementField2D)</code></pre><p>An iterator over the unique nodes of <code>space</code>. Each node is represented by the first <code>((i,j), e)</code> triple.</p><p>This function is experimental, and may change in future.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/CliMA/ClimaCore.jl/blob/a889c473979567e2e318739ae773325f39b0d156/src/Spaces/spectralelement.jl#L694-L701">source</a></section></article><h4 id="Utilities"><a class="docs-heading-anchor" href="#Utilities">Utilities</a><a id="Utilities-1"></a><a class="docs-heading-anchor-permalink" href="#Utilities" title="Permalink"></a></h4><article class="docstring"><header><a class="docstring-binding" id="ClimaCore.Spaces.area" href="#ClimaCore.Spaces.area"><code>ClimaCore.Spaces.area</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">Spaces.area(space::Spaces.AbstractSpace)</code></pre><p>The length/area/volume of <code>space</code>. This is computed as the sum of the quadrature weights <span>$W_i$</span> multiplied by the Jacobian determinants <span>$J_i$</span>:</p><p class="math-container">\[\sum_i W_i J_i \approx \int_\Omega \, d \Omega\]</p><p>If <code>space</code> is distributed, this uses a <code>ClimaComms.allreduce</code> operation.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/CliMA/ClimaCore.jl/blob/a889c473979567e2e318739ae773325f39b0d156/src/Spaces/Spaces.jl#L60-L70">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="ClimaCore.Spaces.local_area" href="#ClimaCore.Spaces.local_area"><code>ClimaCore.Spaces.local_area</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">Spaces.local_area(space::Spaces.AbstractSpace)</code></pre><p>The length/area/volume of <code>space</code> local to the current context. See <a href="#ClimaCore.Spaces.area"><code>Spaces.area</code></a></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/CliMA/ClimaCore.jl/blob/a889c473979567e2e318739ae773325f39b0d156/src/Spaces/Spaces.jl#L52-L57">source</a></section></article><h2 id="RecursiveApply"><a class="docs-heading-anchor" href="#RecursiveApply">RecursiveApply</a><a id="RecursiveApply-1"></a><a class="docs-heading-anchor-permalink" href="#RecursiveApply" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-binding" id="ClimaCore.RecursiveApply" href="#ClimaCore.RecursiveApply"><code>ClimaCore.RecursiveApply</code></a> — <span class="docstring-category">Module</span></header><section><div><pre><code class="language-julia hljs">RecursiveApply</code></pre><p>This module contains operators to recurse over nested <code>Tuple</code>s or <code>NamedTuple</code>s.</p><p>To extend to another type <code>T</code>, define <code>RecursiveApply.rmap(fn, args::T...)</code></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/CliMA/ClimaCore.jl/blob/a889c473979567e2e318739ae773325f39b0d156/src/RecursiveApply/RecursiveApply.jl#L1-L7">source</a></section></article><h2 id="Fields"><a class="docs-heading-anchor" href="#Fields">Fields</a><a id="Fields-1"></a><a class="docs-heading-anchor-permalink" href="#Fields" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-binding" id="ClimaCore.Fields.Field" href="#ClimaCore.Fields.Field"><code>ClimaCore.Fields.Field</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">Field(values, space)</code></pre><p>A set of <code>values</code> defined at each point of a <code>space</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/CliMA/ClimaCore.jl/blob/a889c473979567e2e318739ae773325f39b0d156/src/Fields/Fields.jl#L19-L23">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="ClimaCore.Fields.coordinate_field" href="#ClimaCore.Fields.coordinate_field"><code>ClimaCore.Fields.coordinate_field</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">coordinate_field(space::AbstractSpace)</code></pre><p>Construct a <code>Field</code> of the coordinates of the space.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/CliMA/ClimaCore.jl/blob/a889c473979567e2e318739ae773325f39b0d156/src/Fields/Fields.jl#L285-L289">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="ClimaCore.Fields.local_geometry_field" href="#ClimaCore.Fields.local_geometry_field"><code>ClimaCore.Fields.local_geometry_field</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">local_geometry_field(space::AbstractSpace)</code></pre><p>Construct a <code>Field</code> of the <code>LocalGeometry</code> of the space.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/CliMA/ClimaCore.jl/blob/a889c473979567e2e318739ae773325f39b0d156/src/Fields/Fields.jl#L294-L298">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Base.zeros-Tuple{ClimaCore.Spaces.AbstractSpace}" href="#Base.zeros-Tuple{ClimaCore.Spaces.AbstractSpace}"><code>Base.zeros</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">zeros(space::AbstractSpace)</code></pre><p>Construct a field on <code>space</code> that is zero everywhere.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/CliMA/ClimaCore.jl/blob/a889c473979567e2e318739ae773325f39b0d156/src/Fields/Fields.jl#L251-L255">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Base.ones-Tuple{ClimaCore.Spaces.AbstractSpace}" href="#Base.ones-Tuple{ClimaCore.Spaces.AbstractSpace}"><code>Base.ones</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">ones(space::AbstractSpace)</code></pre><p>Construct a field on <code>space</code> that is one everywhere.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/CliMA/ClimaCore.jl/blob/a889c473979567e2e318739ae773325f39b0d156/src/Fields/Fields.jl#L264-L268">source</a></section></article><div class="admonition is-warning"><header class="admonition-header">Missing docstring.</header><div class="admonition-body"><p>Missing docstring for <code>Base.sum(::Fields.Field)</code>. Check Documenter&#39;s build log for details.</p></div></div><article class="docstring"><header><a class="docstring-binding" id="ClimaCore.Fields.local_sum" href="#ClimaCore.Fields.local_sum"><code>ClimaCore.Fields.local_sum</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">Fields.local_sum(v::Field)</code></pre><p>Compute the approximate integral of <code>v</code> over the domain local to the current context.</p><p>See <a href="@ref"><code>sum</code></a> for the integral over the full domain.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/CliMA/ClimaCore.jl/blob/a889c473979567e2e318739ae773325f39b0d156/src/Fields/mapreduce.jl#L3-L10">source</a></section></article><div class="admonition is-warning"><header class="admonition-header">Missing docstring.</header><div class="admonition-body"><p>Missing docstring for <code>Fields.Statistics.mean(::Fields.Field)</code>. Check Documenter&#39;s build log for details.</p></div></div><div class="admonition is-warning"><header class="admonition-header">Missing docstring.</header><div class="admonition-body"><p>Missing docstring for <code>Fields.LinearAlgebra.norm(::Fields.Field)</code>. Check Documenter&#39;s build log for details.</p></div></div><article class="docstring"><header><a class="docstring-binding" id="ClimaCore.Fields.set!" href="#ClimaCore.Fields.set!"><code>ClimaCore.Fields.set!</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">set!(f::Function, field::Field, args = ())</code></pre><p>Apply function <code>f</code> to populate values in field <code>field</code>. <code>f</code> must have a function signature with signature <code>f(::LocalGeometry[, args...])</code>. Additional arguments may be passed to <code>f</code> with <code>args</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/CliMA/ClimaCore.jl/blob/a889c473979567e2e318739ae773325f39b0d156/src/Fields/Fields.jl#L453-L462">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="ClimaCore.Fields.ColumnIndex" href="#ClimaCore.Fields.ColumnIndex"><code>ClimaCore.Fields.ColumnIndex</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">ColumnIndex(ij,h)</code></pre><p>An index into a column of a field. This can be used as an argument to <code>getindex</code> of a <code>Field</code>, to return a field on that column.</p><p><strong>Example</strong></p><pre><code class="language-julia hljs">colidx = ColumnIndex((1,1),1)
field[colidx]</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/CliMA/ClimaCore.jl/blob/a889c473979567e2e318739ae773325f39b0d156/src/Fields/indices.jl#L1-L12">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="ClimaCore.Fields.bycolumn" href="#ClimaCore.Fields.bycolumn"><code>ClimaCore.Fields.bycolumn</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">Fields.bycolumn(fn, space)</code></pre><p>Call <code>fn(colidx)</code> to every <a href="#ClimaCore.Fields.ColumnIndex"><code>ColumnIndex</code></a> <code>colidx</code> of <code>space</code>. This can be used to apply multiple column-wise operations in a single pass, making use of multiple threads.</p><div class="admonition is-info"><header class="admonition-header">Note</header><div class="admonition-body"><p>On GPUs this will simply evaluate <code>f</code> once with <code>colidx=:</code> (i.e. it doesn&#39;t perform evaluation by columns). This may change in future.</p></div></div><p><strong>Example</strong></p><pre><code class="language-julia hljs">∇ = GradientF2C()
div = DivergenceC2F()

bycolumn(axes(f)) do colidx
    @. ∇f[colidx] = ∇(f[colidx])
    @. df[colidx] = div(∇f[colidx])
end</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/CliMA/ClimaCore.jl/blob/a889c473979567e2e318739ae773325f39b0d156/src/Fields/indices.jl#L46-L69">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="ClimaCore.Fields.Δz_field" href="#ClimaCore.Fields.Δz_field"><code>ClimaCore.Fields.Δz_field</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">Δz_field(field::Field)
Δz_field(space::AbstractSpace)</code></pre><p>A <code>Field</code> containing the <code>Δz</code> values on the same space as the given field.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/CliMA/ClimaCore.jl/blob/a889c473979567e2e318739ae773325f39b0d156/src/Fields/Fields.jl#L306-L311">source</a></section></article><h2 id="Hypsography"><a class="docs-heading-anchor" href="#Hypsography">Hypsography</a><a id="Hypsography-1"></a><a class="docs-heading-anchor-permalink" href="#Hypsography" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-binding" id="ClimaCore.Hypsography.LinearAdaption" href="#ClimaCore.Hypsography.LinearAdaption"><code>ClimaCore.Hypsography.LinearAdaption</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">LinearAdaption(surface::Field)</code></pre><p>Locate the levels by linear interpolation between the surface field and the top of the domain, using the method of <a href="../references/#GalChen1975">Tzvi Gal-Chen, Richard C. J Somerville (1975)</a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/CliMA/ClimaCore.jl/blob/a889c473979567e2e318739ae773325f39b0d156/src/Hypsography/Hypsography.jl#L10-L15">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="ClimaCore.Hypsography.SLEVEAdaption" href="#ClimaCore.Hypsography.SLEVEAdaption"><code>ClimaCore.Hypsography.SLEVEAdaption</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">SLEVEAdaption(surface::Field, ηₕ::FT, s::FT)</code></pre><p>Locate vertical levels using an exponential function between the surface field and the top of the domain, using the method of <a href="../references/#Schar2002">Christoph Schär, Daniel Leuenberger, Oliver Fuhrer, Daniel Lüthi, Claude Girard&quot; (2002)</a>. This method is modified such no warping is applied above some user defined parameter 0 ≤ ηₕ &lt; 1.0, where the lower and upper  bounds represent the domain bottom and top respectively. <code>s</code> governs the decay rate.  If the decay-scale is poorly specified (i.e., <code>s * zₜ</code> is lower than the maximum  surface elevation), a warning is thrown and <code>s</code> is adjusted such that it <code>szₜ &gt; maximum(z_surface)</code>. </p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/CliMA/ClimaCore.jl/blob/a889c473979567e2e318739ae773325f39b0d156/src/Hypsography/Hypsography.jl#L21-L30">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="ClimaCore.Hypsography.diffuse_surface_elevation!" href="#ClimaCore.Hypsography.diffuse_surface_elevation!"><code>ClimaCore.Hypsography.diffuse_surface_elevation!</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">diffuse_surface_elevation!(f::Field; κ::T, iter::Int, dt::T)</code></pre><p>Option for 2nd order diffusive smoothing of generated terrain. Mutate (smooth) a given elevation profile <code>f</code> before assigning the surface elevation to the <code>HypsographyAdaption</code> type. A spectral second-order diffusion  operator is applied with forward-Euler updates to generate profiles for each new iteration. Steps to generate smoothed terrain ( represented as a ClimaCore Field) are as follows: </p><ul><li>Compute discrete elevation profile f</li><li>Compute diffuse<em>surface</em>elevation!(f, κ, iter). f is mutated.</li><li>Define <code>Hypsography.LinearAdaption(f)</code></li><li>Define <code>ExtrudedFiniteDifferenceSpace</code> with new surface elevation.</li></ul><p>Default diffusion parameters are appropriate for spherical arrangements.  For <code>zmax-zsfc</code> == 𝒪(10^4), κ == 𝒪(10^8), dt == 𝒪(10⁻¹).</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/CliMA/ClimaCore.jl/blob/a889c473979567e2e318739ae773325f39b0d156/src/Hypsography/Hypsography.jl#L199-L214">source</a></section></article><h2 id="Limiters"><a class="docs-heading-anchor" href="#Limiters">Limiters</a><a id="Limiters-1"></a><a class="docs-heading-anchor-permalink" href="#Limiters" title="Permalink"></a></h2><p>The limiters supertype is</p><article class="docstring"><header><a class="docstring-binding" id="ClimaCore.Limiters.AbstractLimiter" href="#ClimaCore.Limiters.AbstractLimiter"><code>ClimaCore.Limiters.AbstractLimiter</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">AbstractLimiter</code></pre><p>Supertype for all limiters.</p><p><strong>Interfaces</strong></p><ul><li><a href="@ref"><code>quasimonotone_limiter!</code></a></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/CliMA/ClimaCore.jl/blob/a889c473979567e2e318739ae773325f39b0d156/src/Limiters/Limiters.jl#L9-L17">source</a></section></article><p>This class of flux-limiters is applied only in the horizontal direction (on spectral advection operators).</p><h3 id="Interfaces-4"><a class="docs-heading-anchor" href="#Interfaces-4">Interfaces</a><a class="docs-heading-anchor-permalink" href="#Interfaces-4" title="Permalink"></a></h3><article class="docstring"><header><a class="docstring-binding" id="ClimaCore.Limiters.QuasiMonotoneLimiter" href="#ClimaCore.Limiters.QuasiMonotoneLimiter"><code>ClimaCore.Limiters.QuasiMonotoneLimiter</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">QuasiMonotoneLimiter</code></pre><p>This limiter is inspired by the one presented in Guba et al <a href="../references/#GubaOpt2014">Oksana Guba, Mark Taylor, Amik St-Cyr (2014)</a>. In the reference paper, it is denoted by OP1, and is outlined in eqs. (37)-(40). Quasimonotone here is meant to be monotone with respect to the spectral element nodal values. This limiter involves solving a constrained optimization problem (a weighted least square problem up to a fixed tolerance) that is completely local to each element.</p><p>As in HOMME, the implementation idea here is the following: we need to find a grid field which is closest to the initial field (in terms of weighted sum), but satisfies the min/max constraints. So, first we find values that do not satisfy constraints and bring these values to a closest constraint. This way we introduce some change in the tracer mass, which we then redistribute so that the l2 error is smallest. This redistribution might violate constraints; thus, we do a few iterations (until <code>abs(Δtracer_mass) &lt;= rtol * tracer_mass</code>).</p><ul><li><code>ρq</code>: tracer density Field, where <code>q</code> denotes tracer concentration per unit mass. This can be a scalar field, or a struct-valued field.</li><li><code>ρ</code>: fluid density Field (scalar).</li></ul><p><strong>Constructor</strong></p><pre><code class="nohighlight hljs">limiter = QuasiMonotoneLimiter(ρq::Field; rtol = eps(eltype(parent(ρq))))</code></pre><p>Creates a limiter instance for the field <code>ρq</code> with relative tolerance <code>rtol</code>.</p><p><strong>Usage</strong></p><p>Call <a href="#ClimaCore.Limiters.compute_bounds!"><code>compute_bounds!</code></a> on the input fields:</p><pre><code class="nohighlight hljs">compute_bounds!(limiter, ρq, ρ)</code></pre><p>Then call <a href="#ClimaCore.Limiters.apply_limiter!"><code>apply_limiter!</code></a> on the output fields:</p><pre><code class="nohighlight hljs">apply_limiter!(ρq, ρ, limiter)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/CliMA/ClimaCore.jl/blob/a889c473979567e2e318739ae773325f39b0d156/src/Limiters/quasimonotone.jl#L1-L38">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="ClimaCore.Limiters.compute_bounds!" href="#ClimaCore.Limiters.compute_bounds!"><code>ClimaCore.Limiters.compute_bounds!</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">compute_bounds!(limiter::QuasiMonotoneLimiter, ρq::Field, ρ::Field)</code></pre><p>Compute the desired bounds for the tracer concentration per unit mass <code>q</code>, based on the tracer density, <code>ρq</code>, and density, <code>ρ</code>, fields.</p><p>This is computed by</p><ol><li><a href="#ClimaCore.Limiters.compute_element_bounds!"><code>compute_element_bounds!</code></a></li><li>starts the ghost exchange (if distributed)</li><li><a href="#ClimaCore.Limiters.compute_neighbor_bounds_local!"><code>compute_neighbor_bounds_local!</code></a></li><li>completes the ghost exchange (if distributed)</li><li><a href="#ClimaCore.Limiters.compute_neighbor_bounds_ghost!"><code>compute_neighbor_bounds_ghost!</code></a> (if distributed)</li></ol></div><a class="docs-sourcelink" target="_blank" href="https://github.com/CliMA/ClimaCore.jl/blob/a889c473979567e2e318739ae773325f39b0d156/src/Limiters/quasimonotone.jl#L184-L196">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="ClimaCore.Limiters.apply_limiter!" href="#ClimaCore.Limiters.apply_limiter!"><code>ClimaCore.Limiters.apply_limiter!</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">apply_limiter!(ρq, ρ, limiter::QuasiMonotoneLimiter)</code></pre><p>Apply the limiter on the tracer density  <code>ρq</code>, using the computed desired bounds on the concentration <code>q</code> and density <code>ρ</code> as an optimal weight. This iterates over each element, calling <a href="#ClimaCore.Limiters.apply_limit_slab!"><code>apply_limit_slab!</code></a>. If the limiter fails to converge for any element, a warning is issued.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/CliMA/ClimaCore.jl/blob/a889c473979567e2e318739ae773325f39b0d156/src/Limiters/quasimonotone.jl#L235-L242">source</a></section></article><h3 id="Internals-3"><a class="docs-heading-anchor" href="#Internals-3">Internals</a><a class="docs-heading-anchor-permalink" href="#Internals-3" title="Permalink"></a></h3><article class="docstring"><header><a class="docstring-binding" id="ClimaCore.Limiters.compute_element_bounds!" href="#ClimaCore.Limiters.compute_element_bounds!"><code>ClimaCore.Limiters.compute_element_bounds!</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">compute_element_bounds!(limiter::QuasiMonotoneLimiter, ρq, ρ)</code></pre><p>Given two fields <code>ρq</code> and <code>ρ</code>, computes the min and max of <code>q</code> in each element, storing it in <code>limiter.q_bounds</code>.</p><p>Part of <a href="#ClimaCore.Limiters.compute_bounds!"><code>compute_bounds!</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/CliMA/ClimaCore.jl/blob/a889c473979567e2e318739ae773325f39b0d156/src/Limiters/quasimonotone.jl#L79-L86">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="ClimaCore.Limiters.compute_neighbor_bounds_local!" href="#ClimaCore.Limiters.compute_neighbor_bounds_local!"><code>ClimaCore.Limiters.compute_neighbor_bounds_local!</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">compute_neighbor_bounds_local!(limiter::QuasiMonotoneLimiter, topology)</code></pre><p>Update the field <code>limiter.q_bounds_nbr</code> based on <code>limiter.q_bounds</code> in the local neighbors.</p><p>Part of <a href="#ClimaCore.Limiters.compute_bounds!"><code>compute_bounds!</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/CliMA/ClimaCore.jl/blob/a889c473979567e2e318739ae773325f39b0d156/src/Limiters/quasimonotone.jl#L115-L122">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="ClimaCore.Limiters.compute_neighbor_bounds_ghost!" href="#ClimaCore.Limiters.compute_neighbor_bounds_ghost!"><code>ClimaCore.Limiters.compute_neighbor_bounds_ghost!</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">compute_neighbor_bounds_ghost!(limiter::QuasiMonotoneLimiter, topology)</code></pre><p>Update the field <code>limiter.q_bounds_nbr</code> based on <code>limiter.q_bounds</code> in the ghost neighbors. This should be called after the ghost exchange has completed.</p><p>Part of <a href="#ClimaCore.Limiters.compute_bounds!"><code>compute_bounds!</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/CliMA/ClimaCore.jl/blob/a889c473979567e2e318739ae773325f39b0d156/src/Limiters/quasimonotone.jl#L148-L155">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="ClimaCore.Limiters.apply_limit_slab!" href="#ClimaCore.Limiters.apply_limit_slab!"><code>ClimaCore.Limiters.apply_limit_slab!</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">apply_limit_slab!(slab_ρq, slab_ρ, slab_WJ, slab_q_bounds, rtol)</code></pre><p>Apply the computed bounds of the tracer concentration (<code>slab_q_bounds</code>) in the limiter to <code>slab_ρq</code>, given the total mass <code>slab_ρ</code>, metric terms <code>slab_WJ</code>, and relative tolerance <code>rtol</code>. Return whether the tolerance condition could be satisfied.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/CliMA/ClimaCore.jl/blob/a889c473979567e2e318739ae773325f39b0d156/src/Limiters/quasimonotone.jl#L271-L278">source</a></section></article><h2 id="InputOutput"><a class="docs-heading-anchor" href="#InputOutput">InputOutput</a><a id="InputOutput-1"></a><a class="docs-heading-anchor-permalink" href="#InputOutput" title="Permalink"></a></h2><h3 id="Writers"><a class="docs-heading-anchor" href="#Writers">Writers</a><a id="Writers-1"></a><a class="docs-heading-anchor-permalink" href="#Writers" title="Permalink"></a></h3><article class="docstring"><header><a class="docstring-binding" id="ClimaCore.InputOutput.HDF5Writer" href="#ClimaCore.InputOutput.HDF5Writer"><code>ClimaCore.InputOutput.HDF5Writer</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">HDF5Writer(filename::AbstractString[, context::ClimaComms.AbstractCommsContext])</code></pre><p>An <code>AbstractWriter</code> for writing to HDF5-formatted files using the ClimaCore storage conventions. An internal cache is used to avoid writing duplicate domains, meshes, topologies and spaces to the file. Use <a href="#ClimaCore.InputOutput.HDF5Reader"><code>HDF5Reader</code></a> to load the data from the file.</p><p>The optional <code>context</code> can be used for writing distributed fields: in this case, the <code>MPICommsContext</code> used passed as an argument: this must match the context used for distributing the <code>Field</code>.</p><div class="admonition is-info"><header class="admonition-header">Note</header><div class="admonition-body"><p>The default Julia HDF5 binaries are not built with MPI support. To use the distributed functionality, you will need to configure HDF5.jl with an MPI-enabled HDF5 library, see <a href="https://juliaio.github.io/HDF5.jl/stable/#Parallel-HDF5">the HDF5.jl documentation</a>.</p></div></div><p><strong>Interface</strong></p><p><a href="#ClimaCore.InputOutput.write!"><code>write!</code></a></p><p><strong>Usage</strong></p><pre><code class="language-julia hljs">writer = InputOutput.HDF5Writer(filename)
InputOutput.write!(writer, Y, &quot;Y&quot;)
close(writer)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/CliMA/ClimaCore.jl/blob/a889c473979567e2e318739ae773325f39b0d156/src/InputOutput/writers.jl#L3-L33">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="ClimaCore.InputOutput.write!" href="#ClimaCore.InputOutput.write!"><code>ClimaCore.InputOutput.write!</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">write!(writer::AbstractWriter, obj[, preferredname])</code></pre><p>Write the object <code>obj</code> using <code>writer</code>. An optional <code>preferredname</code> can be provided, otherwise <a href="@ref"><code>defaultname</code></a> will be used to generate a name. The name of the object will be returned.</p><p>A cache of domains, meshes, topologies and spaces is kept: if one of these objects has already been written, then the file will not be modified: instead the name under which the object was first written will be returned. Note that <code>Field</code>s and <code>FieldVector</code>s are <em>not</em> cached, and so can be written multiple times.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/CliMA/ClimaCore.jl/blob/a889c473979567e2e318739ae773325f39b0d156/src/InputOutput/writers.jl#L77-L89">source</a></section><section><div><pre><code class="nohighlight hljs">write!(writer::HDF5Writer, name =&gt; value...)</code></pre><p>Write one or more <code>name =&gt; value</code> pairs to <code>writer</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/CliMA/ClimaCore.jl/blob/a889c473979567e2e318739ae773325f39b0d156/src/InputOutput/writers.jl#L439-L443">source</a></section><section><div><pre><code class="nohighlight hljs">write!(filename::AbstractString, name =&gt; value...)</code></pre><p>Write one or more <code>name =&gt; value</code> pairs to the HDF5 file <code>filename</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/CliMA/ClimaCore.jl/blob/a889c473979567e2e318739ae773325f39b0d156/src/InputOutput/writers.jl#L452-L456">source</a></section></article><h3 id="Readers"><a class="docs-heading-anchor" href="#Readers">Readers</a><a id="Readers-1"></a><a class="docs-heading-anchor-permalink" href="#Readers" title="Permalink"></a></h3><article class="docstring"><header><a class="docstring-binding" id="ClimaCore.InputOutput.HDF5Reader" href="#ClimaCore.InputOutput.HDF5Reader"><code>ClimaCore.InputOutput.HDF5Reader</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">HDF5Reader(filename::AbstractString[, context::ClimaComms.AbstractCommsContext])</code></pre><p>An <code>AbstractReader</code> for reading from HDF5 files created by <a href="#ClimaCore.InputOutput.HDF5Writer"><code>HDF5Writer</code></a>. The reader object contains an internal cache of domains, meshes, topologies and spaces that are read so that duplicate objects are not created.</p><p>The optional <code>context</code> can be used for reading distributed fields: in this case, the <code>MPICommsContext</code> used passed as an argument: resulting <code>Field</code>s will be distributed using this context. As with <a href="#ClimaCore.InputOutput.HDF5Writer"><code>HDF5Writer</code></a>, this requires a HDF5 library with MPI support.</p><p><strong>Interface</strong></p><ul><li><a href="#ClimaCore.InputOutput.read_domain"><code>read_domain</code></a></li><li><a href="#ClimaCore.InputOutput.read_mesh"><code>read_mesh</code></a></li><li><a href="#ClimaCore.InputOutput.read_topology"><code>read_topology</code></a></li><li><a href="#ClimaCore.InputOutput.read_space"><code>read_space</code></a></li><li><a href="#ClimaCore.InputOutput.read_field"><code>read_field</code></a></li></ul><p><strong>Usage</strong></p><pre><code class="language-julia hljs">reader = InputOutput.HDF5Reader(filename)
Y = read_field(reader, &quot;Y&quot;)
Y.c |&gt; propertynames
Y.f |&gt; propertynames
ρ_field = read_field(reader, &quot;Y.c.ρ&quot;)
w_field = read_field(reader, &quot;Y.f.w&quot;)
close(reader)</code></pre><p>To explore the contents of the <code>reader</code>, use either</p><pre><code class="language-julia hljs">julia&gt; reader |&gt; propertynames</code></pre><p>e.g, to explore the components of the <code>space</code>, </p><pre><code class="language-julia hljs">julia&gt; reader.space_cache
Dict{Any, Any} with 3 entries:
  &quot;center_extruded_finite_difference_space&quot; =&gt; CenterExtrudedFiniteDifferenceSpace:…
  &quot;horizontal_space&quot;                        =&gt; SpectralElementSpace2D:…
  &quot;face_extruded_finite_difference_space&quot;   =&gt; FaceExtrudedFiniteDifferenceSpace:…</code></pre><p>Once &quot;unpacked&quot; as shown above, <code>ClimaCorePlots</code> or <code>ClimaCoreMakie</code> can be used to visualise fields. <code>ClimaCoreTempestRemap</code> supports interpolation onto user-specified grids if necessary.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/CliMA/ClimaCore.jl/blob/a889c473979567e2e318739ae773325f39b0d156/src/InputOutput/readers.jl#L37-L84">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="ClimaCore.InputOutput.read_domain" href="#ClimaCore.InputOutput.read_domain"><code>ClimaCore.InputOutput.read_domain</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">read_domain(reader::AbstractReader, name)</code></pre><p>Reads a domain named <code>name</code> from <code>reader</code>. Domain objects are cached in the reader to avoid creating duplicate objects.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/CliMA/ClimaCore.jl/blob/a889c473979567e2e318739ae773325f39b0d156/src/InputOutput/readers.jl#L179-L184">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="ClimaCore.InputOutput.read_mesh" href="#ClimaCore.InputOutput.read_mesh"><code>ClimaCore.InputOutput.read_mesh</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">read_mesh(reader::AbstractReader, name)</code></pre><p>Reads a mesh named <code>name</code> from <code>reader</code>, or from the reader cache if it has already been read.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/CliMA/ClimaCore.jl/blob/a889c473979567e2e318739ae773325f39b0d156/src/InputOutput/readers.jl#L214-L219">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="ClimaCore.InputOutput.read_topology" href="#ClimaCore.InputOutput.read_topology"><code>ClimaCore.InputOutput.read_topology</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">read_topology(reader::AbstractReader, name)</code></pre><p>Reads a topology named <code>name</code> from <code>reader</code>, or from the reader cache if it has already been read.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/CliMA/ClimaCore.jl/blob/a889c473979567e2e318739ae773325f39b0d156/src/InputOutput/readers.jl#L258-L263">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="ClimaCore.InputOutput.read_space" href="#ClimaCore.InputOutput.read_space"><code>ClimaCore.InputOutput.read_space</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">read_space(reader::AbstractReader, name)</code></pre><p>Reads a space named <code>name</code> from <code>reader</code>, or from the reader cache if it has already been read.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/CliMA/ClimaCore.jl/blob/a889c473979567e2e318739ae773325f39b0d156/src/InputOutput/readers.jl#L309-L314">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="ClimaCore.InputOutput.read_field" href="#ClimaCore.InputOutput.read_field"><code>ClimaCore.InputOutput.read_field</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">read_field(reader, name)</code></pre><p>Reads a <code>Field</code> or <code>FieldVector</code> named <code>name</code> from <code>reader</code>. Fields are <em>not</em> cached, so that reading the same field multiple times will create multiple distinct objects.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/CliMA/ClimaCore.jl/blob/a889c473979567e2e318739ae773325f39b0d156/src/InputOutput/readers.jl#L362-L368">source</a></section></article><h2 id="Remapping"><a class="docs-heading-anchor" href="#Remapping">Remapping</a><a id="Remapping-1"></a><a class="docs-heading-anchor-permalink" href="#Remapping" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-binding" id="ClimaCore.Remapping.interpolate_array" href="#ClimaCore.Remapping.interpolate_array"><code>ClimaCore.Remapping.interpolate_array</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">interpolate_array(field, xpts, ypts)
interpolate_array(field, xpts, ypts, zpts)</code></pre><p>Interpolate a field to a regular array using pointwise interpolation.</p><p>This is primarily used for plotting and diagnostics.</p><p><strong>Examples</strong></p><pre><code class="language-julia hljs">longpts = range(Geometry.LongPoint(-180.0), Geometry.LongPoint(180.0), length = 21)
latpts = range(Geometry.LatPoint(-80.0), Geometry.LatPoint(80.0), length = 21)
zpts = range(Geometry.ZPoint(0.0), Geometry.ZPoint(1000.0), length = 21)

interpolate_array(field, longpts, latpts, zpts)</code></pre><div class="admonition is-info"><header class="admonition-header">Note</header><div class="admonition-body"><p>Hypsography is not currently handled correctly.</p></div></div></div><a class="docs-sourcelink" target="_blank" href="https://github.com/CliMA/ClimaCore.jl/blob/a889c473979567e2e318739ae773325f39b0d156/src/Remapping/interpolate_array.jl#L75-L95">source</a></section></article></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../matrix_fields/">« MatrixFields</a><a class="docs-footer-nextpage" href="../performance_tips/">Performance tips »</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 0.27.24 on <span class="colophon-date" title="Friday 28 July 2023 17:42">Friday 28 July 2023</span>. Using Julia version 1.8.5.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
