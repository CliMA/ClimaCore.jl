<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>API · ClimaCore.jl</title><script data-outdated-warner src="../assets/warner.js"></script><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.044/juliamono.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.3/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.3/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.3/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.13.11/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL=".."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../assets/documenter.js"></script><script src="../siteinfo.js"></script><script src="../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><a class="docs-logo" href="../"><img src="../assets/logo.png" alt="ClimaCore.jl logo"/></a><div class="docs-package-name"><span class="docs-autofit"><a href="../">ClimaCore.jl</a></span></div><form class="docs-search" action="../search/"><input class="docs-search-query" id="documenter-search-query" name="q" type="text" placeholder="Search docs"/></form><ul class="docs-menu"><li><a class="tocitem" href="../">Home</a></li><li><a class="tocitem" href="../intro/">Introduction</a></li><li class="is-active"><a class="tocitem" href>API</a><ul class="internal"><li><a class="tocitem" href="#DataLayouts"><span>DataLayouts</span></a></li><li><a class="tocitem" href="#Geometry"><span>Geometry</span></a></li><li><a class="tocitem" href="#Domains"><span>Domains</span></a></li><li><a class="tocitem" href="#Meshes"><span>Meshes</span></a></li><li><a class="tocitem" href="#Topologies"><span>Topologies</span></a></li><li><a class="tocitem" href="#Spaces"><span>Spaces</span></a></li><li><a class="tocitem" href="#RecursiveApply"><span>RecursiveApply</span></a></li><li><a class="tocitem" href="#Fields"><span>Fields</span></a></li><li><a class="tocitem" href="#Limiters"><span>Limiters</span></a></li></ul></li><li><a class="tocitem" href="../math_framework/">Mathematical Framework</a></li><li><a class="tocitem" href="../operators/">Operators</a></li><li><input class="collapse-toggle" id="menuitem-6" type="checkbox"/><label class="tocitem" for="menuitem-6"><span class="docs-label">Developer docs</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../performance_tips/">Performance tips</a></li></ul></li><li><input class="collapse-toggle" id="menuitem-7" type="checkbox"/><label class="tocitem" for="menuitem-7"><span class="docs-label">Tutorials</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../tutorials/introduction/">Introduction to ClimaCore.jl</a></li></ul></li><li><a class="tocitem" href="../examples/">Examples</a></li><li><input class="collapse-toggle" id="menuitem-9" type="checkbox"/><label class="tocitem" for="menuitem-9"><span class="docs-label">Libraries</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../lib/ClimaCoreVTK/">ClimaCoreVTK.jl</a></li><li><a class="tocitem" href="../lib/ClimaCoreTempestRemap/">ClimaCoreTempestRemap.jl</a></li></ul></li><li><a class="tocitem" href="../references/">References</a></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><nav class="breadcrumb"><ul class="is-hidden-mobile"><li class="is-active"><a href>API</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>API</a></li></ul></nav><div class="docs-right"><a class="docs-edit-link" href="https://github.com/CliMA/ClimaCore.jl/blob/main/docs/src/api.md" title="Edit on GitHub"><span class="docs-icon fab"></span><span class="docs-label is-hidden-touch">Edit on GitHub</span></a><a class="docs-settings-button fas fa-cog" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-sidebar-button fa fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a></div></header><article class="content" id="documenter-page"><h1 id="API"><a class="docs-heading-anchor" href="#API">API</a><a id="API-1"></a><a class="docs-heading-anchor-permalink" href="#API" title="Permalink"></a></h1><h2 id="DataLayouts"><a class="docs-heading-anchor" href="#DataLayouts">DataLayouts</a><a id="DataLayouts-1"></a><a class="docs-heading-anchor-permalink" href="#DataLayouts" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-binding" id="ClimaCore.DataLayouts" href="#ClimaCore.DataLayouts"><code>ClimaCore.DataLayouts</code></a> — <span class="docstring-category">Module</span></header><section><div><pre><code class="language-julia hljs">ClimaCore.DataLayouts</code></pre><p>Notation:</p><ul><li><code>i,j</code> are horizontal node indices within an element</li><li><code>k</code> is the vertical node index within an element</li><li><code>f</code> is the field index (1 if field is scalar, &gt;1 if it is a vector field)</li><li><code>v</code> is the vertical element index in a stack</li><li><code>h</code> is the element stack index</li></ul><p>Data layout is specified by the order in which they appear, e.g. <code>IJKFVH</code> indexes the underlying array as <code>[i,j,k,f,v,h]</code></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/CliMA/ClimaCore.jl/blob/32cddc9bc6cdc98cfe50851494c1259acd0bf375/src/DataLayouts/DataLayouts.jl#L1-L14">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="ClimaCore.DataLayouts.DataF" href="#ClimaCore.DataLayouts.DataF"><code>ClimaCore.DataLayouts.DataF</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">DataF{S, A} &lt;: Data0D{S}</code></pre><p>Backing <code>DataLayout</code> for 0D point data.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/CliMA/ClimaCore.jl/blob/32cddc9bc6cdc98cfe50851494c1259acd0bf375/src/DataLayouts/DataLayouts.jl#L446-L450">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="ClimaCore.DataLayouts.IF" href="#ClimaCore.DataLayouts.IF"><code>ClimaCore.DataLayouts.IF</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">IF{S, Ni, A} &lt;: DataSlab1D{S, Ni}</code></pre><p>Backing <code>DataLayout</code> for 1D spectral element slab data.</p><p>Nodal element data (I) are contiguous for each <code>S</code> datatype struct field (F) for a single element slab.</p><p>A <code>DataSlab1D</code> view can be returned from other <code>Data1D</code> objects by calling <code>slab(data, idx...)</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/CliMA/ClimaCore.jl/blob/32cddc9bc6cdc98cfe50851494c1259acd0bf375/src/DataLayouts/DataLayouts.jl#L664-L672">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="ClimaCore.DataLayouts.IJF" href="#ClimaCore.DataLayouts.IJF"><code>ClimaCore.DataLayouts.IJF</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">IJF{S, Nij, A} &lt;: DataSlab2D{S, Nij}</code></pre><p>Backing <code>DataLayout</code> for 2D spectral element slab data.</p><p>Nodal element data (I,J) are contiguous for each <code>S</code> datatype struct field (F) for a single element slab.</p><p>A <code>DataSlab2D</code> view can be returned from other <code>Data2D</code> objects by calling <code>slab(data, idx...)</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/CliMA/ClimaCore.jl/blob/32cddc9bc6cdc98cfe50851494c1259acd0bf375/src/DataLayouts/DataLayouts.jl#L548-L556">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="ClimaCore.DataLayouts.VF" href="#ClimaCore.DataLayouts.VF"><code>ClimaCore.DataLayouts.VF</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">VF{S, A} &lt;: DataColumn{S}</code></pre><p>Backing <code>DataLayout</code> for 1D FV column data.</p><p>Column level data (V) are contiguous for each <code>S</code> datatype struct field (F).</p><p>A <code>DataColumn</code> view can be returned from other <code>Data1DX</code>, <code>Data2DX</code> objects by calling <code>column(data, idx...)</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/CliMA/ClimaCore.jl/blob/32cddc9bc6cdc98cfe50851494c1259acd0bf375/src/DataLayouts/DataLayouts.jl#L736-L744">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="ClimaCore.DataLayouts.IFH" href="#ClimaCore.DataLayouts.IFH"><code>ClimaCore.DataLayouts.IFH</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">IFH{S, Ni, A} &lt;: Data1D{S, Ni}</code></pre><p>Backing <code>DataLayout</code> for 1D spectral element slabs.</p><p>Element nodal point (I) data is contiguous for each datatype <code>S</code> struct field (F), for each 1D mesh element (H).</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/CliMA/ClimaCore.jl/blob/32cddc9bc6cdc98cfe50851494c1259acd0bf375/src/DataLayouts/DataLayouts.jl#L353-L360">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="ClimaCore.DataLayouts.IJFH" href="#ClimaCore.DataLayouts.IJFH"><code>ClimaCore.DataLayouts.IJFH</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">IJFH{S, Nij, A} &lt;: Data2D{S, Nij}</code></pre><p>Backing <code>DataLayout</code> for 2D spectral element slabs.</p><p>Element nodal point (I,J) data is contiguous for each datatype <code>S</code> struct field (F), for each 2D mesh element slab (H).</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/CliMA/ClimaCore.jl/blob/32cddc9bc6cdc98cfe50851494c1259acd0bf375/src/DataLayouts/DataLayouts.jl#L242-L249">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="ClimaCore.DataLayouts.VIFH" href="#ClimaCore.DataLayouts.VIFH"><code>ClimaCore.DataLayouts.VIFH</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">VIFH{S, Ni, A} &lt;: Data1DX{S, Ni}</code></pre><p>Backing <code>DataLayout</code> for 1D spectral element slab + extruded 1D FV column data.</p><p>Column levels (V) are contiguous for every element nodal point (I) for each datatype <code>S</code> struct field (F), for each 1D mesh element slab (H).</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/CliMA/ClimaCore.jl/blob/32cddc9bc6cdc98cfe50851494c1259acd0bf375/src/DataLayouts/DataLayouts.jl#L979-L986">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="ClimaCore.DataLayouts.VIJFH" href="#ClimaCore.DataLayouts.VIJFH"><code>ClimaCore.DataLayouts.VIJFH</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">VIJFH{S, Nij, A} &lt;: Data2DX{S, Nij}</code></pre><p>Backing <code>DataLayout</code> for 2D spectral element slab + extruded 1D FV column data.</p><p>Column levels (V) are contiguous for every element nodal point (I, J) for each <code>S</code> datatype struct field (F), for each 2D mesh element slab (H).</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/CliMA/ClimaCore.jl/blob/32cddc9bc6cdc98cfe50851494c1259acd0bf375/src/DataLayouts/DataLayouts.jl#L844-L851">source</a></section></article><h2 id="Geometry"><a class="docs-heading-anchor" href="#Geometry">Geometry</a><a id="Geometry-1"></a><a class="docs-heading-anchor-permalink" href="#Geometry" title="Permalink"></a></h2><h3 id="Coordinates"><a class="docs-heading-anchor" href="#Coordinates">Coordinates</a><a id="Coordinates-1"></a><a class="docs-heading-anchor-permalink" href="#Coordinates" title="Permalink"></a></h3><article class="docstring"><header><a class="docstring-binding" id="ClimaCore.Geometry.AbstractPoint" href="#ClimaCore.Geometry.AbstractPoint"><code>ClimaCore.Geometry.AbstractPoint</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">AbstractPoint</code></pre><p>Represents a point in space.</p><p>The following types are supported:</p><ul><li><code>XPoint(x)</code></li><li><code>YPoint(y)</code></li><li><code>ZPoint(z)</code></li><li><code>XYPoint(x, y)</code></li><li><code>XZPoint(x, z)</code></li><li><code>XYZPoint(x, y, z)</code></li><li><code>LatLongPoint(lat, long)</code></li><li><code>LatLongZPoint(lat, long, z)</code></li><li><code>Cartesian1Point(x1)</code></li><li><code>Cartesian2Point(x2)</code></li><li><code>Cartesian3Point(x3)</code></li><li><code>Cartesian12Point(x1, x2)</code></li><li><code>Cartesian13Point(x1, x3)</code></li><li><code>Cartesian123Point(x1, x2, x3)</code></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/CliMA/ClimaCore.jl/blob/32cddc9bc6cdc98cfe50851494c1259acd0bf375/src/Geometry/coordinates.jl#L1-L21">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="ClimaCore.Geometry.float_type" href="#ClimaCore.Geometry.float_type"><code>ClimaCore.Geometry.float_type</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">float_type(T)</code></pre><p>Return the floating point type backing <code>T</code>: <code>T</code> can either be an object or a type.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/CliMA/ClimaCore.jl/blob/32cddc9bc6cdc98cfe50851494c1259acd0bf375/src/Geometry/coordinates.jl#L24-L28">source</a></section></article><p>Points represent <em>locations</em> in space, specified by coordinates in a given coordinate system (Cartesian, spherical, etc), whereas vectors, on the other hand, represent <em>displacements</em> in space.</p><p>An analogy with time works well: times (also called instants or datetimes) are <em>locations</em> in time, while, durations are <em>displacements</em> in time.</p><p><strong>Note 1</strong>: Latitude and longitude are specified via angles (and, therefore, trigonometric functions: <code>cosd</code>, <code>sind</code>, <code>acosd</code>, <code>asind</code>, <code>tand</code>,...) in degrees, not in radians. Moreover, <code>lat</code> (usually denoted by <span>$\theta$</span>) <span>$\in [-90.0, 90.0]$</span>, and <code>long</code> (usually denoted by <span>$\lambda$</span>) <span>$\in [-180.0, 180.0]$</span>.</p><p><strong>Note 2:</strong>: In a <code>Geometry.LatLongZPoint(lat, long, z)</code>, <code>z</code> represents the elevation above the surface of the sphere with radius R (implicitly accounted for in the geoemtry).</p><p><strong>Note 3</strong>: There are also a set of specific Cartesian points (<code>Cartesian1Point(x1)</code>, <code>Cartesian2Point(x2)</code>, etc). These are occasionally useful for converting everything to a full Cartesian domain (e.g. for visualization purposes). These are distinct from <code>XYZPoint</code> as <code>ZPoint</code> can mean different things in different domains.</p><h2 id="Domains"><a class="docs-heading-anchor" href="#Domains">Domains</a><a id="Domains-1"></a><a class="docs-heading-anchor-permalink" href="#Domains" title="Permalink"></a></h2><h3 id="Types"><a class="docs-heading-anchor" href="#Types">Types</a><a id="Types-1"></a><a class="docs-heading-anchor-permalink" href="#Types" title="Permalink"></a></h3><article class="docstring"><header><a class="docstring-binding" id="ClimaCore.Domains.AbstractDomain" href="#ClimaCore.Domains.AbstractDomain"><code>ClimaCore.Domains.AbstractDomain</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">AbstractDomain</code></pre><p>A domain represents a region of space.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/CliMA/ClimaCore.jl/blob/32cddc9bc6cdc98cfe50851494c1259acd0bf375/src/Domains/Domains.jl#L7-L11">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="ClimaCore.Domains.IntervalDomain" href="#ClimaCore.Domains.IntervalDomain"><code>ClimaCore.Domains.IntervalDomain</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">IntervalDomain(coord⁻, coord⁺; periodic=true)
IntervalDomain(coord⁻, coord⁺; boundary_names::Tuple{Symbol,Symbol})</code></pre><p>Construct a <code>IntervalDomain</code>, the closed interval is given by <code>coord⁻</code>, <code>coord⁺</code> coordinate arguments.</p><p>Either a <code>periodic</code> or <code>boundary_names</code> keyword argument is required.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/CliMA/ClimaCore.jl/blob/32cddc9bc6cdc98cfe50851494c1259acd0bf375/src/Domains/Domains.jl#L38-L45">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="ClimaCore.Domains.RectangleDomain" href="#ClimaCore.Domains.RectangleDomain"><code>ClimaCore.Domains.RectangleDomain</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">RectangleDomain(x1::ClosedInterval, x2::ClosedInterval;
    x1boundary::Tuple{Symbol,Symbol},
    x2boundary::Tuple{Symbol,Symbol},
    x1periodic = false,
    x2periodic = false,
)</code></pre><p>Construct a <code>RectangularDomain</code> in the horizontal. If a given x1 or x2 boundary is not periodic, then <code>x1boundary</code> or <code>x2boundary</code> boundary name keyword arguments must be supplied.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/CliMA/ClimaCore.jl/blob/32cddc9bc6cdc98cfe50851494c1259acd0bf375/src/Domains/Domains.jl#L94-L104">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="ClimaCore.Domains.SphereDomain" href="#ClimaCore.Domains.SphereDomain"><code>ClimaCore.Domains.SphereDomain</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">SphereDomain(radius)</code></pre><p>A domain representing the surface of a sphere with radius <code>radius</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/CliMA/ClimaCore.jl/blob/32cddc9bc6cdc98cfe50851494c1259acd0bf375/src/Domains/Domains.jl#L135-L139">source</a></section></article><h3 id="Interfaces"><a class="docs-heading-anchor" href="#Interfaces">Interfaces</a><a id="Interfaces-1"></a><a class="docs-heading-anchor-permalink" href="#Interfaces" title="Permalink"></a></h3><article class="docstring"><header><a class="docstring-binding" id="ClimaCore.Domains.boundary_names" href="#ClimaCore.Domains.boundary_names"><code>ClimaCore.Domains.boundary_names</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">boundary_names(obj::Union{AbstractDomain, AbstractMesh, AbstractTopology})</code></pre><p>A tuple or vector of unique boundary names of a spatial domain.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/CliMA/ClimaCore.jl/blob/32cddc9bc6cdc98cfe50851494c1259acd0bf375/src/Domains/Domains.jl#L18-L22">source</a></section></article><h2 id="Meshes"><a class="docs-heading-anchor" href="#Meshes">Meshes</a><a id="Meshes-1"></a><a class="docs-heading-anchor-permalink" href="#Meshes" title="Permalink"></a></h2><p>A <code>Mesh</code> is a division of a domain into elements.</p><h3 id="Mesh-types"><a class="docs-heading-anchor" href="#Mesh-types">Mesh types</a><a id="Mesh-types-1"></a><a class="docs-heading-anchor-permalink" href="#Mesh-types" title="Permalink"></a></h3><article class="docstring"><header><a class="docstring-binding" id="ClimaCore.Meshes.AbstractMesh" href="#ClimaCore.Meshes.AbstractMesh"><code>ClimaCore.Meshes.AbstractMesh</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">AbstractMesh{dim}</code></pre><p>A <code>Mesh</code> is an object which represents how we discretize a domain into elements.</p><p>It should be lightweight (i.e. exists on all MPI ranks), e.g for meshes stored in a file, it would contain the filename.</p><p><strong>Face and vertex numbering</strong></p><p>In 1D, faces and vertices are the same, and both are numbered <code>[1,2]</code>.</p><p>In 2D, a face is a line segment between to vertices, and both are numbered <code>[1,2,3,4]</code>, in a counter-clockwise direction.</p><pre><code class="nohighlight hljs"> v4        f3        v3
   o-----------------o
   |                 |	    face    vertices
   |                 |	      f1 =&gt;  v1 v2
f4 |                 | f2     f2 =&gt;  v2 v3
   |                 |	      f3 =&gt;  v3 v4
   |                 |        f4 =&gt;  v4 v1
   |                 |
   o-----------------o
  v1       f1        v2</code></pre><p><strong>Interface</strong></p><p>A subtype of <code>AbstractMesh</code> should define the following methods:</p><ul><li><a href="#ClimaCore.Meshes.domain"><code>domain(mesh)</code></a></li><li><a href="#ClimaCore.Meshes.elements"><code>elements(mesh)</code></a></li><li><a href="#ClimaCore.Meshes.is_boundary_face"><code>is_boundary_face(mesh, elem, face)</code></a></li><li><a href="#ClimaCore.Meshes.boundary_face_name"><code>boundary_face_name(mesh, elem, face)</code></a></li><li><a href="#ClimaCore.Meshes.opposing_face"><code>opposing_face(mesh, elem, face)</code></a></li><li><a href="#ClimaCore.Meshes.coordinates"><code>coordinates(mesh, elem, vert)</code></a></li><li><a href="#ClimaCore.Meshes.containing_element"><code>containing_element</code></a> (optional)</li></ul><p>The following types/methods are provided by <code>AbstractMesh</code>:</p><ul><li><a href="#ClimaCore.Meshes.SharedVertices"><code>SharedVertices(mesh, elem, vert)</code></a></li><li><a href="#ClimaCore.Meshes.face_connectivity_matrix"><code>face_connectivity_matrix(mesh[,elemorder])</code></a></li><li><a href="#ClimaCore.Meshes.vertex_connectivity_matrix"><code>vertex_connectivity_matrix(mesh[,elemorder])</code></a></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/CliMA/ClimaCore.jl/blob/32cddc9bc6cdc98cfe50851494c1259acd0bf375/src/Meshes/Meshes.jl#L21-L63">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="ClimaCore.Meshes.IntervalMesh" href="#ClimaCore.Meshes.IntervalMesh"><code>ClimaCore.Meshes.IntervalMesh</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">IntervalMesh &lt;: AbstractMesh</code></pre><p>A 1D mesh on an <code>IntervalDomain</code>.</p><p><strong>Constuctors</strong></p><pre><code class="nohighlight hljs">IntervalMesh(domain::IntervalDomain, faces::AbstractVector)</code></pre><p>Construct a 1D mesh with face locations at <code>faces</code>.</p><pre><code class="nohighlight hljs">IntervalMesh(domain::IntervalDomain[, stetching=Uniform()]; nelems=)</code></pre><p>Constuct a 1D mesh on <code>domain</code> with <code>nelems</code> elements, using <code>stretching</code>. Possible values of <code>stretching</code> are:</p><ul><li><a href="#ClimaCore.Meshes.Uniform"><code>Uniform()</code></a></li><li><a href="#ClimaCore.Meshes.ExponentialStretching"><code>ExponentialStretching(H)</code></a></li><li><a href="@ref"><code>GeneralizedExponentialStretching(dz_surface, dz_top)</code></a></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/CliMA/ClimaCore.jl/blob/32cddc9bc6cdc98cfe50851494c1259acd0bf375/src/Meshes/interval.jl#L1-L19">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="ClimaCore.Meshes.RectilinearMesh" href="#ClimaCore.Meshes.RectilinearMesh"><code>ClimaCore.Meshes.RectilinearMesh</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">RectilinearMesh &lt;: AbstractMesh2D</code></pre><p><strong>Constructors</strong></p><pre><code class="nohighlight hljs">RectilinearMesh(domain::RectangleDomain, n1, n2)</code></pre><p>Construct a <code>RectilinearMesh</code> of equally-spaced <code>n1</code> by <code>n2</code> elements on <code>domain</code>.</p><pre><code class="nohighlight hljs">RectilinearMesh(intervalmesh1::IntervalMesh1, intervalmesh2::IntervalMesh2)</code></pre><p>Construct the product mesh of <code>intervalmesh1</code> and <code>intervalmesh2</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/CliMA/ClimaCore.jl/blob/32cddc9bc6cdc98cfe50851494c1259acd0bf375/src/Meshes/rectangle.jl#L1-L13">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="ClimaCore.Meshes.AbstractCubedSphere" href="#ClimaCore.Meshes.AbstractCubedSphere"><code>ClimaCore.Meshes.AbstractCubedSphere</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">AbstractCubedSphere &lt;: AbstractMesh2D</code></pre><p>This is an abstract type of cubed-sphere meshes on <code>SphereDomain</code>s. A cubed-sphere mesh has 6 panels, laid out as follows:</p><pre><code class="nohighlight hljs">                                          :   Panel 1   :
                            +-------------+-------------+
                            |     +x1     |     +x1     |
                            |             |             |
                            |    Panel    |    Panel    |
                            |+x3   5   -x3|-x2   6   +x2|
                            |     -x2     |     -x3     |
                            |             |             |
                            |     -x1     |     -x1     |
              +-------------+-------------+-------------+
              |     -x2     |     -x2     |
              |             |             |
              |    Panel    |    Panel    |
              |+x1   3   -x1|+x3   4   -x3|
              |     +x3     |     -x1     |
              |             |             |
              |     +x2     |     +x2     |
+-------------+-------------+-------------+
|     +x3     |     +x3     |
|             |             |
|    Panel    |    Panel    |
|-x2   1   +x2|+x1   2   -x1|
|     +x1     |     +x2     |
|             |             |
|     -x3     |     -x3     |
+-------------+-------------+
:   Panel 6   :</code></pre><p>This is the same panel ordering used by the S2 Geometry library (though we use 1-based instead of 0-based numering).</p><p>Elements are indexed by a <code>CartesianIndex{3}</code> object, where the components are:</p><ul><li>horizontal element index (left to right) within each panel.</li><li>vertical element index (bottom to top) within each panel.</li><li>panel number</li></ul><p>Subtypes should have the following fields:</p><ul><li><code>domain</code>: a <code>SphereDomain</code></li><li><code>ne</code>: number of elements across each panel</li></ul><p><strong>External links</strong></p><ul><li><a href="https://s2geometry.io/devguide/s2cell_hierarchy">S2Geometry library</a></li><li><a href="https://mitgcm.readthedocs.io/en/latest/phys_pkgs/exch2.html?highlight=cube%20sphere#fig-48tile">MIT GCM exch2</a></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/CliMA/ClimaCore.jl/blob/32cddc9bc6cdc98cfe50851494c1259acd0bf375/src/Meshes/cubedsphere.jl#L1-L51">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="ClimaCore.Meshes.EquiangularCubedSphere" href="#ClimaCore.Meshes.EquiangularCubedSphere"><code>ClimaCore.Meshes.EquiangularCubedSphere</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">EquiangularCubedSphere &lt;: AbstractCubedSphere</code></pre><p>An equiangular gnomonic mesh proposed by <a href="../references/#Ronchi1996">C. Ronchi, R. Iacono, P. S. Paolucci (1996)</a>. Uses the element indexing convention of <a href="#ClimaCore.Meshes.AbstractCubedSphere"><code>AbstractCubedSphere</code></a>.</p><p><strong>Constructors</strong></p><pre><code class="nohighlight hljs">EquiangularCubedSphere(
    domain::Domains.SphereDomain,
    ne::Integer,
    localelementmap=NormalizedBilinearMap()
    )</code></pre><p>Constuct an <code>EquiangularCubedSphere</code> on <code>domain</code> with <code>ne</code> elements across each panel.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/CliMA/ClimaCore.jl/blob/32cddc9bc6cdc98cfe50851494c1259acd0bf375/src/Meshes/cubedsphere.jl#L327-L343">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="ClimaCore.Meshes.EquidistantCubedSphere" href="#ClimaCore.Meshes.EquidistantCubedSphere"><code>ClimaCore.Meshes.EquidistantCubedSphere</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">EquidistantCubedSphere &lt;: AbstractCubedSphere</code></pre><p>An equidistant gnomonic mesh outlined in <a href="../references/#Rancic1996">M. Rančić, R. J. Purser, F. Mesinger (1996)</a> and <a href="../references/#Nair2005">Ramachandran D Nair, Stephen J Thomas, Richard D Loft (2005)</a>. Uses the element indexing convention of <a href="#ClimaCore.Meshes.AbstractCubedSphere"><code>AbstractCubedSphere</code></a>.</p><p><strong>Constructors</strong></p><pre><code class="nohighlight hljs">EquidistantCubedSphere(domain::Domains.SphereDomain, ne::Integer)</code></pre><p>Constuct an <code>EquidistantCubedSphere</code> on <code>domain</code> with <code>ne</code> elements across each panel.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/CliMA/ClimaCore.jl/blob/32cddc9bc6cdc98cfe50851494c1259acd0bf375/src/Meshes/cubedsphere.jl#L378-L390">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="ClimaCore.Meshes.ConformalCubedSphere" href="#ClimaCore.Meshes.ConformalCubedSphere"><code>ClimaCore.Meshes.ConformalCubedSphere</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">ConformalCubedSphere &lt;: AbstractCubedSphere</code></pre><p>A conformal mesh outlined in <a href="../references/#Rancic1996">M. Rančić, R. J. Purser, F. Mesinger (1996)</a>. Uses the element indexing convention of <a href="#ClimaCore.Meshes.AbstractCubedSphere"><code>AbstractCubedSphere</code></a>.</p><p><strong>Constructors</strong></p><pre><code class="nohighlight hljs">ConformalCubedSphere(domain::Domains.SphereDomain, ne::Integer)</code></pre><p>Constuct a <code>ConformalCubedSphere</code> on <code>domain</code> with <code>ne</code> elements across each panel.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/CliMA/ClimaCore.jl/blob/32cddc9bc6cdc98cfe50851494c1259acd0bf375/src/Meshes/cubedsphere.jl#L416-L428">source</a></section></article><h3 id="Local-element-map"><a class="docs-heading-anchor" href="#Local-element-map">Local element map</a><a id="Local-element-map-1"></a><a class="docs-heading-anchor-permalink" href="#Local-element-map" title="Permalink"></a></h3><article class="docstring"><header><a class="docstring-binding" id="ClimaCore.Meshes.LocalElementMap" href="#ClimaCore.Meshes.LocalElementMap"><code>ClimaCore.Meshes.LocalElementMap</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">LocalElementMap</code></pre><p>An abstract type of mappings from the reference element to a physical domain.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/CliMA/ClimaCore.jl/blob/32cddc9bc6cdc98cfe50851494c1259acd0bf375/src/Meshes/cubedsphere.jl#L54-L58">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="ClimaCore.Meshes.IntrinsicMap" href="#ClimaCore.Meshes.IntrinsicMap"><code>ClimaCore.Meshes.IntrinsicMap</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">IntrinsicMap()</code></pre><p>This <a href="#ClimaCore.Meshes.LocalElementMap"><code>LocalElementMap</code></a> uses the intrinsic mapping of the cubed sphere to map the reference element to the physical domain.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/CliMA/ClimaCore.jl/blob/32cddc9bc6cdc98cfe50851494c1259acd0bf375/src/Meshes/cubedsphere.jl#L61-L66">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="ClimaCore.Meshes.NormalizedBilinearMap" href="#ClimaCore.Meshes.NormalizedBilinearMap"><code>ClimaCore.Meshes.NormalizedBilinearMap</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">NormalizedBilinearMap()</code></pre><p>The <a href="#ClimaCore.Meshes.LocalElementMap"><code>LocalElementMap</code></a> for meshes on spherical domains of <a href="../references/#Guba2014">O. Guba, M. A. Taylor, P. A. Ullrich, J. R. Overfelt, M. N. Levy (2014)</a>. It uses bilinear interpolation between the Cartesian coordinates of the element vertices, then normalizes the result to lie on the sphere.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/CliMA/ClimaCore.jl/blob/32cddc9bc6cdc98cfe50851494c1259acd0bf375/src/Meshes/cubedsphere.jl#L69-L76">source</a></section></article><h3 id="Mesh-stretching"><a class="docs-heading-anchor" href="#Mesh-stretching">Mesh stretching</a><a id="Mesh-stretching-1"></a><a class="docs-heading-anchor-permalink" href="#Mesh-stretching" title="Permalink"></a></h3><article class="docstring"><header><a class="docstring-binding" id="ClimaCore.Meshes.Uniform" href="#ClimaCore.Meshes.Uniform"><code>ClimaCore.Meshes.Uniform</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">Uniform()</code></pre><p>Use uniformly-sized elements.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/CliMA/ClimaCore.jl/blob/32cddc9bc6cdc98cfe50851494c1259acd0bf375/src/Meshes/interval.jl#L76-L80">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="ClimaCore.Meshes.ExponentialStretching" href="#ClimaCore.Meshes.ExponentialStretching"><code>ClimaCore.Meshes.ExponentialStretching</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">ExponentialStretching(H)</code></pre><p>Apply exponential stretching to the domain when constructing elements. <code>H</code> is the scale height (a typical atmospheric scale height <code>H ≈ 7.5</code>km).</p><p>For an interval <span>$[z_0,z_1]$</span>, this makes the elements uniformally spaced in <span>$\zeta$</span>, where</p><p class="math-container">\[\zeta = \frac{1 - e^{-\eta/h}}{1-e^{-1/h}},\]</p><p>where <span>$\eta = \frac{z - z_0}{z_1-z_0}$</span>, and <span>$h = \frac{H}{z_1-z_0}$</span> is the non-dimensional scale height.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/CliMA/ClimaCore.jl/blob/32cddc9bc6cdc98cfe50851494c1259acd0bf375/src/Meshes/interval.jl#L96-L109">source</a></section></article><h3 id="Interfaces-2"><a class="docs-heading-anchor" href="#Interfaces-2">Interfaces</a><a class="docs-heading-anchor-permalink" href="#Interfaces-2" title="Permalink"></a></h3><article class="docstring"><header><a class="docstring-binding" id="ClimaCore.Meshes.domain" href="#ClimaCore.Meshes.domain"><code>ClimaCore.Meshes.domain</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">Meshes.domain(mesh::AbstractMesh)</code></pre><p>The <a href="#ClimaCore.Domains.AbstractDomain"><code>Domains.AbstractDomain</code></a> on which the mesh is defined.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/CliMA/ClimaCore.jl/blob/32cddc9bc6cdc98cfe50851494c1259acd0bf375/src/Meshes/Meshes.jl#L69-L73">source</a></section><section><div><pre><code class="nohighlight hljs">domain(topology)</code></pre><p>Returns the domain of the <code>topology</code> from the underlying <code>mesh</code></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/CliMA/ClimaCore.jl/blob/32cddc9bc6cdc98cfe50851494c1259acd0bf375/src/Topologies/Topologies.jl#L45-L49">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="ClimaCore.Meshes.elements" href="#ClimaCore.Meshes.elements"><code>ClimaCore.Meshes.elements</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">Meshes.elements(mesh::AbstractMesh)</code></pre><p>An iterator over the elements of a mesh. Elements of a mesh can be of any type.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/CliMA/ClimaCore.jl/blob/32cddc9bc6cdc98cfe50851494c1259acd0bf375/src/Meshes/Meshes.jl#L76-L80">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="ClimaCore.Meshes.nelements" href="#ClimaCore.Meshes.nelements"><code>ClimaCore.Meshes.nelements</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">nelements(mesh::AbstractMesh)</code></pre><p>The number of elements in the mesh.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/CliMA/ClimaCore.jl/blob/32cddc9bc6cdc98cfe50851494c1259acd0bf375/src/Meshes/common.jl#L4-L8">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="ClimaCore.Meshes.is_boundary_face" href="#ClimaCore.Meshes.is_boundary_face"><code>ClimaCore.Meshes.is_boundary_face</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">Meshes.is_boundary_face(mesh::AbstractMesh, elem, face::Int)::Bool</code></pre><p>Determine whether face <code>face</code> of element <code>elem</code> is on the boundary of <code>mesh</code>.</p><p><code>elem</code> should be an element of <a href="#ClimaCore.Meshes.elements"><code>elements(mesh)</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/CliMA/ClimaCore.jl/blob/32cddc9bc6cdc98cfe50851494c1259acd0bf375/src/Meshes/Meshes.jl#L83-L89">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="ClimaCore.Meshes.boundary_face_name" href="#ClimaCore.Meshes.boundary_face_name"><code>ClimaCore.Meshes.boundary_face_name</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">Meshes.boundary_face_name(mesh::AbstractMesh, elem, face::Int)::Union{Symbol,Nothing}</code></pre><p>The name of the boundary facing <code>face</code> of element <code>elem</code>, or <code>nothing</code> if it is not on the boundary.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/CliMA/ClimaCore.jl/blob/32cddc9bc6cdc98cfe50851494c1259acd0bf375/src/Meshes/Meshes.jl#L92-L97">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="ClimaCore.Meshes.opposing_face" href="#ClimaCore.Meshes.opposing_face"><code>ClimaCore.Meshes.opposing_face</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">opelem, opface, reversed = Meshes.opposing_face(mesh::AbstractMesh, elem, face::Int)</code></pre><p>The element and face (<code>opelem</code>, <code>opface</code>) that oppose face <code>face</code> of element <code>elem</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/CliMA/ClimaCore.jl/blob/32cddc9bc6cdc98cfe50851494c1259acd0bf375/src/Meshes/Meshes.jl#L100-L104">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="ClimaCore.Meshes.coordinates" href="#ClimaCore.Meshes.coordinates"><code>ClimaCore.Meshes.coordinates</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">Meshes.coordinates(mesh, elem, vert::Int)
Meshes.coordinates(mesh, elem, ξ::SVector)</code></pre><p>Return the physical coordinates of a point in an element <code>elem</code> of <code>mesh</code>. The position of the point can either be a vertex number <code>vert</code> or the coordinates <code>ξ</code> in the reference element.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/CliMA/ClimaCore.jl/blob/32cddc9bc6cdc98cfe50851494c1259acd0bf375/src/Meshes/common.jl#L164-L171">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="ClimaCore.Meshes.containing_element" href="#ClimaCore.Meshes.containing_element"><code>ClimaCore.Meshes.containing_element</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">elem = Meshes.containing_element(mesh::AbstractMesh, coord)</code></pre><p>The element <code>elem</code> in <code>mesh</code> containing the coordinate <code>coord</code>. If the coordinate falls on the boundary between two or more elements, an arbitrary element is chosen.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/CliMA/ClimaCore.jl/blob/32cddc9bc6cdc98cfe50851494c1259acd0bf375/src/Meshes/common.jl#L181-L187">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="ClimaCore.Meshes.reference_coordinates" href="#ClimaCore.Meshes.reference_coordinates"><code>ClimaCore.Meshes.reference_coordinates</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">ξ = Meshes.reference_coordinates(mesh::AbstractMesh, elem, coord)</code></pre><p>An <code>SVector</code> of coordinates in the reference element such that</p><pre><code class="nohighlight hljs">Meshes.coordinates(mesh, elem, ξ) == coord</code></pre><p>This can be used for interpolation to a specific point.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/CliMA/ClimaCore.jl/blob/32cddc9bc6cdc98cfe50851494c1259acd0bf375/src/Meshes/common.jl#L190-L198">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="ClimaCore.Meshes.SharedVertices" href="#ClimaCore.Meshes.SharedVertices"><code>ClimaCore.Meshes.SharedVertices</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">Meshes.SharedVertices(mesh, elem, vert)</code></pre><p>An iterator over (element, vertex) pairs that are shared with <code>(elem,vert)</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/CliMA/ClimaCore.jl/blob/32cddc9bc6cdc98cfe50851494c1259acd0bf375/src/Meshes/common.jl#L28-L32">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="ClimaCore.Meshes.face_connectivity_matrix" href="#ClimaCore.Meshes.face_connectivity_matrix"><code>ClimaCore.Meshes.face_connectivity_matrix</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">M = Meshes.face_connectivity_matrix(mesh, elemorder = elements(mesh))</code></pre><p>Construct a <code>Bool</code>-valued <code>SparseCSCMatrix</code> containing the face connections of <code>mesh</code>. Elements are indexed according to <code>elemorder</code>.</p><p>Note that <code>M[i,i] == true</code> only if two distinct faces of element <code>i</code> are connected.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/CliMA/ClimaCore.jl/blob/32cddc9bc6cdc98cfe50851494c1259acd0bf375/src/Meshes/common.jl#L101-L108">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="ClimaCore.Meshes.vertex_connectivity_matrix" href="#ClimaCore.Meshes.vertex_connectivity_matrix"><code>ClimaCore.Meshes.vertex_connectivity_matrix</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">M = Meshes.vertex_connectivity_matrix(mesh, elemorder = elements(mesh))</code></pre><p>Construct a <code>Bool</code>-valued <code>SparseCSCMatrix</code> containing the vertex connections of <code>mesh</code>. Elements are indexed according to <code>elemorder</code>.</p><p>Note that <code>M[i,i] == true</code> only if two distinct vertices of element <code>i</code> are connected.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/CliMA/ClimaCore.jl/blob/32cddc9bc6cdc98cfe50851494c1259acd0bf375/src/Meshes/common.jl#L132-L139">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="ClimaCore.Meshes.linearindices" href="#ClimaCore.Meshes.linearindices"><code>ClimaCore.Meshes.linearindices</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">Meshes.linearindices(elemorder)</code></pre><p>Given a data structure <code>elemorder[i] = elem</code> that orders elements, construct the inverse map from <code>orderindex = linearindices(elemorder)</code> such that <code>orderindex[elem] = i</code>.</p><p>This will try to use the most efficient structure available.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/CliMA/ClimaCore.jl/blob/32cddc9bc6cdc98cfe50851494c1259acd0bf375/src/Meshes/common.jl#L75-L83">source</a></section></article><h2 id="Topologies"><a class="docs-heading-anchor" href="#Topologies">Topologies</a><a id="Topologies-1"></a><a class="docs-heading-anchor-permalink" href="#Topologies" title="Permalink"></a></h2><p>A <code>Topology</code> determines the ordering and connections between elements of a mesh. <img src="cubedsphere_spacefillingcurve.png" alt="Space-filling curve element ordering for a cubed sphere mesh"/></p><h3 id="Types-2"><a class="docs-heading-anchor" href="#Types-2">Types</a><a class="docs-heading-anchor-permalink" href="#Types-2" title="Permalink"></a></h3><article class="docstring"><header><a class="docstring-binding" id="ClimaCore.Topologies.AbstractTopology" href="#ClimaCore.Topologies.AbstractTopology"><code>ClimaCore.Topologies.AbstractTopology</code></a> — <span class="docstring-category">Type</span></header><section><div><p>AbstractTopology</p><p>Subtypes of <code>AbstractHorizontalTopology</code> define connectiveness of a mesh in the horizontal domain.</p><p><strong>Interfaces</strong></p><ul><li><a href="@ref"><code>nelems</code></a></li><li><a href="#ClimaCore.Meshes.domain"><code>domain</code></a></li><li><a href="#ClimaCore.Topologies.mesh"><code>mesh</code></a></li><li><a href="#ClimaCore.Topologies.nlocalelems"><code>nlocalelems</code></a></li><li><a href="@ref"><code>nneighbors</code></a></li><li><a href="@ref"><code>nsendelems</code></a></li><li><a href="@ref"><code>nghostelems</code></a></li><li><a href="@ref"><code>localelemindex</code></a></li><li><a href="#ClimaCore.Topologies.vertex_coordinates"><code>vertex_coordinates</code></a></li><li><a href="#ClimaCore.Topologies.opposing_face"><code>opposing_face</code></a></li><li><a href="@ref"><code>face_node_index</code></a></li><li><a href="#ClimaCore.Topologies.interior_faces"><code>interior_faces</code></a></li><li><a href="@ref"><code>ghost_faces</code></a></li><li><a href="@ref"><code>vertex_node_index</code></a></li><li><a href="@ref"><code>vertices</code></a></li><li><a href="#ClimaCore.Topologies.local_neighboring_elements"><code>local_neighboring_elements</code></a></li><li><a href="#ClimaCore.Topologies.ghost_neighboring_elements"><code>ghost_neighboring_elements</code></a></li><li><a href="@ref"><code>local_vertices</code></a></li><li><a href="@ref"><code>ghost_vertices</code></a></li><li><a href="@ref"><code>neighbors</code></a></li><li><a href="#ClimaCore.Topologies.boundary_tags"><code>boundary_tags</code></a></li><li><a href="#ClimaCore.Topologies.boundary_tag"><code>boundary_tag</code></a></li><li><a href="#ClimaCore.Topologies.boundary_faces"><code>boundary_faces</code></a></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/CliMA/ClimaCore.jl/blob/32cddc9bc6cdc98cfe50851494c1259acd0bf375/src/Topologies/Topologies.jl#L7-L39">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="ClimaCore.Topologies.IntervalTopology" href="#ClimaCore.Topologies.IntervalTopology"><code>ClimaCore.Topologies.IntervalTopology</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">IntervalTopology(mesh::IntervalMesh)</code></pre><p>A sequential topology on an <a href="#ClimaCore.Meshes.IntervalMesh"><code>Meshes.IntervalMesh</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/CliMA/ClimaCore.jl/blob/32cddc9bc6cdc98cfe50851494c1259acd0bf375/src/Topologies/interval.jl#L3-L7">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="ClimaCore.Topologies.Topology2D" href="#ClimaCore.Topologies.Topology2D"><code>ClimaCore.Topologies.Topology2D</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">Topology2D(mesh::AbstractMesh2D, elemorder=Mesh.elements(mesh))</code></pre><p>This is a generic non-distributed topology for 2D meshes. <code>elemorder</code> is a vector or other linear ordering of the <code>Mesh.elements(mesh)</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/CliMA/ClimaCore.jl/blob/32cddc9bc6cdc98cfe50851494c1259acd0bf375/src/Topologies/topology2d.jl#L1-L6">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="ClimaCore.Topologies.spacefillingcurve" href="#ClimaCore.Topologies.spacefillingcurve"><code>ClimaCore.Topologies.spacefillingcurve</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">spacefillingcurve(mesh::Meshes.AbstractCubedSphere)</code></pre><p>Generate element ordering, <code>elemorder</code>, based on a space filling curve for a <code>CubedSphere</code> mesh.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/CliMA/ClimaCore.jl/blob/32cddc9bc6cdc98cfe50851494c1259acd0bf375/src/Topologies/dtopology2d.jl#L89-L95">source</a></section><section><div><pre><code class="nohighlight hljs">spacefillingcurve(mesh::Meshes.RectilinearMesh)</code></pre><p>Generate element ordering, <code>elemorder</code>, based on a space filling curve for a <code>Rectilinear</code> mesh.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/CliMA/ClimaCore.jl/blob/32cddc9bc6cdc98cfe50851494c1259acd0bf375/src/Topologies/dtopology2d.jl#L112-L118">source</a></section></article><h3 id="Interfaces-3"><a class="docs-heading-anchor" href="#Interfaces-3">Interfaces</a><a class="docs-heading-anchor-permalink" href="#Interfaces-3" title="Permalink"></a></h3><div class="admonition is-warning"><header class="admonition-header">Missing docstring.</header><div class="admonition-body"><p>Missing docstring for <code>Topologies.domain</code>. Check Documenter&#39;s build log for details.</p></div></div><article class="docstring"><header><a class="docstring-binding" id="ClimaCore.Topologies.mesh" href="#ClimaCore.Topologies.mesh"><code>ClimaCore.Topologies.mesh</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">mesh(topology)</code></pre><p>Returns the mesh underlying the <code>topology</code></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/CliMA/ClimaCore.jl/blob/32cddc9bc6cdc98cfe50851494c1259acd0bf375/src/Topologies/Topologies.jl#L52-L56">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="ClimaCore.Topologies.nlocalelems" href="#ClimaCore.Topologies.nlocalelems"><code>ClimaCore.Topologies.nlocalelems</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">nlocalelems(topology)</code></pre><p>The number of local elements in <code>topology</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/CliMA/ClimaCore.jl/blob/32cddc9bc6cdc98cfe50851494c1259acd0bf375/src/Topologies/Topologies.jl#L66-L70">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="ClimaCore.Topologies.vertex_coordinates" href="#ClimaCore.Topologies.vertex_coordinates"><code>ClimaCore.Topologies.vertex_coordinates</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">(c1,c2,c3,c4) = vertex_coordinates(topology, elem)</code></pre><p>The coordinates of the 4 vertices of element <code>elem</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/CliMA/ClimaCore.jl/blob/32cddc9bc6cdc98cfe50851494c1259acd0bf375/src/Topologies/Topologies.jl#L106-L110">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="ClimaCore.Topologies.opposing_face" href="#ClimaCore.Topologies.opposing_face"><code>ClimaCore.Topologies.opposing_face</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">(opelem, opface, reversed) = opposing_face(topology, elem, face)</code></pre><p>The opposing face of face number <code>face</code> of element <code>elem</code> in <code>topology</code>.</p><ul><li><code>opelem</code> is the opposing element number, 0 for a boundary, negative for a ghost element</li><li><code>opface</code> is the opposite face number, or boundary face number if a boundary</li><li><code>reversed</code> indicates whether the opposing face has the opposite orientation.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/CliMA/ClimaCore.jl/blob/32cddc9bc6cdc98cfe50851494c1259acd0bf375/src/Topologies/Topologies.jl#L113-L121">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="ClimaCore.Topologies.interior_faces" href="#ClimaCore.Topologies.interior_faces"><code>ClimaCore.Topologies.interior_faces</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">interior_faces(topology::AbstractTopology)</code></pre><p>An iterator over the interior faces of <code>topology</code>. Each element of the iterator is a 5-tuple the form</p><pre><code class="nohighlight hljs">(elem1, face1, elem2, face2, reversed)</code></pre><p>where <code>elemX, faceX</code> are the element and face numbers, and <code>reversed</code> indicates whether they have opposing orientations.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/CliMA/ClimaCore.jl/blob/32cddc9bc6cdc98cfe50851494c1259acd0bf375/src/Topologies/Topologies.jl#L145-L155">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="ClimaCore.Topologies.boundary_tags" href="#ClimaCore.Topologies.boundary_tags"><code>ClimaCore.Topologies.boundary_tags</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">boundary_tags(topology)</code></pre><p>A <code>Tuple</code> or <code>NamedTuple</code> of the boundary tags of the topology. A boundary tag is an integer that uniquely identifies a boundary.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/CliMA/ClimaCore.jl/blob/32cddc9bc6cdc98cfe50851494c1259acd0bf375/src/Topologies/Topologies.jl#L282-L287">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="ClimaCore.Topologies.boundary_tag" href="#ClimaCore.Topologies.boundary_tag"><code>ClimaCore.Topologies.boundary_tag</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">boundary_tag(topology, name::Symbol)</code></pre><p>The boundary tag of the topology for boundary name <code>name</code>. A boundary tag is an integer that uniquely identifies a boundary.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/CliMA/ClimaCore.jl/blob/32cddc9bc6cdc98cfe50851494c1259acd0bf375/src/Topologies/Topologies.jl#L290-L295">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="ClimaCore.Topologies.boundary_faces" href="#ClimaCore.Topologies.boundary_faces"><code>ClimaCore.Topologies.boundary_faces</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">boundary_faces(topology, boundarytag)</code></pre><p>An iterator over the faces of <code>topology</code> which face the boundary with tag <code>boundarytag</code>. Each element of the iterator is an <code>(elem, face)</code> pair.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/CliMA/ClimaCore.jl/blob/32cddc9bc6cdc98cfe50851494c1259acd0bf375/src/Topologies/Topologies.jl#L298-L303">source</a></section></article><div class="admonition is-warning"><header class="admonition-header">Missing docstring.</header><div class="admonition-body"><p>Missing docstring for <code>Topologies.vertices</code>. Check Documenter&#39;s build log for details.</p></div></div><article class="docstring"><header><a class="docstring-binding" id="ClimaCore.Topologies.local_neighboring_elements" href="#ClimaCore.Topologies.local_neighboring_elements"><code>ClimaCore.Topologies.local_neighboring_elements</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">local_neighboring_elements(topology::AbstractTopology, lidx::Integer)</code></pre><p>An iterator of the local element indices (lidx) of the local elements which are neighbors of the local element <code>lidx</code> in <code>topology</code> (excluding <code>lidx</code> itself).</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/CliMA/ClimaCore.jl/blob/32cddc9bc6cdc98cfe50851494c1259acd0bf375/src/Topologies/Topologies.jl#L181-L186">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="ClimaCore.Topologies.ghost_neighboring_elements" href="#ClimaCore.Topologies.ghost_neighboring_elements"><code>ClimaCore.Topologies.ghost_neighboring_elements</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">ghost_neighboring_elements(topology::AbstractTopology, ridx::Integer)</code></pre><p>An iterator of the receive buffer indices (ridx) of the ghost elements which are neighbors  of the local element <code>lidx</code> in <code>topology</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/CliMA/ClimaCore.jl/blob/32cddc9bc6cdc98cfe50851494c1259acd0bf375/src/Topologies/Topologies.jl#L189-L194">source</a></section></article><h2 id="Spaces"><a class="docs-heading-anchor" href="#Spaces">Spaces</a><a id="Spaces-1"></a><a class="docs-heading-anchor-permalink" href="#Spaces" title="Permalink"></a></h2><p>A <code>Space</code> represents a discretized function space over some domain. Currently two main discretizations are supported: Spectral Element Discretization (both Continuous Galerkin and Discontinuous Galerkin types) and a staggered Finite Difference Discretization. Combination of these two in the horizontal/vertical directions, respectively, is what we call a <em>hybrid</em> space.</p><p>Sketch of a 2DX hybrid discretization:</p><p><img src="../DiscretizationSketch.png" alt="3D hybrid discretization in a Cartesian domain"/></p><article class="docstring"><header><a class="docstring-binding" id="ClimaCore.Spaces" href="#ClimaCore.Spaces"><code>ClimaCore.Spaces</code></a> — <span class="docstring-category">Module</span></header><section><div><pre><code class="language-julia hljs">Meshes</code></pre><ul><li>domain</li><li>topology</li><li>coordinates</li><li>metric terms (inverse partial derivatives)</li><li>quadrature rules and weights</li></ul><p><strong>References / notes</strong></p><ul><li><a href="https://ceed.exascaleproject.org/ceed-code/">ceed</a></li><li><a href="https://github.com/CliMA/ClimateMachine.jl/blob/ans/sphere/test/Numerics/DGMethods/compressible_navier_stokes_equations/sphere/sphere_helper_functions.jl">QA</a></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/CliMA/ClimaCore.jl/blob/32cddc9bc6cdc98cfe50851494c1259acd0bf375/src/Spaces/Spaces.jl#L1-L14">source</a></section></article><h3 id="Finite-Difference-Spaces"><a class="docs-heading-anchor" href="#Finite-Difference-Spaces">Finite Difference Spaces</a><a id="Finite-Difference-Spaces-1"></a><a class="docs-heading-anchor-permalink" href="#Finite-Difference-Spaces" title="Permalink"></a></h3><p>ClimaCore.jl supports staggered Finite Difference discretizations. Finite Differences discretize an interval domain by approximating the function by a value at either the center of each element (also referred to as <em>cell</em>) (<code>CenterFiniteDifferenceSpace</code>), or the interfaces (faces in 3D, edges in 2D or points in 1D) between elements (<code>FaceFiniteDifferenceSpace</code>).</p><p>Users should construct either the center or face space from the mesh, then construct the other space from the original one: this internally reuses the same data structures, and avoids allocating additional memory.</p><h3 id="Quadratures"><a class="docs-heading-anchor" href="#Quadratures">Quadratures</a><a id="Quadratures-1"></a><a class="docs-heading-anchor-permalink" href="#Quadratures" title="Permalink"></a></h3><article class="docstring"><header><a class="docstring-binding" id="ClimaCore.Spaces.Quadratures.QuadratureStyle" href="#ClimaCore.Spaces.Quadratures.QuadratureStyle"><code>ClimaCore.Spaces.Quadratures.QuadratureStyle</code></a> — <span class="docstring-category">Type</span></header><section><div><p>QuadratureStyle</p><p>Quadrature style supertype. See sub-types:</p><ul><li><a href="#ClimaCore.Spaces.Quadratures.GLL"><code>GLL</code></a></li><li><a href="#ClimaCore.Spaces.Quadratures.GL"><code>GL</code></a></li><li><a href="#ClimaCore.Spaces.Quadratures.Uniform"><code>Uniform</code></a></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/CliMA/ClimaCore.jl/blob/32cddc9bc6cdc98cfe50851494c1259acd0bf375/src/Spaces/quadrature.jl#L11-L18">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="ClimaCore.Spaces.Quadratures.GLL" href="#ClimaCore.Spaces.Quadratures.GLL"><code>ClimaCore.Spaces.Quadratures.GLL</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">GLL{Nq}()</code></pre><p>Gauss-Legendre-Lobatto quadrature using <code>Nq</code> quadrature points.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/CliMA/ClimaCore.jl/blob/32cddc9bc6cdc98cfe50851494c1259acd0bf375/src/Spaces/quadrature.jl#L44-L48">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="ClimaCore.Spaces.Quadratures.GL" href="#ClimaCore.Spaces.Quadratures.GL"><code>ClimaCore.Spaces.Quadratures.GL</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">GL{Nq}()</code></pre><p>Gauss-Legendre quadrature using <code>Nq</code> quadrature points.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/CliMA/ClimaCore.jl/blob/32cddc9bc6cdc98cfe50851494c1259acd0bf375/src/Spaces/quadrature.jl#L59-L63">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="ClimaCore.Spaces.Quadratures.Uniform" href="#ClimaCore.Spaces.Quadratures.Uniform"><code>ClimaCore.Spaces.Quadratures.Uniform</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">Uniform{Nq}()</code></pre><p>Uniformly-spaced quadrature.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/CliMA/ClimaCore.jl/blob/32cddc9bc6cdc98cfe50851494c1259acd0bf375/src/Spaces/quadrature.jl#L74-L78">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="ClimaCore.Spaces.Quadratures.degrees_of_freedom" href="#ClimaCore.Spaces.Quadratures.degrees_of_freedom"><code>ClimaCore.Spaces.Quadratures.degrees_of_freedom</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">degrees_of_freedom(QuadratureStyle) -&gt; Int</code></pre><p>Returns the degrees<em>of</em>freedom of the <code>QuadratureStyle</code> concrete type</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/CliMA/ClimaCore.jl/blob/32cddc9bc6cdc98cfe50851494c1259acd0bf375/src/Spaces/quadrature.jl#L29-L33">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="ClimaCore.Spaces.Quadratures.polynomial_degree" href="#ClimaCore.Spaces.Quadratures.polynomial_degree"><code>ClimaCore.Spaces.Quadratures.polynomial_degree</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">polynomial_degree(QuadratureStyle) -&gt; Int</code></pre><p>Returns the polynomial degree of the <code>QuadratureStyle</code> concrete type</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/CliMA/ClimaCore.jl/blob/32cddc9bc6cdc98cfe50851494c1259acd0bf375/src/Spaces/quadrature.jl#L21-L25">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="ClimaCore.Spaces.Quadratures.quadrature_points" href="#ClimaCore.Spaces.Quadratures.quadrature_points"><code>ClimaCore.Spaces.Quadratures.quadrature_points</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">points, weights = quadrature_points(::Type{FT}, quadrature_style)</code></pre><p>The points and weights of the quadrature rule in floating point type <code>FT</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/CliMA/ClimaCore.jl/blob/32cddc9bc6cdc98cfe50851494c1259acd0bf375/src/Spaces/quadrature.jl#L36-L40">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="ClimaCore.Spaces.Quadratures.barycentric_weights" href="#ClimaCore.Spaces.Quadratures.barycentric_weights"><code>ClimaCore.Spaces.Quadratures.barycentric_weights</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">barycentric_weights(x::SVector{Nq}) where {Nq}</code></pre><p>The barycentric weights associated with the array of point locations <code>x</code>:</p><p class="math-container">\[w_j = \frac{1}{\prod_{k \ne j} (x_i - x_j)}\]</p><p>See <a href="../references/#Berrut2004">Jean-Paul Berrut, Lloyd N Trefethen (2004)</a>, equation 3.2.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/CliMA/ClimaCore.jl/blob/32cddc9bc6cdc98cfe50851494c1259acd0bf375/src/Spaces/quadrature.jl#L114-L124">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="ClimaCore.Spaces.Quadratures.interpolation_matrix" href="#ClimaCore.Spaces.Quadratures.interpolation_matrix"><code>ClimaCore.Spaces.Quadratures.interpolation_matrix</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">interpolation_matrix(x::SVector, r::SVector{Nq})</code></pre><p>The matrix which interpolates the Lagrange polynomial of degree <code>Nq-1</code> through the points <code>r</code>, to points <code>x</code>. The matrix coefficients are computed using the Barycentric formula of <a href="../references/#Berrut2004">Jean-Paul Berrut, Lloyd N Trefethen (2004)</a>, section 4:</p><p class="math-container">\[I_{ij} = \begin{cases}
1 &amp; \text{if } x_i = r_j, \\
0 &amp; \text{if } x_i = r_k \text{ for } k \ne j, \\
\frac{\displaystyle \frac{w_j}{x_i - r_j}}{\displaystyle \sum_k \frac{w_k}{x_i - r_k}} &amp; \text{otherwise,}
\end{cases}\]</p><p>where <span>$w_j$</span> are the barycentric weights, see <a href="#ClimaCore.Spaces.Quadratures.barycentric_weights"><code>barycentric_weights</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/CliMA/ClimaCore.jl/blob/32cddc9bc6cdc98cfe50851494c1259acd0bf375/src/Spaces/quadrature.jl#L143-L157">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="ClimaCore.Spaces.Quadratures.differentiation_matrix" href="#ClimaCore.Spaces.Quadratures.differentiation_matrix"><code>ClimaCore.Spaces.Quadratures.differentiation_matrix</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">differentiation_matrix(r::SVector{Nq, T}) where {Nq, T}</code></pre><p>The spectral differentiation matrix for the Lagrange polynomial of degree <code>Nq-1</code> interpolating at points <code>r</code>.</p><p>The matrix coefficients are computed using the <a href="../references/#Berrut2004">Jean-Paul Berrut, Lloyd N Trefethen (2004)</a>, section 9.3:</p><p class="math-container">\[D_{ij} = \begin{cases}
    \displaystyle
    \frac{w_j}{w_i (x_i - x_j)} &amp;\text{ if } i \ne j \\
    -\sum_{k \ne j} D_{kj} &amp;\text{ if } i = j
\end{cases}\]</p><p>where <span>$w_j$</span> are the barycentric weights, see <a href="#ClimaCore.Spaces.Quadratures.barycentric_weights"><code>barycentric_weights</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/CliMA/ClimaCore.jl/blob/32cddc9bc6cdc98cfe50851494c1259acd0bf375/src/Spaces/quadrature.jl#L231-L246">source</a></section><section><div><pre><code class="nohighlight hljs">differentiation_matrix(FT, quadstyle::QuadratureStyle)</code></pre><p>The spectral differentiation matrix at the quadrature points of <code>quadstyle</code>, using floating point types <code>FT</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/CliMA/ClimaCore.jl/blob/32cddc9bc6cdc98cfe50851494c1259acd0bf375/src/Spaces/quadrature.jl#L266-L271">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="ClimaCore.Spaces.Quadratures.orthonormal_poly" href="#ClimaCore.Spaces.Quadratures.orthonormal_poly"><code>ClimaCore.Spaces.Quadratures.orthonormal_poly</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">V = orthonormal_poly(points, quad)</code></pre><p><code>V_{ij}</code> contains the <code>j-1</code>th Legendre polynomial evaluated at <code>points[i]</code>. i.e. it is the mapping from the modal to the nodal representation.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/CliMA/ClimaCore.jl/blob/32cddc9bc6cdc98cfe50851494c1259acd0bf375/src/Spaces/quadrature.jl#L195-L200">source</a></section></article><h4 id="Internals"><a class="docs-heading-anchor" href="#Internals">Internals</a><a id="Internals-1"></a><a class="docs-heading-anchor-permalink" href="#Internals" title="Permalink"></a></h4><article class="docstring"><header><a class="docstring-binding" id="ClimaCore.Spaces.dss_transform" href="#ClimaCore.Spaces.dss_transform"><code>ClimaCore.Spaces.dss_transform</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">dss_transform(arg, local_geometry, weight, I...)</code></pre><p>Transfrom <code>arg[I...]</code> to a basis for direct stiffness summation (DSS). Transformations only apply to vector quantities.</p><ul><li><code>local_geometry[I...]</code> is the relevant <code>LocalGeometry</code> object. If it is <code>nothing</code>, then no transformation is performed</li><li><code>weight[I...]</code> is the relevant DSS weights. If <code>weight</code> is <code>nothing</code>, then the result is simply summation.</li></ul><p>See <a href="../operators/#ClimaCore.Spaces.weighted_dss!"><code>Spaces.weighted_dss!</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/CliMA/ClimaCore.jl/blob/32cddc9bc6cdc98cfe50851494c1259acd0bf375/src/Spaces/dss.jl#L4-L14">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="ClimaCore.Spaces.dss_untransform" href="#ClimaCore.Spaces.dss_untransform"><code>ClimaCore.Spaces.dss_untransform</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">dss_untransform(T, targ, local_geometry, I...)</code></pre><p>Transform <code>targ[I...]</code> back to a value of type <code>T</code> after performing direct stiffness summation (DSS).</p><p>See <a href="../operators/#ClimaCore.Spaces.weighted_dss!"><code>Spaces.weighted_dss!</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/CliMA/ClimaCore.jl/blob/32cddc9bc6cdc98cfe50851494c1259acd0bf375/src/Spaces/dss.jl#L119-L125">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="ClimaCore.Spaces.dss_interior_faces!" href="#ClimaCore.Spaces.dss_interior_faces!"><code>ClimaCore.Spaces.dss_interior_faces!</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">dss_interior_faces!(topology, data [, local_geometry_data=nothing, local_weights=nothing])</code></pre><p>Perform DSS on the local interior faces of the topology.</p><p>If <code>local_geometry</code> is <code>nothing</code>, no transformations are applied to vectors. If <code>local_weights</code> is <code>nothing</code>, no weighting is applied (i.e. colocated values are summed).</p><p>Part of <a href="../operators/#ClimaCore.Spaces.weighted_dss!"><code>Spaces.weighted_dss!</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/CliMA/ClimaCore.jl/blob/32cddc9bc6cdc98cfe50851494c1259acd0bf375/src/Spaces/dss.jl#L323-L332">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="ClimaCore.Spaces.dss_local_vertices!" href="#ClimaCore.Spaces.dss_local_vertices!"><code>ClimaCore.Spaces.dss_local_vertices!</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">dss_local_vertices!(topology, data[, local_geometry_data=nothing, local_weights=nothing])</code></pre><p>Perform DSS on the local vertices of the topology.</p><p>Part of <a href="../operators/#ClimaCore.Spaces.weighted_dss!"><code>Spaces.weighted_dss!</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/CliMA/ClimaCore.jl/blob/32cddc9bc6cdc98cfe50851494c1259acd0bf375/src/Spaces/dss.jl#L389-L395">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="ClimaCore.Spaces.dss_ghost_faces!" href="#ClimaCore.Spaces.dss_ghost_faces!"><code>ClimaCore.Spaces.dss_ghost_faces!</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">dss_ghost_faces!(topology, data, ghost_data,
    local_geometry_data=nothing, ghost_geometry_data=nothing,
    local_weights=nothing ghost_weights=nothing;
    update_ghost=false)</code></pre><p>Perform DSS on the ghost faces of the topology. <code>ghost_data</code> should contain the ghost element data.</p><p>Part of <a href="../operators/#ClimaCore.Spaces.weighted_dss!"><code>Spaces.weighted_dss!</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/CliMA/ClimaCore.jl/blob/32cddc9bc6cdc98cfe50851494c1259acd0bf375/src/Spaces/dss.jl#L434-L443">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="ClimaCore.Spaces.dss_ghost_vertices!" href="#ClimaCore.Spaces.dss_ghost_vertices!"><code>ClimaCore.Spaces.dss_ghost_vertices!</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">dss_ghost_vertices!(topology, data, ghost_data,
    local_geometry_data=nothing, ghost_geometry_data=nothing,
    local_weights=nothing ghost_weights=nothing;
    update_ghost=false)</code></pre><p>Perform DSS on the ghost faces of the topology. <code>ghost_data</code> should contain the ghost element data.</p><p>Part of <a href="../operators/#ClimaCore.Spaces.weighted_dss!"><code>Spaces.weighted_dss!</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/CliMA/ClimaCore.jl/blob/32cddc9bc6cdc98cfe50851494c1259acd0bf375/src/Spaces/dss.jl#L505-L514">source</a></section></article><h2 id="RecursiveApply"><a class="docs-heading-anchor" href="#RecursiveApply">RecursiveApply</a><a id="RecursiveApply-1"></a><a class="docs-heading-anchor-permalink" href="#RecursiveApply" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-binding" id="ClimaCore.RecursiveApply" href="#ClimaCore.RecursiveApply"><code>ClimaCore.RecursiveApply</code></a> — <span class="docstring-category">Module</span></header><section><div><pre><code class="language-julia hljs">RecursiveApply</code></pre><p>This module contains operators to recurse over nested <code>Tuple</code>s or <code>NamedTuple</code>s.</p><p>To extend to another type <code>T</code>, define <code>RecursiveApply.rmap(fn, args::T...)</code></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/CliMA/ClimaCore.jl/blob/32cddc9bc6cdc98cfe50851494c1259acd0bf375/src/RecursiveApply/RecursiveApply.jl#L1-L7">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="ClimaCore.RecursiveApply.tuplemap" href="#ClimaCore.RecursiveApply.tuplemap"><code>ClimaCore.RecursiveApply.tuplemap</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">tuplemap(fn::Function, tup)</code></pre><p>A <code>map</code> impl for mapping function <code>fn</code> a tuple argument <code>tup</code></p><p>Currently just calls <code>Base.map</code> behind the scenes but is left stubbed out for potential specialization in the future.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/CliMA/ClimaCore.jl/blob/32cddc9bc6cdc98cfe50851494c1259acd0bf375/src/RecursiveApply/RecursiveApply.jl#L12-L19">source</a></section><section><div><pre><code class="nohighlight hljs">tuplemap(fn::Function, tup1, tup2)</code></pre><p>A <code>map</code> impl for mapping function <code>fn</code> over <code>tup1</code>, <code>tup2</code> tuple arguments.</p><p>Currently just calls <code>Base.map</code> behind the scenes but is left stubbed out for potential specialization in the future.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/CliMA/ClimaCore.jl/blob/32cddc9bc6cdc98cfe50851494c1259acd0bf375/src/RecursiveApply/RecursiveApply.jl#L24-L31">source</a></section></article><h2 id="Fields"><a class="docs-heading-anchor" href="#Fields">Fields</a><a id="Fields-1"></a><a class="docs-heading-anchor-permalink" href="#Fields" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-binding" id="ClimaCore.Fields.Field" href="#ClimaCore.Fields.Field"><code>ClimaCore.Fields.Field</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">Field(values, space)</code></pre><p>A set of <code>values</code> defined at each point of a <code>space</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/CliMA/ClimaCore.jl/blob/32cddc9bc6cdc98cfe50851494c1259acd0bf375/src/Fields/Fields.jl#L15-L19">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="ClimaCore.Fields.coordinate_field" href="#ClimaCore.Fields.coordinate_field"><code>ClimaCore.Fields.coordinate_field</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">coordinate_field(space::AbstractSpace)</code></pre><p>Construct a <code>Field</code> of the coordinates of the space.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/CliMA/ClimaCore.jl/blob/32cddc9bc6cdc98cfe50851494c1259acd0bf375/src/Fields/Fields.jl#L238-L242">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="ClimaCore.Fields.local_geometry_field" href="#ClimaCore.Fields.local_geometry_field"><code>ClimaCore.Fields.local_geometry_field</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">local_geometry_field(space::AbstractSpace)</code></pre><p>Construct a <code>Field</code> of the <code>LocalGeometry</code> of the space.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/CliMA/ClimaCore.jl/blob/32cddc9bc6cdc98cfe50851494c1259acd0bf375/src/Fields/Fields.jl#L247-L251">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Base.zeros-Tuple{ClimaCore.Spaces.AbstractSpace}" href="#Base.zeros-Tuple{ClimaCore.Spaces.AbstractSpace}"><code>Base.zeros</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">zeros(space::AbstractSpace)</code></pre><p>Construct a field on <code>space</code> that is zero everywhere.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/CliMA/ClimaCore.jl/blob/32cddc9bc6cdc98cfe50851494c1259acd0bf375/src/Fields/Fields.jl#L204-L208">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Base.ones-Tuple{ClimaCore.Spaces.AbstractSpace}" href="#Base.ones-Tuple{ClimaCore.Spaces.AbstractSpace}"><code>Base.ones</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">ones(space::AbstractSpace)</code></pre><p>Construct a field on <code>space</code> that is one everywhere.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/CliMA/ClimaCore.jl/blob/32cddc9bc6cdc98cfe50851494c1259acd0bf375/src/Fields/Fields.jl#L217-L221">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Base.sum-Tuple{ClimaCore.Fields.Field}" href="#Base.sum-Tuple{ClimaCore.Fields.Field}"><code>Base.sum</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">sum([f=identity,]v::Field)</code></pre><p>Approximate integration of <code>v</code> or <code>f.(v)</code> over the domain. In an <code>AbstractSpectralElementSpace</code>, an integral over the entire space is computed by summation over the elements of the integrand multiplied by the Jacobian determinants and the quadrature weights at each node within an element. Hence, <code>sum</code> is computed by summation of the field values multiplied by the Jacobian determinants and quadrature weights:</p><p class="math-container">\[\sum_i f(v_i) W_i J_i
\approx
\int_\Omega f(v) \, d \Omega\]</p><p>where <span>$v_i$</span> is the value at each node, and <span>$f$</span> is the identity function if not specified.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/CliMA/ClimaCore.jl/blob/32cddc9bc6cdc98cfe50851494c1259acd0bf375/src/Fields/mapreduce.jl#L8-L23">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Statistics.mean-Tuple{ClimaCore.Fields.Field}" href="#Statistics.mean-Tuple{ClimaCore.Fields.Field}"><code>Statistics.mean</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">mean([f=identity, ]v::Field)</code></pre><p>The mean value of <code>field</code> or <code>f.(field)</code> over the domain, weighted by area. Similar to <code>sum</code>, in an <code>AbstractSpectralElementSpace</code>, this is computed by summation of the field values multiplied by the Jacobian determinants and quadrature weights:</p><p class="math-container">\[\frac{\sum_i f(v_i) W_i J_i}{\sum_i W_i J_i}
\approx
\frac{\int_\Omega f(v) \, d \Omega}{\int_\Omega \, d \Omega}\]</p><p>where <span>$v_i$</span> is the Field value at each node, and <span>$f$</span> is the identity function if not specified.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/CliMA/ClimaCore.jl/blob/32cddc9bc6cdc98cfe50851494c1259acd0bf375/src/Fields/mapreduce.jl#L50-L63">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="LinearAlgebra.norm-Tuple{ClimaCore.Fields.Field}" href="#LinearAlgebra.norm-Tuple{ClimaCore.Fields.Field}"><code>LinearAlgebra.norm</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">norm(v::Field, p=2; normalize=true)</code></pre><p>The approximate <span>$L^p$</span> norm of <code>v</code>, where <span>$L^p$</span> represents the space of measurable functions for which the p-th power of the absolute value is Lebesgue integrable, that is:</p><p class="math-container">\[\| v \|_p = \left( \int_\Omega |v|^p d \Omega \right)^{1/p}\]</p><p>where <span>$|v|$</span> is defined to be the absolute value if <span>$v$</span> is a scalar-valued Field, or the 2-norm if it is a vector-valued Field or composite Field (see <a href="https://docs.julialang.org/en/v1/stdlib/LinearAlgebra/#LinearAlgebra.norm">LinearAlgebra.norm</a>). Similar to <code>sum</code> and <code>mean</code>, in an <code>AbstractSpectralElementSpace</code>, this is computed by summation of the field values multiplied by the Jacobian determinants and quadrature weights. If <code>normalize=true</code> (the default), then internally the discrete norm is divided by the sum of the Jacobian determinants and quadrature weights:</p><p class="math-container">\[\left(\frac{\sum_i |v_i|^p W_i J_i}{\sum_i W_i J_i}\right)^{1/p}
\approx
\left(\frac{\int_\Omega |v|^p \, d \Omega}{\int_\Omega \, d \Omega}\right)^{1/p}\]</p><p>If <code>p=Inf</code>, then the norm is the maximum of the absolute values</p><p class="math-container">\[\max_i |v_i| \approx \sup_{\Omega} |v|\]</p><p>Consequently all norms should have the same units for all <span>$p$</span> (being the same as calling <code>norm</code> on a single value).</p><p>If <code>normalize=false</code>, then the denominator term is omitted, and so the result will be the norm as described above multiplied by the length/area/volume of <span>$\Omega$</span> to the power of <span>$1/p$</span>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/CliMA/ClimaCore.jl/blob/32cddc9bc6cdc98cfe50851494c1259acd0bf375/src/Fields/mapreduce.jl#L71-L101">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="ClimaCore.Fields.set!" href="#ClimaCore.Fields.set!"><code>ClimaCore.Fields.set!</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">set!(f::Function, field::Field, args = ())</code></pre><p>Apply function <code>f</code> to populate values in field <code>field</code>. <code>f</code> must have a function signature with signature <code>f(::LocalGeometry[, args...])</code>. Additional arguments may be passed to <code>f</code> with <code>args</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/CliMA/ClimaCore.jl/blob/32cddc9bc6cdc98cfe50851494c1259acd0bf375/src/Fields/Fields.jl#L379-L388">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="ClimaCore.Fields.ColumnIndex" href="#ClimaCore.Fields.ColumnIndex"><code>ClimaCore.Fields.ColumnIndex</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">ColumnIndex(ij,h)</code></pre><p>An index into a column of a field. This can be used as an argument to <code>getindex</code> of a <code>Field</code>, to return a field on that column.</p><p><strong>Example</strong></p><pre><code class="language-julia hljs">colidx = ColumnIndex((1,1),1)
field[colidx]</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/CliMA/ClimaCore.jl/blob/32cddc9bc6cdc98cfe50851494c1259acd0bf375/src/Fields/indices.jl#L1-L12">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="ClimaCore.Fields.bycolumn" href="#ClimaCore.Fields.bycolumn"><code>ClimaCore.Fields.bycolumn</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">Fields.bycolumn(fn, space)</code></pre><p>Call <code>fn(colidx)</code> to every <a href="#ClimaCore.Fields.ColumnIndex"><code>ColumnIndex</code></a> <code>colidx</code> of <code>space</code>. This can be used to apply multiple column-wise operations in a single pass, making use of multiple threads.</p><p><strong>Example</strong></p><pre><code class="language-julia hljs">∇ = GradientF2C()
div = DivergenceC2F()

bycolumn(axes(f)) do colidx
    @. ∇f[colidx] = ∇(f[colidx])
    @. df[colidx] = div(∇f[colidx])
end</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/CliMA/ClimaCore.jl/blob/32cddc9bc6cdc98cfe50851494c1259acd0bf375/src/Fields/indices.jl#L33-L50">source</a></section></article><h2 id="Limiters"><a class="docs-heading-anchor" href="#Limiters">Limiters</a><a id="Limiters-1"></a><a class="docs-heading-anchor-permalink" href="#Limiters" title="Permalink"></a></h2><h3 id="Interfaces-4"><a class="docs-heading-anchor" href="#Interfaces-4">Interfaces</a><a class="docs-heading-anchor-permalink" href="#Interfaces-4" title="Permalink"></a></h3><article class="docstring"><header><a class="docstring-binding" id="ClimaCore.Limiters.QuasiMonotoneLimiter" href="#ClimaCore.Limiters.QuasiMonotoneLimiter"><code>ClimaCore.Limiters.QuasiMonotoneLimiter</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">QuasiMonotoneLimiter</code></pre><p>This limiter is inspired by the one presented in Guba et al <a href="../references/#GubaOpt2014">Oksana Guba, Mark Taylor, Amik St-Cyr (2014)</a>. In the reference paper, it is denoted by OP1, and is outlined in eqs. (37)-(40). Quasimonotone here is meant to be monotone with respect to the spectral element nodal values. This limiter involves solving a constrained optimization problem (a weighted least square problem up to a fixed tolerance) that is completely local to each element.</p><p>As in HOMME, the implementation idea here is the following: we need to find a grid field which is closest to the initial field (in terms of weighted sum), but satisfies the min/max constraints. So, first we find values that do not satisfy constraints and bring these values to a closest constraint. This way we introduce some mass change (<code>mass_change</code>), which we then redistribute so that the l2 error is smallest. This redistribution might violate constraints; thus, we do a few iterations (typically a couple).</p><ul><li><code>ρq</code>: tracer density Field, where <code>q</code> denotes tracer concentration per unit mass. This can be a scalar field, or a struct-valued field.</li><li><code>ρ</code>: fluid density Field (scalar).</li></ul><p><strong>Constructor</strong></p><pre><code class="nohighlight hljs">limiter = QuasiMonotoneLimiter(ρq::Field, ρ::Field)</code></pre><p>Creates a limiter instance for the field <code>ρq</code> and the field <code>ρ</code>.</p><p><strong>Usage</strong></p><p>Call <a href="#ClimaCore.Limiters.compute_bounds!"><code>compute_bounds!</code></a> on the input fields:</p><pre><code class="nohighlight hljs">compute_bounds!(limiter, ρq, ρ)</code></pre><p>Then call <a href="#ClimaCore.Limiters.apply_limiter!"><code>apply_limiter!</code></a> on the output fields:</p><pre><code class="nohighlight hljs">apply_limiter!(ρq, ρ, limiter)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/CliMA/ClimaCore.jl/blob/32cddc9bc6cdc98cfe50851494c1259acd0bf375/src/Limiters/quasimonotone.jl#L1-L38">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="ClimaCore.Limiters.compute_bounds!" href="#ClimaCore.Limiters.compute_bounds!"><code>ClimaCore.Limiters.compute_bounds!</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">compute_bounds!(limiter::QuasiMonotoneLimiter, ρq::Field, ρ::Field)</code></pre><p>Compute the desired bounds for the tracer concentration per unit mass <code>q</code>, based on the tracer density, <code>ρq</code>, and density, <code>ρ</code>, fields.</p><p>This is computed by</p><ol><li><a href="#ClimaCore.Limiters.compute_element_bounds!"><code>compute_element_bounds!</code></a></li><li>starts the ghost exchange (if distributed)</li><li><a href="#ClimaCore.Limiters.compute_neighbor_bounds_local!"><code>compute_neighbor_bounds_local!</code></a></li><li>completes the ghost exchange (if distributed)</li><li><a href="#ClimaCore.Limiters.compute_neighbor_bounds_ghost!"><code>compute_neighbor_bounds_ghost!</code></a> (if distributed)</li></ol></div><a class="docs-sourcelink" target="_blank" href="https://github.com/CliMA/ClimaCore.jl/blob/32cddc9bc6cdc98cfe50851494c1259acd0bf375/src/Limiters/quasimonotone.jl#L190-L202">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="ClimaCore.Limiters.apply_limiter!" href="#ClimaCore.Limiters.apply_limiter!"><code>ClimaCore.Limiters.apply_limiter!</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">apply_limiter!(ρq, ρ, limiter::QuasiMonotoneLimiter)</code></pre><p>Apply the limiter on the tracer density  <code>ρq</code>, using the computed desired bounds on the concentration <code>q</code> and density, <code>ρ</code>, as an optimal weight. This iterates over each element, calling <a href="#ClimaCore.Limiters.apply_limit_slab!"><code>apply_limit_slab!</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/CliMA/ClimaCore.jl/blob/32cddc9bc6cdc98cfe50851494c1259acd0bf375/src/Limiters/quasimonotone.jl#L241-L247">source</a></section></article><h3 id="Internals-2"><a class="docs-heading-anchor" href="#Internals-2">Internals</a><a class="docs-heading-anchor-permalink" href="#Internals-2" title="Permalink"></a></h3><article class="docstring"><header><a class="docstring-binding" id="ClimaCore.Limiters.compute_element_bounds!" href="#ClimaCore.Limiters.compute_element_bounds!"><code>ClimaCore.Limiters.compute_element_bounds!</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">compute_element_bounds!(limiter::QuasiMonotoneLimiter, ρq, ρ)</code></pre><p>Given two fields <code>ρq</code> and <code>ρ</code>, computes the min and max of <code>q</code> in each element, storing it in <code>limiter.q_bounds</code>.</p><p>Part of <a href="#ClimaCore.Limiters.compute_bounds!"><code>compute_bounds!</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/CliMA/ClimaCore.jl/blob/32cddc9bc6cdc98cfe50851494c1259acd0bf375/src/Limiters/quasimonotone.jl#L85-L92">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="ClimaCore.Limiters.compute_neighbor_bounds_local!" href="#ClimaCore.Limiters.compute_neighbor_bounds_local!"><code>ClimaCore.Limiters.compute_neighbor_bounds_local!</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">compute_neighbor_bounds_local!(limiter::QuasiMonotoneLimiter, topology)</code></pre><p>Update the field <code>limiter.q_bounds_nbr</code> based on <code>limiter.q_bounds</code> in the local neighbors.</p><p>Part of <a href="#ClimaCore.Limiters.compute_bounds!"><code>compute_bounds!</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/CliMA/ClimaCore.jl/blob/32cddc9bc6cdc98cfe50851494c1259acd0bf375/src/Limiters/quasimonotone.jl#L121-L128">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="ClimaCore.Limiters.compute_neighbor_bounds_ghost!" href="#ClimaCore.Limiters.compute_neighbor_bounds_ghost!"><code>ClimaCore.Limiters.compute_neighbor_bounds_ghost!</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">compute_neighbor_bounds_ghost!(limiter::QuasiMonotoneLimiter, topology)</code></pre><p>Update the field <code>limiter.q_bounds_nbr</code> based on <code>limiter.q_bounds</code> in the ghost neighbors. This should be called after the ghost exchange has completed.</p><p>Part of <a href="#ClimaCore.Limiters.compute_bounds!"><code>compute_bounds!</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/CliMA/ClimaCore.jl/blob/32cddc9bc6cdc98cfe50851494c1259acd0bf375/src/Limiters/quasimonotone.jl#L154-L161">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="ClimaCore.Limiters.apply_limit_slab!" href="#ClimaCore.Limiters.apply_limit_slab!"><code>ClimaCore.Limiters.apply_limit_slab!</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">apply_limit_slab!(slab_ρq, slab_ρ, slab_wj, slab_q_bounds)</code></pre><p>Apply the computed bounds of the tracer concentration (<code>slab_q_bounds</code>) in the limiter to <code>slab_ρq</code>, given the total mass <code>slab_ρ</code> and weights <code>slab_wj</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/CliMA/ClimaCore.jl/blob/32cddc9bc6cdc98cfe50851494c1259acd0bf375/src/Limiters/quasimonotone.jl#L275-L280">source</a></section></article></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../intro/">« Introduction</a><a class="docs-footer-nextpage" href="../math_framework/">Mathematical Framework »</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 0.27.19 on <span class="colophon-date" title="Tuesday 12 July 2022 16:42">Tuesday 12 July 2022</span>. Using Julia version 1.7.3.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
