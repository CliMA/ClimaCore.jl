<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>MatrixFields · ClimaCore.jl</title><meta name="title" content="MatrixFields · ClimaCore.jl"/><meta property="og:title" content="MatrixFields · ClimaCore.jl"/><meta property="twitter:title" content="MatrixFields · ClimaCore.jl"/><meta name="description" content="Documentation for ClimaCore.jl."/><meta property="og:description" content="Documentation for ClimaCore.jl."/><meta property="twitter:description" content="Documentation for ClimaCore.jl."/><script data-outdated-warner src="../assets/warner.js"></script><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.050/juliamono.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.16.8/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL=".."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../assets/documenter.js"></script><script src="../search_index.js"></script><script src="../siteinfo.js"></script><script src="../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><a class="docs-logo" href="../"><img src="../assets/logo.png" alt="ClimaCore.jl logo"/></a><div class="docs-package-name"><span class="docs-autofit"><a href="../">ClimaCore.jl</a></span></div><button class="docs-search-query input is-rounded is-small is-clickable my-2 mx-auto py-1 px-2" id="documenter-search-query">Search docs (Ctrl + /)</button><ul class="docs-menu"><li><a class="tocitem" href="../">Home</a></li><li><a class="tocitem" href="../intro/">Introduction</a></li><li><a class="tocitem" href="../math_framework/">Mathematical Framework</a></li><li><a class="tocitem" href="../installation_instructions/">Installation and How-to Guides</a></li><li><a class="tocitem" href="../operators/">Operators</a></li><li class="is-active"><a class="tocitem" href>MatrixFields</a><ul class="internal"><li><a class="tocitem" href="#Matrix-Field-Element-Type"><span>Matrix Field Element Type</span></a></li><li><a class="tocitem" href="#Matrix-Field-Multiplication"><span>Matrix Field Multiplication</span></a></li><li><a class="tocitem" href="#Operator-Matrices"><span>Operator Matrices</span></a></li><li class="toplevel"><a class="tocitem" href="#Linear-Solvers"><span>Linear Solvers</span></a></li><li class="toplevel"><a class="tocitem" href="#Preconditioners"><span>Preconditioners</span></a></li><li><a class="tocitem" href="#Internals"><span>Internals</span></a></li><li><a class="tocitem" href="#Utilities"><span>Utilities</span></a></li></ul></li><li><a class="tocitem" href="../api/">API</a></li><li><input class="collapse-toggle" id="menuitem-8" type="checkbox"/><label class="tocitem" for="menuitem-8"><span class="docs-label">Developer docs</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../performance_tips/">Performance tips</a></li></ul></li><li><input class="collapse-toggle" id="menuitem-9" type="checkbox"/><label class="tocitem" for="menuitem-9"><span class="docs-label">Tutorials</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../tutorials/introduction/">Introduction to ClimaCore.jl</a></li></ul></li><li><a class="tocitem" href="../examples/">Examples</a></li><li><input class="collapse-toggle" id="menuitem-11" type="checkbox"/><label class="tocitem" for="menuitem-11"><span class="docs-label">Libraries</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../lib/ClimaCorePlots/">ClimaCorePlots.jl</a></li><li><a class="tocitem" href="../lib/ClimaCoreMakie/">ClimaCoreMakie.jl</a></li><li><a class="tocitem" href="../lib/ClimaCoreVTK/">ClimaCoreVTK.jl</a></li><li><a class="tocitem" href="../lib/ClimaCoreTempestRemap/">ClimaCoreTempestRemap.jl</a></li><li><a class="tocitem" href="../lib/ClimaCoreSpectra/">ClimaCoreSpectra.jl</a></li></ul></li><li><a class="tocitem" href="../Contributing/">Contributing guide</a></li><li><a class="tocitem" href="../code_of_conduct/">Code of Conduct</a></li><li><a class="tocitem" href="../references/">References</a></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><a class="docs-sidebar-button docs-navbar-link fa-solid fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a><nav class="breadcrumb"><ul class="is-hidden-mobile"><li class="is-active"><a href>MatrixFields</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>MatrixFields</a></li></ul></nav><div class="docs-right"><a class="docs-navbar-link" href="https://github.com/CliMA/ClimaCore.jl" title="View the repository on GitHub"><span class="docs-icon fa-brands"></span><span class="docs-label is-hidden-touch">GitHub</span></a><a class="docs-navbar-link" href="https://github.com/CliMA/ClimaCore.jl/blob/main/docs/src/matrix_fields.md" title="Edit source on GitHub"><span class="docs-icon fa-solid"></span></a><a class="docs-settings-button docs-navbar-link fa-solid fa-gear" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-article-toggle-button fa-solid fa-chevron-up" id="documenter-article-toggle-button" href="javascript:;" title="Collapse all docstrings"></a></div></header><article class="content" id="documenter-page"><h1 id="MatrixFields"><a class="docs-heading-anchor" href="#MatrixFields">MatrixFields</a><a id="MatrixFields-1"></a><a class="docs-heading-anchor-permalink" href="#MatrixFields" title="Permalink"></a></h1><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="ClimaCore.MatrixFields" href="#ClimaCore.MatrixFields"><code>ClimaCore.MatrixFields</code></a> — <span class="docstring-category">Module</span></header><section><div><pre><code class="language-julia hljs">MatrixFields</code></pre><p>This module adds support for defining and manipulating <code>Field</code>s that represent matrices. Specifically, it adds the <code>BandMatrixRow</code> type, which can be used to store the entries of a band matrix. A <code>Field</code> of <code>BandMatrixRow</code>s on a <code>FiniteDifferenceSpace</code> can be interpreted as a band matrix by vertically concatenating the <code>BandMatrixRow</code>s. Similarly, a <code>Field</code> of <code>BandMatrixRow</code>s on an <code>ExtrudedFiniteDifferenceSpace</code> can be interpreted as a collection of band matrices, one for each column of the <code>Field</code>. Such <code>Field</code>s are called <code>ColumnwiseBandMatrixField</code>s, and this module adds the following functionality for them:</p><ul><li>Constructors, e.g., <code>matrix_field = @. BidiagonalMatrixRow(field1, field2)</code></li><li>Linear combinations, e.g., <code>@. 3 * matrix_field1 + matrix_field2 / 3</code></li><li>Matrix-vector multiplication, e.g., <code>@. matrix_field ⋅ field</code></li><li>Matrix-matrix multiplication, e.g., <code>@. matrix_field1 ⋅ matrix_field2</code></li><li>Compatibility with <code>LinearAlgebra.I</code>, e.g., <code>@. matrix_field = (4I,)</code> or   <code>@. matrix_field - (4I,)</code></li><li>Integration with <code>RecursiveApply</code>, e.g., the entries of <code>matrix_field</code> can be   <code>Tuple</code>s or <code>NamedTuple</code>s instead of single values, which allows   <code>matrix_field</code> to represent multiple band matrices at the same time</li><li>Integration with <code>Operators</code>, e.g., the <code>matrix_field</code> that gets applied to   the argument of any <code>FiniteDifferenceOperator</code> <code>op</code> can be obtained using   the <code>FiniteDifferenceOperator</code> <code>operator_matrix(op)</code></li><li>Conversions to native array types, e.g., <code>field2arrays(matrix_field)</code> can   convert each column of <code>matrix_field</code> into a <code>BandedMatrix</code> from   <code>BandedMatrices.jl</code></li><li>Custom printing, e.g., <code>matrix_field</code> gets displayed as a <code>BandedMatrix</code>,   specifically, as the <code>BandedMatrix</code> that corresponds to its first column</li></ul><p>This module also adds support for defining and manipulating sparse block matrices of <code>Field</code>s. Specifically, it adds the <code>FieldMatrix</code> type, which is a dictionary that maps pairs of <code>FieldName</code>s to <code>ColumnwiseBandMatrixField</code>s or multiples of <code>LinearAlgebra.I</code>. This comes with the following functionality:</p><ul><li>Addition and subtraction, e.g., <code>@. field_matrix1 + field_matrix2</code></li><li>Matrix-vector multiplication, e.g., <code>@. field_matrix * field_vector</code></li><li>Matrix-matrix multiplication, e.g., <code>@. field_matrix1 * field_matrix2</code></li><li>Integration with <code>RecursiveApply</code>, e.g., the entries of <code>field_matrix</code> can be   specified either as matrix <code>Field</code>s of <code>Tuple</code>s or <code>NamedTuple</code>s, or as   separate matrix <code>Field</code>s of single values</li><li>The ability to solve linear equations using <code>FieldMatrixSolver</code>, which is a   generalization of <code>ldiv!</code> that is designed to optimize solver performance</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/CliMA/ClimaCore.jl/blob/02d4ac9b5b5a734b1d81da96651848e38bc63355/src/MatrixFields/MatrixFields.jl#L1-L43">source</a></section></article><h2 id="Matrix-Field-Element-Type"><a class="docs-heading-anchor" href="#Matrix-Field-Element-Type">Matrix Field Element Type</a><a id="Matrix-Field-Element-Type-1"></a><a class="docs-heading-anchor-permalink" href="#Matrix-Field-Element-Type" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="ClimaCore.MatrixFields.BandMatrixRow" href="#ClimaCore.MatrixFields.BandMatrixRow"><code>ClimaCore.MatrixFields.BandMatrixRow</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">BandMatrixRow{ld}(entries...)</code></pre><p>Stores the nonzero entries in a row of a band matrix, starting with the lowest diagonal, which has index <code>ld</code>. Supported operations include accessing the entry on the diagonal with index <code>d</code> by calling <code>row[d]</code>, taking linear combinations with other band matrix rows (and with <code>LinearAlgebra.I</code>), and checking for equality with other band matrix rows (and with <code>LinearAlgebra.I</code>). There are several aliases for commonly used subtypes of <code>BandMatrixRow</code>:</p><ul><li><code>DiagonalMatrixRow(entry_1)</code></li><li><code>BidiagonalMatrixRow(entry_1, entry_2)</code></li><li><code>TridiagonalMatrixRow(entry_1, entry_2, entry_3)</code></li><li><code>QuaddiagonalMatrixRow(entry_1, entry_2, entry_3, entry_4)</code></li><li><code>PentadiagonalMatrixRow(entry_1, entry_2, entry_3, entry_4, entry_5)</code></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/CliMA/ClimaCore.jl/blob/02d4ac9b5b5a734b1d81da96651848e38bc63355/src/MatrixFields/band_matrix_row.jl#L1-L15">source</a></section></article><h2 id="Matrix-Field-Multiplication"><a class="docs-heading-anchor" href="#Matrix-Field-Multiplication">Matrix Field Multiplication</a><a id="Matrix-Field-Multiplication-1"></a><a class="docs-heading-anchor-permalink" href="#Matrix-Field-Multiplication" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="ClimaCore.MatrixFields.MultiplyColumnwiseBandMatrixField" href="#ClimaCore.MatrixFields.MultiplyColumnwiseBandMatrixField"><code>ClimaCore.MatrixFields.MultiplyColumnwiseBandMatrixField</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">MultiplyColumnwiseBandMatrixField()</code></pre><p>An operator that multiplies a <code>ColumnwiseBandMatrixField</code> by another <code>Field</code>, i.e., matrix-vector or matrix-matrix multiplication. The <code>⋅</code> symbol is an alias for <code>MultiplyColumnwiseBandMatrixField()</code>.</p><p>What follows is a derivation of the algorithm used by this operator with single-column <code>Field</code>s. For <code>Field</code>s on multiple columns, the same computation is done for each column.</p><p>In this derivation, we will use <span>$M_1$</span> and <span>$M_2$</span> to denote two <code>ColumnwiseBandMatrixField</code>s, and we will use <span>$V$</span> to denote a regular (vector-like) <code>Field</code>. For both <span>$M_1$</span> and <span>$M_2$</span>, we will use the array-like index notation <span>$M[row, col]$</span> to denote <span>$M[row][col-row]$</span>, i.e., the entry in the <code>BandMatrixRow</code> <span>$M[row]$</span> located on the diagonal with index <span>$col - row$</span>. We will also use <code>outer_indices</code><span>$($</span><code>space</code><span>$)$</span> to denote the tuple <span>$($</span><code>left_idx</code><span>$($</span><code>space</code><span>$),$</span><code>right_idx</code><span>$($</span><code>space</code><span>$))$</span>.</p><p><strong>1. Matrix-Vector Multiplication</strong></p><p>From the definition of matrix-vector multiplication,</p><p class="math-container">\[(M_1 ⋅ V)[i] = \sum_k M_1[i, k] * V[k].\]</p><p>To establish bounds on the values of <span>$k$</span>, let us define the following values:</p><ul><li><span>$li_1, ri_1 ={}$</span><code>outer_indices</code><span>$($</span><code>column_axes</code><span>$(M_1))$</span></li><li><span>$ld_1, ud_1 ={}$</span><code>outer_diagonals</code><span>$($</span><code>eltype</code><span>$(M_1))$</span></li></ul><p>Since <span>$M_1[i, k]$</span> is only well-defined if <span>$k$</span> is a valid column index and <span>$k - i$</span> is a valid diagonal index, we know that</p><p class="math-container">\[li_1 \leq k \leq ri_1 \quad \text{and} \quad ld_1 \leq k - i \leq ud_1.\]</p><p>Combining these into a single inequality gives us</p><p class="math-container">\[\text{max}(li_1, i + ld_1) \leq k \leq \text{min}(ri_1, i + ud_1).\]</p><p>So, we can rewrite the expression for <span>$(M_1 ⋅ V)[i]$</span> as</p><p class="math-container">\[(M_1 ⋅ V)[i] =
    \sum_{k\ =\ \text{max}(li_1, i + ld_1)}^{\text{min}(ri_1, i + ud_1)}
    M_1[i, k] * V[k].\]</p><p>If we replace the variable <span>$k$</span> with <span>$d = k - i$</span> and switch from array-like indexing to <code>Field</code> indexing, we find that</p><p class="math-container">\[(M_1 ⋅ V)[i] =
    \sum_{d\ =\ \text{max}(li_1 - i, ld_1)}^{\text{min}(ri_1 - i, ud_1)}
    M_1[i][d] * V[i + d].\]</p><p><strong>1.1 Interior vs. Boundary Indices</strong></p><p>Now, suppose that the row index <span>$i$</span> is such that</p><p class="math-container">\[li_1 - ld_1 \leq i \leq ri_1 - ud_1.\]</p><p>If this is the case, then the bounds on <span>$d$</span> can be simplified to</p><p class="math-container">\[\text{max}(li_1 - i, ld_1) = ld_1 \quad \text{and} \quad
\text{min}(ri_1 - i, ud_1) = ud_1.\]</p><p>The expression for <span>$(M_1 ⋅ V)[i]$</span> then becomes</p><p class="math-container">\[(M_1 ⋅ V)[i] = \sum_{d = ld_1}^{ud_1} M_1[i][d] * V[i + d].\]</p><p>The values of <span>$i$</span> in this range are considered to be in the &quot;interior&quot; of the operator, while those not in this range (for which we cannot make the above simplification) are considered to be on the &quot;boundary&quot;.</p><p><strong>2. Matrix-Matrix Multiplication</strong></p><p>From the definition of matrix-matrix multiplication,</p><p class="math-container">\[(M_1 ⋅ M_2)[i, j] = \sum_k M_1[i, k] * M_2[k, j].\]</p><p>To establish bounds on the values of <span>$j$</span> and <span>$k$</span>, let us define the following values:</p><ul><li><span>$li_1, ri_1 ={}$</span><code>outer_indices</code><span>$($</span><code>column_axes</code><span>$(M_1))$</span></li><li><span>$ld_1, ud_1 ={}$</span><code>outer_diagonals</code><span>$($</span><code>eltype</code><span>$(M_1))$</span></li><li><span>$li_2, ri_2 ={}$</span><code>outer_indices</code><span>$($</span><code>column_axes</code><span>$(M_2))$</span></li><li><span>$ld_2, ud_2 ={}$</span><code>outer_diagonals</code><span>$($</span><code>eltype</code><span>$(M_2))$</span></li></ul><p>In addition, let <span>$ld_{prod}$</span> and <span>$ud_{prod}$</span> denote the outer diagonal indices of the product matrix <span>$M_1 ⋅ M_2$</span>. We will derive the values of <span>$ld_{prod}$</span> and <span>$ud_{prod}$</span> in the last section.</p><p>Since <span>$M_1[i, k]$</span> is only well-defined if <span>$k$</span> is a valid column index and <span>$k - i$</span> is a valid diagonal index, we know that</p><p class="math-container">\[li_1 \leq k \leq ri_1 \quad \text{and} \quad ld_1 \leq k - i \leq ud_1.\]</p><p>Since <span>$M_2[k, j]$</span> is only well-defined if <span>$j$</span> is a valid column index and <span>$j - k$</span> is a valid diagonal index, we also know that</p><p class="math-container">\[li_2 \leq j \leq ri_2 \quad \text{and} \quad ld_2 \leq j - k \leq ud_2.\]</p><p>Finally, <span>$(M_1 ⋅ M_2)[i, j]$</span> is only well-defined if <span>$j - i$</span> is a valid diagonal index, so</p><p class="math-container">\[ld_{prod} \leq j - i \leq ud_{prod}.\]</p><p>These inequalities can be combined to obtain</p><p class="math-container">\[\begin{gather*}
\text{max}(li_2, i + ld_{prod}) \leq j \leq
\text{min}(ri_2, i + ud_{prod}) \\
\text{and} \\
\text{max}(li_1, i + ld_1, j - ud_2) \leq k \leq
\text{min}(ri_1, i + ud_1, j - ld_2).
\end{gather*}\]</p><p>So, we can rewrite the expression for <span>$(M_1 ⋅ M_2)[i, j]$</span> as</p><p class="math-container">\[\begin{gather*}
(M_1 ⋅ M_2)[i, j] =
    \sum_{
        k\ =\ \text{max}(li_1, i + ld_1, j - ud_2)
    }^{\text{min}(ri_1, i + ud_1, j - ld_2)}
    M_1[i, k] * M_2[k, j], \text{ where} \\[0.5em]
\text{max}(li_2, i + ld_{prod}) \leq j \leq \text{min}(ri_2, i + ud_{prod}).
\end{gather*}\]</p><p>If we replace the variable <span>$k$</span> with <span>$d = k - i$</span>, replace the variable <span>$j$</span> with <span>$d_{prod} = j - i$</span>, and switch from array-like indexing to <code>Field</code> indexing, we find that</p><p class="math-container">\[\begin{gather*}
(M_1 ⋅ M_2)[i][d_{prod}] =
    \sum_{
        d\ =\ \text{max}(li_1 - i, ld_1, d_{prod} - ud_2)
    }^{\text{min}(ri_1 - i, ud_1, d_{prod} - ld_2)}
    M_1[i][d] * M_2[i + d][d_{prod} - d], \text{ where} \\[0.5em]
\text{max}(li_2 - i, ld_{prod}) \leq d_{prod} \leq
    \text{min}(ri_2 - i, ud_{prod}).
\end{gather*}\]</p><p><strong>2.1 Interior vs. Boundary Indices</strong></p><p>Now, suppose that the row index <span>$i$</span> is such that</p><p class="math-container">\[\text{max}(li_1 - ld_1, li_2 - ld_{prod}) \leq i \leq
    \text{min}(ri_1 - ud_1, ri_2 - ud_{prod}).\]</p><p>If this is the case, then the bounds on <span>$d_{prod}$</span> can be simplified to</p><p class="math-container">\[\text{max}(li_2 - i, ld_{prod}) = ld_{prod} \quad \text{and} \quad
\text{min}(ri_2 - i, ud_{prod}) = ud_{prod}.\]</p><p>Similarly, the bounds on <span>$d$</span> can be simplified using the fact that</p><p class="math-container">\[\text{max}(li_1 - i, ld_1) = ld_1 \quad \text{and} \quad
\text{min}(ri_1 - i, ud_1) = ud_1.\]</p><p>The expression for <span>$(M_1 ⋅ M_2)[i][d_{prod}]$</span> then becomes</p><p class="math-container">\[\begin{gather*}
(M_1 ⋅ M_2)[i][d_{prod}] =
    \sum_{
        d\ =\ \text{max}(ld_1, d_{prod} - ud_2)
    }^{\text{min}(ud_1, d_{prod} - ld_2)}
    M_1[i][d] * M_2[i + d][d_{prod} - d], \text{ where} \\[0.5em]
ld_{prod} \leq d_{prod} \leq ud_{prod}.
\end{gather*}\]</p><p>The values of <span>$i$</span> in this range are considered to be in the &quot;interior&quot; of the operator, while those not in this range (for which we cannot make these simplifications) are considered to be on the &quot;boundary&quot;.</p><p><strong>2.2 <span>$ld_{prod}$</span> and <span>$ud_{prod}$</span></strong></p><p>We only need to compute <span>$(M_1 ⋅ M_2)[i][d_{prod}]$</span> for values of <span>$d_{prod}$</span> that correspond to a nonempty sum in the interior, i.e, those for which</p><p class="math-container">\[\text{max}(ld_1, d_{prod} - ud_2) \leq \text{min}(ud_1, d_{prod} - ld_2).\]</p><p>This can be broken down into the four inequalities</p><p class="math-container">\[ld_1 \leq ud_1, \qquad ld_1 \leq d_{prod} - ld_2, \qquad
d_{prod} - ud_2 \leq ud_1, \quad \text{and} \quad
d_{prod} - ud_2 \leq d_{prod} - ld_2.\]</p><p>By definition, <span>$ld_1 \leq ud_1$</span> and <span>$ld_2 \leq ud_2$</span>, so the first and last inequality are always true. Rearranging the remaining two inequalities tells us that</p><p class="math-container">\[ld_1 + ld_2 \leq d_{prod} \leq ud_1 + ud_2.\]</p><p>In other words, the outer diagonal indices of <span>$M_1 ⋅ M_2$</span> are</p><p class="math-container">\[ld_{prod} = ld_1 + ld_2 \quad \text{and} \quad ud_{prod} = ud_1 + ud_2.\]</p><p>This means that we can express the bounds on the interior values of <span>$i$</span> as</p><p class="math-container">\[\text{max}(li_1, li_2 - ld_2) - ld_1 \leq i \leq
    \text{min}(ri_1, ri_2 - ud_2) - ud_1.\]</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/CliMA/ClimaCore.jl/blob/02d4ac9b5b5a734b1d81da96651848e38bc63355/src/MatrixFields/matrix_multiplication.jl#L1-L200">source</a></section></article><h2 id="Operator-Matrices"><a class="docs-heading-anchor" href="#Operator-Matrices">Operator Matrices</a><a id="Operator-Matrices-1"></a><a class="docs-heading-anchor-permalink" href="#Operator-Matrices" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="ClimaCore.MatrixFields.operator_matrix" href="#ClimaCore.MatrixFields.operator_matrix"><code>ClimaCore.MatrixFields.operator_matrix</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">operator_matrix(op)</code></pre><p>Constructs a new operator (or operator-like object) that generates the matrix applied by <code>op</code> to its final argument. If <code>op_matrix = operator_matrix(op)</code>, we can use the following identities:</p><ul><li>When <code>op</code> takes one argument, <code>@. op(arg) == @. op_matrix() ⋅ arg</code>.</li><li>When <code>op</code> takes multiple arguments,   <code>@. op(args..., arg) == @. op_matrix(args...) ⋅ arg</code>.</li></ul><p>When <code>op</code> takes more than one argument, <code>operator_matrix(op)</code> constructs a <code>FiniteDifferenceOperator</code> that generates the operator matrix. When <code>op</code> only takes one argument, it instead constructs an <code>AbstractLazyOperator</code>, which is internally converted into a <code>FiniteDifferenceOperator</code> when used in a broadcast expression. Implementing <code>op_matrix</code> as a lazy operator allows us to add an argument to the expression <code>op_matrix.()</code>, and we then use this argument to infer the space and element type of the operator matrix.</p><p>As an example, the <code>InterpolateF2C()</code> operator on a space with <span>$n$</span> cell centers applies an <span>$n \times (n + 1)$</span> bidiagonal matrix:</p><p class="math-container">\[\textrm{interp}(arg) = \begin{bmatrix}
    0.5 &amp;     0.5 &amp;       0 &amp; \cdots &amp;       0 &amp;       0 &amp;       0 \\
      0 &amp;     0.5 &amp;     0.5 &amp; \cdots &amp;       0 &amp;       0 &amp;       0 \\
      0 &amp;       0 &amp;     0.5 &amp; \cdots &amp;       0 &amp;       0 &amp;       0 \\
\vdots &amp; \vdots &amp; \vdots &amp; \ddots &amp; \vdots &amp; \vdots &amp; \vdots \\
      0 &amp;       0 &amp;       0 &amp; \cdots &amp;     0.5 &amp;     0.5 &amp;       0 \\
      0 &amp;       0 &amp;       0 &amp; \cdots &amp;       0 &amp;     0.5 &amp;     0.5
\end{bmatrix} ⋅ arg\]</p><p>The <code>GradientF2C()</code> operator applies a similar matrix, but with different entries:</p><p class="math-container">\[\textrm{grad}(arg) = \begin{bmatrix}
-\textbf{e}^3 &amp;  \textbf{e}^3 &amp;              0 &amp; \cdots &amp;              0 &amp;              0 &amp;             0 \\
             0 &amp; -\textbf{e}^3 &amp;  \textbf{e}^3 &amp; \cdots &amp;              0 &amp;              0 &amp;             0 \\
             0 &amp;              0 &amp; -\textbf{e}^3 &amp; \cdots &amp;              0 &amp;              0 &amp;             0 \\
       \vdots &amp;        \vdots &amp;        \vdots &amp; \ddots &amp;        \vdots &amp;        \vdots &amp;       \vdots \\
             0 &amp;              0 &amp;              0 &amp; \cdots &amp; -\textbf{e}^3 &amp;  \textbf{e}^3 &amp;             0 \\
             0 &amp;              0 &amp;              0 &amp; \cdots &amp;              0 &amp; -\textbf{e}^3 &amp; \textbf{e}^3
\end{bmatrix} ⋅ arg\]</p><p>The unit vector <span>$\textbf{e}^3$</span>, which can also be thought of as the differential along the third coordinate axis (<span>$\textrm{d}\xi^3$</span>), is implemented as a <code>Geometry.Covariant3Vector(1)</code>.</p><p>Not all operators have well-defined operator matrices. For example, the operator <code>GradientC2F(; bottom = SetGradient(grad_b), top = SetGradient(grad_t))</code> applies an affine transformation:</p><p class="math-container">\[\textrm{grad}(arg) = \begin{bmatrix}
grad_b \\ 0 \\ 0 \\ \vdots \\ 0 \\ 0 \\ grad_t
\end{bmatrix} + \begin{bmatrix}
             0 &amp;              0 &amp;              0 &amp; \cdots &amp;              0 &amp;             0 \\
-\textbf{e}^3 &amp;  \textbf{e}^3 &amp;              0 &amp; \cdots &amp;              0 &amp;             0 \\
             0 &amp; -\textbf{e}^3 &amp;  \textbf{e}^3 &amp; \cdots &amp;              0 &amp;             0 \\
       \vdots &amp;        \vdots &amp;        \vdots &amp; \ddots &amp;        \vdots &amp;       \vdots \\
             0 &amp;              0 &amp;              0 &amp; \cdots &amp;  \textbf{e}^3 &amp;             0 \\
             0 &amp;              0 &amp;              0 &amp; \cdots &amp; -\textbf{e}^3 &amp; \textbf{e}^3 \\
             0 &amp;              0 &amp;              0 &amp; \cdots &amp;              0 &amp;             0
\end{bmatrix} ⋅ arg\]</p><p>However, this simplifies to a linear transformation when <span>$grad_b$</span> and <span>$grad_t$</span> are both 0:</p><p class="math-container">\[\textrm{grad}(arg) = \begin{bmatrix}
             0 &amp;              0 &amp;              0 &amp; \cdots &amp;              0 &amp;             0 \\
-\textbf{e}^3 &amp;  \textbf{e}^3 &amp;              0 &amp; \cdots &amp;              0 &amp;             0 \\
             0 &amp; -\textbf{e}^3 &amp;  \textbf{e}^3 &amp; \cdots &amp;              0 &amp;             0 \\
       \vdots &amp;        \vdots &amp;        \vdots &amp; \ddots &amp;        \vdots &amp;       \vdots \\
             0 &amp;              0 &amp;              0 &amp; \cdots &amp;  \textbf{e}^3 &amp;             0 \\
             0 &amp;              0 &amp;              0 &amp; \cdots &amp; -\textbf{e}^3 &amp; \textbf{e}^3 \\
             0 &amp;              0 &amp;              0 &amp; \cdots &amp;              0 &amp;             0
\end{bmatrix} ⋅ arg\]</p><p>In general, when <code>op</code> has nonzero boundary conditions that make it apply an affine transformation, <code>operator_matrix(op)</code> will print out a warning and zero out the boundary conditions before computing the operator matrix.</p><p>In addition to affine transformations, there are also some operators that apply nonlinear transformations to their arguments; that is, transformations which cannot be accurately approximated without using more terms of the form</p><p class="math-container">\[\textrm{op}(\textbf{0}) +
\textrm{op}&#39;(\textbf{0}) ⋅ arg +
\textrm{op}&#39;&#39;(\textbf{0}) ⋅ arg ⋅ arg +
\ldots.\]</p><p>When <code>op</code> is such an operator, <code>operator_matrix(op)</code> will throw an error. In the future, we may want to modify <code>operator_matrix(op)</code> so that it will instead return <span>$\textrm{op}&#39;(\textbf{0})$</span>, where <span>$\textbf{0} ={}$</span><code>zero.(arg)</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/CliMA/ClimaCore.jl/blob/02d4ac9b5b5a734b1d81da96651848e38bc63355/src/MatrixFields/operator_matrices.jl#L116-L207">source</a></section></article><h1 id="Linear-Solvers"><a class="docs-heading-anchor" href="#Linear-Solvers">Linear Solvers</a><a id="Linear-Solvers-1"></a><a class="docs-heading-anchor-permalink" href="#Linear-Solvers" title="Permalink"></a></h1><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="ClimaCore.MatrixFields.FieldMatrixSolverAlgorithm" href="#ClimaCore.MatrixFields.FieldMatrixSolverAlgorithm"><code>ClimaCore.MatrixFields.FieldMatrixSolverAlgorithm</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">FieldMatrixSolverAlgorithm</code></pre><p>Description of how to solve an equation of the form <code>A * x = b</code> for <code>x</code>, where <code>A</code> is a <code>FieldMatrix</code> and where <code>x</code> and <code>b</code> are both <code>FieldVector</code>s. Different algorithms can be nested inside each other, enabling the construction of specialized linear solvers that fully utilize the sparsity pattern of <code>A</code>.</p><p><strong>Interface</strong></p><p>Every subtype of <code>FieldMatrixSolverAlgorithm</code> must implement methods for the following functions:</p><ul><li><a href="#ClimaCore.MatrixFields.field_matrix_solver_cache"><code>field_matrix_solver_cache</code></a></li><li><a href="#ClimaCore.MatrixFields.check_field_matrix_solver"><code>check_field_matrix_solver</code></a></li><li><a href="#ClimaCore.MatrixFields.run_field_matrix_solver!"><code>run_field_matrix_solver!</code></a></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/CliMA/ClimaCore.jl/blob/02d4ac9b5b5a734b1d81da96651848e38bc63355/src/MatrixFields/field_matrix_solver.jl#L1-L16">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="ClimaCore.MatrixFields.FieldMatrixSolver" href="#ClimaCore.MatrixFields.FieldMatrixSolver"><code>ClimaCore.MatrixFields.FieldMatrixSolver</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">FieldMatrixSolver(alg, A, b)</code></pre><p>Combination of a <code>FieldMatrixSolverAlgorithm</code> <code>alg</code> and the cache it requires to solve the equation <code>A * x = b</code> for <code>x</code>. The values of <code>A</code> and <code>b</code> that get passed to this constructor should be <code>similar</code> to the ones that get passed to <code>field_matrix_solve!</code> in order to ensure that the cache gets allocated correctly.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/CliMA/ClimaCore.jl/blob/02d4ac9b5b5a734b1d81da96651848e38bc63355/src/MatrixFields/field_matrix_solver.jl#L44-L52">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="ClimaCore.MatrixFields.field_matrix_solve!" href="#ClimaCore.MatrixFields.field_matrix_solve!"><code>ClimaCore.MatrixFields.field_matrix_solve!</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">field_matrix_solve!(solver, x, A, b)</code></pre><p>Solves the equation <code>A * x = b</code> for <code>x</code> using the <code>FieldMatrixSolver</code> <code>solver</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/CliMA/ClimaCore.jl/blob/02d4ac9b5b5a734b1d81da96651848e38bc63355/src/MatrixFields/field_matrix_solver.jl#L69-L73">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="ClimaCore.MatrixFields.BlockDiagonalSolve" href="#ClimaCore.MatrixFields.BlockDiagonalSolve"><code>ClimaCore.MatrixFields.BlockDiagonalSolve</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">BlockDiagonalSolve()</code></pre><p>A <code>FieldMatrixSolverAlgorithm</code> for a block diagonal matrix:</p><p class="math-container">\[A = \begin{bmatrix}
     A_{11} &amp; \mathbf{0} &amp; \mathbf{0} &amp; \cdots &amp; \mathbf{0} \\
\mathbf{0} &amp;      A_{22} &amp; \mathbf{0} &amp; \cdots &amp; \mathbf{0} \\
\mathbf{0} &amp; \mathbf{0} &amp;      A_{33} &amp; \cdots &amp; \mathbf{0} \\
    \vdots &amp;     \vdots &amp;     \vdots &amp; \ddots &amp;     \vdots \\
\mathbf{0} &amp; \mathbf{0} &amp; \mathbf{0} &amp; \cdots &amp;      A_{NN}
\end{bmatrix}\]</p><p>This algorithm solves the <code>N</code> block equations <code>Aₙₙ * xₙ = bₙ</code> in sequence (though we might want to parallelize it in the future).</p><p>If <code>Aₙₙ</code> is a diagonal matrix, the equation <code>Aₙₙ * xₙ = bₙ</code> is solved by making a single pass over the data, setting each <code>xₙ[i]</code> to <code>inv(Aₙₙ[i, i]) * bₙ[i]</code>.</p><p>Otherwise, the equation <code>Aₙₙ * xₙ = bₙ</code> is solved using Gaussian elimination (without pivoting), which makes two passes over the data. This is currently only implemented for tri-diagonal and penta-diagonal matrices <code>Aₙₙ</code>. In Gaussian elimination, <code>Aₙₙ</code> is effectively factorized into the product <code>Lₙ * Dₙ * Uₙ</code>, where <code>Dₙ</code> is a diagonal matrix, and where <code>Lₙ</code> and <code>Uₙ</code> are unit lower and upper triangular matrices, respectively. The first pass multiplies both sides of the equation by <code>inv(Lₙ * Dₙ)</code>, replacing <code>Aₙₙ</code> with <code>Uₙ</code> and <code>bₙ</code> with <code>Uₙxₙ</code>, which is referred to as putting <code>Aₙₙ</code> into &quot;reduced row echelon form&quot;. The second pass solves <code>Uₙ * xₙ = Uₙxₙ</code> for <code>xₙ</code> with a unit upper triangular matrix solver, which is referred to as &quot;back substitution&quot;. These operations can become numerically unstable when <code>Aₙₙ</code> has entries with large disparities in magnitude, but avoiding this would require swapping the rows of <code>Aₙₙ</code> (i.e., replacing <code>Dₙ</code> with a partial pivoting matrix).</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/CliMA/ClimaCore.jl/blob/02d4ac9b5b5a734b1d81da96651848e38bc63355/src/MatrixFields/field_matrix_solver.jl#L197-L229">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="ClimaCore.MatrixFields.BlockLowerTriangularSolve" href="#ClimaCore.MatrixFields.BlockLowerTriangularSolve"><code>ClimaCore.MatrixFields.BlockLowerTriangularSolve</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">BlockLowerTriangularSolve(names₁...; [alg₁], [alg₂])</code></pre><p>A <code>FieldMatrixSolverAlgorithm</code> for a 2×2 block lower triangular matrix:</p><p class="math-container">\[A = \begin{bmatrix} A_{11} &amp; \mathbf{0} \\ A_{21} &amp; A_{22} \end{bmatrix}\]</p><p>The <code>FieldName</code>s in <code>names₁</code> correspond to the subscript <code>₁</code>, while all other <code>FieldName</code>s correspond to the subscript <code>₂</code>. This algorithm has 2 steps:</p><ol><li>Solve <code>A₁₁ * x₁ = b₁</code> for <code>x₁</code> using the algorithm <code>alg₁</code>, which is set to a <a href="#ClimaCore.MatrixFields.BlockDiagonalSolve"><code>BlockDiagonalSolve</code></a> by default.</li><li>Solve <code>A₂₂ * x₂ = b₂ - A₂₁ * x₁</code> for <code>x₂</code> using the algorithm <code>alg₂</code>, which is also set to a <code>BlockDiagonalSolve</code> by default.</li></ol></div><a class="docs-sourcelink" target="_blank" href="https://github.com/CliMA/ClimaCore.jl/blob/02d4ac9b5b5a734b1d81da96651848e38bc63355/src/MatrixFields/field_matrix_solver.jl#L255-L268">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="ClimaCore.MatrixFields.BlockArrowheadSolve" href="#ClimaCore.MatrixFields.BlockArrowheadSolve"><code>ClimaCore.MatrixFields.BlockArrowheadSolve</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">BlockArrowheadSolve(names₁...; [alg₂])</code></pre><p>A <code>FieldMatrixSolverAlgorithm</code> for a 2×2 block arrowhead matrix:</p><p class="math-container">\[A = \begin{bmatrix} A_{11} &amp; A_{12} \\ A_{21} &amp; A_{22} \end{bmatrix}, \quad
\text{where } A_{11} \text{ is a diagonal matrix}\]</p><p>The <code>FieldName</code>s in <code>names₁</code> correspond to the subscript <code>₁</code>, while all other <code>FieldName</code>s correspond to the subscript <code>₂</code>. This algorithm has only 1 step:</p><ol><li>Solve <code>(A₂₂ - A₂₁ * inv(A₁₁) * A₁₂) * x₂ = b₂ - A₂₁ * inv(A₁₁) * b₁</code> for <code>x₂</code> using the algorithm <code>alg₂</code>, which is set to a <a href="#ClimaCore.MatrixFields.BlockDiagonalSolve"><code>BlockDiagonalSolve</code></a> by default, and set <code>x₁</code> to <code>inv(A₁₁) * (b₁ - A₁₂ * x₂)</code>.</li></ol><p>Since <code>A₁₁</code> is a diagonal matrix, <code>inv(A₁₁)</code> is easy to compute, which means that the Schur complement of <code>A₁₁</code> in <code>A</code>, <code>A₂₂ - A₂₁ * inv(A₁₁) * A₁₂</code>, as well as the vectors <code>b₂ - A₂₁ * inv(A₁₁) * b₁</code> and <code>inv(A₁₁) * (b₁ - A₁₂ * x₂)</code>, are also easy to compute.</p><p>This algorithm is equivalent to block Gaussian elimination with all operations inlined into a single step.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/CliMA/ClimaCore.jl/blob/02d4ac9b5b5a734b1d81da96651848e38bc63355/src/MatrixFields/field_matrix_solver.jl#L315-L336">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="ClimaCore.MatrixFields.SchurComplementReductionSolve" href="#ClimaCore.MatrixFields.SchurComplementReductionSolve"><code>ClimaCore.MatrixFields.SchurComplementReductionSolve</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">SchurComplementReductionSolve(names₁...; [alg₁], alg₂)</code></pre><p>A <code>FieldMatrixSolverAlgorithm</code> for any 2×2 block matrix:</p><p class="math-container">\[A = \begin{bmatrix} A_{11} &amp; A_{12} \\ A_{21} &amp; A_{22} \end{bmatrix}\]</p><p>The <code>FieldName</code>s in <code>names₁</code> correspond to the subscript <code>₁</code>, while all other <code>FieldName</code>s correspond to the subscript <code>₂</code>. This algorithm has 3 steps:</p><ol><li>Solve <code>A₁₁ * x₁′ = b₁</code> for <code>x₁′</code> using the algorithm <code>alg₁</code>, which is set to a <a href="#ClimaCore.MatrixFields.BlockDiagonalSolve"><code>BlockDiagonalSolve</code></a> by default.</li><li>Solve <code>(A₂₂ - A₂₁ * inv(A₁₁) * A₁₂) * x₂ = b₂ - A₂₁ * x₁′</code> for <code>x₂</code> using the algorithm <code>alg₂</code>.</li><li>Solve <code>A₁₁ * x₁ = b₁ - A₁₂ * x₂</code> for <code>x₁</code> using the algorithm <code>alg₁</code>.</li></ol><p>Since <code>A₁₁</code> is not necessarily a diagonal matrix, <code>inv(A₁₁)</code> will generally be a dense matrix, which means that the Schur complement of <code>A₁₁</code> in <code>A</code>, <code>A₂₂ - A₂₁ * inv(A₁₁) * A₁₂</code>, cannot be computed efficiently. So, <code>alg₂</code> must be set to a <code>LazyFieldMatrixSolverAlgorithm</code>, which can evaluate the matrix-vector product <code>(A₂₂ - A₂₁ * inv(A₁₁) * A₁₂) * x₂</code> without actually computing the Schur complement matrix. This involves representing the Schur complement matrix by a <a href="#ClimaCore.MatrixFields.LazySchurComplement"><code>LazySchurComplement</code></a>, which uses <code>alg₁</code> to invert <code>A₁₁</code> when computing the matrix-vector product.</p><p>This algorithm is equivalent to block Gaussian elimination, where steps 1 and 2 put <code>A</code> into reduced row echelon form, and step 3 performs back substitution. For more information on this algorithm, see Section 5 of <a href="../references/#Benzi2005">Numerical solution of saddle point problems</a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/CliMA/ClimaCore.jl/blob/02d4ac9b5b5a734b1d81da96651848e38bc63355/src/MatrixFields/field_matrix_solver.jl#L370-L398">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="ClimaCore.MatrixFields.LazyFieldMatrixSolverAlgorithm" href="#ClimaCore.MatrixFields.LazyFieldMatrixSolverAlgorithm"><code>ClimaCore.MatrixFields.LazyFieldMatrixSolverAlgorithm</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">LazyFieldMatrixSolverAlgorithm</code></pre><p>A <code>FieldMatrixSolverAlgorithm</code> that does not require <code>A</code> to be a <code>FieldMatrix</code>, i.e., a &quot;matrix-free&quot; algorithm. Internally, a <code>FieldMatrixSolverAlgorithm</code> (for example, <a href="#ClimaCore.MatrixFields.SchurComplementReductionSolve"><code>SchurComplementReductionSolve</code></a>) might run a <code>LazyFieldMatrixSolverAlgorithm</code> on a &quot;lazy&quot; representation of a <code>FieldMatrix</code> (like a <a href="#ClimaCore.MatrixFields.LazySchurComplement"><code>LazySchurComplement</code></a>).</p><p>The only operations used by a <code>LazyFieldMatrixSolverAlgorithm</code> that depend on <code>A</code> are <a href="#ClimaCore.MatrixFields.lazy_mul"><code>lazy_mul</code></a> and, when required, <a href="#ClimaCore.MatrixFields.lazy_preconditioner"><code>lazy_preconditioner</code></a>. These and other lazy operations are used to minimize the number of calls to <code>Base.materialize!</code>, since each call comes with a small performance penalty.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/CliMA/ClimaCore.jl/blob/02d4ac9b5b5a734b1d81da96651848e38bc63355/src/MatrixFields/field_matrix_solver.jl#L179-L192">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="ClimaCore.MatrixFields.StationaryIterativeSolve" href="#ClimaCore.MatrixFields.StationaryIterativeSolve"><code>ClimaCore.MatrixFields.StationaryIterativeSolve</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">StationaryIterativeSolve(; [kwargs...])</code></pre><p>A <code>LazyFieldMatrixSolverAlgorithm</code> that solves <code>A * x = b</code> by setting <code>x</code> to some initial value <code>x[0]</code> (usually just the zero vector, <span>$\mathbf{0}$</span>) and then iteratively updating it to</p><p class="math-container">\[x[n] = x[n - 1] + \textrm{inv}(P) * (b - A * x[n - 1]).\]</p><p>The matrix <code>P</code> is called a &quot;left preconditioner&quot; for <code>A</code>. In general, this algorithm converges more quickly when <code>P</code> is a close approximation of <code>A</code>, although more complicated approximations often come with a performance penalty.</p><p><strong>Background</strong></p><p>Let <code>x&#39;</code> denote the value of <code>x</code> for which <code>A * x = b</code>. Replacing <code>b</code> with <code>A * x&#39;</code> in the formula for <code>x[n]</code> tells us that</p><p class="math-container">\[x[n] = x&#39; + (I - \textrm{inv}(P) * A) * (x[n - 1] - x&#39;).\]</p><p>In other words, the error on iteration <code>n</code>, <code>x[n] - x&#39;</code>, can be expressed in terms of the error on the previous iteration, <code>x[n - 1] - x&#39;</code>, as</p><p class="math-container">\[x[n] - x&#39; = (I - \textrm{inv}(P) * A) * (x[n - 1] - x&#39;).\]</p><p>By induction, this means that the error on iteration <code>n</code> is</p><p class="math-container">\[x[n] - x&#39; = (I - \textrm{inv}(P) * A)^n * (x[0] - x&#39;).\]</p><p>If we pick some norm <span>$||\cdot||$</span>, we find that the norm of the error is bounded by</p><p class="math-container">\[||x[n] - x&#39;|| ≤ ||(I - \textrm{inv}(P) * A)^n|| * ||x[0] - x&#39;||.\]</p><p>For any matrix <span>$M$</span>, the spectral radius of <span>$M$</span> is defined as</p><p class="math-container">\[\rho(M) = \max\{|λ| : λ \text{ is an eigenvalue of } M\}.\]</p><p>The spectral radius has the property that</p><p class="math-container">\[||M^n|| \sim \rho(M)^n, \quad \text{i.e.,} \quad
\lim_{n \to \infty} \frac{||M^n||}{\rho(M)^n} = 1.\]</p><p>So, as the value of <code>n</code> increases, the norm of the error becomes bounded by</p><p class="math-container">\[||x[n] - x&#39;|| \leq \rho(I - \textrm{inv}(P) * A)^n * ||x[0] - x&#39;||.\]</p><p>This indicates that <code>x[n]</code> will converge to <code>x&#39;</code> (i.e., that the norm of the error will converge to 0) when <code>ρ(I - inv(P) * A) &lt; 1</code>, and that the convergence rate is roughly bounded by <code>ρ(I - inv(P) * A)</code> for large values of <code>n</code>. More precisely, it can be shown that <code>x[n]</code> will converge to <code>x&#39;</code> if and only if <code>ρ(I - inv(P) * A) &lt; 1</code>. In practice, though, the convergence eventually stops due to the limits of floating point precision.</p><p>Also, if we assume that <code>x[n] ≈ x&#39;</code>, we can use the formula for <code>x[n]</code> to approximate the error on the previous iteration as</p><p class="math-container">\[x[n - 1] - x&#39; ≈ x[n - 1] - x[n] = \textrm{inv}(P) * (A * x[n - 1] - b).\]</p><p><strong>Debugging</strong></p><p>This algorithm has support for 2 debugging message group names, which can be passed to the environment variable <code>JULIA_DEBUG</code>:</p><ul><li><code>error_norm</code>: prints <code>||x[n] - x&#39;||₂</code> on every iteration, approximating the error <code>x[n] - x&#39;</code> as described above</li><li><code>spectral_radius</code>: prints <code>ρ(I - inv(P) * A)</code>, approximating this value with the <code>eigsolve</code> function from KrylovKit.jl</li></ul><p>Because the <code>eigsolve</code> function is not compatible with CUDA, debugging the spectral radius is currently not possible on GPUs.</p><p><strong>Keyword Arguments</strong></p><p>There are 4 values that can be included in <code>kwargs...</code>:</p><ul><li><code>P_alg = nothing</code>: a <code>PreconditionerAlgorithm</code> that specifies how to compute <code>P</code> and solve <code>P * x = b</code> for <code>x</code>, or <code>nothing</code> if preconditioning is not required (in which case <code>P</code> is effectively set to <code>one(A)</code>)</li><li><code>n_iters = 1</code>: the number of iterations</li><li><code>correlated_solves = false</code>: whether to set <code>x[0]</code> to a value of <code>x</code> that was generated during an earlier call to <code>field_matrix_solve!</code>, instead of setting it to <span>$\mathbf{0}$</span> (it is always set to <span>$\mathbf{0}$</span> on the first call to <code>field_matrix_solve!</code>)</li><li><code>eigsolve_kwargs = (;)</code>: keyword arguments for the <code>eigsolve</code> function that can be used to tune its accuracy and speed (only applicable when debugging the spectral radius)</li><li><code>debug = nothing</code>: keyword argument for printing debug information to <code>@debug</code>. By default, <code>debug</code> is set to true if <code>&quot;error_norm&quot;</code> or <code>&quot;spectral_radius&quot;</code> is in <code>ENV[&quot;JULIA_DEBUG&quot;]</code>, which must be set by users.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/CliMA/ClimaCore.jl/blob/02d4ac9b5b5a734b1d81da96651848e38bc63355/src/MatrixFields/field_matrix_iterative_solver.jl#L281-L370">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="ClimaCore.MatrixFields.ApproximateBlockArrowheadIterativeSolve" href="#ClimaCore.MatrixFields.ApproximateBlockArrowheadIterativeSolve"><code>ClimaCore.MatrixFields.ApproximateBlockArrowheadIterativeSolve</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">ApproximateBlockArrowheadIterativeSolve(names₁...; [P_alg₁], [alg₁], [alg₂], [kwargs...])</code></pre><p>Shorthand for constructing a <a href="#ClimaCore.MatrixFields.SchurComplementReductionSolve"><code>SchurComplementReductionSolve</code></a> whose <code>alg₂</code> is set to a <a href="#ClimaCore.MatrixFields.StationaryIterativeSolve"><code>StationaryIterativeSolve</code></a> with a <a href="#ClimaCore.MatrixFields.BlockArrowheadSchurComplementPreconditioner"><code>BlockArrowheadSchurComplementPreconditioner</code></a>. The keyword argument <code>alg₁</code> is passed to the constructor for <code>SchurComplementReductionSolve</code>, the keyword arguments <code>P_alg₁</code> and <code>alg₂</code> are passed to the constructor for <code>BlockArrowheadSchurComplementPreconditioner</code>, and all other keyword arguments are passed to the constructor for <code>StationaryIterativeSolve</code>.</p><p>This algorithm is somewhat similar to a <code>StationaryIterativeSolve</code> with a <a href="#ClimaCore.MatrixFields.BlockArrowheadPreconditioner"><code>BlockArrowheadPreconditioner</code></a>, but it usually converges much more quickly, i.e., the spectral radius of its iteration matrix (<code>I - inv(P) * A</code>) tends to be significantly smaller. Roughly speaking, this is because it runs the iterative solver on an equation with fewer variables (the Schur complement equation, <code>(A₂₂ - A₂₁ * inv(A₁₁) * A₁₂) * x₂ = b₂′</code>), which means that, on each iteration, it accumulates less error due to coupling between variables. However, even though it converges more quickly, its iterations take longer because they involve using <code>alg₁</code> to invert <code>A₁₁</code>. So, when only a few iterations are needed, a <code>StationaryIterativeSolve</code> with a <code>BlockArrowheadPreconditioner</code> might be more performant.</p><p>This algorithm is an example of a &quot;segregated&quot; solve, in contrast to the alternative &quot;coupled&quot; solve. In the context of computational fluid dynamics, this algorithm can also be viewed as a &quot;SIMPLE&quot; (Semi-Implicit Method for Pressure-Linked Equations) scheme.  For more information, see Sections 4, 5, and 10 of <a href="../references/#Benzi2005">Numerical solution of saddle point problems</a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/CliMA/ClimaCore.jl/blob/02d4ac9b5b5a734b1d81da96651848e38bc63355/src/MatrixFields/field_matrix_iterative_solver.jl#L485-L513">source</a></section></article><h1 id="Preconditioners"><a class="docs-heading-anchor" href="#Preconditioners">Preconditioners</a><a id="Preconditioners-1"></a><a class="docs-heading-anchor-permalink" href="#Preconditioners" title="Permalink"></a></h1><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="ClimaCore.MatrixFields.PreconditionerAlgorithm" href="#ClimaCore.MatrixFields.PreconditionerAlgorithm"><code>ClimaCore.MatrixFields.PreconditionerAlgorithm</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">PreconditionerAlgorithm</code></pre><p>Description of how to approximate a <code>FieldMatrix</code> or something similar like a <a href="#ClimaCore.MatrixFields.LazySchurComplement"><code>LazySchurComplement</code></a> with a preconditioner <code>P</code> for which <code>P * x = b</code> is easy to solve for <code>x</code>. If <code>P</code> is a diagonal matrix, then <code>x</code> can be computed as <code>@. inv(P) * b</code>; otherwise, the <code>PreconditionerAlgorithm</code> must specify a <code>FieldMatrixSolverAlgorithm</code> that can be used to solve <code>P * x = b</code> for <code>x</code>.</p><p><strong>Interface</strong></p><p>Every subtype of <code>PreconditionerAlgorithm</code> must implement methods for the following functions:</p><ul><li><a href="#ClimaCore.MatrixFields.solver_algorithm"><code>solver_algorithm</code></a></li><li><a href="#ClimaCore.MatrixFields.lazy_preconditioner"><code>lazy_preconditioner</code></a></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/CliMA/ClimaCore.jl/blob/02d4ac9b5b5a734b1d81da96651848e38bc63355/src/MatrixFields/field_matrix_iterative_solver.jl#L3-L18">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="ClimaCore.MatrixFields.MainDiagonalPreconditioner" href="#ClimaCore.MatrixFields.MainDiagonalPreconditioner"><code>ClimaCore.MatrixFields.MainDiagonalPreconditioner</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">MainDiagonalPreconditioner()</code></pre><p>A <code>PreconditionerAlgorithm</code> that sets <code>P</code> to the main diagonal of <code>A</code>. This is also called a &quot;Jacobi&quot; preconditioner.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/CliMA/ClimaCore.jl/blob/02d4ac9b5b5a734b1d81da96651848e38bc63355/src/MatrixFields/field_matrix_iterative_solver.jl#L112-L117">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="ClimaCore.MatrixFields.BlockDiagonalPreconditioner" href="#ClimaCore.MatrixFields.BlockDiagonalPreconditioner"><code>ClimaCore.MatrixFields.BlockDiagonalPreconditioner</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">BlockDiagonalPreconditioner()</code></pre><p>A <code>PreconditionerAlgorithm</code> that sets <code>P</code> to the block diagonal entries of <code>A</code>. This is also called a &quot;block Jacobi&quot; preconditioner.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/CliMA/ClimaCore.jl/blob/02d4ac9b5b5a734b1d81da96651848e38bc63355/src/MatrixFields/field_matrix_iterative_solver.jl#L124-L129">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="ClimaCore.MatrixFields.BlockArrowheadPreconditioner" href="#ClimaCore.MatrixFields.BlockArrowheadPreconditioner"><code>ClimaCore.MatrixFields.BlockArrowheadPreconditioner</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">BlockArrowheadPreconditioner(names₁...; [P_alg₁], [alg₂])</code></pre><p>A <code>PreconditionerAlgorithm</code> for a 2×2 block matrix:</p><p class="math-container">\[A = \begin{bmatrix} A_{11} &amp; A_{12} \\ A_{21} &amp; A_{22} \end{bmatrix}\]</p><p>The <code>FieldName</code>s in <code>names₁</code> correspond to the subscript <code>₁</code>, while all other <code>FieldName</code>s correspond to the subscript <code>₂</code>. The preconditioner <code>P</code> is set to the following matrix:</p><p class="math-container">\[P = \begin{bmatrix} P_{11} &amp; A_{12} \\ A_{21} &amp; A_{22} \end{bmatrix}, \quad
\text{where } P_{11} \text{ is a diagonal matrix}\]</p><p>The internal preconditioner <code>P₁₁</code> is generated by the <code>PreconditionerAlgorithm</code> <code>P_alg₁</code>, which is set to a <a href="#ClimaCore.MatrixFields.MainDiagonalPreconditioner"><code>MainDiagonalPreconditioner</code></a> by default. The Schur complement of <code>P₁₁</code> in <code>P</code>, <code>A₂₂ - A₂₁ * inv(P₁₁) * A₁₂</code>, is inverted using the <code>FieldMatrixSolverAlgorithm</code> <code>alg₂</code>, which is set to a <a href="#ClimaCore.MatrixFields.BlockDiagonalSolve"><code>BlockDiagonalSolve</code></a> by default.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/CliMA/ClimaCore.jl/blob/02d4ac9b5b5a734b1d81da96651848e38bc63355/src/MatrixFields/field_matrix_iterative_solver.jl#L136-L155">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="ClimaCore.MatrixFields.BlockArrowheadSchurComplementPreconditioner" href="#ClimaCore.MatrixFields.BlockArrowheadSchurComplementPreconditioner"><code>ClimaCore.MatrixFields.BlockArrowheadSchurComplementPreconditioner</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">BlockArrowheadSchurComplementPreconditioner(; [P_alg₁], [alg₂])</code></pre><p>A <code>PreconditionerAlgorithm</code> that is equivalent to a <a href="#ClimaCore.MatrixFields.BlockArrowheadPreconditioner"><code>BlockArrowheadPreconditioner</code></a>, but only applied to the Schur complement of <code>A₁₁</code> in <code>A</code>, <code>A₂₂ - A₂₁ * inv(A₁₁) * A₁₂</code>, which is represented by a <a href="#ClimaCore.MatrixFields.LazySchurComplement"><code>LazySchurComplement</code></a>. Specifically, the preconditioner this generates is the Schur complement of <code>P₁₁</code> in <code>P</code>, <code>A₂₂ - A₂₁ * inv(P₁₁) * A₁₂</code>, where <code>P₁₁</code> is generated by <code>P_alg₁</code>. Unlike the <code>BlockArrowheadPreconditioner</code> constructor, this constructor does not require <code>names₁</code> because the block structure of <code>A</code> can be inferred from the <code>LazySchurComplement</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/CliMA/ClimaCore.jl/blob/02d4ac9b5b5a734b1d81da96651848e38bc63355/src/MatrixFields/field_matrix_iterative_solver.jl#L187-L198">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="ClimaCore.MatrixFields.WeightedPreconditioner" href="#ClimaCore.MatrixFields.WeightedPreconditioner"><code>ClimaCore.MatrixFields.WeightedPreconditioner</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">WeightedPreconditioner(M, unweighted_P_alg)</code></pre><p>A <code>PreconditionerAlgorithm</code> that sets <code>P</code> to <code>M * P′</code>, where <code>M</code> is a diagonal <code>FieldMatrix</code> and <code>P′</code> is the preconditioner generated by <code>unweighted_P_alg</code>. When the entries of <code>M</code> are larger than 1, this is called &quot;relaxation&quot; or &quot;damping&quot;; when the entries are smaller than 1, this is called &quot;extrapolation&quot;.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/CliMA/ClimaCore.jl/blob/02d4ac9b5b5a734b1d81da96651848e38bc63355/src/MatrixFields/field_matrix_iterative_solver.jl#L227-L234">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="ClimaCore.MatrixFields.CustomPreconditioner" href="#ClimaCore.MatrixFields.CustomPreconditioner"><code>ClimaCore.MatrixFields.CustomPreconditioner</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">CustomPreconditioner(M, alg)</code></pre><p>A <code>PreconditionerAlgorithm</code> that sets <code>P</code> to the <code>FieldMatrix</code> <code>M</code> and inverts <code>P</code> using the <code>FieldMatrixSolverAlgorithm</code> <code>alg</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/CliMA/ClimaCore.jl/blob/02d4ac9b5b5a734b1d81da96651848e38bc63355/src/MatrixFields/field_matrix_iterative_solver.jl#L254-L259">source</a></section></article><h2 id="Internals"><a class="docs-heading-anchor" href="#Internals">Internals</a><a id="Internals-1"></a><a class="docs-heading-anchor-permalink" href="#Internals" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="ClimaCore.MatrixFields.outer_diagonals" href="#ClimaCore.MatrixFields.outer_diagonals"><code>ClimaCore.MatrixFields.outer_diagonals</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">outer_diagonals(::Type{&lt;:BandMatrixRow})</code></pre><p>Gets the indices of the lower and upper diagonals, <code>ld</code> and <code>ud</code>, of the given subtype of <code>BandMatrixRow</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/CliMA/ClimaCore.jl/blob/02d4ac9b5b5a734b1d81da96651848e38bc63355/src/MatrixFields/band_matrix_row.jl#L34-L39">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="ClimaCore.MatrixFields.band_matrix_row_type" href="#ClimaCore.MatrixFields.band_matrix_row_type"><code>ClimaCore.MatrixFields.band_matrix_row_type</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">band_matrix_row_type(ld, ud, T)</code></pre><p>A shorthand for getting the subtype of <code>BandMatrixRow</code> that has entries of type <code>T</code> on the diagonals with indices in the range <code>ld:ud</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/CliMA/ClimaCore.jl/blob/02d4ac9b5b5a734b1d81da96651848e38bc63355/src/MatrixFields/band_matrix_row.jl#L43-L48">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="ClimaCore.MatrixFields.mul_with_projection" href="#ClimaCore.MatrixFields.mul_with_projection"><code>ClimaCore.MatrixFields.mul_with_projection</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">mul_with_projection(x, y, lg)</code></pre><p>Similar to <code>x * y</code>, except that this version automatically projects <code>y</code> to avoid <code>DimensionMismatch</code> errors for <code>AxisTensor</code>s. For example, if <code>x</code> is a covector along the <code>Covariant3Axis</code> (e.g., <code>Covariant3Vector(1)&#39;</code>), then <code>y</code> will be projected onto the <code>Contravariant3Axis</code>. In general, the first axis of <code>y</code> will be projected onto the dual of the last axis of <code>x</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/CliMA/ClimaCore.jl/blob/02d4ac9b5b5a734b1d81da96651848e38bc63355/src/MatrixFields/rmul_with_projection.jl#L1-L9">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="ClimaCore.MatrixFields.rmul_with_projection" href="#ClimaCore.MatrixFields.rmul_with_projection"><code>ClimaCore.MatrixFields.rmul_with_projection</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">rmul_with_projection(x, y, lg)</code></pre><p>Similar to <code>rmul(x, y)</code>, except that this version calls <code>mul_with_projection</code> instead of <code>*</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/CliMA/ClimaCore.jl/blob/02d4ac9b5b5a734b1d81da96651848e38bc63355/src/MatrixFields/rmul_with_projection.jl#L17-L22">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="ClimaCore.MatrixFields.mul_return_type" href="#ClimaCore.MatrixFields.mul_return_type"><code>ClimaCore.MatrixFields.mul_return_type</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">mul_return_type(X, Y)</code></pre><p>Computes the return type of <code>mul_with_projection(x, y, lg)</code>, where <code>x isa X</code> and <code>y isa Y</code>. This can also be used to obtain the return type of <code>x * y</code>, although <code>x * y</code> will throw an error when projection is necessary.</p><p>Note that this is equivalent to calling the internal function <code>_return_type</code>: <code>Base._return_type(mul_with_projection, Tuple{X, Y, LG})</code>, where <code>lg isa LG</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/CliMA/ClimaCore.jl/blob/02d4ac9b5b5a734b1d81da96651848e38bc63355/src/MatrixFields/rmul_with_projection.jl#L51-L60">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="ClimaCore.MatrixFields.rmul_return_type" href="#ClimaCore.MatrixFields.rmul_return_type"><code>ClimaCore.MatrixFields.rmul_return_type</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">rmul_return_type(X, Y)</code></pre><p>Computes the return type of <code>rmul_with_projection(x, y, lg)</code>, where <code>x isa X</code> and <code>y isa Y</code>. This can also be used to obtain the return type of <code>rmul(x, y)</code>, although <code>rmul(x, y)</code> will throw an error when projection is necessary.</p><p>Note that this is equivalent to calling the internal function <code>_return_type</code>: <code>Base._return_type(rmul_with_projection, Tuple{X, Y, LG})</code>, where <code>lg isa LG</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/CliMA/ClimaCore.jl/blob/02d4ac9b5b5a734b1d81da96651848e38bc63355/src/MatrixFields/rmul_with_projection.jl#L137-L146">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="ClimaCore.MatrixFields.matrix_shape" href="#ClimaCore.MatrixFields.matrix_shape"><code>ClimaCore.MatrixFields.matrix_shape</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">matrix_shape(matrix_field, [matrix_space])</code></pre><p>Returns either <code>Square()</code>, <code>FaceToCenter()</code>, or <code>CenterToFace()</code>, depending on whether the diagonal indices of <code>matrix_field</code> are <code>Int</code>s or <code>PlusHalf</code>s and whether <code>matrix_space</code> is on cell centers or cell faces. By default, <code>matrix_space</code> is set to <code>axes(matrix_field)</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/CliMA/ClimaCore.jl/blob/02d4ac9b5b5a734b1d81da96651848e38bc63355/src/MatrixFields/matrix_shape.jl#L6-L13">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="ClimaCore.MatrixFields.column_axes" href="#ClimaCore.MatrixFields.column_axes"><code>ClimaCore.MatrixFields.column_axes</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">column_axes(matrix_field, [matrix_space])</code></pre><p>Returns the space that corresponds to the columns of <code>matrix_field</code>, i.e., the <code>axes</code> of the <code>Field</code>s by which <code>matrix_field</code> can be multiplied. The <code>matrix_space</code>, on the other hand, is the space that corresponds to the rows of <code>matrix_field</code>. By default, <code>matrix_space</code> is set to <code>axes(matrix_field)</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/CliMA/ClimaCore.jl/blob/02d4ac9b5b5a734b1d81da96651848e38bc63355/src/MatrixFields/matrix_shape.jl#L23-L30">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="ClimaCore.MatrixFields.AbstractLazyOperator" href="#ClimaCore.MatrixFields.AbstractLazyOperator"><code>ClimaCore.MatrixFields.AbstractLazyOperator</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">AbstractLazyOperator</code></pre><p>Supertype for &quot;lazy operators&quot;, i.e., operators that can be called without any arguments by users, as long as they appear in broadcast expressions that contain at least one <code>Field</code>. If <code>lazy_op</code> is an <code>AbstractLazyOperator</code>, the expression <code>lazy_op.()</code> will internally be translated to <code>non_lazy_op.(fields...)</code>, as long as it appears in a broadcast expression with at least one <code>Field</code>. This translation is done by the function <code>replace_lazy_operator(space, lazy_op)</code>, which must be implemented by every subtype of <code>AbstractLazyOperator</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/CliMA/ClimaCore.jl/blob/02d4ac9b5b5a734b1d81da96651848e38bc63355/src/MatrixFields/lazy_operators.jl#L1-L11">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="ClimaCore.MatrixFields.replace_lazy_operator" href="#ClimaCore.MatrixFields.replace_lazy_operator"><code>ClimaCore.MatrixFields.replace_lazy_operator</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">replace_lazy_operator(space, lazy_op)</code></pre><p>Generates an instance of <code>Base.AbstractBroadcasted</code> that corresponds to the expression <code>lazy_op.()</code>, where the broadcast in which this expression appears is being evaluated on the given <code>space</code>. Note that the staggering (<code>CellCenter</code> or <code>CellFace</code>) of this <code>space</code> depends on the specifics of the broadcast and is not predetermined.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/CliMA/ClimaCore.jl/blob/02d4ac9b5b5a734b1d81da96651848e38bc63355/src/MatrixFields/lazy_operators.jl#L71-L79">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="ClimaCore.MatrixFields.FieldName" href="#ClimaCore.MatrixFields.FieldName"><code>ClimaCore.MatrixFields.FieldName</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">FieldName(name_chain...)</code></pre><p>A singleton type that represents a chain of <code>getproperty</code> calls, which can be used to access a property or sub-property of an object <code>x</code> using the function <code>get_field(x, name)</code>. The entire object <code>x</code> can also be accessed with the empty <code>FieldName()</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/CliMA/ClimaCore.jl/blob/02d4ac9b5b5a734b1d81da96651848e38bc63355/src/MatrixFields/field_name.jl#L1-L8">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="ClimaCore.MatrixFields.@name" href="#ClimaCore.MatrixFields.@name"><code>ClimaCore.MatrixFields.@name</code></a> — <span class="docstring-category">Macro</span></header><section><div><pre><code class="language-julia hljs">@name(expr)</code></pre><p>Shorthand for constructing a <code>FieldName</code>. Some examples include</p><ul><li><code>name = @name()</code>, in which case <code>get_field(x, name)</code> returns <code>x</code></li><li><code>name = @name(a)</code>, in which case <code>get_field(x, name)</code> returns <code>x.a</code></li><li><code>name = @name(a.b.c)</code>, in which case <code>get_field(x, name)</code> returns <code>x.a.b.c</code></li><li><code>name = @name(a.b.c.:(1).d)</code>, in which case <code>get_field(x, name)</code> returns <code>x.a.b.c.:(1).d</code></li></ul><p>This macro is preferred over the <code>FieldName</code> constructor because it checks whether <code>expr</code> is a syntactically valid chain of <code>getproperty</code> calls before calling the constructor.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/CliMA/ClimaCore.jl/blob/02d4ac9b5b5a734b1d81da96651848e38bc63355/src/MatrixFields/field_name.jl#L13-L26">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="ClimaCore.MatrixFields.FieldNameTree" href="#ClimaCore.MatrixFields.FieldNameTree"><code>ClimaCore.MatrixFields.FieldNameTree</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">FieldNameTree(x)</code></pre><p>Tree of <code>FieldName</code>s that can be used to access <code>x</code> with <code>get_field(x, name)</code>. Check whether a <code>name</code> is valid by calling <code>is_valid_name(name, tree)</code>, and extract the children of <code>name</code> by calling <code>child_names(name, tree)</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/CliMA/ClimaCore.jl/blob/02d4ac9b5b5a734b1d81da96651848e38bc63355/src/MatrixFields/field_name.jl#L106-L112">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="ClimaCore.MatrixFields.FieldNameSet" href="#ClimaCore.MatrixFields.FieldNameSet"><code>ClimaCore.MatrixFields.FieldNameSet</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">FieldNameSet{T}(values, [name_tree])</code></pre><p>An <code>AbstractSet</code> that contains values of type <code>T</code>, which serves as an analogue of a <code>KeySet</code> for a <code>FieldNameDict</code>. There are two subtypes of <code>FieldNameSet</code>:</p><ul><li><code>FieldVectorKeys</code>, for which <code>T</code> is set to <code>FieldName</code></li><li><code>FieldMatrixKeys</code>, for which <code>T</code> is set to <code>Tuple{FieldName, FieldName}</code>; each tuple of type <code>T</code> represents a pair of row-column indices</li></ul><p>Since <code>FieldName</code>s are singleton types, the result of almost any <code>FieldNameSet</code> operation can be inferred during compilation. So, with the exception of <code>map</code>, <code>foreach</code>, and <code>set_string</code>, functions of <code>FieldNameSet</code>s do not have any performance cost at runtime (as long as their arguments are inferrable).</p><p>Unlike other <code>AbstractSet</code>s, <code>FieldNameSet</code> has special behavior for overlapping values. For example, the <code>FieldName</code>s <code>@name(a.b)</code> and <code>@name(a.b.c)</code> overlap, so any set operation needs to first decompose <code>@name(a.b)</code> into its child values before combining it with <code>@name(a.b.c)</code>. In order to support this (and also to support the ability to compute set complements), <code>FieldNameSet</code> stores a <code>FieldNameTree</code> <code>name_tree</code>, which it uses to infer child values. If <code>name_tree</code> is not specified, it gets set to <code>nothing</code> by default, which causes some <code>FieldNameSet</code> operations to become disabled. For binary operations like <code>union</code> or <code>setdiff</code>, only one set needs to specify a <code>name_tree</code>; if two sets both specify a <code>name_tree</code>, the <code>name_tree</code>s must be identical.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/CliMA/ClimaCore.jl/blob/02d4ac9b5b5a734b1d81da96651848e38bc63355/src/MatrixFields/field_name_set.jl#L3-L27">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="ClimaCore.MatrixFields.FieldNameDict" href="#ClimaCore.MatrixFields.FieldNameDict"><code>ClimaCore.MatrixFields.FieldNameDict</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">FieldNameDict(keys, entries)
FieldNameDict{T}(key_entry_pairs...)</code></pre><p>An <code>AbstractDict</code> with keys of type <code>T</code> that are stored as a <code>FieldNameSet{T}</code>. There are two subtypes of <code>FieldNameDict</code>:</p><ul><li><code>FieldMatrix</code>, which maps a set of <code>FieldMatrixKeys</code> to either <code>ColumnwiseBandMatrixField</code>s or multiples of <code>LinearAlgebra.I</code>; this is the only user-facing subtype of <code>FieldNameDict</code></li><li><code>FieldVectorView</code>, which maps a set of <code>FieldVectorKeys</code> to <code>Field</code>s; this subtype is automatically generated when a <code>FieldVector</code> is used in the same operation as a <code>FieldMatrix</code> (e.g., when both appear in the same broadcast expression, or when both are passed to a <code>FieldMatrixSolver</code>)</li></ul><p>A <code>FieldNameDict</code> can also be &quot;lazy&quot;, which means that it can store <code>AbstractBroadcasted</code> objects that become <code>Field</code>s when they are materialized. Many internal operations generate lazy <code>FieldNameDict</code>s to reduce the number of calls to <code>materialize!</code>, since each call comes with a small performance penalty.</p><p>The entry at a specific key can be extracted by calling <code>dict[key]</code>, and the entries that correspond to all the keys in a <code>FieldNameSet</code> can be extracted by calling <code>dict[set]</code>. If <code>dict</code> is a <code>FieldMatrix</code>, the corresponding identity matrix can be computed by calling <code>one(dict)</code>.</p><p>When broadcasting over <code>FieldNameDict</code>s, the following operations are supported:</p><ul><li>Addition and subtraction</li><li>Multiplication, where the first argument must be a <code>FieldMatrix</code></li><li>Inversion, where the argument must be a diagonal <code>FieldMatrix</code>, i.e., one in which every entry is either a <code>ColumnwiseBandMatrixField</code> of <code>DiagonalMatrixRow</code>s or a multiple of <code>LinearAlgebra.I</code></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/CliMA/ClimaCore.jl/blob/02d4ac9b5b5a734b1d81da96651848e38bc63355/src/MatrixFields/field_name_dict.jl#L1-L31">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="ClimaCore.MatrixFields.field_vector_view" href="#ClimaCore.MatrixFields.field_vector_view"><code>ClimaCore.MatrixFields.field_vector_view</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">field_vector_view(x, [name_tree])</code></pre><p>Constructs a <code>FieldVectorView</code> that contains all of the <code>Field</code>s in the <code>FieldVector</code> <code>x</code>. The default <code>name_tree</code> is <code>FieldNameTree(x)</code>, but this can be modified if needed.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/CliMA/ClimaCore.jl/blob/02d4ac9b5b5a734b1d81da96651848e38bc63355/src/MatrixFields/field_name_dict.jl#L224-L230">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="ClimaCore.MatrixFields.concrete_field_vector" href="#ClimaCore.MatrixFields.concrete_field_vector"><code>ClimaCore.MatrixFields.concrete_field_vector</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">concrete_field_vector(vector)</code></pre><p>Converts the <code>FieldVectorView</code> <code>vector</code> back into a <code>FieldVector</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/CliMA/ClimaCore.jl/blob/02d4ac9b5b5a734b1d81da96651848e38bc63355/src/MatrixFields/field_name_dict.jl#L251-L255">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="ClimaCore.MatrixFields.is_lazy" href="#ClimaCore.MatrixFields.is_lazy"><code>ClimaCore.MatrixFields.is_lazy</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">is_lazy(dict)</code></pre><p>Checks whether the <code>FieldNameDict</code> <code>dict</code> contains any un-materialized <code>AbstractBroadcasted</code> entries.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/CliMA/ClimaCore.jl/blob/02d4ac9b5b5a734b1d81da96651848e38bc63355/src/MatrixFields/field_name_dict.jl#L199-L204">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="ClimaCore.MatrixFields.lazy_main_diagonal" href="#ClimaCore.MatrixFields.lazy_main_diagonal"><code>ClimaCore.MatrixFields.lazy_main_diagonal</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">lazy_main_diagonal(matrix)</code></pre><p>Constructs a lazy <code>FieldMatrix</code> that contains the main diagonal of <code>matrix</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/CliMA/ClimaCore.jl/blob/02d4ac9b5b5a734b1d81da96651848e38bc63355/src/MatrixFields/field_name_dict.jl#L208-L212">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="ClimaCore.MatrixFields.lazy_mul" href="#ClimaCore.MatrixFields.lazy_mul"><code>ClimaCore.MatrixFields.lazy_mul</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">lazy_mul(A, args...)</code></pre><p>Constructs a lazy <code>FieldMatrix</code> that represents the product <code>@. *(A, args...)</code>. This involves regular broadcasting when <code>A</code> is a <code>FieldMatrix</code>, but it has more complex behavior for other objects like the <a href="#ClimaCore.MatrixFields.LazySchurComplement"><code>LazySchurComplement</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/CliMA/ClimaCore.jl/blob/02d4ac9b5b5a734b1d81da96651848e38bc63355/src/MatrixFields/field_matrix_solver.jl#L135-L141">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="ClimaCore.MatrixFields.LazySchurComplement" href="#ClimaCore.MatrixFields.LazySchurComplement"><code>ClimaCore.MatrixFields.LazySchurComplement</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">LazySchurComplement(A₁₁, A₁₂, A₂₁, A₂₂, [alg₁, cache₁, A₁₂_x₂, invA₁₁_A₁₂_x₂])</code></pre><p>An analogue of a <code>FieldMatrix</code> that represents the Schur complement of <code>A₁₁</code> in <code>A</code>, <code>A₂₂ - A₂₁ * inv(A₁₁) * A₁₂</code>. Since <code>inv(A₁₁)</code> will generally be a dense matrix, it would not be efficient to directly compute the Schur complement. So, this object only supports the &quot;lazy&quot; functions <a href="#ClimaCore.MatrixFields.lazy_mul"><code>lazy_mul</code></a>, which allows it to be multiplied by the vector <code>x₂</code>, and <a href="#ClimaCore.MatrixFields.lazy_preconditioner"><code>lazy_preconditioner</code></a>, which allows it to be approximated with a <code>FieldMatrix</code>.</p><p>The values <code>alg₁</code>, <code>cache₁</code>, <code>A₁₂_x₂</code>, and <code>invA₁₁_A₁₂_x₂</code> need to be specified in order for <code>lazy_mul</code> to be able to compute <code>inv(A₁₁) * A₁₂ * x₂</code>. When a <code>LazySchurComplement</code> is not passed to <code>lazy_mul</code>, these values can be omitted.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/CliMA/ClimaCore.jl/blob/02d4ac9b5b5a734b1d81da96651848e38bc63355/src/MatrixFields/field_matrix_solver.jl#L144-L157">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="ClimaCore.MatrixFields.field_matrix_solver_cache" href="#ClimaCore.MatrixFields.field_matrix_solver_cache"><code>ClimaCore.MatrixFields.field_matrix_solver_cache</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">field_matrix_solver_cache(alg, A, b)</code></pre><p>Allocates the cache required by the <code>FieldMatrixSolverAlgorithm</code> <code>alg</code> to solve the equation <code>A * x = b</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/CliMA/ClimaCore.jl/blob/02d4ac9b5b5a734b1d81da96651848e38bc63355/src/MatrixFields/field_matrix_solver.jl#L19-L24">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="ClimaCore.MatrixFields.check_field_matrix_solver" href="#ClimaCore.MatrixFields.check_field_matrix_solver"><code>ClimaCore.MatrixFields.check_field_matrix_solver</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">check_field_matrix_solver(alg, cache, A, b)</code></pre><p>Checks that the sparsity structure of <code>A</code> is supported by the <code>FieldMatrixSolverAlgorithm</code> <code>alg</code>, and that <code>A</code> is compatible with <code>b</code> in the equation <code>A * x = b</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/CliMA/ClimaCore.jl/blob/02d4ac9b5b5a734b1d81da96651848e38bc63355/src/MatrixFields/field_matrix_solver.jl#L27-L33">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="ClimaCore.MatrixFields.run_field_matrix_solver!" href="#ClimaCore.MatrixFields.run_field_matrix_solver!"><code>ClimaCore.MatrixFields.run_field_matrix_solver!</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">run_field_matrix_solver!(alg, cache, x, A, b)</code></pre><p>Sets <code>x</code> to the value that solves the equation <code>A * x = b</code> using the <code>FieldMatrixSolverAlgorithm</code> <code>alg</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/CliMA/ClimaCore.jl/blob/02d4ac9b5b5a734b1d81da96651848e38bc63355/src/MatrixFields/field_matrix_solver.jl#L36-L41">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="ClimaCore.MatrixFields.solver_algorithm" href="#ClimaCore.MatrixFields.solver_algorithm"><code>ClimaCore.MatrixFields.solver_algorithm</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">solver_algorithm(P_alg)</code></pre><p>A <code>FieldMatrixSolverAlgorithm</code> that can be used to solve <code>P * x = b</code> for <code>x</code>, where <code>P</code> is the preconditioner generated by the <code>PreconditionerAlgorithm</code> <code>P_alg</code>. If <code>P_alg</code> is <code>nothing</code> instead of a <code>PreconditionerAlgorithm</code>, or if <code>P</code> is a diagonal matrix (and no solver is required to invert it), this returns <code>nothing</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/CliMA/ClimaCore.jl/blob/02d4ac9b5b5a734b1d81da96651848e38bc63355/src/MatrixFields/field_matrix_iterative_solver.jl#L21-L29">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="ClimaCore.MatrixFields.lazy_preconditioner" href="#ClimaCore.MatrixFields.lazy_preconditioner"><code>ClimaCore.MatrixFields.lazy_preconditioner</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">lazy_preconditioner(P_alg, A)</code></pre><p>Constructs a lazy <code>FieldMatrix</code> (or a concrete one when possible) that approximates <code>A</code> according to the <code>PreconditionerAlgorithm</code> <code>P_alg</code>. If <code>P_alg</code> is <code>nothing</code> instead of a <code>PreconditionerAlgorithm</code>, this returns <code>one(A)</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/CliMA/ClimaCore.jl/blob/02d4ac9b5b5a734b1d81da96651848e38bc63355/src/MatrixFields/field_matrix_iterative_solver.jl#L34-L40">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="ClimaCore.MatrixFields.preconditioner_cache" href="#ClimaCore.MatrixFields.preconditioner_cache"><code>ClimaCore.MatrixFields.preconditioner_cache</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">preconditioner_cache(P_alg, A, b)</code></pre><p>Allocates the cache required to solve the equation <code>P * x = b</code>, where <code>P</code> is the preconditioner generated by the <code>PreconditionerAlgorithm</code> <code>P_alg</code> for <code>A</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/CliMA/ClimaCore.jl/blob/02d4ac9b5b5a734b1d81da96651848e38bc63355/src/MatrixFields/field_matrix_iterative_solver.jl#L43-L48">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="ClimaCore.MatrixFields.check_preconditioner" href="#ClimaCore.MatrixFields.check_preconditioner"><code>ClimaCore.MatrixFields.check_preconditioner</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">check_preconditioner(P_alg, P_cache, A, b)</code></pre><p>Checks that <code>P</code> is compatible with <code>b</code> in the equation <code>P * x = b</code>, where <code>P</code> is the preconditioner generated by the <code>PreconditionerAlgorithm</code> <code>P_alg</code> for <code>A</code>. If <code>P_alg</code> requires a <code>FieldMatrixSolverAlgorithm</code> <code>alg</code> to solve the equation, this also calls <a href="#ClimaCore.MatrixFields.check_field_matrix_solver"><code>check_field_matrix_solver</code></a> on <code>alg</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/CliMA/ClimaCore.jl/blob/02d4ac9b5b5a734b1d81da96651848e38bc63355/src/MatrixFields/field_matrix_iterative_solver.jl#L60-L67">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="ClimaCore.MatrixFields.lazy_or_concrete_preconditioner" href="#ClimaCore.MatrixFields.lazy_or_concrete_preconditioner"><code>ClimaCore.MatrixFields.lazy_or_concrete_preconditioner</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">lazy_or_concrete_preconditioner(P_alg, P_cache, A)</code></pre><p>A wrapper for <a href="#ClimaCore.MatrixFields.lazy_preconditioner"><code>lazy_preconditioner</code></a> that turns the lazy <code>FieldMatrix</code> <code>P</code> into a concrete <code>FieldMatrix</code> when the <code>PreconditionerAlgorithm</code> <code>P_alg</code> requires a <code>FieldMatrixSolverAlgorithm</code> to invert it.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/CliMA/ClimaCore.jl/blob/02d4ac9b5b5a734b1d81da96651848e38bc63355/src/MatrixFields/field_matrix_iterative_solver.jl#L79-L85">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="ClimaCore.MatrixFields.apply_preconditioner" href="#ClimaCore.MatrixFields.apply_preconditioner"><code>ClimaCore.MatrixFields.apply_preconditioner</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">apply_preconditioner(P_alg, P_cache, P, lazy_b)</code></pre><p>Constructs a lazy <code>FieldMatrix</code> (or a concrete one when possible) that represents the product <code>@. inv(P) * b</code>. Here, <code>lazy_b</code> is a (possibly lazy) <code>FieldVectorView</code> that represents <code>b</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/CliMA/ClimaCore.jl/blob/02d4ac9b5b5a734b1d81da96651848e38bc63355/src/MatrixFields/field_matrix_iterative_solver.jl#L94-L100">source</a></section></article><h2 id="Utilities"><a class="docs-heading-anchor" href="#Utilities">Utilities</a><a id="Utilities-1"></a><a class="docs-heading-anchor-permalink" href="#Utilities" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="ClimaCore.MatrixFields.column_field2array" href="#ClimaCore.MatrixFields.column_field2array"><code>ClimaCore.MatrixFields.column_field2array</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">column_field2array(field)</code></pre><p>Converts a field defined on a <code>FiniteDifferenceSpace</code> into either a <code>Vector</code> or a <code>BandedMatrix</code>, depending on whether the elements of the field are single values or <code>BandMatrixRow</code>s. This involves copying the data stored in the field. Because <code>BandedMatrix</code> does not currently support operations with <code>CuArray</code>s, all GPU data is copied to the CPU.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/CliMA/ClimaCore.jl/blob/02d4ac9b5b5a734b1d81da96651848e38bc63355/src/MatrixFields/field2arrays.jl#L25-L33">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="ClimaCore.MatrixFields.column_field2array_view" href="#ClimaCore.MatrixFields.column_field2array_view"><code>ClimaCore.MatrixFields.column_field2array_view</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">column_field2array_view(field)</code></pre><p>Similar to <code>column_field2array(field)</code>, except that this version avoids copying the data stored in the field.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/CliMA/ClimaCore.jl/blob/02d4ac9b5b5a734b1d81da96651848e38bc63355/src/MatrixFields/field2arrays.jl#L64-L69">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="ClimaCore.MatrixFields.field2arrays" href="#ClimaCore.MatrixFields.field2arrays"><code>ClimaCore.MatrixFields.field2arrays</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">field2arrays(field)</code></pre><p>Converts a field defined on a <code>FiniteDifferenceSpace</code> or on an <code>ExtrudedFiniteDifferenceSpace</code> into a collection of arrays, each of which corresponds to a column of the field. This is done by calling <code>column_field2array</code> on each of the field&#39;s columns.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/CliMA/ClimaCore.jl/blob/02d4ac9b5b5a734b1d81da96651848e38bc63355/src/MatrixFields/field2arrays.jl#L101-L108">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="ClimaCore.MatrixFields.field2arrays_view" href="#ClimaCore.MatrixFields.field2arrays_view"><code>ClimaCore.MatrixFields.field2arrays_view</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">field2arrays_view(field)</code></pre><p>Similar to <code>field2arrays(field)</code>, except that this version calls <code>column_field2array_view</code> instead of <code>column_field2array</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/CliMA/ClimaCore.jl/blob/02d4ac9b5b5a734b1d81da96651848e38bc63355/src/MatrixFields/field2arrays.jl#L111-L116">source</a></section></article></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../operators/">« Operators</a><a class="docs-footer-nextpage" href="../api/">API »</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option><option value="auto">Automatic (OS)</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 1.2.1 on <span class="colophon-date" title="Monday 26 February 2024 20:59">Monday 26 February 2024</span>. Using Julia version 1.10.1.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
