<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>MatrixFields · ClimaCore.jl</title><meta name="title" content="MatrixFields · ClimaCore.jl"/><meta property="og:title" content="MatrixFields · ClimaCore.jl"/><meta property="twitter:title" content="MatrixFields · ClimaCore.jl"/><meta name="description" content="Documentation for ClimaCore.jl."/><meta property="og:description" content="Documentation for ClimaCore.jl."/><meta property="twitter:description" content="Documentation for ClimaCore.jl."/><script data-outdated-warner src="../assets/warner.js"></script><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.050/juliamono.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.16.8/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL=".."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../assets/documenter.js"></script><script src="../search_index.js"></script><script src="../siteinfo.js"></script><script src="../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><a class="docs-logo" href="../"><img src="../assets/logo.png" alt="ClimaCore.jl logo"/></a><div class="docs-package-name"><span class="docs-autofit"><a href="../">ClimaCore.jl</a></span></div><button class="docs-search-query input is-rounded is-small is-clickable my-2 mx-auto py-1 px-2" id="documenter-search-query">Search docs (Ctrl + /)</button><ul class="docs-menu"><li><a class="tocitem" href="../">Home</a></li><li><a class="tocitem" href="../intro/">Introduction</a></li><li><a class="tocitem" href="../math_framework/">Mathematical Framework</a></li><li><a class="tocitem" href="../installation_instructions/">Installation and How-to Guides</a></li><li><a class="tocitem" href="../operators/">Operators</a></li><li class="is-active"><a class="tocitem" href>MatrixFields</a><ul class="internal"><li><a class="tocitem" href="#Matrix-Field-Element-Type"><span>Matrix Field Element Type</span></a></li><li><a class="tocitem" href="#Matrix-Field-Multiplication"><span>Matrix Field Multiplication</span></a></li><li><a class="tocitem" href="#Operator-Matrices"><span>Operator Matrices</span></a></li><li class="toplevel"><a class="tocitem" href="#Linear-Solvers"><span>Linear Solvers</span></a></li><li><a class="tocitem" href="#Internals"><span>Internals</span></a></li><li><a class="tocitem" href="#Utilities"><span>Utilities</span></a></li></ul></li><li><a class="tocitem" href="../api/">API</a></li><li><input class="collapse-toggle" id="menuitem-8" type="checkbox"/><label class="tocitem" for="menuitem-8"><span class="docs-label">Developer docs</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../performance_tips/">Performance tips</a></li></ul></li><li><input class="collapse-toggle" id="menuitem-9" type="checkbox"/><label class="tocitem" for="menuitem-9"><span class="docs-label">Tutorials</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../tutorials/introduction/">Introduction to ClimaCore.jl</a></li></ul></li><li><a class="tocitem" href="../examples/">Examples</a></li><li><input class="collapse-toggle" id="menuitem-11" type="checkbox"/><label class="tocitem" for="menuitem-11"><span class="docs-label">Libraries</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../lib/ClimaCorePlots/">ClimaCorePlots.jl</a></li><li><a class="tocitem" href="../lib/ClimaCoreMakie/">ClimaCoreMakie.jl</a></li><li><a class="tocitem" href="../lib/ClimaCoreVTK/">ClimaCoreVTK.jl</a></li><li><a class="tocitem" href="../lib/ClimaCoreTempestRemap/">ClimaCoreTempestRemap.jl</a></li><li><a class="tocitem" href="../lib/ClimaCoreSpectra/">ClimaCoreSpectra.jl</a></li></ul></li><li><a class="tocitem" href="../Contributing/">Contributing guide</a></li><li><a class="tocitem" href="../code_of_conduct/">Code of Conduct</a></li><li><a class="tocitem" href="../references/">References</a></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><a class="docs-sidebar-button docs-navbar-link fa-solid fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a><nav class="breadcrumb"><ul class="is-hidden-mobile"><li class="is-active"><a href>MatrixFields</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>MatrixFields</a></li></ul></nav><div class="docs-right"><a class="docs-navbar-link" href="https://github.com/CliMA/ClimaCore.jl" title="View the repository on GitHub"><span class="docs-icon fa-brands"></span><span class="docs-label is-hidden-touch">GitHub</span></a><a class="docs-navbar-link" href="https://github.com/CliMA/ClimaCore.jl/blob/main/docs/src/matrix_fields.md" title="Edit source on GitHub"><span class="docs-icon fa-solid"></span></a><a class="docs-settings-button docs-navbar-link fa-solid fa-gear" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-article-toggle-button fa-solid fa-chevron-up" id="documenter-article-toggle-button" href="javascript:;" title="Collapse all docstrings"></a></div></header><article class="content" id="documenter-page"><h1 id="MatrixFields"><a class="docs-heading-anchor" href="#MatrixFields">MatrixFields</a><a id="MatrixFields-1"></a><a class="docs-heading-anchor-permalink" href="#MatrixFields" title="Permalink"></a></h1><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="ClimaCore.MatrixFields" href="#ClimaCore.MatrixFields"><code>ClimaCore.MatrixFields</code></a> — <span class="docstring-category">Module</span></header><section><div><pre><code class="language-julia hljs">MatrixFields</code></pre><p>This module adds support for defining and manipulating <code>Field</code>s that represent matrices. Specifically, it adds the <code>BandMatrixRow</code> type, which can be used to store the entries of a band matrix. A <code>Field</code> of <code>BandMatrixRow</code>s on a <code>FiniteDifferenceSpace</code> can be interpreted as a band matrix by vertically concatenating the <code>BandMatrixRow</code>s. Similarly, a <code>Field</code> of <code>BandMatrixRow</code>s on an <code>ExtrudedFiniteDifferenceSpace</code> can be interpreted as a collection of band matrices, one for each column of the <code>Field</code>. Such <code>Field</code>s are called <code>ColumnwiseBandMatrixField</code>s, and this module adds the following functionality for them:</p><ul><li>Constructors, e.g., <code>matrix_field = @. BidiagonalMatrixRow(field1, field2)</code></li><li>Linear combinations, e.g., <code>@. 3 * matrix_field1 + matrix_field2 / 3</code></li><li>Matrix-vector multiplication, e.g., <code>@. matrix_field ⋅ field</code></li><li>Matrix-matrix multiplication, e.g., <code>@. matrix_field1 ⋅ matrix_field2</code></li><li>Compatibility with <code>LinearAlgebra.I</code>, e.g., <code>@. matrix_field = (4I,)</code> or   <code>@. matrix_field - (4I,)</code></li><li>Integration with <code>RecursiveApply</code>, e.g., the entries of <code>matrix_field</code> can be   <code>Tuple</code>s or <code>NamedTuple</code>s instead of single values, which allows   <code>matrix_field</code> to represent multiple band matrices at the same time</li><li>Integration with <code>Operators</code>, e.g., the <code>matrix_field</code> that gets applied to   the argument of any <code>FiniteDifferenceOperator</code> <code>op</code> can be obtained using   the <code>FiniteDifferenceOperator</code> <code>operator_matrix(op)</code></li><li>Conversions to native array types, e.g., <code>field2arrays(matrix_field)</code> can   convert each column of <code>matrix_field</code> into a <code>BandedMatrix</code> from   <code>BandedMatrices.jl</code></li><li>Custom printing, e.g., <code>matrix_field</code> gets displayed as a <code>BandedMatrix</code>,   specifically, as the <code>BandedMatrix</code> that corresponds to its first column</li></ul><p>This module also adds support for defining and manipulating sparse block matrices of <code>Field</code>s. Specifically, it adds the <code>FieldMatrix</code> type, which is a dictionary that maps pairs of <code>FieldName</code>s to <code>ColumnwiseBandMatrixField</code>s or multiples of <code>LinearAlgebra.I</code>. This comes with the following functionality:</p><ul><li>Addition and subtraction, e.g., <code>@. field_matrix1 + field_matrix2</code></li><li>Matrix-vector multiplication, e.g., <code>@. field_matrix * field_vector</code></li><li>Matrix-matrix multiplication, e.g., <code>@. field_matrix1 * field_matrix2</code></li><li>Integration with <code>RecursiveApply</code>, e.g., the entries of <code>field_matrix</code> can be   specified either as matrix <code>Field</code>s of <code>Tuple</code>s or <code>NamedTuple</code>s, or as   separate matrix <code>Field</code>s of single values</li><li>The ability to solve linear equations using <code>FieldMatrixSolver</code>, which is a   generalization of <code>ldiv!</code> that is designed to optimize solver performance</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/CliMA/ClimaCore.jl/blob/afd7f8e524c06f648ae510d832b57e21d641b1d4/src/MatrixFields/MatrixFields.jl#L1-L43">source</a></section></article><h2 id="Matrix-Field-Element-Type"><a class="docs-heading-anchor" href="#Matrix-Field-Element-Type">Matrix Field Element Type</a><a id="Matrix-Field-Element-Type-1"></a><a class="docs-heading-anchor-permalink" href="#Matrix-Field-Element-Type" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="ClimaCore.MatrixFields.BandMatrixRow" href="#ClimaCore.MatrixFields.BandMatrixRow"><code>ClimaCore.MatrixFields.BandMatrixRow</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">BandMatrixRow{ld}(entries...)</code></pre><p>Stores the nonzero entries in a row of a band matrix, starting with the lowest diagonal, which has index <code>ld</code>. Supported operations include accessing the entry on the diagonal with index <code>d</code> by calling <code>row[d]</code>, taking linear combinations with other band matrix rows (and with <code>LinearAlgebra.I</code>), and checking for equality with other band matrix rows (and with <code>LinearAlgebra.I</code>). There are several aliases for commonly used subtypes of <code>BandMatrixRow</code>:</p><ul><li><code>DiagonalMatrixRow(entry_1)</code></li><li><code>BidiagonalMatrixRow(entry_1, entry_2)</code></li><li><code>TridiagonalMatrixRow(entry_1, entry_2, entry_3)</code></li><li><code>QuaddiagonalMatrixRow(entry_1, entry_2, entry_3, entry_4)</code></li><li><code>PentadiagonalMatrixRow(entry_1, entry_2, entry_3, entry_4, entry_5)</code></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/CliMA/ClimaCore.jl/blob/afd7f8e524c06f648ae510d832b57e21d641b1d4/src/MatrixFields/band_matrix_row.jl#L1-L15">source</a></section></article><h2 id="Matrix-Field-Multiplication"><a class="docs-heading-anchor" href="#Matrix-Field-Multiplication">Matrix Field Multiplication</a><a id="Matrix-Field-Multiplication-1"></a><a class="docs-heading-anchor-permalink" href="#Matrix-Field-Multiplication" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="ClimaCore.MatrixFields.MultiplyColumnwiseBandMatrixField" href="#ClimaCore.MatrixFields.MultiplyColumnwiseBandMatrixField"><code>ClimaCore.MatrixFields.MultiplyColumnwiseBandMatrixField</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">MultiplyColumnwiseBandMatrixField()</code></pre><p>An operator that multiplies a <code>ColumnwiseBandMatrixField</code> by another <code>Field</code>, i.e., matrix-vector or matrix-matrix multiplication. The <code>⋅</code> symbol is an alias for <code>MultiplyColumnwiseBandMatrixField()</code>.</p><p>What follows is a derivation of the algorithm used by this operator with single-column <code>Field</code>s. For <code>Field</code>s on multiple columns, the same computation is done for each column.</p><p>In this derivation, we will use <span>$M_1$</span> and <span>$M_2$</span> to denote two <code>ColumnwiseBandMatrixField</code>s, and we will use <span>$V$</span> to denote a regular (vector-like) <code>Field</code>. For both <span>$M_1$</span> and <span>$M_2$</span>, we will use the array-like index notation <span>$M[row, col]$</span> to denote <span>$M[row][col-row]$</span>, i.e., the entry in the <code>BandMatrixRow</code> <span>$M[row]$</span> located on the diagonal with index <span>$col - row$</span>. We will also use <code>outer_indices</code><span>$($</span><code>space</code><span>$)$</span> to denote the tuple <span>$($</span><code>left_idx</code><span>$($</span><code>space</code><span>$),$</span><code>right_idx</code><span>$($</span><code>space</code><span>$))$</span>.</p><p><strong>1. Matrix-Vector Multiplication</strong></p><p>From the definition of matrix-vector multiplication,</p><p class="math-container">\[(M_1 ⋅ V)[i] = \sum_k M_1[i, k] * V[k].\]</p><p>To establish bounds on the values of <span>$k$</span>, let us define the following values:</p><ul><li><span>$li_1, ri_1 ={}$</span><code>outer_indices</code><span>$($</span><code>column_axes</code><span>$(M_1))$</span></li><li><span>$ld_1, ud_1 ={}$</span><code>outer_diagonals</code><span>$($</span><code>eltype</code><span>$(M_1))$</span></li></ul><p>Since <span>$M_1[i, k]$</span> is only well-defined if <span>$k$</span> is a valid column index and <span>$k - i$</span> is a valid diagonal index, we know that</p><p class="math-container">\[li_1 \leq k \leq ri_1 \quad \text{and} \quad ld_1 \leq k - i \leq ud_1.\]</p><p>Combining these into a single inequality gives us</p><p class="math-container">\[\text{max}(li_1, i + ld_1) \leq k \leq \text{min}(ri_1, i + ud_1).\]</p><p>So, we can rewrite the expression for <span>$(M_1 ⋅ V)[i]$</span> as</p><p class="math-container">\[(M_1 ⋅ V)[i] =
    \sum_{k\ =\ \text{max}(li_1, i + ld_1)}^{\text{min}(ri_1, i + ud_1)}
    M_1[i, k] * V[k].\]</p><p>If we replace the variable <span>$k$</span> with <span>$d = k - i$</span> and switch from array-like indexing to <code>Field</code> indexing, we find that</p><p class="math-container">\[(M_1 ⋅ V)[i] =
    \sum_{d\ =\ \text{max}(li_1 - i, ld_1)}^{\text{min}(ri_1 - i, ud_1)}
    M_1[i][d] * V[i + d].\]</p><p><strong>1.1 Interior vs. Boundary Indices</strong></p><p>Now, suppose that the row index <span>$i$</span> is such that</p><p class="math-container">\[li_1 - ld_1 \leq i \leq ri_1 - ud_1.\]</p><p>If this is the case, then the bounds on <span>$d$</span> can be simplified to</p><p class="math-container">\[\text{max}(li_1 - i, ld_1) = ld_1 \quad \text{and} \quad
\text{min}(ri_1 - i, ud_1) = ud_1.\]</p><p>The expression for <span>$(M_1 ⋅ V)[i]$</span> then becomes</p><p class="math-container">\[(M_1 ⋅ V)[i] = \sum_{d = ld_1}^{ud_1} M_1[i][d] * V[i + d].\]</p><p>The values of <span>$i$</span> in this range are considered to be in the &quot;interior&quot; of the operator, while those not in this range (for which we cannot make the above simplification) are considered to be on the &quot;boundary&quot;.</p><p><strong>2. Matrix-Matrix Multiplication</strong></p><p>From the definition of matrix-matrix multiplication,</p><p class="math-container">\[(M_1 ⋅ M_2)[i, j] = \sum_k M_1[i, k] * M_2[k, j].\]</p><p>To establish bounds on the values of <span>$j$</span> and <span>$k$</span>, let us define the following values:</p><ul><li><span>$li_1, ri_1 ={}$</span><code>outer_indices</code><span>$($</span><code>column_axes</code><span>$(M_1))$</span></li><li><span>$ld_1, ud_1 ={}$</span><code>outer_diagonals</code><span>$($</span><code>eltype</code><span>$(M_1))$</span></li><li><span>$li_2, ri_2 ={}$</span><code>outer_indices</code><span>$($</span><code>column_axes</code><span>$(M_2))$</span></li><li><span>$ld_2, ud_2 ={}$</span><code>outer_diagonals</code><span>$($</span><code>eltype</code><span>$(M_2))$</span></li></ul><p>In addition, let <span>$ld_{prod}$</span> and <span>$ud_{prod}$</span> denote the outer diagonal indices of the product matrix <span>$M_1 ⋅ M_2$</span>. We will derive the values of <span>$ld_{prod}$</span> and <span>$ud_{prod}$</span> in the last section.</p><p>Since <span>$M_1[i, k]$</span> is only well-defined if <span>$k$</span> is a valid column index and <span>$k - i$</span> is a valid diagonal index, we know that</p><p class="math-container">\[li_1 \leq k \leq ri_1 \quad \text{and} \quad ld_1 \leq k - i \leq ud_1.\]</p><p>Since <span>$M_2[k, j]$</span> is only well-defined if <span>$j$</span> is a valid column index and <span>$j - k$</span> is a valid diagonal index, we also know that</p><p class="math-container">\[li_2 \leq j \leq ri_2 \quad \text{and} \quad ld_2 \leq j - k \leq ud_2.\]</p><p>Finally, <span>$(M_1 ⋅ M_2)[i, j]$</span> is only well-defined if <span>$j - i$</span> is a valid diagonal index, so</p><p class="math-container">\[ld_{prod} \leq j - i \leq ud_{prod}.\]</p><p>These inequalities can be combined to obtain</p><p class="math-container">\[\begin{gather*}
\text{max}(li_2, i + ld_{prod}) \leq j \leq
\text{min}(ri_2, i + ud_{prod}) \\
\text{and} \\
\text{max}(li_1, i + ld_1, j - ud_2) \leq k \leq
\text{min}(ri_1, i + ud_1, j - ld_2).
\end{gather*}\]</p><p>So, we can rewrite the expression for <span>$(M_1 ⋅ M_2)[i, j]$</span> as</p><p class="math-container">\[\begin{gather*}
(M_1 ⋅ M_2)[i, j] =
    \sum_{
        k\ =\ \text{max}(li_1, i + ld_1, j - ud_2)
    }^{\text{min}(ri_1, i + ud_1, j - ld_2)}
    M_1[i, k] * M_2[k, j], \text{ where} \\[0.5em]
\text{max}(li_2, i + ld_{prod}) \leq j \leq \text{min}(ri_2, i + ud_{prod}).
\end{gather*}\]</p><p>If we replace the variable <span>$k$</span> with <span>$d = k - i$</span>, replace the variable <span>$j$</span> with <span>$d_{prod} = j - i$</span>, and switch from array-like indexing to <code>Field</code> indexing, we find that</p><p class="math-container">\[\begin{gather*}
(M_1 ⋅ M_2)[i][d_{prod}] =
    \sum_{
        d\ =\ \text{max}(li_1 - i, ld_1, d_{prod} - ud_2)
    }^{\text{min}(ri_1 - i, ud_1, d_{prod} - ld_2)}
    M_1[i][d] * M_2[i + d][d_{prod} - d], \text{ where} \\[0.5em]
\text{max}(li_2 - i, ld_{prod}) \leq d_{prod} \leq
    \text{min}(ri_2 - i, ud_{prod}).
\end{gather*}\]</p><p><strong>2.1 Interior vs. Boundary Indices</strong></p><p>Now, suppose that the row index <span>$i$</span> is such that</p><p class="math-container">\[\text{max}(li_1 - ld_1, li_2 - ld_{prod}) \leq i \leq
    \text{min}(ri_1 - ud_1, ri_2 - ud_{prod}).\]</p><p>If this is the case, then the bounds on <span>$d_{prod}$</span> can be simplified to</p><p class="math-container">\[\text{max}(li_2 - i, ld_{prod}) = ld_{prod} \quad \text{and} \quad
\text{min}(ri_2 - i, ud_{prod}) = ud_{prod}.\]</p><p>Similarly, the bounds on <span>$d$</span> can be simplified using the fact that</p><p class="math-container">\[\text{max}(li_1 - i, ld_1) = ld_1 \quad \text{and} \quad
\text{min}(ri_1 - i, ud_1) = ud_1.\]</p><p>The expression for <span>$(M_1 ⋅ M_2)[i][d_{prod}]$</span> then becomes</p><p class="math-container">\[\begin{gather*}
(M_1 ⋅ M_2)[i][d_{prod}] =
    \sum_{
        d\ =\ \text{max}(ld_1, d_{prod} - ud_2)
    }^{\text{min}(ud_1, d_{prod} - ld_2)}
    M_1[i][d] * M_2[i + d][d_{prod} - d], \text{ where} \\[0.5em]
ld_{prod} \leq d_{prod} \leq ud_{prod}.
\end{gather*}\]</p><p>The values of <span>$i$</span> in this range are considered to be in the &quot;interior&quot; of the operator, while those not in this range (for which we cannot make these simplifications) are considered to be on the &quot;boundary&quot;.</p><p><strong>2.2 <span>$ld_{prod}$</span> and <span>$ud_{prod}$</span></strong></p><p>We only need to compute <span>$(M_1 ⋅ M_2)[i][d_{prod}]$</span> for values of <span>$d_{prod}$</span> that correspond to a nonempty sum in the interior, i.e, those for which</p><p class="math-container">\[\text{max}(ld_1, d_{prod} - ud_2) \leq \text{min}(ud_1, d_{prod} - ld_2).\]</p><p>This can be broken down into the four inequalities</p><p class="math-container">\[ld_1 \leq ud_1, \qquad ld_1 \leq d_{prod} - ld_2, \qquad
d_{prod} - ud_2 \leq ud_1, \quad \text{and} \quad
d_{prod} - ud_2 \leq d_{prod} - ld_2.\]</p><p>By definition, <span>$ld_1 \leq ud_1$</span> and <span>$ld_2 \leq ud_2$</span>, so the first and last inequality are always true. Rearranging the remaining two inequalities tells us that</p><p class="math-container">\[ld_1 + ld_2 \leq d_{prod} \leq ud_1 + ud_2.\]</p><p>In other words, the outer diagonal indices of <span>$M_1 ⋅ M_2$</span> are</p><p class="math-container">\[ld_{prod} = ld_1 + ld_2 \quad \text{and} \quad ud_{prod} = ud_1 + ud_2.\]</p><p>This means that we can express the bounds on the interior values of <span>$i$</span> as</p><p class="math-container">\[\text{max}(li_1, li_2 - ld_2) - ld_1 \leq i \leq
    \text{min}(ri_1, ri_2 - ud_2) - ud_1.\]</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/CliMA/ClimaCore.jl/blob/afd7f8e524c06f648ae510d832b57e21d641b1d4/src/MatrixFields/matrix_multiplication.jl#L1-L200">source</a></section></article><h2 id="Operator-Matrices"><a class="docs-heading-anchor" href="#Operator-Matrices">Operator Matrices</a><a id="Operator-Matrices-1"></a><a class="docs-heading-anchor-permalink" href="#Operator-Matrices" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="ClimaCore.MatrixFields.operator_matrix" href="#ClimaCore.MatrixFields.operator_matrix"><code>ClimaCore.MatrixFields.operator_matrix</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">operator_matrix(op)</code></pre><p>Constructs a new operator (or operator-like object) that generates the matrix applied by <code>op</code> to its final argument. If <code>op_matrix = operator_matrix(op)</code>, we can use the following identities:</p><ul><li>When <code>op</code> takes one argument, <code>@. op(arg) == @. op_matrix() ⋅ arg</code>.</li><li>When <code>op</code> takes multiple arguments,   <code>@. op(args..., arg) == @. op_matrix(args...) ⋅ arg</code>.</li></ul><p>When <code>op</code> takes more than one argument, <code>operator_matrix(op)</code> constructs a <code>FiniteDifferenceOperator</code> that generates the operator matrix. When <code>op</code> only takes one argument, it instead constructs an <code>AbstractLazyOperator</code>, which is internally converted into a <code>FiniteDifferenceOperator</code> when used in a broadcast expression. Implementing <code>op_matrix</code> as a lazy operator allows us to add an argument to the expression <code>op_matrix.()</code>, and we then use this argument to infer the space and element type of the operator matrix.</p><p>As an example, the <code>InterpolateF2C()</code> operator on a space with <span>$n$</span> cell centers applies an <span>$n \times (n + 1)$</span> bidiagonal matrix:</p><p class="math-container">\[\textrm{interp}(arg) = \begin{bmatrix}
    0.5 &amp;     0.5 &amp;       0 &amp; \cdots &amp;       0 &amp;       0 &amp;       0 \\
      0 &amp;     0.5 &amp;     0.5 &amp; \cdots &amp;       0 &amp;       0 &amp;       0 \\
      0 &amp;       0 &amp;     0.5 &amp; \cdots &amp;       0 &amp;       0 &amp;       0 \\
\vdots &amp; \vdots &amp; \vdots &amp; \ddots &amp; \vdots &amp; \vdots &amp; \vdots \\
      0 &amp;       0 &amp;       0 &amp; \cdots &amp;     0.5 &amp;     0.5 &amp;       0 \\
      0 &amp;       0 &amp;       0 &amp; \cdots &amp;       0 &amp;     0.5 &amp;     0.5
\end{bmatrix} ⋅ arg\]</p><p>The <code>GradientF2C()</code> operator applies a similar matrix, but with different entries:</p><p class="math-container">\[\textrm{grad}(arg) = \begin{bmatrix}
-\textbf{e}^3 &amp;  \textbf{e}^3 &amp;              0 &amp; \cdots &amp;              0 &amp;              0 &amp;             0 \\
             0 &amp; -\textbf{e}^3 &amp;  \textbf{e}^3 &amp; \cdots &amp;              0 &amp;              0 &amp;             0 \\
             0 &amp;              0 &amp; -\textbf{e}^3 &amp; \cdots &amp;              0 &amp;              0 &amp;             0 \\
       \vdots &amp;        \vdots &amp;        \vdots &amp; \ddots &amp;        \vdots &amp;        \vdots &amp;       \vdots \\
             0 &amp;              0 &amp;              0 &amp; \cdots &amp; -\textbf{e}^3 &amp;  \textbf{e}^3 &amp;             0 \\
             0 &amp;              0 &amp;              0 &amp; \cdots &amp;              0 &amp; -\textbf{e}^3 &amp; \textbf{e}^3
\end{bmatrix} ⋅ arg\]</p><p>The unit vector <span>$\textbf{e}^3$</span>, which can also be thought of as the differential along the third coordinate axis (<span>$\textrm{d}\xi^3$</span>), is implemented as a <code>Geometry.Covariant3Vector(1)</code>.</p><p>Not all operators have well-defined operator matrices. For example, the operator <code>GradientC2F(; bottom = SetGradient(grad_b), top = SetGradient(grad_t))</code> applies an affine transformation:</p><p class="math-container">\[\textrm{grad}(arg) = \begin{bmatrix}
grad_b \\ 0 \\ 0 \\ \vdots \\ 0 \\ 0 \\ grad_t
\end{bmatrix} + \begin{bmatrix}
             0 &amp;              0 &amp;              0 &amp; \cdots &amp;              0 &amp;             0 \\
-\textbf{e}^3 &amp;  \textbf{e}^3 &amp;              0 &amp; \cdots &amp;              0 &amp;             0 \\
             0 &amp; -\textbf{e}^3 &amp;  \textbf{e}^3 &amp; \cdots &amp;              0 &amp;             0 \\
       \vdots &amp;        \vdots &amp;        \vdots &amp; \ddots &amp;        \vdots &amp;       \vdots \\
             0 &amp;              0 &amp;              0 &amp; \cdots &amp;  \textbf{e}^3 &amp;             0 \\
             0 &amp;              0 &amp;              0 &amp; \cdots &amp; -\textbf{e}^3 &amp; \textbf{e}^3 \\
             0 &amp;              0 &amp;              0 &amp; \cdots &amp;              0 &amp;             0
\end{bmatrix} ⋅ arg\]</p><p>However, this simplifies to a linear transformation when <span>$grad_b$</span> and <span>$grad_t$</span> are both 0:</p><p class="math-container">\[\textrm{grad}(arg) = \begin{bmatrix}
             0 &amp;              0 &amp;              0 &amp; \cdots &amp;              0 &amp;             0 \\
-\textbf{e}^3 &amp;  \textbf{e}^3 &amp;              0 &amp; \cdots &amp;              0 &amp;             0 \\
             0 &amp; -\textbf{e}^3 &amp;  \textbf{e}^3 &amp; \cdots &amp;              0 &amp;             0 \\
       \vdots &amp;        \vdots &amp;        \vdots &amp; \ddots &amp;        \vdots &amp;       \vdots \\
             0 &amp;              0 &amp;              0 &amp; \cdots &amp;  \textbf{e}^3 &amp;             0 \\
             0 &amp;              0 &amp;              0 &amp; \cdots &amp; -\textbf{e}^3 &amp; \textbf{e}^3 \\
             0 &amp;              0 &amp;              0 &amp; \cdots &amp;              0 &amp;             0
\end{bmatrix} ⋅ arg\]</p><p>In general, when <code>op</code> has nonzero boundary conditions that make it apply an affine transformation, <code>operator_matrix(op)</code> will print out a warning and zero out the boundary conditions before computing the operator matrix.</p><p>In addition to affine transformations, there are also some operators that apply nonlinear transformations to their arguments; that is, transformations which cannot be accurately approximated without using more terms of the form</p><p class="math-container">\[\textrm{op}(\textbf{0}) +
\textrm{op}&#39;(\textbf{0}) ⋅ arg +
\textrm{op}&#39;&#39;(\textbf{0}) ⋅ arg ⋅ arg +
\ldots.\]</p><p>When <code>op</code> is such an operator, <code>operator_matrix(op)</code> will throw an error. In the future, we may want to modify <code>operator_matrix(op)</code> so that it will instead return <span>$\textrm{op}&#39;(\textbf{0})$</span>, where <span>$\textbf{0} ={}$</span><code>zero.(arg)</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/CliMA/ClimaCore.jl/blob/afd7f8e524c06f648ae510d832b57e21d641b1d4/src/MatrixFields/operator_matrices.jl#L116-L207">source</a></section></article><h1 id="Linear-Solvers"><a class="docs-heading-anchor" href="#Linear-Solvers">Linear Solvers</a><a id="Linear-Solvers-1"></a><a class="docs-heading-anchor-permalink" href="#Linear-Solvers" title="Permalink"></a></h1><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="ClimaCore.MatrixFields.FieldMatrixSolverAlgorithm" href="#ClimaCore.MatrixFields.FieldMatrixSolverAlgorithm"><code>ClimaCore.MatrixFields.FieldMatrixSolverAlgorithm</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">FieldMatrixSolverAlgorithm</code></pre><p>Description of how to solve an equation of the form <code>A * x = b</code> for <code>x</code>, where <code>A</code> is a <code>FieldMatrix</code> and where <code>x</code> and <code>b</code> are both <code>FieldVector</code>s. Different algorithms can be nested inside each other, enabling the construction of specialized linear solvers that fully utilize the sparsity pattern of <code>A</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/CliMA/ClimaCore.jl/blob/afd7f8e524c06f648ae510d832b57e21d641b1d4/src/MatrixFields/field_matrix_solver.jl#L1-L8">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="ClimaCore.MatrixFields.FieldMatrixSolver" href="#ClimaCore.MatrixFields.FieldMatrixSolver"><code>ClimaCore.MatrixFields.FieldMatrixSolver</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">FieldMatrixSolver(alg, A, b)</code></pre><p>Combination of a <code>FieldMatrixSolverAlgorithm</code> and the cache that it requires to solve the equation <code>A * x = b</code> for <code>x</code>. The values of <code>A</code> and <code>b</code> that get passed to this constructor should be <code>similar</code> to the ones that get passed to <code>field_matrix_solve!</code> in order to ensure that the cache gets allocated correctly.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/CliMA/ClimaCore.jl/blob/afd7f8e524c06f648ae510d832b57e21d641b1d4/src/MatrixFields/field_matrix_solver.jl#L11-L19">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="ClimaCore.MatrixFields.field_matrix_solve!" href="#ClimaCore.MatrixFields.field_matrix_solve!"><code>ClimaCore.MatrixFields.field_matrix_solve!</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">field_matrix_solve!(solver, x, A, b)</code></pre><p>Solves the equation <code>A * x = b</code> for <code>x</code> using the given <code>FieldMatrixSolver</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/CliMA/ClimaCore.jl/blob/afd7f8e524c06f648ae510d832b57e21d641b1d4/src/MatrixFields/field_matrix_solver.jl#L35-L39">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="ClimaCore.MatrixFields.BlockDiagonalSolve" href="#ClimaCore.MatrixFields.BlockDiagonalSolve"><code>ClimaCore.MatrixFields.BlockDiagonalSolve</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">BlockDiagonalSolve()</code></pre><p>A <code>FieldMatrixSolverAlgorithm</code> for a block diagonal matrix <code>A</code>, which solves each block&#39;s equation <code>Aᵢᵢ * xᵢ = bᵢ</code> in sequence. The equation for <code>xᵢ</code> is solved as follows:</p><ul><li>If <code>Aᵢᵢ = λᵢ * I</code>, the equation is solved by setting <code>xᵢ .= inv(λᵢ) .* bᵢ</code>.</li><li>If <code>Aᵢᵢ = Dᵢ</code>, where <code>Dᵢ</code> is a diagonal matrix, the equation is solved by making a single pass over the data, setting each <code>xᵢ[n] = inv(Dᵢ[n]) * bᵢ[n]</code>.</li><li>If <code>Aᵢᵢ = Lᵢ * Dᵢ * Uᵢ</code>, where <code>Dᵢ</code> is a diagonal matrix and where <code>Lᵢ</code> and <code>Uᵢ</code> are unit lower and upper triangular matrices, respectively, the equation is solved using Gauss-Jordan elimination, which makes two passes over the data. The first pass multiplies both sides of the equation by <code>inv(Lᵢ * Dᵢ)</code>, replacing <code>Aᵢᵢ</code> with <code>Uᵢ</code> and <code>bᵢ</code> with <code>Uᵢxᵢ</code>, which is also referred to as putting <code>Aᵢᵢ</code> into &quot;reduced row echelon form&quot;. The second pass solves <code>Uᵢ * xᵢ = Uᵢxᵢ</code> for <code>xᵢ</code> using a unit upper triangular matrix solver, which is also referred to as &quot;back substitution&quot;. Only tri-diagonal and penta-diagonal matrices <code>Aᵢᵢ</code> are currently supported.</li><li>The general case of <code>Aᵢᵢ = inv(Pᵢ) * Lᵢ * Uᵢ</code>, where <code>Pᵢ</code> is a row permutation matrix (i.e., LU factorization with partial pivoting), is not currently supported.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/CliMA/ClimaCore.jl/blob/afd7f8e524c06f648ae510d832b57e21d641b1d4/src/MatrixFields/field_matrix_solver.jl#L84-L105">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="ClimaCore.MatrixFields.BlockLowerTriangularSolve" href="#ClimaCore.MatrixFields.BlockLowerTriangularSolve"><code>ClimaCore.MatrixFields.BlockLowerTriangularSolve</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">BlockLowerTriangularSolve(names₁...; [alg₁], [alg₂])</code></pre><p>A <code>FieldMatrixSolverAlgorithm</code> for a block lower triangular matrix <code>A</code>, which solves for <code>x</code> by executing the following steps:</p><ol><li>Partition the entries in <code>A</code>, <code>x</code>, and <code>b</code> into the blocks <code>A₁₁</code>, <code>A₁₂</code>, <code>A₂₁</code>, <code>A₂₂</code>, <code>x₁</code>, <code>x₂</code>, <code>b₁</code>, and <code>b₂</code>, based on the <code>FieldName</code>s in <code>names₁</code>. In this notation, the subscript <code>₁</code> corresponds to <code>FieldName</code>s that are covered by <code>names₁</code>, while the subscript <code>₂</code> corresponds to all other <code>FieldNames</code>. A subscript in the first position refers to <code>FieldName</code>s that are used as row indices, while a subscript in the second position refers to column indices. This algorithm requires that the upper triangular block <code>A₁₂</code> be empty. (Any upper triangular solve can also be expressed as a lower triangular solve by swapping the subscripts <code>₁</code> and <code>₂</code>.)</li><li>Solve <code>A₁₁ * x₁ = b₁</code> for <code>x₁</code> using the algorithm <code>alg₁</code>, which is set to <code>BlockDiagonalSolve()</code> by default.</li><li>Solve <code>A₂₂ * x₂ = b₂ - A₂₁ * x₁</code> for <code>x₂</code> using the algorithm <code>alg₂</code>, which is set to <code>BlockDiagonalSolve()</code> by default.</li></ol></div><a class="docs-sourcelink" target="_blank" href="https://github.com/CliMA/ClimaCore.jl/blob/afd7f8e524c06f648ae510d832b57e21d641b1d4/src/MatrixFields/field_matrix_solver.jl#L131-L149">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="ClimaCore.MatrixFields.SchurComplementSolve" href="#ClimaCore.MatrixFields.SchurComplementSolve"><code>ClimaCore.MatrixFields.SchurComplementSolve</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">SchurComplementSolve(names₁...; [alg₁])</code></pre><p>A <code>FieldMatrixSolverAlgorithm</code> for a block matrix <code>A</code>, which solves for <code>x</code> by executing the following steps:</p><ol><li>Partition the entries in <code>A</code>, <code>x</code>, and <code>b</code> into the blocks <code>A₁₁</code>, <code>A₁₂</code>, <code>A₂₁</code>, <code>A₂₂</code>, <code>x₁</code>, <code>x₂</code>, <code>b₁</code>, and <code>b₂</code>, based on the <code>FieldName</code>s in <code>names₁</code>. In this notation, the subscript <code>₁</code> corresponds to <code>FieldName</code>s that are covered by <code>names₁</code>, while the subscript <code>₂</code> corresponds to all other <code>FieldNames</code>. A subscript in the first position refers to <code>FieldName</code>s that are used as row indices, while a subscript in the second position refers to column indices. This algorithm requires that the block <code>A₂₂</code> be a diagonal matrix, which allows it to assume that <code>inv(A₂₂)</code> can be computed on the fly.</li><li>Solve <code>(A₁₁ - A₁₂ * inv(A₂₂) * A₂₁) * x₁ = b₁ - A₁₂ * inv(A₂₂) * b₂</code> for <code>x₁</code> using the algorithm <code>alg₁</code>, which is set to <code>BlockDiagonalSolve()</code> by default. The matrix <code>A₁₁ - A₁₂ * inv(A₂₂) * A₂₁</code> is called the &quot;Schur complement&quot; of <code>A₂₂</code> in <code>A</code>.</li><li>Set <code>x₂</code> to <code>inv(A₂₂) * (b₂ - A₂₁ * x₁)</code>.</li></ol></div><a class="docs-sourcelink" target="_blank" href="https://github.com/CliMA/ClimaCore.jl/blob/afd7f8e524c06f648ae510d832b57e21d641b1d4/src/MatrixFields/field_matrix_solver.jl#L190-L208">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="ClimaCore.MatrixFields.ApproximateFactorizationSolve" href="#ClimaCore.MatrixFields.ApproximateFactorizationSolve"><code>ClimaCore.MatrixFields.ApproximateFactorizationSolve</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">ApproximateFactorizationSolve(name_pairs₁...; [alg₁], [alg₂])</code></pre><p>A <code>FieldMatrixSolverAlgorithm</code> for a block matrix <code>A</code>, which (approximately) solves for <code>x</code> by executing the following steps:</p><ol><li>Use the entries in <code>A = M + I = M₁ + M₂ + I</code> to compute <code>A₁ = M₁ + I</code> and <code>A₂ = M₂ + I</code>, based on the pairs of <code>FieldName</code>s in <code>name_pairs₁</code>. In this notation, the subscript <code>₁</code> refers to pairs of <code>FieldName</code>s that are covered by <code>name_pairs₁</code>, while the subscript <code>₂</code> refers to all other pairs of  <code>FieldNames</code>s. This algorithm approximates the matrix <code>A</code> as the product <code>A₁ * A₂</code>, which introduces an error that scales roughly with the norm of <code>A₁ * A₂ - A = M₁ * M₂</code>. (More precisely, the error introduced by this algorithm is <code>x_exact - x_approx = inv(A) * b - inv(A₁ * A₂) * b</code>.)</li><li>Solve <code>A₁ * A₂x = b</code> for <code>A₂x</code> using the algorithm <code>alg₁</code>, which is set to <code>BlockDiagonalSolve()</code> by default.</li><li>Solve <code>A₂ * x = A₂x</code> for <code>x</code> using the algorithm <code>alg₂</code>, which is set to <code>BlockDiagonalSolve()</code> by default.</li></ol></div><a class="docs-sourcelink" target="_blank" href="https://github.com/CliMA/ClimaCore.jl/blob/afd7f8e524c06f648ae510d832b57e21d641b1d4/src/MatrixFields/field_matrix_solver.jl#L242-L259">source</a></section></article><h2 id="Internals"><a class="docs-heading-anchor" href="#Internals">Internals</a><a id="Internals-1"></a><a class="docs-heading-anchor-permalink" href="#Internals" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="ClimaCore.MatrixFields.outer_diagonals" href="#ClimaCore.MatrixFields.outer_diagonals"><code>ClimaCore.MatrixFields.outer_diagonals</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">outer_diagonals(::Type{&lt;:BandMatrixRow})</code></pre><p>Gets the indices of the lower and upper diagonals, <code>ld</code> and <code>ud</code>, of the given subtype of <code>BandMatrixRow</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/CliMA/ClimaCore.jl/blob/afd7f8e524c06f648ae510d832b57e21d641b1d4/src/MatrixFields/band_matrix_row.jl#L34-L39">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="ClimaCore.MatrixFields.band_matrix_row_type" href="#ClimaCore.MatrixFields.band_matrix_row_type"><code>ClimaCore.MatrixFields.band_matrix_row_type</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">band_matrix_row_type(ld, ud, T)</code></pre><p>A shorthand for getting the subtype of <code>BandMatrixRow</code> that has entries of type <code>T</code> on the diagonals with indices in the range <code>ld:ud</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/CliMA/ClimaCore.jl/blob/afd7f8e524c06f648ae510d832b57e21d641b1d4/src/MatrixFields/band_matrix_row.jl#L43-L48">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="ClimaCore.MatrixFields.mul_with_projection" href="#ClimaCore.MatrixFields.mul_with_projection"><code>ClimaCore.MatrixFields.mul_with_projection</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">mul_with_projection(x, y, lg)</code></pre><p>Similar to <code>x * y</code>, except that this version automatically projects <code>y</code> to avoid <code>DimensionMismatch</code> errors for <code>AxisTensor</code>s. For example, if <code>x</code> is a covector along the <code>Covariant3Axis</code> (e.g., <code>Covariant3Vector(1)&#39;</code>), then <code>y</code> will be projected onto the <code>Contravariant3Axis</code>. In general, the first axis of <code>y</code> will be projected onto the dual of the last axis of <code>x</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/CliMA/ClimaCore.jl/blob/afd7f8e524c06f648ae510d832b57e21d641b1d4/src/MatrixFields/rmul_with_projection.jl#L1-L9">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="ClimaCore.MatrixFields.rmul_with_projection" href="#ClimaCore.MatrixFields.rmul_with_projection"><code>ClimaCore.MatrixFields.rmul_with_projection</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">rmul_with_projection(x, y, lg)</code></pre><p>Similar to <code>rmul(x, y)</code>, except that this version calls <code>mul_with_projection</code> instead of <code>*</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/CliMA/ClimaCore.jl/blob/afd7f8e524c06f648ae510d832b57e21d641b1d4/src/MatrixFields/rmul_with_projection.jl#L17-L22">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="ClimaCore.MatrixFields.mul_return_type" href="#ClimaCore.MatrixFields.mul_return_type"><code>ClimaCore.MatrixFields.mul_return_type</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">mul_return_type(X, Y)</code></pre><p>Computes the return type of <code>mul_with_projection(x, y, lg)</code>, where <code>x isa X</code> and <code>y isa Y</code>. This can also be used to obtain the return type of <code>x * y</code>, although <code>x * y</code> will throw an error when projection is necessary.</p><p>Note that this is equivalent to calling the internal function <code>_return_type</code>: <code>Base._return_type(mul_with_projection, Tuple{X, Y, LG})</code>, where <code>lg isa LG</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/CliMA/ClimaCore.jl/blob/afd7f8e524c06f648ae510d832b57e21d641b1d4/src/MatrixFields/rmul_with_projection.jl#L51-L60">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="ClimaCore.MatrixFields.rmul_return_type" href="#ClimaCore.MatrixFields.rmul_return_type"><code>ClimaCore.MatrixFields.rmul_return_type</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">rmul_return_type(X, Y)</code></pre><p>Computes the return type of <code>rmul_with_projection(x, y, lg)</code>, where <code>x isa X</code> and <code>y isa Y</code>. This can also be used to obtain the return type of <code>rmul(x, y)</code>, although <code>rmul(x, y)</code> will throw an error when projection is necessary.</p><p>Note that this is equivalent to calling the internal function <code>_return_type</code>: <code>Base._return_type(rmul_with_projection, Tuple{X, Y, LG})</code>, where <code>lg isa LG</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/CliMA/ClimaCore.jl/blob/afd7f8e524c06f648ae510d832b57e21d641b1d4/src/MatrixFields/rmul_with_projection.jl#L137-L146">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="ClimaCore.MatrixFields.matrix_shape" href="#ClimaCore.MatrixFields.matrix_shape"><code>ClimaCore.MatrixFields.matrix_shape</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">matrix_shape(matrix_field, [matrix_space])</code></pre><p>Returns either <code>Square()</code>, <code>FaceToCenter()</code>, or <code>CenterToFace()</code>, depending on whether the diagonal indices of <code>matrix_field</code> are <code>Int</code>s or <code>PlusHalf</code>s and whether <code>matrix_space</code> is on cell centers or cell faces. By default, <code>matrix_space</code> is set to <code>axes(matrix_field)</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/CliMA/ClimaCore.jl/blob/afd7f8e524c06f648ae510d832b57e21d641b1d4/src/MatrixFields/matrix_shape.jl#L6-L13">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="ClimaCore.MatrixFields.column_axes" href="#ClimaCore.MatrixFields.column_axes"><code>ClimaCore.MatrixFields.column_axes</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">column_axes(matrix_field, [matrix_space])</code></pre><p>Returns the space that corresponds to the columns of <code>matrix_field</code>, i.e., the <code>axes</code> of the <code>Field</code>s by which <code>matrix_field</code> can be multiplied. The <code>matrix_space</code>, on the other hand, is the space that corresponds to the rows of <code>matrix_field</code>. By default, <code>matrix_space</code> is set to <code>axes(matrix_field)</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/CliMA/ClimaCore.jl/blob/afd7f8e524c06f648ae510d832b57e21d641b1d4/src/MatrixFields/matrix_shape.jl#L23-L30">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="ClimaCore.MatrixFields.AbstractLazyOperator" href="#ClimaCore.MatrixFields.AbstractLazyOperator"><code>ClimaCore.MatrixFields.AbstractLazyOperator</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">AbstractLazyOperator</code></pre><p>Supertype for &quot;lazy operators&quot;, i.e., operators that can be called without any arguments by users, as long as they appear in broadcast expressions that contain at least one <code>Field</code>. If <code>lazy_op</code> is an <code>AbstractLazyOperator</code>, the expression <code>lazy_op.()</code> will internally be translated to <code>non_lazy_op.(fields...)</code>, as long as it appears in a broadcast expression with at least one <code>Field</code>. This translation is done by the function <code>replace_lazy_operator(space, lazy_op)</code>, which must be implemented by every subtype of <code>AbstractLazyOperator</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/CliMA/ClimaCore.jl/blob/afd7f8e524c06f648ae510d832b57e21d641b1d4/src/MatrixFields/lazy_operators.jl#L1-L11">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="ClimaCore.MatrixFields.replace_lazy_operator" href="#ClimaCore.MatrixFields.replace_lazy_operator"><code>ClimaCore.MatrixFields.replace_lazy_operator</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">replace_lazy_operator(space, lazy_op)</code></pre><p>Generates an instance of <code>Base.AbstractBroadcasted</code> that corresponds to the expression <code>lazy_op.()</code>, where the broadcast in which this expression appears is being evaluated on the given <code>space</code>. Note that the staggering (<code>CellCenter</code> or <code>CellFace</code>) of this <code>space</code> depends on the specifics of the broadcast and is not predetermined.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/CliMA/ClimaCore.jl/blob/afd7f8e524c06f648ae510d832b57e21d641b1d4/src/MatrixFields/lazy_operators.jl#L71-L79">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="ClimaCore.MatrixFields.FieldName" href="#ClimaCore.MatrixFields.FieldName"><code>ClimaCore.MatrixFields.FieldName</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">FieldName(name_chain...)</code></pre><p>A singleton type that represents a chain of <code>getproperty</code> calls, which can be used to access a property or sub-property of an object <code>x</code> using the function <code>get_field(x, name)</code>. The entire object <code>x</code> can also be accessed with the empty <code>FieldName()</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/CliMA/ClimaCore.jl/blob/afd7f8e524c06f648ae510d832b57e21d641b1d4/src/MatrixFields/field_name.jl#L1-L8">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="ClimaCore.MatrixFields.@name" href="#ClimaCore.MatrixFields.@name"><code>ClimaCore.MatrixFields.@name</code></a> — <span class="docstring-category">Macro</span></header><section><div><pre><code class="language-julia hljs">@name(expr)</code></pre><p>Shorthand for constructing a <code>FieldName</code>. Some examples include</p><ul><li><code>name = @name()</code>, in which case <code>get_field(x, name)</code> returns <code>x</code></li><li><code>name = @name(a)</code>, in which case <code>get_field(x, name)</code> returns <code>x.a</code></li><li><code>name = @name(a.b.c)</code>, in which case <code>get_field(x, name)</code> returns <code>x.a.b.c</code></li><li><code>name = @name(a.b.c.:(1).d)</code>, in which case <code>get_field(x, name)</code> returns <code>x.a.b.c.:(1).d</code></li></ul><p>This macro is preferred over the <code>FieldName</code> constructor because it checks whether <code>expr</code> is a syntactically valid chain of <code>getproperty</code> calls before calling the constructor.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/CliMA/ClimaCore.jl/blob/afd7f8e524c06f648ae510d832b57e21d641b1d4/src/MatrixFields/field_name.jl#L13-L26">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="ClimaCore.MatrixFields.FieldNameTree" href="#ClimaCore.MatrixFields.FieldNameTree"><code>ClimaCore.MatrixFields.FieldNameTree</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">FieldNameTree(x)</code></pre><p>Tree of <code>FieldName</code>s that can be used to access <code>x</code> with <code>get_field(x, name)</code>. Check whether a <code>name</code> is valid by calling <code>is_valid_name(name, tree)</code>, and extract the children of <code>name</code> by calling <code>child_names(name, tree)</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/CliMA/ClimaCore.jl/blob/afd7f8e524c06f648ae510d832b57e21d641b1d4/src/MatrixFields/field_name.jl#L104-L110">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="ClimaCore.MatrixFields.FieldNameSet" href="#ClimaCore.MatrixFields.FieldNameSet"><code>ClimaCore.MatrixFields.FieldNameSet</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">FieldNameSet{T}(values, [name_tree])</code></pre><p>An <code>AbstractSet</code> that contains values of type <code>T</code>, which serves as an analogue of a <code>KeySet</code> for a <code>FieldNameDict</code>. There are two subtypes of <code>FieldNameSet</code>:</p><ul><li><code>FieldVectorKeys</code>, for which <code>T</code> is set to <code>FieldName</code></li><li><code>FieldMatrixKeys</code>, for which <code>T</code> is set to <code>Tuple{FieldName, FieldName}</code>; each tuple of type <code>T</code> represents a pair of row-column indices</li></ul><p>Since <code>FieldName</code>s are singleton types, the result of almost any <code>FieldNameSet</code> operation can be inferred during compilation. So, with the exception of <code>map</code>, <code>foreach</code>, and <code>set_string</code>, functions of <code>FieldNameSet</code>s do not have any performance cost at runtime (as long as their arguments are inferrable).</p><p>Unlike other <code>AbstractSet</code>s, <code>FieldNameSet</code> has special behavior for overlapping values. For example, the <code>FieldName</code>s <code>@name(a.b)</code> and <code>@name(a.b.c)</code> overlap, so any set operation needs to first decompose <code>@name(a.b)</code> into its child values before combining it with <code>@name(a.b.c)</code>. In order to support this (and also to support the ability to compute set complements), <code>FieldNameSet</code> stores a <code>FieldNameTree</code> <code>name_tree</code>, which it uses to infer child values. If <code>name_tree</code> is not specified, it gets set to <code>nothing</code> by default, which causes some <code>FieldNameSet</code> operations to become disabled. For binary operations like <code>union</code> or <code>setdiff</code>, only one set needs to specify a <code>name_tree</code>; if two sets both specify a <code>name_tree</code>, the <code>name_tree</code>s must be identical.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/CliMA/ClimaCore.jl/blob/afd7f8e524c06f648ae510d832b57e21d641b1d4/src/MatrixFields/field_name_set.jl#L3-L27">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="ClimaCore.MatrixFields.FieldNameDict" href="#ClimaCore.MatrixFields.FieldNameDict"><code>ClimaCore.MatrixFields.FieldNameDict</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">FieldNameDict{T1, T2}(keys, entries)
FieldNameDict{T1, T2}(key_entry_pairs...)</code></pre><p>An <code>AbstractDict</code> that contains keys of type <code>T1</code> and entries of type <code>T2</code>, where the keys are stored as a <code>FieldNameSet{T1}</code>. There are four commonly used subtypes of <code>FieldNameDict</code>:</p><ul><li><code>FieldMatrix</code>, which maps a set of <code>FieldMatrixKeys</code> to either <code>ColumnwiseBandMatrixField</code>s or multiples of <code>LinearAlgebra.I</code>; this is the only user-facing subtype of <code>FieldNameDict</code></li><li><code>FieldVectorView</code>, which maps a set of <code>FieldVectorKeys</code> to <code>Field</code>s; this subtype is automatically generated when a <code>FieldVector</code> is used in the same operation as a <code>FieldMatrix</code> (e.g., when both appear in the same broadcast expression or are passed to a <code>FieldMatrixSolver</code>)</li><li><code>FieldMatrixBroadcasted</code> and <code>FieldVectorViewBroadcasted</code>, which are the same as <code>FieldMatrix</code> and <code>FieldVectorView</code>, except that they can also store unevaluated broadcast expressions; these subtypes are automatically generated when a <code>FieldMatrix</code> or a <code>FieldVectorView</code> is used in a broadcast expression</li></ul><p>The entry at a specific key can be extracted by calling <code>dict[key]</code>, and the entries that correspond to all the keys in a <code>FieldNameSet</code> can be extracted by calling <code>dict[set]</code>. If <code>dict</code> is a <code>FieldMatrix</code>, the corresponding identity matrix can be computed by calling <code>one(dict)</code>.</p><p>When broadcasting over <code>FieldNameDict</code>s, the following operations are supported:</p><ul><li>Addition and subtraction</li><li>Multiplication, where the first argument must be a <code>FieldMatrix</code> (or <code>FieldMatrixBroadcasted</code>)</li><li>Inversion, where the argument must be a diagonal <code>FieldMatrix</code> (or <code>FieldMatrixBroadcasted</code>), i.e., one in which every entry is either a <code>ColumnwiseBandMatrixField</code> of <code>DiagonalMatrixRow</code>s or a multiple of <code>LinearAlgebra.I</code></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/CliMA/ClimaCore.jl/blob/afd7f8e524c06f648ae510d832b57e21d641b1d4/src/MatrixFields/field_name_dict.jl#L1-L33">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="ClimaCore.MatrixFields.field_vector_view" href="#ClimaCore.MatrixFields.field_vector_view"><code>ClimaCore.MatrixFields.field_vector_view</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">field_vector_view(x)</code></pre><p>Constructs a <code>FieldVectorView</code> that contains all the top-level <code>Field</code>s in the <code>FieldVector</code> <code>x</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/CliMA/ClimaCore.jl/blob/afd7f8e524c06f648ae510d832b57e21d641b1d4/src/MatrixFields/field_name_dict.jl#L187-L192">source</a></section></article><h2 id="Utilities"><a class="docs-heading-anchor" href="#Utilities">Utilities</a><a id="Utilities-1"></a><a class="docs-heading-anchor-permalink" href="#Utilities" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="ClimaCore.MatrixFields.column_field2array" href="#ClimaCore.MatrixFields.column_field2array"><code>ClimaCore.MatrixFields.column_field2array</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">column_field2array(field)</code></pre><p>Converts a field defined on a <code>FiniteDifferenceSpace</code> into either a <code>Vector</code> or a <code>BandedMatrix</code>, depending on whether the elements of the field are single values or <code>BandMatrixRow</code>s. This involves copying the data stored in the field. Because <code>BandedMatrix</code> does not currently support operations with <code>CuArray</code>s, all GPU data is copied to the CPU.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/CliMA/ClimaCore.jl/blob/afd7f8e524c06f648ae510d832b57e21d641b1d4/src/MatrixFields/field2arrays.jl#L25-L33">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="ClimaCore.MatrixFields.column_field2array_view" href="#ClimaCore.MatrixFields.column_field2array_view"><code>ClimaCore.MatrixFields.column_field2array_view</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">column_field2array_view(field)</code></pre><p>Similar to <code>column_field2array(field)</code>, except that this version avoids copying the data stored in the field.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/CliMA/ClimaCore.jl/blob/afd7f8e524c06f648ae510d832b57e21d641b1d4/src/MatrixFields/field2arrays.jl#L64-L69">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="ClimaCore.MatrixFields.field2arrays" href="#ClimaCore.MatrixFields.field2arrays"><code>ClimaCore.MatrixFields.field2arrays</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">field2arrays(field)</code></pre><p>Converts a field defined on a <code>FiniteDifferenceSpace</code> or on an <code>ExtrudedFiniteDifferenceSpace</code> into a collection of arrays, each of which corresponds to a column of the field. This is done by calling <code>column_field2array</code> on each of the field&#39;s columns.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/CliMA/ClimaCore.jl/blob/afd7f8e524c06f648ae510d832b57e21d641b1d4/src/MatrixFields/field2arrays.jl#L101-L108">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="ClimaCore.MatrixFields.field2arrays_view" href="#ClimaCore.MatrixFields.field2arrays_view"><code>ClimaCore.MatrixFields.field2arrays_view</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">field2arrays_view(field)</code></pre><p>Similar to <code>field2arrays(field)</code>, except that this version calls <code>column_field2array_view</code> instead of <code>column_field2array</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/CliMA/ClimaCore.jl/blob/afd7f8e524c06f648ae510d832b57e21d641b1d4/src/MatrixFields/field2arrays.jl#L111-L116">source</a></section></article></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../operators/">« Operators</a><a class="docs-footer-nextpage" href="../api/">API »</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option><option value="auto">Automatic (OS)</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 1.1.0 on <span class="colophon-date" title="Thursday 12 October 2023 14:40">Thursday 12 October 2023</span>. Using Julia version 1.9.3.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
