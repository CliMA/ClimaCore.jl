<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>API · ClimaCore.jl</title><meta name="title" content="API · ClimaCore.jl"/><meta property="og:title" content="API · ClimaCore.jl"/><meta property="twitter:title" content="API · ClimaCore.jl"/><meta name="description" content="Documentation for ClimaCore.jl."/><meta property="og:description" content="Documentation for ClimaCore.jl."/><meta property="twitter:description" content="Documentation for ClimaCore.jl."/><script data-outdated-warner src="../assets/warner.js"></script><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.050/juliamono.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.16.8/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL=".."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../assets/documenter.js"></script><script src="../search_index.js"></script><script src="../siteinfo.js"></script><script src="../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><a class="docs-logo" href="../"><img src="../assets/logo.png" alt="ClimaCore.jl logo"/></a><div class="docs-package-name"><span class="docs-autofit"><a href="../">ClimaCore.jl</a></span></div><button class="docs-search-query input is-rounded is-small is-clickable my-2 mx-auto py-1 px-2" id="documenter-search-query">Search docs (Ctrl + /)</button><ul class="docs-menu"><li><a class="tocitem" href="../">Home</a></li><li><a class="tocitem" href="../intro/">Introduction</a></li><li><a class="tocitem" href="../math_framework/">Mathematical Framework</a></li><li><a class="tocitem" href="../installation_instructions/">Installation and How-to Guides</a></li><li><a class="tocitem" href="../operators/">Operators</a></li><li><a class="tocitem" href="../matrix_fields/">MatrixFields</a></li><li class="is-active"><a class="tocitem" href>API</a><ul class="internal"><li><a class="tocitem" href="#Utilities"><span>Utilities</span></a></li><li><a class="tocitem" href="#DataLayouts"><span>DataLayouts</span></a></li><li><a class="tocitem" href="#Geometry"><span>Geometry</span></a></li><li><a class="tocitem" href="#Domains"><span>Domains</span></a></li><li><a class="tocitem" href="#Meshes"><span>Meshes</span></a></li><li><a class="tocitem" href="#Topologies"><span>Topologies</span></a></li><li><a class="tocitem" href="#Spaces"><span>Spaces</span></a></li><li><a class="tocitem" href="#RecursiveApply"><span>RecursiveApply</span></a></li><li><a class="tocitem" href="#Fields"><span>Fields</span></a></li><li><a class="tocitem" href="#Hypsography"><span>Hypsography</span></a></li><li><a class="tocitem" href="#Limiters"><span>Limiters</span></a></li><li><a class="tocitem" href="#InputOutput"><span>InputOutput</span></a></li><li><a class="tocitem" href="#Remapping"><span>Remapping</span></a></li></ul></li><li><input class="collapse-toggle" id="menuitem-8" type="checkbox"/><label class="tocitem" for="menuitem-8"><span class="docs-label">Developer docs</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../performance_tips/">Performance tips</a></li></ul></li><li><input class="collapse-toggle" id="menuitem-9" type="checkbox"/><label class="tocitem" for="menuitem-9"><span class="docs-label">Tutorials</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../tutorials/introduction/">Introduction to ClimaCore.jl</a></li></ul></li><li><a class="tocitem" href="../examples/">Examples</a></li><li><input class="collapse-toggle" id="menuitem-11" type="checkbox"/><label class="tocitem" for="menuitem-11"><span class="docs-label">Libraries</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../lib/ClimaCorePlots/">ClimaCorePlots.jl</a></li><li><a class="tocitem" href="../lib/ClimaCoreMakie/">ClimaCoreMakie.jl</a></li><li><a class="tocitem" href="../lib/ClimaCoreVTK/">ClimaCoreVTK.jl</a></li><li><a class="tocitem" href="../lib/ClimaCoreTempestRemap/">ClimaCoreTempestRemap.jl</a></li><li><a class="tocitem" href="../lib/ClimaCoreSpectra/">ClimaCoreSpectra.jl</a></li></ul></li><li><a class="tocitem" href="../Contributing/">Contributing guide</a></li><li><a class="tocitem" href="../code_of_conduct/">Code of Conduct</a></li><li><a class="tocitem" href="../references/">References</a></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><a class="docs-sidebar-button docs-navbar-link fa-solid fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a><nav class="breadcrumb"><ul class="is-hidden-mobile"><li class="is-active"><a href>API</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>API</a></li></ul></nav><div class="docs-right"><a class="docs-navbar-link" href="https://github.com/CliMA/ClimaCore.jl" title="View the repository on GitHub"><span class="docs-icon fa-brands"></span><span class="docs-label is-hidden-touch">GitHub</span></a><a class="docs-navbar-link" href="https://github.com/CliMA/ClimaCore.jl/blob/main/docs/src/api.md" title="Edit source on GitHub"><span class="docs-icon fa-solid"></span></a><a class="docs-settings-button docs-navbar-link fa-solid fa-gear" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-article-toggle-button fa-solid fa-chevron-up" id="documenter-article-toggle-button" href="javascript:;" title="Collapse all docstrings"></a></div></header><article class="content" id="documenter-page"><h1 id="API"><a class="docs-heading-anchor" href="#API">API</a><a id="API-1"></a><a class="docs-heading-anchor-permalink" href="#API" title="Permalink"></a></h1><h2 id="Utilities"><a class="docs-heading-anchor" href="#Utilities">Utilities</a><a id="Utilities-1"></a><a class="docs-heading-anchor-permalink" href="#Utilities" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="ClimaCore.Utilities.PlusHalf" href="#ClimaCore.Utilities.PlusHalf"><code>ClimaCore.Utilities.PlusHalf</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">PlusHalf(i)</code></pre><p>Represents <code>i + 1/2</code>, but stored as internally as an integer value. Used for indexing into staggered finite difference meshes: the convention &quot;half&quot; values are indexed at cell faces, whereas centers are indexed at cell centers.</p><p>Supports <code>+</code>, <code>-</code> and inequalities.</p><p>See also <a href="#ClimaCore.Utilities.half"><code>half</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/CliMA/ClimaCore.jl/blob/v0.14.5/src/Utilities/plushalf.jl#L1-L11">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="ClimaCore.Utilities.half" href="#ClimaCore.Utilities.half"><code>ClimaCore.Utilities.half</code></a> — <span class="docstring-category">Constant</span></header><section><div><pre><code class="language-julia hljs">const half = PlusHalf(0)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/CliMA/ClimaCore.jl/blob/v0.14.5/src/Utilities/plushalf.jl#L17-L19">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="ClimaCore.Utilities.UnrolledFunctions" href="#ClimaCore.Utilities.UnrolledFunctions"><code>ClimaCore.Utilities.UnrolledFunctions</code></a> — <span class="docstring-category">Module</span></header><section><div><pre><code class="language-julia hljs">UnrolledFunctions</code></pre><p>A collection of generated functions that get unrolled during compilation, which make it possible to iterate over nonuniform collections without sacrificing type-stability.</p><p>The functions exported by this module are</p><ul><li><code>unrolled_map(f, values, [values2])</code>: alternative to <code>map</code></li><li><code>unrolled_any(f, values)</code>: alternative to <code>any</code></li><li><code>unrolled_all(f, values)</code>: alternative to <code>all</code></li><li><code>unrolled_filter(f, values)</code>: alternative to <code>filter</code></li><li><code>unrolled_foreach(f, values)</code>: alternative to <code>foreach</code></li><li><code>unrolled_in(value, values)</code>: alternative to <code>in</code></li><li><code>unrolled_unique(values)</code>: alternative to <code>unique</code></li><li><code>unrolled_flatten(values)</code>: alternative to <code>Iterators.flatten</code></li><li><code>unrolled_flatmap(f, values)</code>: alternative to <code>Iterators.flatmap</code></li><li><code>unrolled_product(values1, values2)</code>: alternative to <code>Iterators.product</code></li><li><code>unrolled_findonly(f, values)</code>: checks that only one value satisfies <code>f</code>, and then returns that value</li><li><code>unrolled_split(f, values)</code>: returns a tuple that contains the result of calling <code>unrolled_filter</code> with <code>f</code> and the result of calling it with <code>!f</code></li><li><code>unrolled_take(values, ::Val{N})</code>: alternative to <code>Iterators.take</code>, but with an <code>Int</code> wrapped in a <code>Val</code> as the second argument instead of a regular <code>Int</code>; this usually compiles more quickly than <code>values[1:N]</code></li><li><code>unrolled_drop(values, ::Val{N})</code>: alternative to <code>Iterators.drop</code>, but with an <code>Int</code> wrapped in a <code>Val</code> as the second argument instead of a regular <code>Int</code>; this usually compiles more quickly than <code>values[(end - N + 1):end]</code></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/CliMA/ClimaCore.jl/blob/v0.14.5/src/Utilities/unrolled_functions.jl#L1-L29">source</a></section></article><h3 id="Utilities.Cache"><a class="docs-heading-anchor" href="#Utilities.Cache">Utilities.Cache</a><a id="Utilities.Cache-1"></a><a class="docs-heading-anchor-permalink" href="#Utilities.Cache" title="Permalink"></a></h3><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="ClimaCore.Utilities.Cache" href="#ClimaCore.Utilities.Cache"><code>ClimaCore.Utilities.Cache</code></a> — <span class="docstring-category">Module</span></header><section><div><p><strong><code>Utilities.Cache</code></strong></p><p>ClimaCore maintains an internal cache of topology and grid objects: this ensures that if the constructor with the same arguments is invoked again (e.g. by reading from a file), the cached object will be returned (also known as <em>memoization</em>). This has two main advantages:</p><ol><li><p>topology and metric information can be reused, reducing memory usage.</p></li><li><p>it is easy to check if two fields live on the same grid: we can just check if the underlying grid objects are the same (<code>===</code>), rather than checking all the fields are equal (via <code>==</code>).</p></li></ol><p>However this means that objects in the cache will not be removed from the garbage collector, so we provide an interface to remove these.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/CliMA/ClimaCore.jl/blob/v0.14.5/src/Utilities/cache.jl#L1-L17">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="ClimaCore.Utilities.Cache.cached_objects" href="#ClimaCore.Utilities.Cache.cached_objects"><code>ClimaCore.Utilities.Cache.cached_objects</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">Utilities.Cache.cached_objects()</code></pre><p>List all currently cached objects.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/CliMA/ClimaCore.jl/blob/v0.14.5/src/Utilities/cache.jl#L23-L27">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="ClimaCore.Utilities.Cache.clean_cache!" href="#ClimaCore.Utilities.Cache.clean_cache!"><code>ClimaCore.Utilities.Cache.clean_cache!</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">Utilities.Cache.clean_cache!(object)</code></pre><p>Remove <code>object</code> from the cache of created objects. </p><p>In most cases, this function should not need to be called, unless you are constructing many grid objects, for example when doing a sweep over grid paramaters.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/CliMA/ClimaCore.jl/blob/v0.14.5/src/Utilities/cache.jl#L33-L41">source</a></section><section><div><pre><code class="language-julia hljs">Utilities.Cache.clean_cache!()</code></pre><p>Remove all objects from the cache of created objects. </p><p>In most cases, this function should not need to be called, unless you are constructing many grid objects, for example when doing a sweep over grid paramaters.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/CliMA/ClimaCore.jl/blob/v0.14.5/src/Utilities/cache.jl#L49-L57">source</a></section></article><h2 id="DataLayouts"><a class="docs-heading-anchor" href="#DataLayouts">DataLayouts</a><a id="DataLayouts-1"></a><a class="docs-heading-anchor-permalink" href="#DataLayouts" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="ClimaCore.DataLayouts" href="#ClimaCore.DataLayouts"><code>ClimaCore.DataLayouts</code></a> — <span class="docstring-category">Module</span></header><section><div><pre><code class="language-julia hljs">ClimaCore.DataLayouts</code></pre><p>Notation:</p><ul><li><code>i,j</code> are horizontal node indices within an element</li><li><code>k</code> is the vertical node index within an element</li><li><code>f</code> is the field index (1 if field is scalar, &gt;1 if it is a vector field)</li><li><code>v</code> is the vertical element index in a stack</li><li><code>h</code> is the element stack index</li></ul><p>Data layout is specified by the order in which they appear, e.g. <code>IJKFVH</code> indexes the underlying array as <code>[i,j,k,f,v,h]</code></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/CliMA/ClimaCore.jl/blob/v0.14.5/src/DataLayouts/DataLayouts.jl#L1-L14">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="ClimaCore.DataLayouts.DataF" href="#ClimaCore.DataLayouts.DataF"><code>ClimaCore.DataLayouts.DataF</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">DataF{S, A} &lt;: Data0D{S}</code></pre><p>Backing <code>DataLayout</code> for 0D point data.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/CliMA/ClimaCore.jl/blob/v0.14.5/src/DataLayouts/DataLayouts.jl#L532-L536">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="ClimaCore.DataLayouts.IF" href="#ClimaCore.DataLayouts.IF"><code>ClimaCore.DataLayouts.IF</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">IF{S, Ni, A} &lt;: DataSlab1D{S, Ni}</code></pre><p>Backing <code>DataLayout</code> for 1D spectral element slab data.</p><p>Nodal element data (I) are contiguous for each <code>S</code> datatype struct field (F) for a single element slab.</p><p>A <code>DataSlab1D</code> view can be returned from other <code>Data1D</code> objects by calling <code>slab(data, idx...)</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/CliMA/ClimaCore.jl/blob/v0.14.5/src/DataLayouts/DataLayouts.jl#L790-L798">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="ClimaCore.DataLayouts.IJF" href="#ClimaCore.DataLayouts.IJF"><code>ClimaCore.DataLayouts.IJF</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">IJF{S, Nij, A} &lt;: DataSlab2D{S, Nij}</code></pre><p>Backing <code>DataLayout</code> for 2D spectral element slab data.</p><p>Nodal element data (I,J) are contiguous for each <code>S</code> datatype struct field (F) for a single element slab.</p><p>A <code>DataSlab2D</code> view can be returned from other <code>Data2D</code> objects by calling <code>slab(data, idx...)</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/CliMA/ClimaCore.jl/blob/v0.14.5/src/DataLayouts/DataLayouts.jl#L651-L659">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="ClimaCore.DataLayouts.VF" href="#ClimaCore.DataLayouts.VF"><code>ClimaCore.DataLayouts.VF</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">VF{S, A} &lt;: DataColumn{S}</code></pre><p>Backing <code>DataLayout</code> for 1D FV column data.</p><p>Column level data (V) are contiguous for each <code>S</code> datatype struct field (F).</p><p>A <code>DataColumn</code> view can be returned from other <code>Data1DX</code>, <code>Data2DX</code> objects by calling <code>column(data, idx...)</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/CliMA/ClimaCore.jl/blob/v0.14.5/src/DataLayouts/DataLayouts.jl#L888-L896">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="ClimaCore.DataLayouts.IFH" href="#ClimaCore.DataLayouts.IFH"><code>ClimaCore.DataLayouts.IFH</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">IFH{S, Ni, A} &lt;: Data1D{S, Ni}</code></pre><p>Backing <code>DataLayout</code> for 1D spectral element slabs.</p><p>Element nodal point (I) data is contiguous for each datatype <code>S</code> struct field (F), for each 1D mesh element (H).</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/CliMA/ClimaCore.jl/blob/v0.14.5/src/DataLayouts/DataLayouts.jl#L400-L407">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="ClimaCore.DataLayouts.IJFH" href="#ClimaCore.DataLayouts.IJFH"><code>ClimaCore.DataLayouts.IJFH</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">IJFH{S, Nij, A} &lt;: Data2D{S, Nij}</code></pre><p>Backing <code>DataLayout</code> for 2D spectral element slabs.</p><p>Element nodal point (I,J) data is contiguous for each datatype <code>S</code> struct field (F), for each 2D mesh element slab (H).</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/CliMA/ClimaCore.jl/blob/v0.14.5/src/DataLayouts/DataLayouts.jl#L244-L251">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="ClimaCore.DataLayouts.VIFH" href="#ClimaCore.DataLayouts.VIFH"><code>ClimaCore.DataLayouts.VIFH</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">VIFH{S, Ni, A} &lt;: Data1DX{S, Ni}</code></pre><p>Backing <code>DataLayout</code> for 1D spectral element slab + extruded 1D FV column data.</p><p>Column levels (V) are contiguous for every element nodal point (I) for each datatype <code>S</code> struct field (F), for each 1D mesh element slab (H).</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/CliMA/ClimaCore.jl/blob/v0.14.5/src/DataLayouts/DataLayouts.jl#L1170-L1177">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="ClimaCore.DataLayouts.VIJFH" href="#ClimaCore.DataLayouts.VIJFH"><code>ClimaCore.DataLayouts.VIJFH</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">VIJFH{S, Nij, A} &lt;: Data2DX{S, Nij}</code></pre><p>Backing <code>DataLayout</code> for 2D spectral element slab + extruded 1D FV column data.</p><p>Column levels (V) are contiguous for every element nodal point (I, J) for each <code>S</code> datatype struct field (F), for each 2D mesh element slab (H).</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/CliMA/ClimaCore.jl/blob/v0.14.5/src/DataLayouts/DataLayouts.jl#L1003-L1010">source</a></section></article><h2 id="Geometry"><a class="docs-heading-anchor" href="#Geometry">Geometry</a><a id="Geometry-1"></a><a class="docs-heading-anchor-permalink" href="#Geometry" title="Permalink"></a></h2><h3 id="Coordinates"><a class="docs-heading-anchor" href="#Coordinates">Coordinates</a><a id="Coordinates-1"></a><a class="docs-heading-anchor-permalink" href="#Coordinates" title="Permalink"></a></h3><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="ClimaCore.Geometry.AbstractPoint" href="#ClimaCore.Geometry.AbstractPoint"><code>ClimaCore.Geometry.AbstractPoint</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">AbstractPoint</code></pre><p>Represents a point in space.</p><p>The following types are supported:</p><ul><li><code>XPoint(x)</code></li><li><code>YPoint(y)</code></li><li><code>ZPoint(z)</code></li><li><code>XYPoint(x, y)</code></li><li><code>XZPoint(x, z)</code></li><li><code>XYZPoint(x, y, z)</code></li><li><code>LatPoint(lat)</code></li><li><code>LongPoint(long)</code></li><li><code>LatLongPoint(lat, long)</code></li><li><code>LatLongZPoint(lat, long, z)</code></li><li><code>Cartesian1Point(x1)</code></li><li><code>Cartesian2Point(x2)</code></li><li><code>Cartesian3Point(x3)</code></li><li><code>Cartesian12Point(x1, x2)</code></li><li><code>Cartesian13Point(x1, x3)</code></li><li><code>Cartesian123Point(x1, x2, x3)</code></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/CliMA/ClimaCore.jl/blob/v0.14.5/src/Geometry/coordinates.jl#L1-L23">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="ClimaCore.Geometry.float_type" href="#ClimaCore.Geometry.float_type"><code>ClimaCore.Geometry.float_type</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">float_type(T)</code></pre><p>Return the floating point type backing <code>T</code>: <code>T</code> can either be an object or a type.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/CliMA/ClimaCore.jl/blob/v0.14.5/src/Geometry/coordinates.jl#L26-L30">source</a></section></article><p>Points represent <em>locations</em> in space, specified by coordinates in a given coordinate system (Cartesian, spherical, etc), whereas vectors, on the other hand, represent <em>displacements</em> in space.</p><p>An analogy with time works well: times (also called instants or datetimes) are <em>locations</em> in time, while, durations are <em>displacements</em> in time.</p><p><strong>Note 1</strong>: Latitude and longitude are specified via angles (and, therefore, trigonometric functions: <code>cosd</code>, <code>sind</code>, <code>acosd</code>, <code>asind</code>, <code>tand</code>,...) in degrees, not in radians. Moreover, <code>lat</code> (usually denoted by <span>$\theta$</span>) <span>$\in [-90.0, 90.0]$</span>, and <code>long</code> (usually denoted by <span>$\lambda$</span>) <span>$\in [-180.0, 180.0]$</span>.</p><p><strong>Note 2:</strong>: In a <code>Geometry.LatLongZPoint(lat, long, z)</code>, <code>z</code> represents the elevation above the surface of the sphere with radius R (implicitly accounted for in the geoemtry).</p><p><strong>Note 3</strong>: There are also a set of specific Cartesian points (<code>Cartesian1Point(x1)</code>, <code>Cartesian2Point(x2)</code>, etc). These are occasionally useful for converting everything to a full Cartesian domain (e.g. for visualization purposes). These are distinct from <code>XYZPoint</code> as <code>ZPoint</code> can mean different things in different domains.</p><h2 id="Domains"><a class="docs-heading-anchor" href="#Domains">Domains</a><a id="Domains-1"></a><a class="docs-heading-anchor-permalink" href="#Domains" title="Permalink"></a></h2><h3 id="Types"><a class="docs-heading-anchor" href="#Types">Types</a><a id="Types-1"></a><a class="docs-heading-anchor-permalink" href="#Types" title="Permalink"></a></h3><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="ClimaCore.Domains.AbstractDomain" href="#ClimaCore.Domains.AbstractDomain"><code>ClimaCore.Domains.AbstractDomain</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">AbstractDomain</code></pre><p>A domain represents a region of space.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/CliMA/ClimaCore.jl/blob/v0.14.5/src/Domains/Domains.jl#L7-L11">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="ClimaCore.Domains.IntervalDomain" href="#ClimaCore.Domains.IntervalDomain"><code>ClimaCore.Domains.IntervalDomain</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">IntervalDomain(coord⁻, coord⁺; periodic=true)
IntervalDomain(coord⁻, coord⁺; boundary_names::Tuple{Symbol,Symbol})</code></pre><p>Construct a <code>IntervalDomain</code>, the closed interval is given by <code>coord⁻</code>, <code>coord⁺</code> coordinate arguments.</p><p>Either a <code>periodic</code> or <code>boundary_names</code> keyword argument is required.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/CliMA/ClimaCore.jl/blob/v0.14.5/src/Domains/Domains.jl#L42-L49">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="ClimaCore.Domains.RectangleDomain" href="#ClimaCore.Domains.RectangleDomain"><code>ClimaCore.Domains.RectangleDomain</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">RectangleDomain(x1::ClosedInterval, x2::ClosedInterval;
    x1boundary::Tuple{Symbol,Symbol},
    x2boundary::Tuple{Symbol,Symbol},
    x1periodic = false,
    x2periodic = false,
)</code></pre><p>Construct a <code>RectangularDomain</code> in the horizontal. If a given x1 or x2 boundary is not periodic, then <code>x1boundary</code> or <code>x2boundary</code> boundary name keyword arguments must be supplied.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/CliMA/ClimaCore.jl/blob/v0.14.5/src/Domains/Domains.jl#L105-L115">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="ClimaCore.Domains.SphereDomain" href="#ClimaCore.Domains.SphereDomain"><code>ClimaCore.Domains.SphereDomain</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">SphereDomain(radius)</code></pre><p>A domain representing the surface of a sphere with radius <code>radius</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/CliMA/ClimaCore.jl/blob/v0.14.5/src/Domains/Domains.jl#L146-L150">source</a></section></article><h3 id="Interfaces"><a class="docs-heading-anchor" href="#Interfaces">Interfaces</a><a id="Interfaces-1"></a><a class="docs-heading-anchor-permalink" href="#Interfaces" title="Permalink"></a></h3><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="ClimaCore.Domains.boundary_names" href="#ClimaCore.Domains.boundary_names"><code>ClimaCore.Domains.boundary_names</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">boundary_names(obj::Union{AbstractDomain, AbstractMesh, AbstractTopology})</code></pre><p>A tuple or vector of unique boundary names of a spatial domain.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/CliMA/ClimaCore.jl/blob/v0.14.5/src/Domains/Domains.jl#L22-L26">source</a></section></article><h2 id="Meshes"><a class="docs-heading-anchor" href="#Meshes">Meshes</a><a id="Meshes-1"></a><a class="docs-heading-anchor-permalink" href="#Meshes" title="Permalink"></a></h2><p>A <code>Mesh</code> is a division of a domain into elements.</p><h3 id="Mesh-types"><a class="docs-heading-anchor" href="#Mesh-types">Mesh types</a><a id="Mesh-types-1"></a><a class="docs-heading-anchor-permalink" href="#Mesh-types" title="Permalink"></a></h3><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="ClimaCore.Meshes.AbstractMesh" href="#ClimaCore.Meshes.AbstractMesh"><code>ClimaCore.Meshes.AbstractMesh</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">AbstractMesh{dim}</code></pre><p>A <code>Mesh</code> is an object which represents how we discretize a domain into elements.</p><p>It should be lightweight (i.e. exists on all MPI ranks), e.g for meshes stored in a file, it would contain the filename.</p><p><strong>Face and vertex numbering</strong></p><p>In 1D, faces and vertices are the same, and both are numbered <code>[1,2]</code>.</p><p>In 2D, a face is a line segment between to vertices, and both are numbered <code>[1,2,3,4]</code>, in a counter-clockwise direction.</p><pre><code class="nohighlight hljs"> v4        f3        v3
   o-----------------o
   |                 |	    face    vertices
   |                 |	      f1 =&gt;  v1 v2
f4 |                 | f2     f2 =&gt;  v2 v3
   |                 |	      f3 =&gt;  v3 v4
   |                 |        f4 =&gt;  v4 v1
   |                 |
   o-----------------o
  v1       f1        v2</code></pre><p><strong>Interface</strong></p><p>A subtype of <code>AbstractMesh</code> should define the following methods:</p><ul><li><a href="#ClimaCore.Meshes.domain"><code>domain(mesh)</code></a></li><li><a href="#ClimaCore.Meshes.elements"><code>elements(mesh)</code></a></li><li><a href="#ClimaCore.Meshes.is_boundary_face"><code>is_boundary_face(mesh, elem, face)</code></a></li><li><a href="#ClimaCore.Meshes.boundary_face_name"><code>boundary_face_name(mesh, elem, face)</code></a></li><li><a href="#ClimaCore.Meshes.opposing_face"><code>opposing_face(mesh, elem, face)</code></a></li><li><a href="#ClimaCore.Meshes.coordinates"><code>coordinates(mesh, elem, vert)</code></a></li><li><a href="#ClimaCore.Meshes.containing_element"><code>containing_element</code></a> (optional)</li></ul><p>The following types/methods are provided by <code>AbstractMesh</code>:</p><ul><li><a href="#ClimaCore.Meshes.SharedVertices"><code>SharedVertices(mesh, elem, vert)</code></a></li><li><a href="#ClimaCore.Meshes.face_connectivity_matrix"><code>face_connectivity_matrix(mesh[,elemorder])</code></a></li><li><a href="#ClimaCore.Meshes.vertex_connectivity_matrix"><code>vertex_connectivity_matrix(mesh[,elemorder])</code></a></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/CliMA/ClimaCore.jl/blob/v0.14.5/src/Meshes/Meshes.jl#L24-L66">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="ClimaCore.Meshes.IntervalMesh" href="#ClimaCore.Meshes.IntervalMesh"><code>ClimaCore.Meshes.IntervalMesh</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">IntervalMesh &lt;: AbstractMesh</code></pre><p>A 1D mesh on an <code>IntervalDomain</code>.</p><p><strong>Constuctors</strong></p><pre><code class="nohighlight hljs">IntervalMesh(domain::IntervalDomain, faces::AbstractVector)</code></pre><p>Construct a 1D mesh with face locations at <code>faces</code>.</p><pre><code class="nohighlight hljs">IntervalMesh(domain::IntervalDomain[, stretching=Uniform()]; nelems=)</code></pre><p>Constuct a 1D mesh on <code>domain</code> with <code>nelems</code> elements, using <code>stretching</code>. Possible values of <code>stretching</code> are:</p><ul><li><a href="#ClimaCore.Meshes.Uniform"><code>Uniform()</code></a></li><li><a href="#ClimaCore.Meshes.ExponentialStretching"><code>ExponentialStretching(H)</code></a></li><li><a href="#ClimaCore.Meshes.GeneralizedExponentialStretching"><code>GeneralizedExponentialStretching(dz_bottom, dz_top)</code></a></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/CliMA/ClimaCore.jl/blob/v0.14.5/src/Meshes/interval.jl#L1-L19">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="ClimaCore.Meshes.RectilinearMesh" href="#ClimaCore.Meshes.RectilinearMesh"><code>ClimaCore.Meshes.RectilinearMesh</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">RectilinearMesh &lt;: AbstractMesh2D</code></pre><p><strong>Constructors</strong></p><pre><code class="nohighlight hljs">RectilinearMesh(domain::RectangleDomain, n1, n2)</code></pre><p>Construct a <code>RectilinearMesh</code> of equally-spaced <code>n1</code> by <code>n2</code> elements on <code>domain</code>.</p><pre><code class="nohighlight hljs">RectilinearMesh(intervalmesh1::IntervalMesh1, intervalmesh2::IntervalMesh2)</code></pre><p>Construct the product mesh of <code>intervalmesh1</code> and <code>intervalmesh2</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/CliMA/ClimaCore.jl/blob/v0.14.5/src/Meshes/rectangle.jl#L1-L13">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="ClimaCore.Meshes.AbstractCubedSphere" href="#ClimaCore.Meshes.AbstractCubedSphere"><code>ClimaCore.Meshes.AbstractCubedSphere</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">AbstractCubedSphere &lt;: AbstractMesh2D</code></pre><p>This is an abstract type of cubed-sphere meshes on <code>SphereDomain</code>s. A cubed-sphere mesh has 6 panels, laid out as follows:</p><pre><code class="nohighlight hljs">                                          :   Panel 1   :
                            +-------------+-------------+
                            |     +x1     |     +x1     |
                            |             |             |
                            |    Panel    |    Panel    |
                            |+x3   5   -x3|-x2   6   +x2|
                            |     -x2     |     -x3     |
                            |             |             |
                            |     -x1     |     -x1     |
              +-------------+-------------+-------------+
              |     -x2     |     -x2     |
              |             |             |
              |    Panel    |    Panel    |
              |+x1   3   -x1|+x3   4   -x3|
              |     +x3     |     -x1     |
              |             |             |
              |     +x2     |     +x2     |
+-------------+-------------+-------------+
|     +x3     |     +x3     |
|             |             |
|    Panel    |    Panel    |
|-x2   1   +x2|+x1   2   -x1|
|     +x1     |     +x2     |
|             |             |
|     -x3     |     -x3     |
+-------------+-------------+
:   Panel 6   :</code></pre><p>This is the same panel ordering used by the S2 Geometry library (though we use 1-based instead of 0-based numering).</p><p>Elements are indexed by a <code>CartesianIndex{3}</code> object, where the components are:</p><ul><li>horizontal element index (left to right) within each panel.</li><li>vertical element index (bottom to top) within each panel.</li><li>panel number</li></ul><p>Subtypes should have the following fields:</p><ul><li><code>domain</code>: a <code>SphereDomain</code></li><li><code>ne</code>: number of elements across each panel</li></ul><p><strong>External links</strong></p><ul><li><a href="https://s2geometry.io/devguide/s2cell_hierarchy">S2Geometry library</a></li><li><a href="https://mitgcm.readthedocs.io/en/latest/phys_pkgs/exch2.html?highlight=cube%20sphere#fig-48tile">MIT GCM exch2</a></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/CliMA/ClimaCore.jl/blob/v0.14.5/src/Meshes/cubedsphere.jl#L1-L51">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="ClimaCore.Meshes.EquiangularCubedSphere" href="#ClimaCore.Meshes.EquiangularCubedSphere"><code>ClimaCore.Meshes.EquiangularCubedSphere</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">EquiangularCubedSphere &lt;: AbstractCubedSphere</code></pre><p>An equiangular gnomonic mesh proposed by [<a href="../references/#Ronchi1996">7</a>]. Uses the element indexing convention of <a href="#ClimaCore.Meshes.AbstractCubedSphere"><code>AbstractCubedSphere</code></a>.</p><p><strong>Constructors</strong></p><pre><code class="nohighlight hljs">EquiangularCubedSphere(
    domain::Domains.SphereDomain,
    ne::Integer,
    localelementmap=NormalizedBilinearMap()
    )</code></pre><p>Constuct an <code>EquiangularCubedSphere</code> on <code>domain</code> with <code>ne</code> elements across each panel.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/CliMA/ClimaCore.jl/blob/v0.14.5/src/Meshes/cubedsphere.jl#L346-L362">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="ClimaCore.Meshes.EquidistantCubedSphere" href="#ClimaCore.Meshes.EquidistantCubedSphere"><code>ClimaCore.Meshes.EquidistantCubedSphere</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">EquidistantCubedSphere &lt;: AbstractCubedSphere</code></pre><p>An equidistant gnomonic mesh outlined in [<a href="../references/#Rancic1996">8</a>] and [<a href="../references/#Nair2005">9</a>]. Uses the element indexing convention of <a href="#ClimaCore.Meshes.AbstractCubedSphere"><code>AbstractCubedSphere</code></a>.</p><p><strong>Constructors</strong></p><pre><code class="nohighlight hljs">EquidistantCubedSphere(domain::Domains.SphereDomain, ne::Integer)</code></pre><p>Constuct an <code>EquidistantCubedSphere</code> on <code>domain</code> with <code>ne</code> elements across each panel.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/CliMA/ClimaCore.jl/blob/v0.14.5/src/Meshes/cubedsphere.jl#L397-L409">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="ClimaCore.Meshes.ConformalCubedSphere" href="#ClimaCore.Meshes.ConformalCubedSphere"><code>ClimaCore.Meshes.ConformalCubedSphere</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">ConformalCubedSphere &lt;: AbstractCubedSphere</code></pre><p>A conformal mesh outlined in [<a href="../references/#Rancic1996">8</a>]. Uses the element indexing convention of <a href="#ClimaCore.Meshes.AbstractCubedSphere"><code>AbstractCubedSphere</code></a>.</p><p><strong>Constructors</strong></p><pre><code class="nohighlight hljs">ConformalCubedSphere(domain::Domains.SphereDomain, ne::Integer)</code></pre><p>Constuct a <code>ConformalCubedSphere</code> on <code>domain</code> with <code>ne</code> elements across each panel.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/CliMA/ClimaCore.jl/blob/v0.14.5/src/Meshes/cubedsphere.jl#L435-L447">source</a></section></article><h3 id="Local-element-map"><a class="docs-heading-anchor" href="#Local-element-map">Local element map</a><a id="Local-element-map-1"></a><a class="docs-heading-anchor-permalink" href="#Local-element-map" title="Permalink"></a></h3><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="ClimaCore.Meshes.LocalElementMap" href="#ClimaCore.Meshes.LocalElementMap"><code>ClimaCore.Meshes.LocalElementMap</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">LocalElementMap</code></pre><p>An abstract type of mappings from the reference element to a physical domain.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/CliMA/ClimaCore.jl/blob/v0.14.5/src/Meshes/cubedsphere.jl#L54-L58">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="ClimaCore.Meshes.IntrinsicMap" href="#ClimaCore.Meshes.IntrinsicMap"><code>ClimaCore.Meshes.IntrinsicMap</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">IntrinsicMap()</code></pre><p>This <a href="#ClimaCore.Meshes.LocalElementMap"><code>LocalElementMap</code></a> uses the intrinsic mapping of the cubed sphere to map the reference element to the physical domain.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/CliMA/ClimaCore.jl/blob/v0.14.5/src/Meshes/cubedsphere.jl#L61-L66">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="ClimaCore.Meshes.NormalizedBilinearMap" href="#ClimaCore.Meshes.NormalizedBilinearMap"><code>ClimaCore.Meshes.NormalizedBilinearMap</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">NormalizedBilinearMap()</code></pre><p>The <a href="#ClimaCore.Meshes.LocalElementMap"><code>LocalElementMap</code></a> for meshes on spherical domains of [<a href="../references/#Guba2014">10</a>]. It uses bilinear interpolation between the Cartesian coordinates of the element vertices, then normalizes the result to lie on the sphere.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/CliMA/ClimaCore.jl/blob/v0.14.5/src/Meshes/cubedsphere.jl#L69-L76">source</a></section></article><h3 id="Mesh-stretching"><a class="docs-heading-anchor" href="#Mesh-stretching">Mesh stretching</a><a id="Mesh-stretching-1"></a><a class="docs-heading-anchor-permalink" href="#Mesh-stretching" title="Permalink"></a></h3><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="ClimaCore.Meshes.Uniform" href="#ClimaCore.Meshes.Uniform"><code>ClimaCore.Meshes.Uniform</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">Uniform()</code></pre><p>Use uniformly-sized elements.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/CliMA/ClimaCore.jl/blob/v0.14.5/src/Meshes/interval.jl#L114-L118">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="ClimaCore.Meshes.ExponentialStretching" href="#ClimaCore.Meshes.ExponentialStretching"><code>ClimaCore.Meshes.ExponentialStretching</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">ExponentialStretching(H::FT)</code></pre><p>Apply exponential stretching to the domain when constructing elements. <code>H</code> is the scale height (a typical atmospheric scale height <code>H ≈ 7.5</code>km).</p><p>For an interval <span>$[z_0,z_1]$</span>, this makes the elements uniformally spaced in <span>$\zeta$</span>, where</p><p class="math-container">\[\zeta = \frac{1 - e^{-\eta/h}}{1-e^{-1/h}},\]</p><p>where <span>$\eta = \frac{z - z_0}{z_1-z_0}$</span>, and <span>$h = \frac{H}{z_1-z_0}$</span> is the non-dimensional scale height. If <code>reverse_mode</code> is <code>true</code>, the smallest element is at the top, and the largest at the bottom (this is typical for land model configurations).</p><p>Then, the user can define a stretched mesh via</p><pre><code class="nohighlight hljs">ClimaCore.Meshes.IntervalMesh(interval_domain, ExponentialStretching(H); nelems::Int, reverse_mode = false)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/CliMA/ClimaCore.jl/blob/v0.14.5/src/Meshes/interval.jl#L135-L154">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="ClimaCore.Meshes.GeneralizedExponentialStretching" href="#ClimaCore.Meshes.GeneralizedExponentialStretching"><code>ClimaCore.Meshes.GeneralizedExponentialStretching</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">GeneralizedExponentialStretching(dz_bottom::FT, dz_top::FT)</code></pre><p>Apply a generalized form of exponential stretching to the domain when constructing elements. <code>dz_bottom</code> and <code>dz_top</code> are target element grid spacings at the bottom and at the top of the vertical column domain (m). In typical atmosphere configurations, <code>dz_bottom</code> is the smallest grid spacing and <code>dz_top</code> the largest one. On the other hand, for typical land configurations, <code>dz_bottom</code> is the largest grid spacing and <code>dz_top</code> the smallest one.</p><p>For land configurations, use <code>reverse_mode</code> = <code>true</code> (default value <code>false</code>).</p><p>Then, the user can define a generalized stretched mesh via</p><pre><code class="nohighlight hljs">ClimaCore.Meshes.IntervalMesh(interval_domain, GeneralizedExponentialStretching(dz_bottom, dz_top); nelems::Int, reverse_mode = false)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/CliMA/ClimaCore.jl/blob/v0.14.5/src/Meshes/interval.jl#L188-L202">source</a></section></article><h3 id="Mesh-utilities"><a class="docs-heading-anchor" href="#Mesh-utilities">Mesh utilities</a><a id="Mesh-utilities-1"></a><a class="docs-heading-anchor-permalink" href="#Mesh-utilities" title="Permalink"></a></h3><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="ClimaCore.Meshes.truncate_mesh" href="#ClimaCore.Meshes.truncate_mesh"><code>ClimaCore.Meshes.truncate_mesh</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">truncate_mesh(
    parent_mesh::AbstractMesh,
    trunc_domain::IntervalDomain{CT},
)</code></pre><p>Constructs an <code>IntervalMesh</code>, truncating the given <code>parent_mesh</code> defined on a truncated <code>trunc_domain</code>. The truncation preserves the number of degrees of freedom covering the space from the <code>trunc_domain</code>&#39;s <code>z_bottom</code> to <code>z_top</code>, adjusting the stretching.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/CliMA/ClimaCore.jl/blob/v0.14.5/src/Meshes/interval.jl#L308-L317">source</a></section></article><h3 id="Interfaces-2"><a class="docs-heading-anchor" href="#Interfaces-2">Interfaces</a><a class="docs-heading-anchor-permalink" href="#Interfaces-2" title="Permalink"></a></h3><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="ClimaCore.Meshes.domain" href="#ClimaCore.Meshes.domain"><code>ClimaCore.Meshes.domain</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">Meshes.domain(mesh::AbstractMesh)</code></pre><p>The domain (a subtype of  <a href="#ClimaCore.Domains.AbstractDomain"><code>Domains.AbstractDomain</code></a>) on which the mesh is defined.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/CliMA/ClimaCore.jl/blob/v0.14.5/src/Meshes/Meshes.jl#L72-L76">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="ClimaCore.Meshes.elements" href="#ClimaCore.Meshes.elements"><code>ClimaCore.Meshes.elements</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">Meshes.elements(mesh::AbstractMesh)</code></pre><p>An iterator over the elements of a mesh. Elements of a mesh can be of any type.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/CliMA/ClimaCore.jl/blob/v0.14.5/src/Meshes/Meshes.jl#L79-L83">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="ClimaCore.Meshes.nelements" href="#ClimaCore.Meshes.nelements"><code>ClimaCore.Meshes.nelements</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">nelements(mesh::AbstractMesh)</code></pre><p>The number of elements in the mesh.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/CliMA/ClimaCore.jl/blob/v0.14.5/src/Meshes/common.jl#L4-L8">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="ClimaCore.Meshes.is_boundary_face" href="#ClimaCore.Meshes.is_boundary_face"><code>ClimaCore.Meshes.is_boundary_face</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">Meshes.is_boundary_face(mesh::AbstractMesh, elem, face::Int)::Bool</code></pre><p>Determine whether face <code>face</code> of element <code>elem</code> is on the boundary of <code>mesh</code>.</p><p><code>elem</code> should be an element of <a href="#ClimaCore.Meshes.elements"><code>elements(mesh)</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/CliMA/ClimaCore.jl/blob/v0.14.5/src/Meshes/Meshes.jl#L86-L92">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="ClimaCore.Meshes.boundary_face_name" href="#ClimaCore.Meshes.boundary_face_name"><code>ClimaCore.Meshes.boundary_face_name</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">Meshes.boundary_face_name(mesh::AbstractMesh, elem, face::Int)::Union{Symbol,Nothing}</code></pre><p>The name of the boundary facing <code>face</code> of element <code>elem</code>, or <code>nothing</code> if it is not on the boundary.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/CliMA/ClimaCore.jl/blob/v0.14.5/src/Meshes/Meshes.jl#L95-L100">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="ClimaCore.Meshes.opposing_face" href="#ClimaCore.Meshes.opposing_face"><code>ClimaCore.Meshes.opposing_face</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">opelem, opface, reversed = Meshes.opposing_face(mesh::AbstractMesh, elem, face::Int)</code></pre><p>The element and face (<code>opelem</code>, <code>opface</code>) that oppose face <code>face</code> of element <code>elem</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/CliMA/ClimaCore.jl/blob/v0.14.5/src/Meshes/Meshes.jl#L103-L107">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="ClimaCore.Meshes.coordinates" href="#ClimaCore.Meshes.coordinates"><code>ClimaCore.Meshes.coordinates</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">Meshes.coordinates(mesh, elem, vert::Int)
Meshes.coordinates(mesh, elem, ξ::SVector)</code></pre><p>Return the physical coordinates of a point in an element <code>elem</code> of <code>mesh</code>. The position of the point can either be a vertex number <code>vert</code> or the coordinates <code>ξ</code> in the reference element.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/CliMA/ClimaCore.jl/blob/v0.14.5/src/Meshes/common.jl#L164-L171">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="ClimaCore.Meshes.containing_element" href="#ClimaCore.Meshes.containing_element"><code>ClimaCore.Meshes.containing_element</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">elem = Meshes.containing_element(mesh::AbstractMesh, coord)</code></pre><p>The element <code>elem</code> in <code>mesh</code> containing the coordinate <code>coord</code>. If the coordinate falls on the boundary between two or more elements, an arbitrary element is chosen.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/CliMA/ClimaCore.jl/blob/v0.14.5/src/Meshes/common.jl#L181-L187">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="ClimaCore.Meshes.reference_coordinates" href="#ClimaCore.Meshes.reference_coordinates"><code>ClimaCore.Meshes.reference_coordinates</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">ξ = Meshes.reference_coordinates(mesh::AbstractMesh, elem, coord)</code></pre><p>An <code>SVector</code> of coordinates in the reference element such that</p><pre><code class="nohighlight hljs">Meshes.coordinates(mesh, elem, ξ) == coord</code></pre><p>This can be used for interpolation to a specific point.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/CliMA/ClimaCore.jl/blob/v0.14.5/src/Meshes/common.jl#L190-L198">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="ClimaCore.Meshes.SharedVertices" href="#ClimaCore.Meshes.SharedVertices"><code>ClimaCore.Meshes.SharedVertices</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">Meshes.SharedVertices(mesh, elem, vert)</code></pre><p>An iterator over (element, vertex) pairs that are shared with <code>(elem,vert)</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/CliMA/ClimaCore.jl/blob/v0.14.5/src/Meshes/common.jl#L28-L32">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="ClimaCore.Meshes.face_connectivity_matrix" href="#ClimaCore.Meshes.face_connectivity_matrix"><code>ClimaCore.Meshes.face_connectivity_matrix</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">M = Meshes.face_connectivity_matrix(mesh, elemorder = elements(mesh))</code></pre><p>Construct a <code>Bool</code>-valued <code>SparseCSCMatrix</code> containing the face connections of <code>mesh</code>. Elements are indexed according to <code>elemorder</code>.</p><p>Note that <code>M[i,i] == true</code> only if two distinct faces of element <code>i</code> are connected.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/CliMA/ClimaCore.jl/blob/v0.14.5/src/Meshes/common.jl#L101-L108">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="ClimaCore.Meshes.vertex_connectivity_matrix" href="#ClimaCore.Meshes.vertex_connectivity_matrix"><code>ClimaCore.Meshes.vertex_connectivity_matrix</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">M = Meshes.vertex_connectivity_matrix(mesh, elemorder = elements(mesh))</code></pre><p>Construct a <code>Bool</code>-valued <code>SparseCSCMatrix</code> containing the vertex connections of <code>mesh</code>. Elements are indexed according to <code>elemorder</code>.</p><p>Note that <code>M[i,i] == true</code> only if two distinct vertices of element <code>i</code> are connected.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/CliMA/ClimaCore.jl/blob/v0.14.5/src/Meshes/common.jl#L132-L139">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="ClimaCore.Meshes.linearindices" href="#ClimaCore.Meshes.linearindices"><code>ClimaCore.Meshes.linearindices</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">Meshes.linearindices(elemorder)</code></pre><p>Given a data structure <code>elemorder[i] = elem</code> that orders elements, construct the inverse map from <code>orderindex = linearindices(elemorder)</code> such that <code>orderindex[elem] = i</code>.</p><p>This will try to use the most efficient structure available.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/CliMA/ClimaCore.jl/blob/v0.14.5/src/Meshes/common.jl#L75-L83">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="ClimaCore.Meshes.element_horizontal_length_scale" href="#ClimaCore.Meshes.element_horizontal_length_scale"><code>ClimaCore.Meshes.element_horizontal_length_scale</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">Meshes.element_horizontal_length_scale(mesh::AbstractMesh)</code></pre><p>The approximate length scale (in units of distance) of the elements of the mesh.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/CliMA/ClimaCore.jl/blob/v0.14.5/src/Meshes/Meshes.jl#L110-L114">source</a></section></article><h2 id="Topologies"><a class="docs-heading-anchor" href="#Topologies">Topologies</a><a id="Topologies-1"></a><a class="docs-heading-anchor-permalink" href="#Topologies" title="Permalink"></a></h2><p>A <code>Topology</code> determines the ordering and connections between elements of a mesh. <img src="../cubedsphere_spacefillingcurve.png" alt="Space-filling curve element ordering for a cubed sphere mesh"/></p><h3 id="Types-2"><a class="docs-heading-anchor" href="#Types-2">Types</a><a class="docs-heading-anchor-permalink" href="#Types-2" title="Permalink"></a></h3><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="ClimaCore.Topologies.AbstractTopology" href="#ClimaCore.Topologies.AbstractTopology"><code>ClimaCore.Topologies.AbstractTopology</code></a> — <span class="docstring-category">Type</span></header><section><div><p>AbstractTopology</p><p>Subtypes of <code>AbstractHorizontalTopology</code> define connectiveness of a mesh in the horizontal domain.</p><p><strong>Interfaces</strong></p><ul><li><a href="#ClimaCore.Topologies.nelems"><code>nelems</code></a></li><li><a href="#ClimaCore.Meshes.domain"><code>domain(topology::AbstractTopology)</code></a></li><li><a href="#ClimaCore.Topologies.mesh"><code>mesh</code></a></li><li><a href="#ClimaCore.Topologies.nlocalelems"><code>nlocalelems</code></a></li><li><a href="#ClimaCore.Topologies.nneighbors"><code>nneighbors</code></a></li><li><a href="#ClimaCore.Topologies.nsendelems"><code>nsendelems</code></a></li><li><a href="#ClimaCore.Topologies.nghostelems"><code>nghostelems</code></a></li><li><a href="#ClimaCore.Topologies.localelemindex"><code>localelemindex</code></a></li><li><a href="#ClimaCore.Topologies.vertex_coordinates"><code>vertex_coordinates</code></a></li><li><a href="#ClimaCore.Topologies.opposing_face"><code>opposing_face</code></a></li><li><a href="#ClimaCore.Topologies.face_node_index"><code>face_node_index</code></a></li><li><a href="#ClimaCore.Topologies.interior_faces"><code>interior_faces</code></a></li><li><a href="#ClimaCore.Topologies.ghost_faces"><code>ghost_faces</code></a></li><li><a href="#ClimaCore.Topologies.vertex_node_index"><code>vertex_node_index</code></a></li><li><a href="#ClimaCore.Topologies.local_neighboring_elements"><code>local_neighboring_elements</code></a></li><li><a href="#ClimaCore.Topologies.ghost_neighboring_elements"><code>ghost_neighboring_elements</code></a></li><li><a href="#ClimaCore.Topologies.local_vertices"><code>local_vertices</code></a></li><li><a href="#ClimaCore.Topologies.ghost_vertices"><code>ghost_vertices</code></a></li><li><a href="#ClimaCore.Topologies.neighbors"><code>neighbors</code></a></li><li><a href="#ClimaCore.Topologies.boundary_tags"><code>boundary_tags</code></a></li><li><a href="#ClimaCore.Topologies.boundary_tag"><code>boundary_tag</code></a></li><li><a href="#ClimaCore.Topologies.boundary_faces"><code>boundary_faces</code></a></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/CliMA/ClimaCore.jl/blob/v0.14.5/src/Topologies/Topologies.jl#L17-L48">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="ClimaCore.Topologies.IntervalTopology" href="#ClimaCore.Topologies.IntervalTopology"><code>ClimaCore.Topologies.IntervalTopology</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">IntervalTopology([context::SingletonCommsContext,] mesh::IntervalMesh)</code></pre><p>A sequential topology on an <a href="#ClimaCore.Meshes.IntervalMesh"><code>Meshes.IntervalMesh</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/CliMA/ClimaCore.jl/blob/v0.14.5/src/Topologies/interval.jl#L3-L7">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="ClimaCore.Topologies.Topology2D" href="#ClimaCore.Topologies.Topology2D"><code>ClimaCore.Topologies.Topology2D</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">Topology2D(mesh::AbstractMesh2D, elemorder=Mesh.elements(mesh))</code></pre><p>This is a distributed topology for 2D meshes. <code>elemorder</code> is a vector or other linear ordering of the <code>Mesh.elements(mesh)</code>. <code>elempid</code> is a sorted vector of the same length as <code>elemorder</code>, each element of which contains the <code>pid</code> of the owning process.</p><p>Internally, we can refer to elements in several different ways:</p><ul><li><code>elem</code>: an element of the <code>mesh</code>. Often a <code>CartesianIndex</code> object.</li><li><code>gidx</code>: &quot;global index&quot;: an enumeration of all elements:<ul><li><code>elemorder[gidx] == elem</code></li><li><code>orderindex[elem] == gidx</code></li></ul></li><li><code>lidx</code>: &quot;local index&quot;: an enumeration of local elements.<ul><li><code>local_elem_gidx[lidx] == gidx</code></li></ul></li><li><code>sidx</code>: &quot;send index&quot;: an index into the send buffer of a local element. A single local element may have multiple <code>sidx</code>s if it needs to be send to multiple processes.<ul><li><code>send_elem_lidx[sidx] == lidx</code></li></ul></li><li><code>ridx</code>: &quot;receive index&quot;: an index into the receive buffer of a ghost element.<ul><li><code>recv_elem_gidx[ridx] == gidx</code></li></ul></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/CliMA/ClimaCore.jl/blob/v0.14.5/src/Topologies/topology2d.jl#L4-L25">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="ClimaCore.Topologies.spacefillingcurve" href="#ClimaCore.Topologies.spacefillingcurve"><code>ClimaCore.Topologies.spacefillingcurve</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">spacefillingcurve(mesh::Meshes.AbstractCubedSphere)</code></pre><p>Generate element ordering, <code>elemorder</code>, based on a space filling curve for a <code>CubedSphere</code> mesh.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/CliMA/ClimaCore.jl/blob/v0.14.5/src/Topologies/topology2d.jl#L146-L152">source</a></section><section><div><pre><code class="language-julia hljs">spacefillingcurve(mesh::Meshes.RectilinearMesh)</code></pre><p>Generate element ordering, <code>elemorder</code>, based on a space filling curve for a <code>Rectilinear</code> mesh.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/CliMA/ClimaCore.jl/blob/v0.14.5/src/Topologies/topology2d.jl#L169-L175">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="ClimaCore.Topologies.nelems" href="#ClimaCore.Topologies.nelems"><code>ClimaCore.Topologies.nelems</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">nelems(topology)</code></pre><p>The total number of elements in <code>topology</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/CliMA/ClimaCore.jl/blob/v0.14.5/src/Topologies/Topologies.jl#L94-L98">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="ClimaCore.Topologies.nneighbors" href="#ClimaCore.Topologies.nneighbors"><code>ClimaCore.Topologies.nneighbors</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">nneighbors(topology)</code></pre><p>The number of neighbors of this process in <code>topology</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/CliMA/ClimaCore.jl/blob/v0.14.5/src/Topologies/Topologies.jl#L108-L112">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="ClimaCore.Topologies.nsendelems" href="#ClimaCore.Topologies.nsendelems"><code>ClimaCore.Topologies.nsendelems</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">nsendelems(topology)</code></pre><p>The number of elements to send to neighbors in <code>topology</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/CliMA/ClimaCore.jl/blob/v0.14.5/src/Topologies/Topologies.jl#L116-L120">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="ClimaCore.Topologies.nghostelems" href="#ClimaCore.Topologies.nghostelems"><code>ClimaCore.Topologies.nghostelems</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">nghostelems(topology)</code></pre><p>The number of ghost elements in <code>topology</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/CliMA/ClimaCore.jl/blob/v0.14.5/src/Topologies/Topologies.jl#L125-L129">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="ClimaCore.Topologies.localelemindex" href="#ClimaCore.Topologies.localelemindex"><code>ClimaCore.Topologies.localelemindex</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">localelemindex(topology, elem)</code></pre><p>The local index for the specified element; useful for distributed topologies.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/CliMA/ClimaCore.jl/blob/v0.14.5/src/Topologies/Topologies.jl#L134-L138">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="ClimaCore.Topologies.face_node_index" href="#ClimaCore.Topologies.face_node_index"><code>ClimaCore.Topologies.face_node_index</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">i,j = face_node_index(face, Nq, q, reversed=false)</code></pre><p>The node indices of the <code>q</code>th node on face <code>face</code>, where <code>Nq</code> is the number of face nodes in each direction.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/CliMA/ClimaCore.jl/blob/v0.14.5/src/Topologies/Topologies.jl#L159-L164">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="ClimaCore.Topologies.ghost_faces" href="#ClimaCore.Topologies.ghost_faces"><code>ClimaCore.Topologies.ghost_faces</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">ghost_faces(topology::AbstractTopology)</code></pre><p>An iterator over the ghost faces of <code>topology</code>. Each element of the iterator is a 5-tuple the form</p><pre><code class="nohighlight hljs">(elem1, face1, elem2, face2, reversed)</code></pre><p>where <code>elemX, faceX</code> are the element and face numbers, and <code>reversed</code> indicates whether they have opposing orientations.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/CliMA/ClimaCore.jl/blob/v0.14.5/src/Topologies/Topologies.jl#L198-L208">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="ClimaCore.Topologies.vertex_node_index" href="#ClimaCore.Topologies.vertex_node_index"><code>ClimaCore.Topologies.vertex_node_index</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">i,j = vertex_node_index(vertex_num, Nq)</code></pre><p>The node indices of <code>vertex_num</code>, where <code>Nq</code> is the number of face nodes in each direction.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/CliMA/ClimaCore.jl/blob/v0.14.5/src/Topologies/Topologies.jl#L232-L237">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="ClimaCore.Topologies.local_vertices" href="#ClimaCore.Topologies.local_vertices"><code>ClimaCore.Topologies.local_vertices</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">local_vertices(topology)</code></pre><p>An iterator over the interior vertices of <code>topology</code>. Each vertex is an iterator over <code>(lidx, vert)</code> pairs.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/CliMA/ClimaCore.jl/blob/v0.14.5/src/Topologies/Topologies.jl#L293-L298">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="ClimaCore.Topologies.ghost_vertices" href="#ClimaCore.Topologies.ghost_vertices"><code>ClimaCore.Topologies.ghost_vertices</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">ghost_vertices(topology)</code></pre><p>An iterator over the ghost vertices of <code>topology</code>. Each vertex is an iterator over <code>(isghost, lidx/ridx, vert)</code> pairs.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/CliMA/ClimaCore.jl/blob/v0.14.5/src/Topologies/Topologies.jl#L301-L306">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="ClimaCore.Topologies.neighbors" href="#ClimaCore.Topologies.neighbors"><code>ClimaCore.Topologies.neighbors</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">neighbors(topology)</code></pre><p>Returns an array of the PIDs of the neighbors of this process.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/CliMA/ClimaCore.jl/blob/v0.14.5/src/Topologies/Topologies.jl#L309-L313">source</a></section></article><h3 id="Interfaces-3"><a class="docs-heading-anchor" href="#Interfaces-3">Interfaces</a><a class="docs-heading-anchor-permalink" href="#Interfaces-3" title="Permalink"></a></h3><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="ClimaCore.Topologies.mesh" href="#ClimaCore.Topologies.mesh"><code>ClimaCore.Topologies.mesh</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">mesh(topology)</code></pre><p>Returns the mesh underlying the <code>topology</code></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/CliMA/ClimaCore.jl/blob/v0.14.5/src/Topologies/Topologies.jl#L87-L91">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="ClimaCore.Topologies.nlocalelems" href="#ClimaCore.Topologies.nlocalelems"><code>ClimaCore.Topologies.nlocalelems</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">nlocalelems(topology)</code></pre><p>The number of local elements in <code>topology</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/CliMA/ClimaCore.jl/blob/v0.14.5/src/Topologies/Topologies.jl#L101-L105">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="ClimaCore.Topologies.vertex_coordinates" href="#ClimaCore.Topologies.vertex_coordinates"><code>ClimaCore.Topologies.vertex_coordinates</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">(c1,c2,c3,c4) = vertex_coordinates(topology, elem)</code></pre><p>The coordinates of the 4 vertices of element <code>elem</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/CliMA/ClimaCore.jl/blob/v0.14.5/src/Topologies/Topologies.jl#L141-L145">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="ClimaCore.Topologies.opposing_face" href="#ClimaCore.Topologies.opposing_face"><code>ClimaCore.Topologies.opposing_face</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">(opelem, opface, reversed) = opposing_face(topology, elem, face)</code></pre><p>The opposing face of face number <code>face</code> of element <code>elem</code> in <code>topology</code>.</p><ul><li><code>opelem</code> is the opposing element number, 0 for a boundary, negative for a ghost element</li><li><code>opface</code> is the opposite face number, or boundary face number if a boundary</li><li><code>reversed</code> indicates whether the opposing face has the opposite orientation.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/CliMA/ClimaCore.jl/blob/v0.14.5/src/Topologies/Topologies.jl#L148-L156">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="ClimaCore.Topologies.interior_faces" href="#ClimaCore.Topologies.interior_faces"><code>ClimaCore.Topologies.interior_faces</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">interior_faces(topology::AbstractTopology)</code></pre><p>An iterator over the interior faces of <code>topology</code>. Each element of the iterator is a 5-tuple the form</p><pre><code class="nohighlight hljs">(elem1, face1, elem2, face2, reversed)</code></pre><p>where <code>elemX, faceX</code> are the element and face numbers, and <code>reversed</code> indicates whether they have opposing orientations.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/CliMA/ClimaCore.jl/blob/v0.14.5/src/Topologies/Topologies.jl#L180-L190">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="ClimaCore.Topologies.boundary_tags" href="#ClimaCore.Topologies.boundary_tags"><code>ClimaCore.Topologies.boundary_tags</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">boundary_tags(topology)</code></pre><p>A <code>Tuple</code> or <code>NamedTuple</code> of the boundary tags of the topology. A boundary tag is an integer that uniquely identifies a boundary.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/CliMA/ClimaCore.jl/blob/v0.14.5/src/Topologies/Topologies.jl#L317-L322">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="ClimaCore.Topologies.boundary_tag" href="#ClimaCore.Topologies.boundary_tag"><code>ClimaCore.Topologies.boundary_tag</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">boundary_tag(topology, name::Symbol)</code></pre><p>The boundary tag of the topology for boundary name <code>name</code>. A boundary tag is an integer that uniquely identifies a boundary.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/CliMA/ClimaCore.jl/blob/v0.14.5/src/Topologies/Topologies.jl#L325-L330">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="ClimaCore.Topologies.boundary_faces" href="#ClimaCore.Topologies.boundary_faces"><code>ClimaCore.Topologies.boundary_faces</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">boundary_faces(topology, boundarytag)</code></pre><p>An iterator over the faces of <code>topology</code> which face the boundary with tag <code>boundarytag</code>. Each element of the iterator is an <code>(elem, face)</code> pair.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/CliMA/ClimaCore.jl/blob/v0.14.5/src/Topologies/Topologies.jl#L333-L338">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="ClimaCore.Topologies.local_neighboring_elements" href="#ClimaCore.Topologies.local_neighboring_elements"><code>ClimaCore.Topologies.local_neighboring_elements</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">local_neighboring_elements(topology::AbstractTopology, lidx::Integer)</code></pre><p>An iterator of the local element indices (lidx) of the local elements which are neighbors of the local element <code>lidx</code> in <code>topology</code> (excluding <code>lidx</code> itself).</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/CliMA/ClimaCore.jl/blob/v0.14.5/src/Topologies/Topologies.jl#L216-L221">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="ClimaCore.Topologies.ghost_neighboring_elements" href="#ClimaCore.Topologies.ghost_neighboring_elements"><code>ClimaCore.Topologies.ghost_neighboring_elements</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">ghost_neighboring_elements(topology::AbstractTopology, ridx::Integer)</code></pre><p>An iterator of the receive buffer indices (ridx) of the ghost elements which are neighbors  of the local element <code>lidx</code> in <code>topology</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/CliMA/ClimaCore.jl/blob/v0.14.5/src/Topologies/Topologies.jl#L224-L229">source</a></section></article><h2 id="Spaces"><a class="docs-heading-anchor" href="#Spaces">Spaces</a><a id="Spaces-1"></a><a class="docs-heading-anchor-permalink" href="#Spaces" title="Permalink"></a></h2><p>A <code>Space</code> represents a discretized function space over some domain. Currently two main discretizations are supported: Spectral Element Discretization (both Continuous Galerkin and Discontinuous Galerkin types) and a staggered Finite Difference Discretization. Combination of these two in the horizontal/vertical directions, respectively, is what we call a <em>hybrid</em> space.</p><p>Sketch of a 2DX hybrid discretization:</p><p><img src="../DiscretizationSketch.png" alt="3D hybrid discretization in a Cartesian domain"/></p><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="ClimaCore.Spaces" href="#ClimaCore.Spaces"><code>ClimaCore.Spaces</code></a> — <span class="docstring-category">Module</span></header><section><div><pre><code class="language-julia hljs">Meshes</code></pre><ul><li>domain</li><li>topology</li><li>coordinates</li><li>metric terms (inverse partial derivatives)</li><li>quadrature rules and weights</li></ul><p><strong>References / notes</strong></p><ul><li><a href="https://ceed.exascaleproject.org/ceed-code/">ceed</a></li><li><a href="https://github.com/CliMA/ClimateMachine.jl/blob/ans/sphere/test/Numerics/DGMethods/compressible_navier_stokes_equations/sphere/sphere_helper_functions.jl">QA</a></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/CliMA/ClimaCore.jl/blob/v0.14.5/src/Spaces/Spaces.jl#L1-L14">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="ClimaCore.Spaces.Δz_data" href="#ClimaCore.Spaces.Δz_data"><code>ClimaCore.Spaces.Δz_data</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">Δz_data(space::AbstractSpace)</code></pre><p>A DataLayout containing the <code>Δz</code> on a given space <code>space</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/CliMA/ClimaCore.jl/blob/v0.14.5/src/Spaces/finitedifference.jl#L94-L98">source</a></section></article><h3 id="Finite-Difference-Spaces"><a class="docs-heading-anchor" href="#Finite-Difference-Spaces">Finite Difference Spaces</a><a id="Finite-Difference-Spaces-1"></a><a class="docs-heading-anchor-permalink" href="#Finite-Difference-Spaces" title="Permalink"></a></h3><p>ClimaCore.jl supports staggered Finite Difference discretizations. Finite Differences discretize an interval domain by approximating the function by a value at either the center of each element (also referred to as <em>cell</em>) (<code>CenterFiniteDifferenceSpace</code>), or the interfaces (faces in 3D, edges in 2D or points in 1D) between elements (<code>FaceFiniteDifferenceSpace</code>).</p><p>Users should construct either the center or face space from the mesh, then construct the other space from the original one: this internally reuses the same data structures, and avoids allocating additional memory.</p><h4 id="Internals"><a class="docs-heading-anchor" href="#Internals">Internals</a><a id="Internals-1"></a><a class="docs-heading-anchor-permalink" href="#Internals" title="Permalink"></a></h4><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="ClimaCore.Spaces.Δz_metric_component" href="#ClimaCore.Spaces.Δz_metric_component"><code>ClimaCore.Spaces.Δz_metric_component</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">Δz_metric_component(::Type{&lt;:Goemetry.AbstractPoint})</code></pre><p>The index of the z-component of an abstract point in an <code>AxisTensor</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/CliMA/ClimaCore.jl/blob/v0.14.5/src/Spaces/finitedifference.jl#L80-L85">source</a></section></article><h3 id="Spectral-Element-Spaces"><a class="docs-heading-anchor" href="#Spectral-Element-Spaces">Spectral Element Spaces</a><a id="Spectral-Element-Spaces-1"></a><a class="docs-heading-anchor-permalink" href="#Spectral-Element-Spaces" title="Permalink"></a></h3><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="ClimaCore.Spaces.SpectralElementSpace1D" href="#ClimaCore.Spaces.SpectralElementSpace1D"><code>ClimaCore.Spaces.SpectralElementSpace1D</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">SpectralElementSpace1D(grid::SpectralElementGrid1D)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/CliMA/ClimaCore.jl/blob/v0.14.5/src/Spaces/spectralelement.jl#L48-L50">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="ClimaCore.Spaces.SpectralElementSpace2D" href="#ClimaCore.Spaces.SpectralElementSpace2D"><code>ClimaCore.Spaces.SpectralElementSpace2D</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">SpectralElementSpace2D(grid::SpectralElementGrid1D)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/CliMA/ClimaCore.jl/blob/v0.14.5/src/Spaces/spectralelement.jl#L73-L75">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="ClimaCore.Spaces.SpectralElementSpaceSlab" href="#ClimaCore.Spaces.SpectralElementSpaceSlab"><code>ClimaCore.Spaces.SpectralElementSpaceSlab</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">SpectralElementSpaceSlab &lt;: AbstractSpace</code></pre><p>A view into a <code>SpectralElementSpace2D</code> for a single slab.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/CliMA/ClimaCore.jl/blob/v0.14.5/src/Spaces/spectralelement.jl#L110-L114">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="ClimaCore.Spaces.node_horizontal_length_scale" href="#ClimaCore.Spaces.node_horizontal_length_scale"><code>ClimaCore.Spaces.node_horizontal_length_scale</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">Spaces.node_horizontal_length_scale(space::AbstractSpectralElementSpace)</code></pre><p>The approximate length scale of the distance between nodes. This is defined as the length scale of the mesh (see <a href="#ClimaCore.Meshes.element_horizontal_length_scale"><code>Meshes.element_horizontal_length_scale</code></a>), divided by the number of unique quadrature points along each dimension.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/CliMA/ClimaCore.jl/blob/v0.14.5/src/Spaces/spectralelement.jl#L132-L138">source</a></section></article><h3 id="Quadratures"><a class="docs-heading-anchor" href="#Quadratures">Quadratures</a><a id="Quadratures-1"></a><a class="docs-heading-anchor-permalink" href="#Quadratures" title="Permalink"></a></h3><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="ClimaCore.Quadratures.QuadratureStyle" href="#ClimaCore.Quadratures.QuadratureStyle"><code>ClimaCore.Quadratures.QuadratureStyle</code></a> — <span class="docstring-category">Type</span></header><section><div><p>QuadratureStyle</p><p>Quadrature style supertype. See sub-types:</p><ul><li><a href="#ClimaCore.Quadratures.GLL"><code>GLL</code></a></li><li><a href="#ClimaCore.Quadratures.GL"><code>GL</code></a></li><li><a href="#ClimaCore.Quadratures.Uniform"><code>Uniform</code></a></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/CliMA/ClimaCore.jl/blob/v0.14.5/src/Quadratures/Quadratures.jl#L11-L18">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="ClimaCore.Quadratures.GLL" href="#ClimaCore.Quadratures.GLL"><code>ClimaCore.Quadratures.GLL</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">GLL{Nq}()</code></pre><p>Gauss-Legendre-Lobatto quadrature using <code>Nq</code> quadrature points.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/CliMA/ClimaCore.jl/blob/v0.14.5/src/Quadratures/Quadratures.jl#L44-L48">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="ClimaCore.Quadratures.GL" href="#ClimaCore.Quadratures.GL"><code>ClimaCore.Quadratures.GL</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">GL{Nq}()</code></pre><p>Gauss-Legendre quadrature using <code>Nq</code> quadrature points.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/CliMA/ClimaCore.jl/blob/v0.14.5/src/Quadratures/Quadratures.jl#L63-L67">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="ClimaCore.Quadratures.Uniform" href="#ClimaCore.Quadratures.Uniform"><code>ClimaCore.Quadratures.Uniform</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">Uniform{Nq}()</code></pre><p>Uniformly-spaced quadrature.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/CliMA/ClimaCore.jl/blob/v0.14.5/src/Quadratures/Quadratures.jl#L81-L85">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="ClimaCore.Quadratures.degrees_of_freedom" href="#ClimaCore.Quadratures.degrees_of_freedom"><code>ClimaCore.Quadratures.degrees_of_freedom</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">degrees_of_freedom(QuadratureStyle) -&gt; Int</code></pre><p>Returns the degrees<em>of</em>freedom of the <code>QuadratureStyle</code> concrete type</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/CliMA/ClimaCore.jl/blob/v0.14.5/src/Quadratures/Quadratures.jl#L29-L33">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="ClimaCore.Quadratures.polynomial_degree" href="#ClimaCore.Quadratures.polynomial_degree"><code>ClimaCore.Quadratures.polynomial_degree</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">polynomial_degree(QuadratureStyle) -&gt; Int</code></pre><p>Returns the polynomial degree of the <code>QuadratureStyle</code> concrete type</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/CliMA/ClimaCore.jl/blob/v0.14.5/src/Quadratures/Quadratures.jl#L21-L25">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="ClimaCore.Quadratures.quadrature_points" href="#ClimaCore.Quadratures.quadrature_points"><code>ClimaCore.Quadratures.quadrature_points</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">points, weights = quadrature_points(::Type{FT}, quadrature_style)</code></pre><p>The points and weights of the quadrature rule in floating point type <code>FT</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/CliMA/ClimaCore.jl/blob/v0.14.5/src/Quadratures/Quadratures.jl#L36-L40">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="ClimaCore.Quadratures.barycentric_weights" href="#ClimaCore.Quadratures.barycentric_weights"><code>ClimaCore.Quadratures.barycentric_weights</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">barycentric_weights(x::SVector{Nq}) where {Nq}</code></pre><p>The barycentric weights associated with the array of point locations <code>x</code>:</p><p class="math-container">\[w_j = \frac{1}{\prod_{k \ne j} (x_i - x_j)}\]</p><p>See [<a href="../references/#Berrut2004">11</a>], equation 3.2.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/CliMA/ClimaCore.jl/blob/v0.14.5/src/Quadratures/Quadratures.jl#L121-L131">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="ClimaCore.Quadratures.interpolation_matrix" href="#ClimaCore.Quadratures.interpolation_matrix"><code>ClimaCore.Quadratures.interpolation_matrix</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">interpolation_matrix(x::SVector, r::SVector{Nq})</code></pre><p>The matrix which interpolates the Lagrange polynomial of degree <code>Nq-1</code> through the points <code>r</code>, to points <code>x</code>. The matrix coefficients are computed using the Barycentric formula of [<a href="../references/#Berrut2004">11</a>], section 4:</p><p class="math-container">\[I_{ij} = \begin{cases}
1 &amp; \text{if } x_i = r_j, \\
0 &amp; \text{if } x_i = r_k \text{ for } k \ne j, \\
\frac{\displaystyle \frac{w_j}{x_i - r_j}}{\displaystyle \sum_k \frac{w_k}{x_i - r_k}} &amp; \text{otherwise,}
\end{cases}\]</p><p>where <span>$w_j$</span> are the barycentric weights, see <a href="#ClimaCore.Quadratures.barycentric_weights"><code>barycentric_weights</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/CliMA/ClimaCore.jl/blob/v0.14.5/src/Quadratures/Quadratures.jl#L150-L164">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="ClimaCore.Quadratures.differentiation_matrix" href="#ClimaCore.Quadratures.differentiation_matrix"><code>ClimaCore.Quadratures.differentiation_matrix</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">differentiation_matrix(r::SVector{Nq, T}) where {Nq, T}</code></pre><p>The spectral differentiation matrix for the Lagrange polynomial of degree <code>Nq-1</code> interpolating at points <code>r</code>.</p><p>The matrix coefficients are computed using the [<a href="../references/#Berrut2004">11</a>], section 9.3:</p><p class="math-container">\[D_{ij} = \begin{cases}
    \displaystyle
    \frac{w_j}{w_i (x_i - x_j)} &amp;\text{ if } i \ne j \\
    -\sum_{k \ne j} D_{kj} &amp;\text{ if } i = j
\end{cases}\]</p><p>where <span>$w_j$</span> are the barycentric weights, see <a href="#ClimaCore.Quadratures.barycentric_weights"><code>barycentric_weights</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/CliMA/ClimaCore.jl/blob/v0.14.5/src/Quadratures/Quadratures.jl#L261-L276">source</a></section><section><div><pre><code class="language-julia hljs">differentiation_matrix(FT, quadstyle::QuadratureStyle)</code></pre><p>The spectral differentiation matrix at the quadrature points of <code>quadstyle</code>, using floating point types <code>FT</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/CliMA/ClimaCore.jl/blob/v0.14.5/src/Quadratures/Quadratures.jl#L296-L301">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="ClimaCore.Quadratures.orthonormal_poly" href="#ClimaCore.Quadratures.orthonormal_poly"><code>ClimaCore.Quadratures.orthonormal_poly</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">V = orthonormal_poly(points, quad)</code></pre><p><code>V_{ij}</code> contains the <code>j-1</code>th Legendre polynomial evaluated at <code>points[i]</code>. i.e. it is the mapping from the modal to the nodal representation.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/CliMA/ClimaCore.jl/blob/v0.14.5/src/Quadratures/Quadratures.jl#L225-L230">source</a></section></article><h4 id="Internals-2"><a class="docs-heading-anchor" href="#Internals-2">Internals</a><a class="docs-heading-anchor-permalink" href="#Internals-2" title="Permalink"></a></h4><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="ClimaCore.Topologies.dss_transform" href="#ClimaCore.Topologies.dss_transform"><code>ClimaCore.Topologies.dss_transform</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">dss_transform(arg, local_geometry, weight, I...)</code></pre><p>Transfrom <code>arg[I...]</code> to a basis for direct stiffness summation (DSS). Transformations only apply to vector quantities.</p><ul><li><code>local_geometry[I...]</code> is the relevant <code>LocalGeometry</code> object. If it is <code>nothing</code>, then no transformation is performed</li><li><code>weight[I...]</code> is the relevant DSS weights. If <code>weight</code> is <code>nothing</code>, then the result is simply summation.</li></ul><p>See <a href="#ClimaCore.Spaces.weighted_dss!"><code>ClimaCore.Spaces.weighted_dss!</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/CliMA/ClimaCore.jl/blob/v0.14.5/src/Topologies/dss_transform.jl#L4-L14">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="ClimaCore.Topologies.dss_transform!" href="#ClimaCore.Topologies.dss_transform!"><code>ClimaCore.Topologies.dss_transform!</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">function dss_transform!(
    device::ClimaComms.AbstractDevice,
    dss_buffer::DSSBuffer,
    data::Union{DataLayouts.IJFH, DataLayouts.VIJFH},
    local_geometry::Union{DataLayouts.IJFH, DataLayouts.VIJFH},
    weight::DataLayouts.IJFH,
    perimeter::AbstractPerimeter,
    localelems::Vector{Int},
)</code></pre><p>Transforms vectors from Covariant axes to physical (local axis), weights the data at perimeter nodes,  and stores result in the <code>perimeter_data</code> array. This function calls the appropriate version of  <code>dss_transform!</code> based on the data layout of the input arguments.</p><p>Arguments:</p><ul><li><code>dss_buffer</code>: <a href="#ClimaCore.Topologies.DSSBuffer"><code>DSSBuffer</code></a> generated by <code>create_dss_buffer</code> function for field data</li><li><code>data</code>: field data</li><li><code>local_geometry</code>: local metric information defined at each node</li><li><code>weight</code>: local dss weights for horizontal space</li><li><code>perimeter</code>: perimeter iterator</li><li><code>localelems</code>: list of local elements to perform transformation operations on</li></ul><p>Part of <a href="#ClimaCore.Spaces.weighted_dss!"><code>ClimaCore.Spaces.weighted_dss!</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/CliMA/ClimaCore.jl/blob/v0.14.5/src/Topologies/dss.jl#L211-L236">source</a></section><section><div><pre><code class="language-julia hljs">function dss_transform!(
    ::ClimaComms.AbstractCPUDevice,
    perimeter_data::DataLayouts.VIFH,
    data::Union{DataLayouts.IJFH, DataLayouts.VIJFH},
    ∂ξ∂x::Union{DataLayouts.IJFH, DataLayouts.VIJFH},
    ∂x∂ξ::Union{DataLayouts.VIJFH, DataLayouts.IJFH},
    weight::DataLayouts.IJFH,
    perimeter::AbstractPerimeter,
    scalarfidx::Vector{Int},
    covariant12fidx::Vector{Int},
    contravariant12fidx::Vector{Int},
    localelems::Vector{Int},
)</code></pre><p>Transforms vectors from Covariant axes to physical (local axis), weights the data at perimeter nodes, and stores result in the <code>perimeter_data</code> array.</p><p>Arguments:</p><ul><li><code>perimeter_data</code>: contains the perimeter field data, represented on the physical axis, corresponding to the full field data in <code>data</code></li><li><code>data</code>: field data</li><li><code>∂ξ∂x</code>: partial derivatives of the map from <code>x</code> to <code>ξ</code>: <code>∂ξ∂x[i,j]</code> is ∂ξⁱ/∂xʲ</li><li><code>weight</code>: local dss weights for horizontal space</li><li><code>perimeter</code>: perimeter iterator</li><li><code>scalarfidx</code>: field index for scalar fields in the data layout</li><li><code>covariant12fidx</code>: field index for Covariant12 vector fields in the data layout</li><li><code>localelems</code>: list of local elements to perform transformation operations on</li></ul><p>Part of <a href="#ClimaCore.Spaces.weighted_dss!"><code>ClimaCore.Spaces.weighted_dss!</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/CliMA/ClimaCore.jl/blob/v0.14.5/src/Topologies/dss.jl#L315-L345">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="ClimaCore.Topologies.dss_untransform!" href="#ClimaCore.Topologies.dss_untransform!"><code>ClimaCore.Topologies.dss_untransform!</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">dss_untransform!(
    device::ClimaComms.AbstractDevice,
    dss_buffer::DSSBuffer,
    data::Union{DataLayouts.IJFH, DataLayouts.VIJFH},
    local_geometry::Union{DataLayouts.IJFH, DataLayouts.VIJFH},
    perimeter::AbstractPerimeter,
)</code></pre><p>Transforms the DSS&#39;d local vectors back to Covariant12 vectors, and copies the DSS&#39;d data from the <code>perimeter_data</code> to <code>data</code>. This function calls the appropriate version of <code>dss_transform!</code> function based on the data layout of the input arguments.</p><p>Arguments:</p><ul><li><code>dss_buffer</code>: <a href="#ClimaCore.Topologies.DSSBuffer"><code>DSSBuffer</code></a> generated by <code>create_dss_buffer</code> function for field data</li><li><code>data</code>: field data</li><li><code>local_geometry</code>: local metric information defined at each node</li><li><code>perimeter</code>: perimeter iterator</li><li><code>localelems</code>: list of local elements to perform transformation operations on</li></ul><p>Part of <a href="#ClimaCore.Spaces.weighted_dss!"><code>ClimaCore.Spaces.weighted_dss!</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/CliMA/ClimaCore.jl/blob/v0.14.5/src/Topologies/dss.jl#L266-L288">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="ClimaCore.Topologies.dss_untransform" href="#ClimaCore.Topologies.dss_untransform"><code>ClimaCore.Topologies.dss_untransform</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">dss_untransform(T, targ, local_geometry, I...)</code></pre><p>Transform <code>targ[I...]</code> back to a value of type <code>T</code> after performing direct stiffness summation (DSS).</p><p>See <a href="#ClimaCore.Spaces.weighted_dss!"><code>ClimaCore.Spaces.weighted_dss!</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/CliMA/ClimaCore.jl/blob/v0.14.5/src/Topologies/dss_transform.jl#L144-L150">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="ClimaCore.Topologies.dss_local_vertices!" href="#ClimaCore.Topologies.dss_local_vertices!"><code>ClimaCore.Topologies.dss_local_vertices!</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">dss_local_vertices!(
    perimeter_data::DataLayouts.VIFH,
    perimeter::Perimeter2D,
    topology::Topology2D,
)</code></pre><p>Apply dss to local vertices.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/CliMA/ClimaCore.jl/blob/v0.14.5/src/Topologies/dss.jl#L574-L582">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="ClimaCore.Topologies.dss_local!" href="#ClimaCore.Topologies.dss_local!"><code>ClimaCore.Topologies.dss_local!</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">function dss_local!(
    ::ClimaComms.AbstractCPUDevice,
    perimeter_data::DataLayouts.VIFH,
    perimeter::AbstractPerimeter,
    topology::AbstractTopology,
)</code></pre><p>Performs DSS on local vertices and faces.</p><p>Part of <a href="#ClimaCore.Spaces.weighted_dss!"><code>ClimaCore.Spaces.weighted_dss!</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/CliMA/ClimaCore.jl/blob/v0.14.5/src/Topologies/dss.jl#L551-L562">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="ClimaCore.Topologies.dss_local_ghost!" href="#ClimaCore.Topologies.dss_local_ghost!"><code>ClimaCore.Topologies.dss_local_ghost!</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">function dss_local_ghost!(
    ::ClimaComms.AbstractCPUDevice,
    perimeter_data::DataLayouts.VIFH,
    perimeter::AbstractPerimeter,
    topology::AbstractTopology,
)</code></pre><p>Computes the &quot;local&quot; part of ghost vertex dss. (i.e. it computes the summation of all the shared local vertices of a unique ghost vertex and stores the value in each of the local vertex locations in  <code>perimeter_data</code>)</p><p>Part of <a href="#ClimaCore.Spaces.weighted_dss!"><code>ClimaCore.Spaces.weighted_dss!</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/CliMA/ClimaCore.jl/blob/v0.14.5/src/Topologies/dss.jl#L637-L650">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="ClimaCore.Topologies.dss_ghost!" href="#ClimaCore.Topologies.dss_ghost!"><code>ClimaCore.Topologies.dss_ghost!</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">dss_ghost!(
    device::ClimaComms.AbstractCPUDevice,
    perimeter_data::DataLayouts.VIFH,
    perimeter::AbstractPerimeter,
    topology::AbstractTopology,
)</code></pre><p>Sets the value for all local vertices of each unique ghost vertex, in <code>perimeter_data</code>, to that of  the representative ghost vertex.</p><p>Part of <a href="#ClimaCore.Spaces.weighted_dss!"><code>ClimaCore.Spaces.weighted_dss!</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/CliMA/ClimaCore.jl/blob/v0.14.5/src/Topologies/dss.jl#L692-L704">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="ClimaCore.Topologies.create_dss_buffer" href="#ClimaCore.Topologies.create_dss_buffer"><code>ClimaCore.Topologies.create_dss_buffer</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">create_dss_buffer(
    data::Union{DataLayouts.IJFH{S, Nij}, DataLayouts.VIJFH{S, Nij}},
    hspace::AbstractSpectralElementSpace,
) where {S, Nij}</code></pre><p>Creates a <a href="#ClimaCore.Topologies.DSSBuffer"><code>DSSBuffer</code></a> for the field data corresponding to <code>data</code></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/CliMA/ClimaCore.jl/blob/v0.14.5/src/Spaces/dss.jl#L21-L28">source</a></section><section><div><pre><code class="language-julia hljs">Spaces.create_dss_buffer(field::Field)</code></pre><p>Create a buffer for communicating neighbour information of <code>field</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/CliMA/ClimaCore.jl/blob/v0.14.5/src/Fields/Fields.jl#L468-L472">source</a></section><section><div><pre><code class="language-julia hljs">create_dss_buffer(
    data::Union{DataLayouts.IJFH{S, Nij}, DataLayouts.VIJFH{S, Nij}},
    topology::Topology2D,
    local_geometry = nothing,
    local_weights = nothing,
) where {S, Nij}</code></pre><p>Creates a <a href="#ClimaCore.Topologies.DSSBuffer"><code>DSSBuffer</code></a> for the field data corresponding to <code>data</code></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/CliMA/ClimaCore.jl/blob/v0.14.5/src/Topologies/dss.jl#L37-L46">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="ClimaCore.Topologies.fill_send_buffer!" href="#ClimaCore.Topologies.fill_send_buffer!"><code>ClimaCore.Topologies.fill_send_buffer!</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">fill_send_buffer!(::ClimaComms.AbstractCPUDevice, dss_buffer::DSSBuffer; synchronize=true)</code></pre><p>Loads the send buffer from <code>perimeter_data</code>. For unique ghost vertices, only data from the representative vertices which store result of &quot;ghost local&quot; DSS are loaded.</p><p>Part of <a href="#ClimaCore.Spaces.weighted_dss!"><code>ClimaCore.Spaces.weighted_dss!</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/CliMA/ClimaCore.jl/blob/v0.14.5/src/Topologies/dss.jl#L735-L742">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="ClimaCore.Topologies.DSSBuffer" href="#ClimaCore.Topologies.DSSBuffer"><code>ClimaCore.Topologies.DSSBuffer</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">DSSBuffer{G, D, A, B}</code></pre><p><strong>Fields</strong></p><ul><li><p><code>graph_context</code>: ClimaComms graph context for communication</p></li><li><p><code>perimeter_data</code>: Perimeter <code>DataLayout</code> object: typically a <code>VIFH{TT,Np}</code>, where <code>TT</code> is the transformed type, and <code>Np</code> is the length of the perimeter</p></li></ul><ul><li><p><code>send_data</code>: send buffer <code>AbstractVector{FT}</code></p></li><li><p><code>recv_data</code>: recv buffer <code>AbstractVector{FT}</code></p></li><li><p><code>send_buf_idx</code>: indexing array for loading send buffer from <code>perimeter_data</code></p></li><li><p><code>recv_buf_idx</code>: indexing array for loading (and summing) data from recv buffer to <code>perimeter_data</code></p></li><li><p><code>scalarfidx</code>: field id for all scalar fields stored in the <code>data</code> array</p></li><li><p><code>covariant12fidx</code>: field id for all covariant12vector fields stored in the <code>data</code> array</p></li><li><p><code>contravariant12fidx</code>: field id for all contravariant12vector fields stored in the <code>data</code> array</p></li><li><p><code>internal_elems</code>: internal local elements (lidx)</p></li><li><p><code>perimeter_elems</code>: local elements (lidx) located on process boundary</p></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/CliMA/ClimaCore.jl/blob/v0.14.5/src/Topologies/dss.jl#L3-L8">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="ClimaCore.Topologies.load_from_recv_buffer!" href="#ClimaCore.Topologies.load_from_recv_buffer!"><code>ClimaCore.Topologies.load_from_recv_buffer!</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">load_from_recv_buffer!(::ClimaComms.AbstractCPUDevice, dss_buffer::DSSBuffer)</code></pre><p>Adds data from the recv buffer to the corresponding location in <code>perimeter_data</code>. For ghost vertices, this data is added only to the representative vertices. The values are  then scattered to other local vertices corresponding to each unique ghost vertex in <code>dss_local_ghost</code>.</p><p>Part of <a href="#ClimaCore.Spaces.weighted_dss!"><code>ClimaCore.Spaces.weighted_dss!</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/CliMA/ClimaCore.jl/blob/v0.14.5/src/Topologies/dss.jl#L764-L772">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="ClimaCore.Topologies.dss!" href="#ClimaCore.Topologies.dss!"><code>ClimaCore.Topologies.dss!</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">dss!(data, topology)</code></pre><p>Computed unweighted/pure DSS of <code>data</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/CliMA/ClimaCore.jl/blob/v0.14.5/src/Topologies/dss.jl#L794-L798">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="ClimaCore.Spaces.weighted_dss_start!" href="#ClimaCore.Spaces.weighted_dss_start!"><code>ClimaCore.Spaces.weighted_dss_start!</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">weighted_dss_start!(
    data::Union{
        DataLayouts.IFH,
        DataLayouts.VIFH,
        DataLayouts.IJFH,
        DataLayouts.VIJFH,
    },
    space::Union{
        AbstractSpectralElementSpace,
        ExtrudedFiniteDifferenceSpace,
    },
    dss_buffer::Union{DSSBuffer, Nothing},
)</code></pre><p>It comprises of the following steps:</p><p>1). Apply <a href="#ClimaCore.Topologies.dss_transform!"><code>Spaces.dss_transform!</code></a> on perimeter elements. This weights and tranforms vector  fields to physical basis if needed. Scalar fields are weighted. The transformed and/or weighted  perimeter <code>data</code> is stored in <code>perimeter_data</code>.</p><p>2). Apply <a href="#ClimaCore.Topologies.dss_local_ghost!"><code>Spaces.dss_local_ghost!</code></a> This computes partial weighted DSS on ghost vertices, using only the information from <code>local</code> vertices.</p><p>3). <a href="#ClimaCore.Topologies.fill_send_buffer!"><code>Spaces.fill_send_buffer!</code></a>  Loads the send buffer from <code>perimeter_data</code>. For unique ghost vertices, only data from the representative ghost vertices which store result of &quot;ghost local&quot; DSS are loaded.</p><p>4). Start DSS communication with neighboring processes</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/CliMA/ClimaCore.jl/blob/v0.14.5/src/Spaces/dss.jl#L127-L156">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="ClimaCore.Spaces.weighted_dss_internal!" href="#ClimaCore.Spaces.weighted_dss_internal!"><code>ClimaCore.Spaces.weighted_dss_internal!</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">weighted_dss_internal!(
    data::Union{
        DataLayouts.IFH,
        DataLayouts.VIFH,
        DataLayouts.IJFH,
        DataLayouts.VIJFH,
    },
    space::Union{
        AbstractSpectralElementSpace,
        ExtrudedFiniteDifferenceSpace,
    },
    dss_buffer::DSSBuffer,
)</code></pre><p>1). Apply <a href="#ClimaCore.Topologies.dss_transform!"><code>Spaces.dss_transform!</code></a> on interior elements. Local elements are split into interior  and perimeter elements to facilitate overlapping of communication with computation.</p><p>2). Probe communication</p><p>3). <a href="#ClimaCore.Topologies.dss_local!"><code>Spaces.dss_local!</code></a> computes the weighted DSS on local vertices and faces.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/CliMA/ClimaCore.jl/blob/v0.14.5/src/Spaces/dss.jl#L175-L196">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="ClimaCore.Spaces.weighted_dss_ghost!" href="#ClimaCore.Spaces.weighted_dss_ghost!"><code>ClimaCore.Spaces.weighted_dss_ghost!</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">weighted_dss_ghost!(
    data::Union{
        DataLayouts.IFH,
        DataLayouts.VIFH,
        DataLayouts.IJFH,
        DataLayouts.VIJFH,
    },
    space::Union{
        AbstractSpectralElementSpace,
        ExtrudedFiniteDifferenceSpace,
    },
    dss_buffer::Union{DSSBuffer, Nothing},
)</code></pre><p>1). Finish communications.</p><p>2). Call <a href="#ClimaCore.Topologies.load_from_recv_buffer!"><code>Spaces.load_from_recv_buffer!</code></a> After the communication is complete, this adds data from the recv buffer to the corresponding location in  <code>perimeter_data</code>. For ghost vertices, this data is added only to the representative vertices. The values are  then scattered to other local vertices corresponding to each unique ghost vertex in <code>dss_local_ghost</code>.</p><p>3). Call <a href="#ClimaCore.Topologies.dss_untransform!"><code>Spaces.dss_untransform!</code></a> on all local elements. This transforms the DSS&#39;d local vectors back to Covariant12 vectors, and copies the DSS&#39;d data from the <code>perimeter_data</code> to <code>data</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/CliMA/ClimaCore.jl/blob/v0.14.5/src/Spaces/dss.jl#L259-L284">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="ClimaCore.Spaces.weighted_dss!" href="#ClimaCore.Spaces.weighted_dss!"><code>ClimaCore.Spaces.weighted_dss!</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">function weighted_dss!(
    data::Union{
        DataLayouts.IFH,
        DataLayouts.VIFH,
        DataLayouts.IJFH,
        DataLayouts.VIJFH,
    },
    space::Union{
        AbstractSpectralElementSpace,
        ExtrudedFiniteDifferenceSpace,
    },
    dss_buffer::Union{DSSBuffer, Nothing},
)</code></pre><p>Computes weighted dss of <code>data</code>. </p><p>It comprises of the following steps:</p><p>1). <a href="#ClimaCore.Spaces.weighted_dss_start!"><code>Spaces.weighted_dss_start!</code></a></p><p>2). <a href="#ClimaCore.Spaces.weighted_dss_internal!"><code>Spaces.weighted_dss_internal!</code></a></p><p>3). <a href="#ClimaCore.Spaces.weighted_dss_ghost!"><code>Spaces.weighted_dss_ghost!</code></a></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/CliMA/ClimaCore.jl/blob/v0.14.5/src/Spaces/dss.jl#L48-L72">source</a></section><section><div><pre><code class="language-julia hljs">Spaces.weighted_dss!(f::Field[, ghost_buffer = Spaces.create_dss_buffer(field)])</code></pre><p>Apply weighted direct stiffness summation (DSS) to <code>f</code>. This operates in-place (i.e. it modifies the <code>f</code>). <code>ghost_buffer</code> contains the necessary information for communication in a distributed setting, see <a href="#ClimaCore.Topologies.create_dss_buffer"><code>Spaces.create_dss_buffer</code></a>.</p><p>This is a projection operation from the piecewise polynomial space <span>$\mathcal{V}_0$</span> to the continuous space <span>$\mathcal{V}_1 = \mathcal{V}_0 \cap \mathcal{C}_0$</span>, defined as the field <span>$\theta \in \mathcal{V}_1$</span> such that for all <span>$\phi \in \mathcal{V}_1$</span></p><p class="math-container">\[\int_\Omega \phi \theta \,d\Omega = \int_\Omega \phi f \,d\Omega\]</p><p>In matrix form, we define <span>$\bar \theta$</span> to be the unique global node representation, and <span>$Q$</span> to be the &quot;scatter&quot; operator which maps to the redundant node representation <span>$\theta$</span></p><p class="math-container">\[\theta = Q \bar \theta\]</p><p>Then the problem can be written as</p><p class="math-container">\[(Q \bar\phi)^\top W J Q \bar\theta = (Q \bar\phi)^\top W J f\]</p><p>which reduces to</p><p class="math-container">\[\theta = Q \bar\theta = Q (Q^\top W J Q)^{-1} Q^\top W J f\]</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/CliMA/ClimaCore.jl/blob/v0.14.5/src/Fields/Fields.jl#L377-L406">source</a></section><section><div><pre><code class="language-julia hljs">Spaces.weighted_dss!(field1 =&gt; ghost_buffer1, field2 =&gt; ghost_buffer2, ...)</code></pre><p>Call <a href="#ClimaCore.Spaces.weighted_dss!"><code>Spaces.weighted_dss!</code></a> on multiple fields at once, overlapping communication as much as possible.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/CliMA/ClimaCore.jl/blob/v0.14.5/src/Fields/Fields.jl#L423-L428">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="ClimaCore.Spaces.unique_nodes" href="#ClimaCore.Spaces.unique_nodes"><code>ClimaCore.Spaces.unique_nodes</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">unique_nodes(space::SpectralElementSpace2D)</code></pre><p>An iterator over the unique nodes of <code>space</code>. Each node is represented by the first <code>((i,j), e)</code> triple.</p><p>This function is experimental, and may change in future.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/CliMA/ClimaCore.jl/blob/v0.14.5/src/Spaces/spectralelement.jl#L181-L188">source</a></section></article><h4 id="Utilities-2"><a class="docs-heading-anchor" href="#Utilities-2">Utilities</a><a class="docs-heading-anchor-permalink" href="#Utilities-2" title="Permalink"></a></h4><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="ClimaCore.Spaces.area" href="#ClimaCore.Spaces.area"><code>ClimaCore.Spaces.area</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">Spaces.area(space::Spaces.AbstractSpace)</code></pre><p>The length/area/volume of <code>space</code>. This is computed as the sum of the quadrature weights <span>$W_i$</span> multiplied by the Jacobian determinants <span>$J_i$</span>:</p><p class="math-container">\[\sum_i W_i J_i \approx \int_\Omega \, d \Omega\]</p><p>If <code>space</code> is distributed, this uses a <code>ClimaComms.allreduce</code> operation.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/CliMA/ClimaCore.jl/blob/v0.14.5/src/Spaces/Spaces.jl#L107-L117">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="ClimaCore.Spaces.local_area" href="#ClimaCore.Spaces.local_area"><code>ClimaCore.Spaces.local_area</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">Spaces.local_area(space::Spaces.AbstractSpace)</code></pre><p>The length/area/volume of <code>space</code> local to the current context. See <a href="#ClimaCore.Spaces.area"><code>Spaces.area</code></a></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/CliMA/ClimaCore.jl/blob/v0.14.5/src/Spaces/Spaces.jl#L99-L104">source</a></section></article><h2 id="RecursiveApply"><a class="docs-heading-anchor" href="#RecursiveApply">RecursiveApply</a><a id="RecursiveApply-1"></a><a class="docs-heading-anchor-permalink" href="#RecursiveApply" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="ClimaCore.RecursiveApply" href="#ClimaCore.RecursiveApply"><code>ClimaCore.RecursiveApply</code></a> — <span class="docstring-category">Module</span></header><section><div><pre><code class="language-julia hljs">RecursiveApply</code></pre><p>This module contains operators to recurse over nested <code>Tuple</code>s or <code>NamedTuple</code>s.</p><p>To extend to another type <code>T</code>, define <code>RecursiveApply.rmap(fn, args::T...)</code></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/CliMA/ClimaCore.jl/blob/v0.14.5/src/RecursiveApply/RecursiveApply.jl#L1-L7">source</a></section></article><h2 id="Fields"><a class="docs-heading-anchor" href="#Fields">Fields</a><a id="Fields-1"></a><a class="docs-heading-anchor-permalink" href="#Fields" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="ClimaCore.Fields.Field" href="#ClimaCore.Fields.Field"><code>ClimaCore.Fields.Field</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">Field(values, space)</code></pre><p>A set of <code>values</code> defined at each point of a <code>space</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/CliMA/ClimaCore.jl/blob/v0.14.5/src/Fields/Fields.jl#L28-L32">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="ClimaCore.Fields.coordinate_field" href="#ClimaCore.Fields.coordinate_field"><code>ClimaCore.Fields.coordinate_field</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">coordinate_field(space::AbstractSpace)</code></pre><p>Construct a <code>Field</code> of the coordinates of the space.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/CliMA/ClimaCore.jl/blob/v0.14.5/src/Fields/Fields.jl#L330-L334">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="ClimaCore.Fields.local_geometry_field" href="#ClimaCore.Fields.local_geometry_field"><code>ClimaCore.Fields.local_geometry_field</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">local_geometry_field(space::AbstractSpace)</code></pre><p>Construct a <code>Field</code> of the <code>LocalGeometry</code> of the space.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/CliMA/ClimaCore.jl/blob/v0.14.5/src/Fields/Fields.jl#L339-L343">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Base.zeros-Tuple{ClimaCore.Spaces.AbstractSpace}" href="#Base.zeros-Tuple{ClimaCore.Spaces.AbstractSpace}"><code>Base.zeros</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">zeros(space::AbstractSpace)</code></pre><p>Construct a field on <code>space</code> that is zero everywhere.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/CliMA/ClimaCore.jl/blob/v0.14.5/src/Fields/Fields.jl#L296-L300">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Base.ones-Tuple{ClimaCore.Spaces.AbstractSpace}" href="#Base.ones-Tuple{ClimaCore.Spaces.AbstractSpace}"><code>Base.ones</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">ones(space::AbstractSpace)</code></pre><p>Construct a field on <code>space</code> that is one everywhere.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/CliMA/ClimaCore.jl/blob/v0.14.5/src/Fields/Fields.jl#L309-L313">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Base.sum-Tuple{ClimaCore.Fields.Field}" href="#Base.sum-Tuple{ClimaCore.Fields.Field}"><code>Base.sum</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">sum([f=identity,] v::Field)</code></pre><p>Approximate integration of <code>v</code> or <code>f.(v)</code> over the domain. In an <code>AbstractSpectralElementSpace</code>, an integral over the entire space is computed by summation over the elements of the integrand multiplied by the Jacobian determinants and the quadrature weights at each node within an element. Hence, <code>sum</code> is computed by summation of the field values multiplied by the Jacobian determinants and quadrature weights:</p><p class="math-container">\[\sum_i f(v_i) W_i J_i
\approx
\int_\Omega f(v) \, d \Omega\]</p><p>where <span>$v_i$</span> is the value at each node, and <span>$f$</span> is the identity function if not specified.</p><p>If <code>v</code> is a distributed field, this uses a <code>ClimaComms.allreduce</code> operation.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/CliMA/ClimaCore.jl/blob/v0.14.5/src/Fields/mapreduce.jl#L24-L41">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="ClimaCore.Fields.local_sum" href="#ClimaCore.Fields.local_sum"><code>ClimaCore.Fields.local_sum</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">Fields.local_sum(v::Field)</code></pre><p>Compute the approximate integral of <code>v</code> over the domain local to the current context.</p><p>See <a href="#Base.sum-Tuple{ClimaCore.Fields.Field}"><code>sum</code></a> for the integral over the full domain.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/CliMA/ClimaCore.jl/blob/v0.14.5/src/Fields/mapreduce.jl#L3-L10">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Statistics.mean-Tuple{ClimaCore.Fields.Field}" href="#Statistics.mean-Tuple{ClimaCore.Fields.Field}"><code>Statistics.mean</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">mean([f=identity, ]v::Field)</code></pre><p>The mean value of <code>field</code> or <code>f.(field)</code> over the domain, weighted by area. Similar to <code>sum</code>, in an <code>AbstractSpectralElementSpace</code>, this is computed by summation of the field values multiplied by the Jacobian determinants and quadrature weights:</p><p class="math-container">\[\frac{\sum_i f(v_i) W_i J_i}{\sum_i W_i J_i}
\approx
\frac{\int_\Omega f(v) \, d \Omega}{\int_\Omega \, d \Omega}\]</p><p>where <span>$v_i$</span> is the Field value at each node, and <span>$f$</span> is the identity function if not specified.</p><p>If <code>v</code> is a distributed field, this uses a <code>ClimaComms.allreduce</code> operation.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/CliMA/ClimaCore.jl/blob/v0.14.5/src/Fields/mapreduce.jl#L92-L107">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="LinearAlgebra.norm-Tuple{ClimaCore.Fields.Field}" href="#LinearAlgebra.norm-Tuple{ClimaCore.Fields.Field}"><code>LinearAlgebra.norm</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">norm(v::Field, p=2; normalize=true)</code></pre><p>The approximate <span>$L^p$</span> norm of <code>v</code>, where <span>$L^p$</span> represents the space of measurable functions for which the p-th power of the absolute value is Lebesgue integrable, that is:</p><p class="math-container">\[\| v \|_p = \left( \int_\Omega |v|^p d \Omega \right)^{1/p}\]</p><p>where <span>$|v|$</span> is defined to be the absolute value if <span>$v$</span> is a scalar-valued Field, or the 2-norm if it is a vector-valued Field or composite Field (see <a href="https://docs.julialang.org/en/v1/stdlib/LinearAlgebra/#LinearAlgebra.norm">LinearAlgebra.norm</a>). Similar to <code>sum</code> and <code>mean</code>, in an <code>AbstractSpectralElementSpace</code>, this is computed by summation of the field values multiplied by the Jacobian determinants and quadrature weights. If <code>normalize=true</code> (the default), then internally the discrete norm is divided by the sum of the Jacobian determinants and quadrature weights:</p><p class="math-container">\[\left(\frac{\sum_i |v_i|^p W_i J_i}{\sum_i W_i J_i}\right)^{1/p}
\approx
\left(\frac{\int_\Omega |v|^p \, d \Omega}{\int_\Omega \, d \Omega}\right)^{1/p}\]</p><p>If <code>p=Inf</code>, then the norm is the maximum of the absolute values</p><p class="math-container">\[\max_i |v_i| \approx \sup_{\Omega} |v|\]</p><p>Consequently all norms should have the same units for all <span>$p$</span> (being the same as calling <code>norm</code> on a single value).</p><p>If <code>normalize=false</code>, then the denominator term is omitted, and so the result will be the norm as described above multiplied by the length/area/volume of <span>$\Omega$</span> to the power of <span>$1/p$</span>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/CliMA/ClimaCore.jl/blob/v0.14.5/src/Fields/mapreduce.jl#L129-L159">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="ClimaCore.Fields.set!" href="#ClimaCore.Fields.set!"><code>ClimaCore.Fields.set!</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">set!(f::Function, field::Field, args = ())</code></pre><p>Apply function <code>f</code> to populate values in field <code>field</code>. <code>f</code> must have a function signature with signature <code>f(::LocalGeometry[, args...])</code>. Additional arguments may be passed to <code>f</code> with <code>args</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/CliMA/ClimaCore.jl/blob/v0.14.5/src/Fields/Fields.jl#L506-L515">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="ClimaCore.Grids.ColumnIndex" href="#ClimaCore.Grids.ColumnIndex"><code>ClimaCore.Grids.ColumnIndex</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">ColumnIndex(ij,h)</code></pre><p>An index into a column of a field. This can be used as an argument to <code>getindex</code> of a <code>Field</code>, to return a field on that column.</p><p><strong>Example</strong></p><pre><code class="language-julia hljs">colidx = ColumnIndex((1,1),1)
field[colidx]</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/CliMA/ClimaCore.jl/blob/v0.14.5/src/Grids/column.jl#L5-L16">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="ClimaCore.Fields.bycolumn" href="#ClimaCore.Fields.bycolumn"><code>ClimaCore.Fields.bycolumn</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">Fields.bycolumn(fn, space)</code></pre><p>Call <code>fn(colidx)</code> to every <a href="#ClimaCore.Grids.ColumnIndex"><code>ColumnIndex</code></a> <code>colidx</code> of <code>space</code>. This can be used to apply multiple column-wise operations in a single pass, making use of multiple threads.</p><div class="admonition is-info"><header class="admonition-header">Note</header><div class="admonition-body"><p>On GPUs this will simply evaluate <code>f</code> once with <code>colidx=:</code> (i.e. it doesn&#39;t perform evaluation by columns). This may change in future.</p></div></div><p><strong>Example</strong></p><pre><code class="language-julia hljs">∇ = GradientF2C()
div = DivergenceC2F()

bycolumn(axes(f)) do colidx
    @. ∇f[colidx] = ∇(f[colidx])
    @. df[colidx] = div(∇f[colidx])
end</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/CliMA/ClimaCore.jl/blob/v0.14.5/src/Fields/indices.jl#L36-L59">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="ClimaCore.Fields.Δz_field" href="#ClimaCore.Fields.Δz_field"><code>ClimaCore.Fields.Δz_field</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">Δz_field(field::Field)
Δz_field(space::AbstractSpace)</code></pre><p>A <code>Field</code> containing the <code>Δz</code> values on the same space as the given field.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/CliMA/ClimaCore.jl/blob/v0.14.5/src/Fields/Fields.jl#L348-L353">source</a></section></article><h2 id="Hypsography"><a class="docs-heading-anchor" href="#Hypsography">Hypsography</a><a id="Hypsography-1"></a><a class="docs-heading-anchor-permalink" href="#Hypsography" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="ClimaCore.Hypsography.LinearAdaption" href="#ClimaCore.Hypsography.LinearAdaption"><code>ClimaCore.Hypsography.LinearAdaption</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">LinearAdaption(surface::Field)</code></pre><p>Locate the levels by linear interpolation between the surface field and the top of the domain, using the method of [<a href="../references/#GalChen1975">12</a>].</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/CliMA/ClimaCore.jl/blob/v0.14.5/src/Hypsography/Hypsography.jl#L74-L79">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="ClimaCore.Hypsography.SLEVEAdaption" href="#ClimaCore.Hypsography.SLEVEAdaption"><code>ClimaCore.Hypsography.SLEVEAdaption</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">SLEVEAdaption(surface::Field, ηₕ::FT, s::FT)</code></pre><p>Locate vertical levels using an exponential function between the surface field and the top of the domain, using the method of [<a href="../references/#Schar2002">13</a>]. This method is modified such no warping is applied above some user defined parameter 0 ≤ ηₕ &lt; 1.0, where the lower and upper bounds represent the domain bottom and top respectively. <code>s</code> governs the decay rate. If the decay-scale is poorly specified (i.e., <code>s * zₜ</code> is lower than the maximum surface elevation), a warning is thrown and <code>s</code> is adjusted such that it <code>szₜ &gt; maximum(z_surface)</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/CliMA/ClimaCore.jl/blob/v0.14.5/src/Hypsography/Hypsography.jl#L107-L116">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="ClimaCore.Hypsography.diffuse_surface_elevation!" href="#ClimaCore.Hypsography.diffuse_surface_elevation!"><code>ClimaCore.Hypsography.diffuse_surface_elevation!</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">diffuse_surface_elevation!(f::Field; κ::T, iter::Int, dt::T)</code></pre><p>Option for 2nd order diffusive smoothing of generated terrain. Mutate (smooth) a given elevation profile <code>f</code> before assigning the surface elevation to the <code>HypsographyAdaption</code> type. A spectral second-order diffusion operator is applied with forward-Euler updates to generate profiles for each new iteration. Steps to generate smoothed terrain ( represented as a ClimaCore Field) are as follows:</p><ul><li>Compute discrete elevation profile f</li><li>Compute diffuse<em>surface</em>elevation!(f, κ, iter). f is mutated.</li><li>Define <code>Hypsography.LinearAdaption(f)</code></li><li>Define <code>ExtrudedFiniteDifferenceSpace</code> with new surface elevation.</li></ul><p>Default diffusion parameters are appropriate for spherical arrangements. For <code>zmax-zsfc</code> == 𝒪(10^4), κ == 𝒪(10^8), dt == 𝒪(10⁻¹).</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/CliMA/ClimaCore.jl/blob/v0.14.5/src/Hypsography/Hypsography.jl#L272-L287">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="ClimaCore.Hypsography.ref_z_to_physical_z" href="#ClimaCore.Hypsography.ref_z_to_physical_z"><code>ClimaCore.Hypsography.ref_z_to_physical_z</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">ref_z_to_physical_z(adaption::HypsographyAdaption, z_ref::ZPoint, z_surface::ZPoint, z_top::ZPoint) :: ZPoint</code></pre><p>Convert reference <code>z</code>s to physical <code>z</code>s as prescribed by the given adaption.</p><p>This function has to be the inverse of <code>physical_z_to_ref_z</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/CliMA/ClimaCore.jl/blob/v0.14.5/src/Hypsography/Hypsography.jl#L26-L32">source</a></section></article><h2 id="Limiters"><a class="docs-heading-anchor" href="#Limiters">Limiters</a><a id="Limiters-1"></a><a class="docs-heading-anchor-permalink" href="#Limiters" title="Permalink"></a></h2><p>The limiters supertype is</p><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="ClimaCore.Limiters.AbstractLimiter" href="#ClimaCore.Limiters.AbstractLimiter"><code>ClimaCore.Limiters.AbstractLimiter</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">AbstractLimiter</code></pre><p>Supertype for all limiters.</p><p><strong>Interfaces</strong></p><ul><li><a href="#ClimaCore.Limiters.apply_limiter!"><code>apply_limiter!</code></a></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/CliMA/ClimaCore.jl/blob/v0.14.5/src/Limiters/Limiters.jl#L9-L17">source</a></section></article><p>This class of flux-limiters is applied only in the horizontal direction (on spectral advection operators).</p><h3 id="Interfaces-4"><a class="docs-heading-anchor" href="#Interfaces-4">Interfaces</a><a class="docs-heading-anchor-permalink" href="#Interfaces-4" title="Permalink"></a></h3><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="ClimaCore.Limiters.QuasiMonotoneLimiter" href="#ClimaCore.Limiters.QuasiMonotoneLimiter"><code>ClimaCore.Limiters.QuasiMonotoneLimiter</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">QuasiMonotoneLimiter</code></pre><p>This limiter is inspired by the one presented in Guba et al [<a href="../references/#GubaOpt2014">14</a>]. In the reference paper, it is denoted by OP1, and is outlined in eqs. (37)-(40). Quasimonotone here is meant to be monotone with respect to the spectral element nodal values. This limiter involves solving a constrained optimization problem (a weighted least square problem up to a fixed tolerance) that is completely local to each element.</p><p>As in HOMME, the implementation idea here is the following: we need to find a grid field which is closest to the initial field (in terms of weighted sum), but satisfies the min/max constraints. So, first we find values that do not satisfy constraints and bring these values to a closest constraint. This way we introduce some change in the tracer mass, which we then redistribute so that the l2 error is smallest. This redistribution might violate constraints; thus, we do a few iterations (until <code>abs(Δtracer_mass) &lt;= rtol * tracer_mass</code>).</p><ul><li><code>ρq</code>: tracer density Field, where <code>q</code> denotes tracer concentration per unit mass. This can be a scalar field, or a struct-valued field.</li><li><code>ρ</code>: fluid density Field (scalar).</li></ul><p><strong>Constructor</strong></p><pre><code class="nohighlight hljs">limiter = QuasiMonotoneLimiter(ρq::Field; rtol = eps(eltype(parent(ρq))))</code></pre><p>Creates a limiter instance for the field <code>ρq</code> with relative tolerance <code>rtol</code>.</p><p><strong>Usage</strong></p><p>Call <a href="#ClimaCore.Limiters.compute_bounds!"><code>compute_bounds!</code></a> on the input fields:</p><pre><code class="nohighlight hljs">compute_bounds!(limiter, ρq, ρ)</code></pre><p>Then call <a href="#ClimaCore.Limiters.apply_limiter!"><code>apply_limiter!</code></a> on the output fields:</p><pre><code class="nohighlight hljs">apply_limiter!(ρq, ρ, limiter)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/CliMA/ClimaCore.jl/blob/v0.14.5/src/Limiters/quasimonotone.jl#L6-L43">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="ClimaCore.Limiters.compute_bounds!" href="#ClimaCore.Limiters.compute_bounds!"><code>ClimaCore.Limiters.compute_bounds!</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">compute_bounds!(limiter::QuasiMonotoneLimiter, ρq::Field, ρ::Field)</code></pre><p>Compute the desired bounds for the tracer concentration per unit mass <code>q</code>, based on the tracer density, <code>ρq</code>, and density, <code>ρ</code>, fields.</p><p>This is computed by</p><ol><li><a href="#ClimaCore.Limiters.compute_element_bounds!"><code>compute_element_bounds!</code></a></li><li>starts the ghost exchange (if distributed)</li><li><a href="#ClimaCore.Limiters.compute_neighbor_bounds_local!"><code>compute_neighbor_bounds_local!</code></a></li><li>completes the ghost exchange (if distributed)</li><li><a href="#ClimaCore.Limiters.compute_neighbor_bounds_ghost!"><code>compute_neighbor_bounds_ghost!</code></a> (if distributed)</li></ol></div><a class="docs-sourcelink" target="_blank" href="https://github.com/CliMA/ClimaCore.jl/blob/v0.14.5/src/Limiters/quasimonotone.jl#L206-L218">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="ClimaCore.Limiters.apply_limiter!" href="#ClimaCore.Limiters.apply_limiter!"><code>ClimaCore.Limiters.apply_limiter!</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">apply_limiter!(ρq, ρ, limiter::QuasiMonotoneLimiter)</code></pre><p>Apply the limiter on the tracer density  <code>ρq</code>, using the computed desired bounds on the concentration <code>q</code> and density <code>ρ</code> as an optimal weight. This iterates over each element, calling <a href="#ClimaCore.Limiters.apply_limit_slab!"><code>apply_limit_slab!</code></a>. If the limiter fails to converge for any element, a warning is issued.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/CliMA/ClimaCore.jl/blob/v0.14.5/src/Limiters/quasimonotone.jl#L243-L250">source</a></section></article><h3 id="Internals-3"><a class="docs-heading-anchor" href="#Internals-3">Internals</a><a class="docs-heading-anchor-permalink" href="#Internals-3" title="Permalink"></a></h3><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="ClimaCore.Limiters.compute_element_bounds!" href="#ClimaCore.Limiters.compute_element_bounds!"><code>ClimaCore.Limiters.compute_element_bounds!</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">compute_element_bounds!(limiter::QuasiMonotoneLimiter, ρq, ρ)</code></pre><p>Given two fields <code>ρq</code> and <code>ρ</code>, computes the min and max of <code>q</code> in each element, storing it in <code>limiter.q_bounds</code>.</p><p>Part of <a href="#ClimaCore.Limiters.compute_bounds!"><code>compute_bounds!</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/CliMA/ClimaCore.jl/blob/v0.14.5/src/Limiters/quasimonotone.jl#L85-L92">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="ClimaCore.Limiters.compute_neighbor_bounds_local!" href="#ClimaCore.Limiters.compute_neighbor_bounds_local!"><code>ClimaCore.Limiters.compute_neighbor_bounds_local!</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">compute_neighbor_bounds_local!(limiter::QuasiMonotoneLimiter, topology)</code></pre><p>Update the field <code>limiter.q_bounds_nbr</code> based on <code>limiter.q_bounds</code> in the local neighbors.</p><p>Part of <a href="#ClimaCore.Limiters.compute_bounds!"><code>compute_bounds!</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/CliMA/ClimaCore.jl/blob/v0.14.5/src/Limiters/quasimonotone.jl#L132-L139">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="ClimaCore.Limiters.compute_neighbor_bounds_ghost!" href="#ClimaCore.Limiters.compute_neighbor_bounds_ghost!"><code>ClimaCore.Limiters.compute_neighbor_bounds_ghost!</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">compute_neighbor_bounds_ghost!(limiter::QuasiMonotoneLimiter, topology)</code></pre><p>Update the field <code>limiter.q_bounds_nbr</code> based on <code>limiter.q_bounds</code> in the ghost neighbors. This should be called after the ghost exchange has completed.</p><p>Part of <a href="#ClimaCore.Limiters.compute_bounds!"><code>compute_bounds!</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/CliMA/ClimaCore.jl/blob/v0.14.5/src/Limiters/quasimonotone.jl#L170-L177">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="ClimaCore.Limiters.apply_limit_slab!" href="#ClimaCore.Limiters.apply_limit_slab!"><code>ClimaCore.Limiters.apply_limit_slab!</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">apply_limit_slab!(slab_ρq, slab_ρ, slab_WJ, slab_q_bounds, rtol)</code></pre><p>Apply the computed bounds of the tracer concentration (<code>slab_q_bounds</code>) in the limiter to <code>slab_ρq</code>, given the total mass <code>slab_ρ</code>, metric terms <code>slab_WJ</code>, and relative tolerance <code>rtol</code>. Return whether the tolerance condition could be satisfied.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/CliMA/ClimaCore.jl/blob/v0.14.5/src/Limiters/quasimonotone.jl#L286-L293">source</a></section></article><h2 id="InputOutput"><a class="docs-heading-anchor" href="#InputOutput">InputOutput</a><a id="InputOutput-1"></a><a class="docs-heading-anchor-permalink" href="#InputOutput" title="Permalink"></a></h2><h3 id="Writers"><a class="docs-heading-anchor" href="#Writers">Writers</a><a id="Writers-1"></a><a class="docs-heading-anchor-permalink" href="#Writers" title="Permalink"></a></h3><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="ClimaCore.InputOutput.HDF5Writer" href="#ClimaCore.InputOutput.HDF5Writer"><code>ClimaCore.InputOutput.HDF5Writer</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">HDF5Writer(filename::AbstractString[, context::ClimaComms.AbstractCommsContext];
           overwrite::Bool = true)</code></pre><p>An <code>AbstractWriter</code> for writing to HDF5-formatted files using the ClimaCore storage conventions. An internal cache is used to avoid writing duplicate domains, meshes, topologies and spaces to the file. Use <a href="#ClimaCore.InputOutput.HDF5Reader"><code>HDF5Reader</code></a> to load the data from the file.</p><p>The optional <code>context</code> can be used for writing distributed fields: in this case, the <code>MPICommsContext</code> used passed as an argument: this must match the context used for distributing the <code>Field</code>.</p><p>The writer overwrites or appends to existing files depending on the value of the <code>overwrite</code> keyword argument. When <code>overwrite</code> is <code>false</code>, the writer appends to <code>filename</code> if the file already exists, otherwise it creates a new one.</p><div class="admonition is-info"><header class="admonition-header">Note</header><div class="admonition-body"><p>The default Julia HDF5 binaries are not built with MPI support. To use the distributed functionality, you will need to configure HDF5.jl with an MPI-enabled HDF5 library, see <a href="https://juliaio.github.io/HDF5.jl/stable/#Parallel-HDF5">the HDF5.jl documentation</a>.</p></div></div><p><strong>Interface</strong></p><p><a href="#ClimaCore.InputOutput.write!"><code>write!</code></a></p><p><strong>Usage</strong></p><pre><code class="language-julia hljs">writer = InputOutput.HDF5Writer(filename)
InputOutput.write!(writer, Y, &quot;Y&quot;)
close(writer)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/CliMA/ClimaCore.jl/blob/v0.14.5/src/InputOutput/writers.jl#L3-L38">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="ClimaCore.InputOutput.write!" href="#ClimaCore.InputOutput.write!"><code>ClimaCore.InputOutput.write!</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">write!(writer::AbstractWriter, obj[, preferredname])</code></pre><p>Write the object <code>obj</code> using <code>writer</code>. An optional <code>preferredname</code> can be provided, otherwise <a href="#ClimaCore.InputOutput.defaultname"><code>defaultname</code></a> will be used to generate a name. The name of the object will be returned.</p><p>A cache of domains, meshes, topologies and spaces is kept: if one of these objects has already been written, then the file will not be modified: instead the name under which the object was first written will be returned. Note that <code>Field</code>s and <code>FieldVector</code>s are <em>not</em> cached, and so can be written multiple times.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/CliMA/ClimaCore.jl/blob/v0.14.5/src/InputOutput/writers.jl#L96-L108">source</a></section><section><div><pre><code class="language-julia hljs">write!(writer::HDF5Writer, name =&gt; value...)</code></pre><p>Write one or more <code>name =&gt; value</code> pairs to <code>writer</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/CliMA/ClimaCore.jl/blob/v0.14.5/src/InputOutput/writers.jl#L484-L488">source</a></section><section><div><pre><code class="language-julia hljs">write!(filename::AbstractString, name =&gt; value...)</code></pre><p>Write one or more <code>name =&gt; value</code> pairs to the HDF5 file <code>filename</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/CliMA/ClimaCore.jl/blob/v0.14.5/src/InputOutput/writers.jl#L497-L501">source</a></section></article><h3 id="Readers"><a class="docs-heading-anchor" href="#Readers">Readers</a><a id="Readers-1"></a><a class="docs-heading-anchor-permalink" href="#Readers" title="Permalink"></a></h3><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="ClimaCore.InputOutput.HDF5Reader" href="#ClimaCore.InputOutput.HDF5Reader"><code>ClimaCore.InputOutput.HDF5Reader</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">HDF5Reader(filename::AbstractString[, context::ClimaComms.AbstractCommsContext])</code></pre><p>An <code>AbstractReader</code> for reading from HDF5 files created by <a href="#ClimaCore.InputOutput.HDF5Writer"><code>HDF5Writer</code></a>. The reader object contains an internal cache of domains, meshes, topologies and spaces that are read so that duplicate objects are not created.</p><p>The optional <code>context</code> can be used for reading distributed fields: in this case, the <code>MPICommsContext</code> used passed as an argument: resulting <code>Field</code>s will be distributed using this context. As with <a href="#ClimaCore.InputOutput.HDF5Writer"><code>HDF5Writer</code></a>, this requires a HDF5 library with MPI support.</p><p><strong>Interface</strong></p><ul><li><a href="#ClimaCore.InputOutput.read_domain"><code>read_domain</code></a></li><li><a href="#ClimaCore.InputOutput.read_mesh"><code>read_mesh</code></a></li><li><a href="#ClimaCore.InputOutput.read_topology"><code>read_topology</code></a></li><li><a href="#ClimaCore.InputOutput.read_space"><code>read_space</code></a></li><li><a href="#ClimaCore.InputOutput.read_field"><code>read_field</code></a></li></ul><p><strong>Usage</strong></p><pre><code class="language-julia hljs">reader = InputOutput.HDF5Reader(filename)
Y = read_field(reader, &quot;Y&quot;)
Y.c |&gt; propertynames
Y.f |&gt; propertynames
ρ_field = read_field(reader, &quot;Y.c.ρ&quot;)
w_field = read_field(reader, &quot;Y.f.w&quot;)
close(reader)</code></pre><p>To explore the contents of the <code>reader</code>, use either</p><pre><code class="language-julia hljs">julia&gt; reader |&gt; propertynames</code></pre><p>e.g, to explore the components of the <code>space</code>, </p><pre><code class="language-julia hljs">julia&gt; reader.space_cache
Dict{Any, Any} with 3 entries:
  &quot;center_extruded_finite_difference_space&quot; =&gt; CenterExtrudedFiniteDifferenceSpace:…
  &quot;horizontal_space&quot;                        =&gt; SpectralElementSpace2D:…
  &quot;face_extruded_finite_difference_space&quot;   =&gt; FaceExtrudedFiniteDifferenceSpace:…</code></pre><p>Once &quot;unpacked&quot; as shown above, <code>ClimaCorePlots</code> or <code>ClimaCoreMakie</code> can be used to visualise fields. <code>ClimaCoreTempestRemap</code> supports interpolation onto user-specified grids if necessary.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/CliMA/ClimaCore.jl/blob/v0.14.5/src/InputOutput/readers.jl#L33-L80">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="ClimaCore.InputOutput.read_domain" href="#ClimaCore.InputOutput.read_domain"><code>ClimaCore.InputOutput.read_domain</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">read_domain(reader::AbstractReader, name)</code></pre><p>Reads a domain named <code>name</code> from <code>reader</code>. Domain objects are cached in the reader to avoid creating duplicate objects.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/CliMA/ClimaCore.jl/blob/v0.14.5/src/InputOutput/readers.jl#L173-L178">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="ClimaCore.InputOutput.read_mesh" href="#ClimaCore.InputOutput.read_mesh"><code>ClimaCore.InputOutput.read_mesh</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">read_mesh(reader::AbstractReader, name)</code></pre><p>Reads a mesh named <code>name</code> from <code>reader</code>, or from the reader cache if it has already been read.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/CliMA/ClimaCore.jl/blob/v0.14.5/src/InputOutput/readers.jl#L208-L213">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="ClimaCore.InputOutput.read_topology" href="#ClimaCore.InputOutput.read_topology"><code>ClimaCore.InputOutput.read_topology</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">read_topology(reader::AbstractReader, name)</code></pre><p>Reads a topology named <code>name</code> from <code>reader</code>, or from the reader cache if it has already been read.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/CliMA/ClimaCore.jl/blob/v0.14.5/src/InputOutput/readers.jl#L252-L257">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="ClimaCore.InputOutput.read_space" href="#ClimaCore.InputOutput.read_space"><code>ClimaCore.InputOutput.read_space</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">read_space(reader::AbstractReader, name)</code></pre><p>Reads a space named <code>name</code> from <code>reader</code>, or from the reader cache if it has already been read.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/CliMA/ClimaCore.jl/blob/v0.14.5/src/InputOutput/readers.jl#L372-L377">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="ClimaCore.InputOutput.read_field" href="#ClimaCore.InputOutput.read_field"><code>ClimaCore.InputOutput.read_field</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">read_field(reader, name)</code></pre><p>Reads a <code>Field</code> or <code>FieldVector</code> named <code>name</code> from <code>reader</code>. Fields are <em>not</em> cached, so that reading the same field multiple times will create multiple distinct objects.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/CliMA/ClimaCore.jl/blob/v0.14.5/src/InputOutput/readers.jl#L427-L433">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="ClimaCore.InputOutput.defaultname" href="#ClimaCore.InputOutput.defaultname"><code>ClimaCore.InputOutput.defaultname</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">defaultname(obj)</code></pre><p>Default name of object for InputOutput writers.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/CliMA/ClimaCore.jl/blob/v0.14.5/src/InputOutput/writers.jl#L116-L120">source</a></section></article><h2 id="Remapping"><a class="docs-heading-anchor" href="#Remapping">Remapping</a><a id="Remapping-1"></a><a class="docs-heading-anchor-permalink" href="#Remapping" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="ClimaCore.Remapping.interpolate_array" href="#ClimaCore.Remapping.interpolate_array"><code>ClimaCore.Remapping.interpolate_array</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">interpolate_array(field, xpts, ypts)
interpolate_array(field, xpts, ypts, zpts)</code></pre><p>Interpolate a field to a regular array using pointwise interpolation.</p><p>This is primarily used for plotting and diagnostics.</p><p><strong>Examples</strong></p><pre><code class="language-julia hljs">longpts = range(Geometry.LongPoint(-180.0), Geometry.LongPoint(180.0), length = 21)
latpts = range(Geometry.LatPoint(-80.0), Geometry.LatPoint(80.0), length = 21)
zpts = range(Geometry.ZPoint(0.0), Geometry.ZPoint(1000.0), length = 21)

interpolate_array(field, longpts, latpts, zpts)</code></pre><div class="admonition is-info"><header class="admonition-header">Note</header><div class="admonition-body"><p>Hypsography is not currently handled correctly.</p></div></div></div><a class="docs-sourcelink" target="_blank" href="https://github.com/CliMA/ClimaCore.jl/blob/v0.14.5/src/Remapping/interpolate_array.jl#L235-L255">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="ClimaCore.Remapping.interpolate" href="#ClimaCore.Remapping.interpolate"><code>ClimaCore.Remapping.interpolate</code></a> — <span class="docstring-category">Function</span></header><section><div><p>interpolate(remapper::Remapper, fields)    interpolate!(dest, remapper::Remapper, fields)</p><p>Interpolate the given <code>field</code>(s) as prescribed by <code>remapper</code>.</p><p>The optimal number of fields passed is the <code>buffer_length</code> of the <code>remapper</code>. If more fields are passed, the <code>remapper</code> will batch work with size up to its <code>buffer_length</code>.</p><p>This call mutates the internal (private) state of the <code>remapper</code>.</p><p>Horizontally, interpolation is performed with the barycentric formula in [<a href="../references/#Berrut2004">11</a>], equation (3.2). Vertical interpolation is linear except in the boundary elements where it is 0th order.</p><p><code>interpolate!</code> writes the output to the given <code>dest</code>iniation. <code>dest</code> is expected to be defined on the root process and to be <code>nothing</code> for the other processes.</p><p>Note: <code>interpolate</code> allocates new arrays and has some internal type-instability, <code>interpolate!</code> is non-allocating and type-stable.</p><p>When using <code>interpolate!</code>, the <code>dest</code>ination has to be the same array type as the device in use (e.g., <code>CuArray</code> for CUDA runs).</p><p><strong>Example</strong></p><p>Given <code>field1</code>,<code>field2</code>, two <code>Field</code> defined on a cubed sphere.</p><pre><code class="language-julia hljs">longpts = range(-180.0, 180.0, 21)
latpts = range(-80.0, 80.0, 21)
zpts = range(0.0, 1000.0, 21)

hcoords = [Geometry.LatLongPoint(lat, long) for long in longpts, lat in latpts]
zcoords = [Geometry.ZPoint(z) for z in zpts]

space = axes(field1)

remapper = Remapper(space, hcoords, zcoords)

int1 = interpolate(remapper, field1)
int2 = interpolate(remapper, field2)

# Or
int12 = interpolate(remapper, [field1, field2])
# With int1 = int12[1, :, :, :]</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/CliMA/ClimaCore.jl/blob/v0.14.5/src/Remapping/distributed_remapping.jl#L698-L747">source</a></section></article></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../matrix_fields/">« MatrixFields</a><a class="docs-footer-nextpage" href="../performance_tips/">Performance tips »</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="auto">Automatic (OS)</option><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 1.4.1 on <span class="colophon-date" title="Friday 31 May 2024 20:42">Friday 31 May 2024</span>. Using Julia version 1.10.3.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
