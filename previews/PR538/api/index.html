<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>API · ClimaCore.jl</title><script data-outdated-warner src="../assets/warner.js"></script><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.039/juliamono-regular.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.3/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.3/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.3/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.13.11/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL=".."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../assets/documenter.js"></script><script src="../siteinfo.js"></script><script src="../../versions.js"></script><script src="../../copy.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><div class="docs-package-name"><span class="docs-autofit"><a href="../">ClimaCore.jl</a></span></div><form class="docs-search" action="../search/"><input class="docs-search-query" id="documenter-search-query" name="q" type="text" placeholder="Search docs"/></form><ul class="docs-menu"><li><a class="tocitem" href="../">Home</a></li><li class="is-active"><a class="tocitem" href>API</a><ul class="internal"><li><a class="tocitem" href="#DataLayouts"><span>DataLayouts</span></a></li><li><a class="tocitem" href="#Geometry"><span>Geometry</span></a></li><li><a class="tocitem" href="#Domains"><span>Domains</span></a></li><li><a class="tocitem" href="#Meshes"><span>Meshes</span></a></li><li><a class="tocitem" href="#Topologies"><span>Topologies</span></a></li><li><a class="tocitem" href="#Spaces"><span>Spaces</span></a></li><li><a class="tocitem" href="#RecursiveApply"><span>RecursiveApply</span></a></li><li><a class="tocitem" href="#Fields"><span>Fields</span></a></li><li><a class="tocitem" href="#Limiters"><span>Limiters</span></a></li></ul></li><li><a class="tocitem" href="../operators/">Operators</a></li><li><input class="collapse-toggle" id="menuitem-4" type="checkbox"/><label class="tocitem" for="menuitem-4"><span class="docs-label">Tutorials</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../tutorials/introduction/">Introduction to ClimaCore.jl</a></li></ul></li><li><input class="collapse-toggle" id="menuitem-5" type="checkbox"/><label class="tocitem" for="menuitem-5"><span class="docs-label">Libraries</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../lib/ClimaCoreVTK/">ClimaCoreVTK.jl</a></li><li><a class="tocitem" href="../lib/ClimaCoreTempestRemap/">ClimaCoreTempestRemap.jl</a></li></ul></li><li><a class="tocitem" href="../references/">References</a></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><nav class="breadcrumb"><ul class="is-hidden-mobile"><li class="is-active"><a href>API</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>API</a></li></ul></nav><div class="docs-right"><a class="docs-edit-link" href="https://github.com/CliMA/ClimaCore.jl/blob/master/docs/src/api.md" title="Edit on GitHub"><span class="docs-icon fab"></span><span class="docs-label is-hidden-touch">Edit on GitHub</span></a><a class="docs-settings-button fas fa-cog" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-sidebar-button fa fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a></div></header><article class="content" id="documenter-page"><h1 id="API"><a class="docs-heading-anchor" href="#API">API</a><a id="API-1"></a><a class="docs-heading-anchor-permalink" href="#API" title="Permalink"></a></h1><h2 id="DataLayouts"><a class="docs-heading-anchor" href="#DataLayouts">DataLayouts</a><a id="DataLayouts-1"></a><a class="docs-heading-anchor-permalink" href="#DataLayouts" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-binding" id="ClimaCore.DataLayouts" href="#ClimaCore.DataLayouts"><code>ClimaCore.DataLayouts</code></a> — <span class="docstring-category">Module</span></header><section><div><pre><code class="language-julia hljs">ClimaCore.DataLayouts</code></pre><p>Notation:</p><ul><li><code>i,j</code> are horizontal node indices within an element</li><li><code>k</code> is the vertical node index within an element</li><li><code>f</code> is the field index</li><li><code>v</code> is the vertical element index in a stack</li><li><code>h</code> is the element stack index</li></ul><p>Data layout is specified by the order in which they appear, e.g. <code>IJKFVH</code> indexes the underlying array as <code>[i,j,k,f,v,h]</code></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/CliMA/ClimaCore.jl/blob/b439b15db52a660f465ccf7e19008112c0bc11ad/src/DataLayouts/DataLayouts.jl#L1-L14">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="ClimaCore.DataLayouts.IF" href="#ClimaCore.DataLayouts.IF"><code>ClimaCore.DataLayouts.IF</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">IF{S, Ni, A} &lt;: DataSlab1D{S, Ni}</code></pre><p>Backing <code>DataLayout</code> for 1D spectral element slab data.</p><p>Nodal element data (I) are contiguous for each <code>S</code> datatype struct field (F) for a single element slab.</p><p>A <code>DataSlab1D</code> view can be returned from other <code>Data1D</code> objects by calling <code>slab(data, idx...)</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/CliMA/ClimaCore.jl/blob/b439b15db52a660f465ccf7e19008112c0bc11ad/src/DataLayouts/DataLayouts.jl#L542-L550">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="ClimaCore.DataLayouts.IJF" href="#ClimaCore.DataLayouts.IJF"><code>ClimaCore.DataLayouts.IJF</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">IJF{S, Nij, A} &lt;: DataSlab2D{S, Nij}</code></pre><p>Backing <code>DataLayout</code> for 2D spectral element slab data.</p><p>Nodal element data (I,J) are contiguous for each <code>S</code> datatype struct field (F) for a single element slab.</p><p>A <code>DataSlab2D</code> view can be returned from other <code>Data2D</code> objects by calling <code>slab(data, idx...)</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/CliMA/ClimaCore.jl/blob/b439b15db52a660f465ccf7e19008112c0bc11ad/src/DataLayouts/DataLayouts.jl#L433-L441">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="ClimaCore.DataLayouts.VF" href="#ClimaCore.DataLayouts.VF"><code>ClimaCore.DataLayouts.VF</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">VF{S, A} &lt;: DataColumn{S}</code></pre><p>Backing <code>DataLayout</code> for 1D FV column data.</p><p>Column level data (V) are contiguous for each <code>S</code> datatype struct field (F).</p><p>A <code>DataColumn</code> view can be returned from other <code>Data1DX</code>, <code>Data2DX</code> objects by calling <code>column(data, idx...)</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/CliMA/ClimaCore.jl/blob/b439b15db52a660f465ccf7e19008112c0bc11ad/src/DataLayouts/DataLayouts.jl#L608-L616">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="ClimaCore.DataLayouts.IFH" href="#ClimaCore.DataLayouts.IFH"><code>ClimaCore.DataLayouts.IFH</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">IFH{S, Ni, A} &lt;: Data1D{S, Ni}</code></pre><p>Backing <code>DataLayout</code> for 1D spectral element slabs.</p><p>Element nodal point (I) data is contiguous for each datatype <code>S</code> struct field (F), for each 1D mesh element (H).</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/CliMA/ClimaCore.jl/blob/b439b15db52a660f465ccf7e19008112c0bc11ad/src/DataLayouts/DataLayouts.jl#L323-L330">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="ClimaCore.DataLayouts.IJFH" href="#ClimaCore.DataLayouts.IJFH"><code>ClimaCore.DataLayouts.IJFH</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">IJFH{S, Nij, A} &lt;: Data2D{S, Nij}</code></pre><p>Backing <code>DataLayout</code> for 2D spectral element slabs.</p><p>Element nodal point (I,J) data is contiguous for each datatype <code>S</code> struct field (F), for each 2D mesh element slab (H).</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/CliMA/ClimaCore.jl/blob/b439b15db52a660f465ccf7e19008112c0bc11ad/src/DataLayouts/DataLayouts.jl#L231-L238">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="ClimaCore.DataLayouts.VIFH" href="#ClimaCore.DataLayouts.VIFH"><code>ClimaCore.DataLayouts.VIFH</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">VIFH{S, Ni, A} &lt;: Data1DX{S, Ni}</code></pre><p>Backing <code>DataLayout</code> for 1D spectral element slab + extruded 1D FV column data.</p><p>Column levels (V) are contiguous for every element nodal point (I) for each datatype <code>S</code> struct field (F), for each 1D mesh element slab (H).</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/CliMA/ClimaCore.jl/blob/b439b15db52a660f465ccf7e19008112c0bc11ad/src/DataLayouts/DataLayouts.jl#L832-L839">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="ClimaCore.DataLayouts.VIJFH" href="#ClimaCore.DataLayouts.VIJFH"><code>ClimaCore.DataLayouts.VIJFH</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">VIJFH{S, Nij, A} &lt;: Data2DX{S, Nij}</code></pre><p>Backing <code>DataLayout</code> for 2D spectral element slab + extruded 1D FV column data.</p><p>Column levels (V) are contiguous for every element nodal point (I, J) for each <code>S</code> datatype struct field (F), for each 2D mesh element slab (H).</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/CliMA/ClimaCore.jl/blob/b439b15db52a660f465ccf7e19008112c0bc11ad/src/DataLayouts/DataLayouts.jl#L708-L715">source</a></section></article><h2 id="Geometry"><a class="docs-heading-anchor" href="#Geometry">Geometry</a><a id="Geometry-1"></a><a class="docs-heading-anchor-permalink" href="#Geometry" title="Permalink"></a></h2><h3 id="Coordinates"><a class="docs-heading-anchor" href="#Coordinates">Coordinates</a><a id="Coordinates-1"></a><a class="docs-heading-anchor-permalink" href="#Coordinates" title="Permalink"></a></h3><article class="docstring"><header><a class="docstring-binding" id="ClimaCore.Geometry.AbstractPoint" href="#ClimaCore.Geometry.AbstractPoint"><code>ClimaCore.Geometry.AbstractPoint</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">AbstractPoint</code></pre><p>Represents a point in space.</p><p>The following types are supported:</p><ul><li><code>XPoint(x)</code></li><li><code>YPoint(y)</code></li><li><code>ZPoint(z)</code></li><li><code>XYPoint(x, y)</code></li><li><code>XZPoint(x, z)</code></li><li><code>XYZPoint(x, y, z)</code></li><li><code>LatLongPoint(lat, long)</code></li><li><code>LatLongZPoint(lat, long, z)</code></li><li><code>Cartesian1Point(x1)</code></li><li><code>Cartesian2Point(x2)</code></li><li><code>Cartesian3Point(x3)</code></li><li><code>Cartesian12Point(x1, x2)</code></li><li><code>Cartesian13Point(x1, x3)</code></li><li><code>Cartesian123Point(x1, x2, x3)</code></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/CliMA/ClimaCore.jl/blob/b439b15db52a660f465ccf7e19008112c0bc11ad/src/Geometry/coordinates.jl#L1-L21">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="ClimaCore.Geometry.float_type" href="#ClimaCore.Geometry.float_type"><code>ClimaCore.Geometry.float_type</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">float_type(T)</code></pre><p>Return the floating point type backing <code>T</code>: <code>T</code> can either be an object or a type.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/CliMA/ClimaCore.jl/blob/b439b15db52a660f465ccf7e19008112c0bc11ad/src/Geometry/coordinates.jl#L24-L28">source</a></section></article><h2 id="Domains"><a class="docs-heading-anchor" href="#Domains">Domains</a><a id="Domains-1"></a><a class="docs-heading-anchor-permalink" href="#Domains" title="Permalink"></a></h2><h3 id="Types"><a class="docs-heading-anchor" href="#Types">Types</a><a id="Types-1"></a><a class="docs-heading-anchor-permalink" href="#Types" title="Permalink"></a></h3><article class="docstring"><header><a class="docstring-binding" id="ClimaCore.Domains.AbstractDomain" href="#ClimaCore.Domains.AbstractDomain"><code>ClimaCore.Domains.AbstractDomain</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">AbstractDomain</code></pre><p>A domain represents a region of space.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/CliMA/ClimaCore.jl/blob/b439b15db52a660f465ccf7e19008112c0bc11ad/src/Domains/Domains.jl#L7-L11">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="ClimaCore.Domains.IntervalDomain" href="#ClimaCore.Domains.IntervalDomain"><code>ClimaCore.Domains.IntervalDomain</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">IntervalDomain(coord⁻, coord⁺; periodic=true)
IntervalDomain(coord⁻, coord⁺; boundary_names::Tuple{Symbol,Symbol})</code></pre><p>Construct a <code>IntervalDomain</code>, the closed interval is given by <code>coord⁻</code>, <code>coord⁺</code> coordinate arguments.</p><p>Either a <code>periodic</code> or <code>boundary_names</code> keyword argument is required.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/CliMA/ClimaCore.jl/blob/b439b15db52a660f465ccf7e19008112c0bc11ad/src/Domains/Domains.jl#L38-L45">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="ClimaCore.Domains.RectangleDomain" href="#ClimaCore.Domains.RectangleDomain"><code>ClimaCore.Domains.RectangleDomain</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">RectangleDomain(x1::ClosedInterval, x2::ClosedInterval;
    x1boundary::Tuple{Symbol,Symbol},
    x2boundary::Tuple{Symbol,Symbol},
    x1periodic = false,
    x2periodic = false,
)</code></pre><p>Construct a <code>RectangularDomain</code> in the horizontal. If a given x1 or x2 boundary is not periodic, then <code>x1boundary</code> or <code>x2boundary</code> boundary name keyword arguments must be supplied.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/CliMA/ClimaCore.jl/blob/b439b15db52a660f465ccf7e19008112c0bc11ad/src/Domains/Domains.jl#L94-L104">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="ClimaCore.Domains.SphereDomain" href="#ClimaCore.Domains.SphereDomain"><code>ClimaCore.Domains.SphereDomain</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">SphereDomain(radius)</code></pre><p>A domain representing the surface of a sphere with radius <code>radius</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/CliMA/ClimaCore.jl/blob/b439b15db52a660f465ccf7e19008112c0bc11ad/src/Domains/Domains.jl#L135-L139">source</a></section></article><h3 id="Interfaces"><a class="docs-heading-anchor" href="#Interfaces">Interfaces</a><a id="Interfaces-1"></a><a class="docs-heading-anchor-permalink" href="#Interfaces" title="Permalink"></a></h3><article class="docstring"><header><a class="docstring-binding" id="ClimaCore.Domains.boundary_names" href="#ClimaCore.Domains.boundary_names"><code>ClimaCore.Domains.boundary_names</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">boundary_names(obj::Union{AbstractDomain, AbstractMesh, AbstractTopology})</code></pre><p>A tuple or vector of unique boundary names of a spatial domain.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/CliMA/ClimaCore.jl/blob/b439b15db52a660f465ccf7e19008112c0bc11ad/src/Domains/Domains.jl#L18-L22">source</a></section></article><h2 id="Meshes"><a class="docs-heading-anchor" href="#Meshes">Meshes</a><a id="Meshes-1"></a><a class="docs-heading-anchor-permalink" href="#Meshes" title="Permalink"></a></h2><h3 id="Mesh-types"><a class="docs-heading-anchor" href="#Mesh-types">Mesh types</a><a id="Mesh-types-1"></a><a class="docs-heading-anchor-permalink" href="#Mesh-types" title="Permalink"></a></h3><article class="docstring"><header><a class="docstring-binding" id="ClimaCore.Meshes.AbstractMesh" href="#ClimaCore.Meshes.AbstractMesh"><code>ClimaCore.Meshes.AbstractMesh</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">AbstractMesh{dim}</code></pre><p>A <code>Mesh</code> is an object which represents how we discretize a domain into elements.</p><p>It should be lightweight (i.e. exists on all MPI ranks), e.g for meshes stored in a file, it would contain the filename.</p><p><strong>Face and vertex numbering</strong></p><p>In 1D, faces and vertices are the same, and both are numbered <code>[1,2]</code>.</p><p>In 2D, a face is a line segment between to vertices, and both are numbered <code>[1,2,3,4]</code>, in a counter-clockwise direction.</p><pre><code class="nohighlight hljs"> v4        f3        v3
   o-----------------o
   |                 |	    face    vertices
   |                 |	      f1 =&gt;  v1 v2
f4 |                 | f2     f2 =&gt;  v2 v3
   |                 |	      f3 =&gt;  v3 v4
   |                 |        f4 =&gt;  v4 v1
   |                 |
   o-----------------o
  v1       f1        v2</code></pre><p><strong>Interface</strong></p><p>A subtype of <code>AbstractMesh</code> should define the following methods:</p><ul><li><a href="#ClimaCore.Meshes.domain"><code>domain(mesh)</code></a></li><li><a href="#ClimaCore.Meshes.elements"><code>elements(mesh)</code></a></li><li><a href="#ClimaCore.Meshes.is_boundary_face"><code>is_boundary_face(mesh, elem, face)</code></a></li><li><a href="#ClimaCore.Meshes.boundary_face_name"><code>boundary_face_name(mesh, elem, face)</code></a></li><li><a href="#ClimaCore.Meshes.opposing_face"><code>opposing_face(mesh, elem, face)</code></a></li><li><a href="#ClimaCore.Meshes.coordinates"><code>coordinates(mesh, elem, vert)</code></a></li><li><a href="#ClimaCore.Meshes.containing_element"><code>containing_element</code></a> (optional)</li></ul><p>The following types/methods are provided by <code>AbstractMesh</code>:</p><ul><li><a href="#ClimaCore.Meshes.SharedVertices"><code>SharedVertices(mesh, elem, vert)</code></a></li><li><a href="#ClimaCore.Meshes.face_connectivity_matrix"><code>face_connectivity_matrix(mesh[,elemorder])</code></a></li><li><a href="#ClimaCore.Meshes.vertex_connectivity_matrix"><code>vertex_connectivity_matrix(mesh[,elemorder])</code></a></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/CliMA/ClimaCore.jl/blob/b439b15db52a660f465ccf7e19008112c0bc11ad/src/Meshes/Meshes.jl#L21-L63">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="ClimaCore.Meshes.IntervalMesh" href="#ClimaCore.Meshes.IntervalMesh"><code>ClimaCore.Meshes.IntervalMesh</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">IntervalMesh &lt;: AbstractMesh</code></pre><p>A 1D mesh on an <code>IntervalDomain</code>.</p><p><strong>Constuctors</strong></p><pre><code class="nohighlight hljs">IntervalMesh(domain::IntervalDomain, faces::AbstractVector)</code></pre><p>Construct a 1D mesh with face locations at <code>faces</code>.</p><pre><code class="nohighlight hljs">IntervalMesh(domain::IntervalDomain[, stetching=Uniform()]; nelems=)</code></pre><p>Constuct a 1D mesh on <code>domain</code> with <code>nelems</code> elements, using <code>stretching</code>. Possible values of <code>stretching</code> are:</p><ul><li><a href="#ClimaCore.Meshes.Uniform"><code>Uniform()</code></a></li><li><a href="#ClimaCore.Meshes.ExponentialStretching"><code>ExponentialStretching(H)</code></a></li><li><a href="@ref"><code>GeneralizedExponentialStretching(dz_surface, dz_top)</code></a></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/CliMA/ClimaCore.jl/blob/b439b15db52a660f465ccf7e19008112c0bc11ad/src/Meshes/interval.jl#L1-L19">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="ClimaCore.Meshes.RectilinearMesh" href="#ClimaCore.Meshes.RectilinearMesh"><code>ClimaCore.Meshes.RectilinearMesh</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">RectilinearMesh &lt;: AbstractMesh2D</code></pre><p><strong>Constructors</strong></p><pre><code class="nohighlight hljs">RectilinearMesh(domain::RectangleDomain, n1, n2)</code></pre><p>Construct a <code>RectilinearMesh</code> of equally-spaced <code>n1</code> by <code>n2</code> elements on <code>domain</code>.</p><pre><code class="nohighlight hljs">RectilinearMesh(intervalmesh1::IntervalMesh1, intervalmesh2::IntervalMesh2)</code></pre><p>Construct the product mesh of <code>intervalmesh1</code> and <code>intervalmesh2</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/CliMA/ClimaCore.jl/blob/b439b15db52a660f465ccf7e19008112c0bc11ad/src/Meshes/rectangle.jl#L1-L13">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="ClimaCore.Meshes.AbstractCubedSphere" href="#ClimaCore.Meshes.AbstractCubedSphere"><code>ClimaCore.Meshes.AbstractCubedSphere</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">AbstractCubedSphere &lt;: AbstractMesh2D</code></pre><p>This is an abstract type of cubed-sphere meshes on <code>SphereDomain</code>s. A cubed-sphere mesh has 6 panels, laid out as follows:</p><pre><code class="nohighlight hljs">                                          :   Panel 1   :
                            +-------------+-------------+
                            |     +x1     |     +x1     |
                            |             |             |
                            |    Panel    |    Panel    |
                            |+x3   5   -x3|-x2   6   +x2|
                            |     -x2     |     -x3     |
                            |             |             |
                            |     -x1     |     -x1     |
              +-------------+-------------+-------------+
              |     -x2     |     -x2     |
              |             |             |
              |    Panel    |    Panel    |
              |+x1   3   -x1|+x3   4   -x3|
              |     +x3     |     -x1     |
              |             |             |
              |     +x2     |     +x2     |
+-------------+-------------+-------------+
|     +x3     |     +x3     |
|             |             |
|    Panel    |    Panel    |
|-x2   1   +x2|+x1   2   -x1|
|     +x1     |     +x2     |
|             |             |
|     -x3     |     -x3     |
+-------------+-------------+
:   Panel 6   :</code></pre><p>This is the same panel ordering used by the S2 Geometry library (though we use 1-based instead of 0-based numering).</p><p>Elements are indexed by a <code>CartesianIndex{3}</code> object, where the components are:</p><ul><li>horizontal element index (left to right) within each panel.</li><li>vertical element index (bottom to top) within each panel.</li><li>panel number</li></ul><p>Subtypes should have the following fields:</p><ul><li><code>domain</code>: a <code>SphereDomain</code></li><li><code>ne</code>: number of elements across each panel</li></ul><p><strong>External links</strong></p><ul><li><a href="https://s2geometry.io/devguide/s2cell_hierarchy">S2Geometry library</a></li><li><a href="https://mitgcm.readthedocs.io/en/latest/phys_pkgs/exch2.html?highlight=cube%20sphere#fig-48tile">MIT GCM exch2</a></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/CliMA/ClimaCore.jl/blob/b439b15db52a660f465ccf7e19008112c0bc11ad/src/Meshes/cubedsphere.jl#L1-L51">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="ClimaCore.Meshes.EquiangularCubedSphere" href="#ClimaCore.Meshes.EquiangularCubedSphere"><code>ClimaCore.Meshes.EquiangularCubedSphere</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">EquiangularCubedSphere &lt;: AbstractCubedSphere</code></pre><p>An equiangular gnomonic mesh proposed by <a href="../references/#Ronchi1996">C. Ronchi, R. Iacono, P. S. Paolucci (1996)</a>. Uses the element indexing convention of <a href="#ClimaCore.Meshes.AbstractCubedSphere"><code>AbstractCubedSphere</code></a>.</p><p><strong>Constructors</strong></p><pre><code class="nohighlight hljs">EquiangularCubedSphere(
    domain::Domains.SphereDomain,
    ne::Integer,
    localelementmap=NormalizedBilinearMap()
    )</code></pre><p>Constuct an <code>EquiangularCubedSphere</code> on <code>domain</code> with <code>ne</code> elements across each panel.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/CliMA/ClimaCore.jl/blob/b439b15db52a660f465ccf7e19008112c0bc11ad/src/Meshes/cubedsphere.jl#L327-L343">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="ClimaCore.Meshes.EquidistantCubedSphere" href="#ClimaCore.Meshes.EquidistantCubedSphere"><code>ClimaCore.Meshes.EquidistantCubedSphere</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">EquidistantCubedSphere &lt;: AbstractCubedSphere</code></pre><p>An equidistant gnomonic mesh outlined in <a href="../references/#Rancic1996">M. Rančić, R. J. Purser, F. Mesinger (1996)</a> and <a href="../references/#Nair2005">Ramachandran D Nair, Stephen J Thomas, Richard D Loft (2005)</a>. Uses the element indexing convention of <a href="#ClimaCore.Meshes.AbstractCubedSphere"><code>AbstractCubedSphere</code></a>.</p><p><strong>Constructors</strong></p><pre><code class="nohighlight hljs">EquidistantCubedSphere(domain::Domains.SphereDomain, ne::Integer)</code></pre><p>Constuct an <code>EquidistantCubedSphere</code> on <code>domain</code> with <code>ne</code> elements across each panel.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/CliMA/ClimaCore.jl/blob/b439b15db52a660f465ccf7e19008112c0bc11ad/src/Meshes/cubedsphere.jl#L378-L390">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="ClimaCore.Meshes.ConformalCubedSphere" href="#ClimaCore.Meshes.ConformalCubedSphere"><code>ClimaCore.Meshes.ConformalCubedSphere</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">ConformalCubedSphere &lt;: AbstractCubedSphere</code></pre><p>A conformal mesh outlined in <a href="../references/#Rancic1996">M. Rančić, R. J. Purser, F. Mesinger (1996)</a>. Uses the element indexing convention of <a href="#ClimaCore.Meshes.AbstractCubedSphere"><code>AbstractCubedSphere</code></a>.</p><p><strong>Constructors</strong></p><pre><code class="nohighlight hljs">ConformalCubedSphere(domain::Domains.SphereDomain, ne::Integer)</code></pre><p>Constuct an <code>ConformalCubedSphere</code> on <code>domain</code> with <code>ne</code> elements across each panel.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/CliMA/ClimaCore.jl/blob/b439b15db52a660f465ccf7e19008112c0bc11ad/src/Meshes/cubedsphere.jl#L416-L428">source</a></section></article><h3 id="Local-element-map"><a class="docs-heading-anchor" href="#Local-element-map">Local element map</a><a id="Local-element-map-1"></a><a class="docs-heading-anchor-permalink" href="#Local-element-map" title="Permalink"></a></h3><article class="docstring"><header><a class="docstring-binding" id="ClimaCore.Meshes.LocalElementMap" href="#ClimaCore.Meshes.LocalElementMap"><code>ClimaCore.Meshes.LocalElementMap</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">LocalElementMap</code></pre><p>An abstract type of mappings from the reference element to a physical domain.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/CliMA/ClimaCore.jl/blob/b439b15db52a660f465ccf7e19008112c0bc11ad/src/Meshes/cubedsphere.jl#L54-L58">source</a></section></article><div class="admonition is-warning"><header class="admonition-header">Missing docstring.</header><div class="admonition-body"><p>Missing docstring for <code>Meshes.LocalElementMap</code>. Check Documenter&#39;s build log for details.</p></div></div><article class="docstring"><header><a class="docstring-binding" id="ClimaCore.Meshes.IntrinsicMap" href="#ClimaCore.Meshes.IntrinsicMap"><code>ClimaCore.Meshes.IntrinsicMap</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">IntrinsicMap()</code></pre><p>This <a href="#ClimaCore.Meshes.LocalElementMap"><code>LocalElementMap</code></a> uses the intrinsic mapping of the cubed sphere to map the reference element to the physical domain.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/CliMA/ClimaCore.jl/blob/b439b15db52a660f465ccf7e19008112c0bc11ad/src/Meshes/cubedsphere.jl#L61-L66">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="ClimaCore.Meshes.NormalizedBilinearMap" href="#ClimaCore.Meshes.NormalizedBilinearMap"><code>ClimaCore.Meshes.NormalizedBilinearMap</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">NormalizedBilinearMap()</code></pre><p>The <a href="#ClimaCore.Meshes.LocalElementMap"><code>LocalElementMap</code></a> for meshes on spherical domains of <a href="../references/#Guba2014">O. Guba, M. A. Taylor, P. A. Ullrich, J. R. Overfelt, M. N. Levy (2014)</a>. It uses bilinear interpolation between the Cartesian coordinates of the element vertices, then normalizes the result to lie on the sphere.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/CliMA/ClimaCore.jl/blob/b439b15db52a660f465ccf7e19008112c0bc11ad/src/Meshes/cubedsphere.jl#L69-L76">source</a></section></article><h3 id="Mesh-stretching"><a class="docs-heading-anchor" href="#Mesh-stretching">Mesh stretching</a><a id="Mesh-stretching-1"></a><a class="docs-heading-anchor-permalink" href="#Mesh-stretching" title="Permalink"></a></h3><article class="docstring"><header><a class="docstring-binding" id="ClimaCore.Meshes.Uniform" href="#ClimaCore.Meshes.Uniform"><code>ClimaCore.Meshes.Uniform</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">Uniform()</code></pre><p>Use uniformly-sized elements.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/CliMA/ClimaCore.jl/blob/b439b15db52a660f465ccf7e19008112c0bc11ad/src/Meshes/interval.jl#L76-L80">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="ClimaCore.Meshes.ExponentialStretching" href="#ClimaCore.Meshes.ExponentialStretching"><code>ClimaCore.Meshes.ExponentialStretching</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">ExponentialStretching(H)</code></pre><p>Apply exponential stretching to the domain when constructing elements. <code>H</code> is the scale height (a typical atmospheric scale height <code>H ≈ 7.5</code>km).</p><p>For an interval <span>$[z_0,z_1]$</span>, this makes the elements uniformally spaced in <span>$\zeta$</span>, where</p><p class="math-container">\[\zeta = \frac{1 - e^{-\eta/h}}{1-e^{-1/h}},\]</p><p>where <span>$\eta = \frac{z - z_0}{z_1-z_0}$</span>, and <span>$h = \frac{H}{z_1-z_0}$</span> is the non-dimensional scale height.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/CliMA/ClimaCore.jl/blob/b439b15db52a660f465ccf7e19008112c0bc11ad/src/Meshes/interval.jl#L96-L109">source</a></section></article><h3 id="Interfaces-2"><a class="docs-heading-anchor" href="#Interfaces-2">Interfaces</a><a class="docs-heading-anchor-permalink" href="#Interfaces-2" title="Permalink"></a></h3><article class="docstring"><header><a class="docstring-binding" id="ClimaCore.Meshes.domain" href="#ClimaCore.Meshes.domain"><code>ClimaCore.Meshes.domain</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">Meshes.domain(mesh::AbstractMesh)</code></pre><p>The <a href="#ClimaCore.Domains.AbstractDomain"><code>Domains.AbstractDomain</code></a> on which the mesh is defined.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/CliMA/ClimaCore.jl/blob/b439b15db52a660f465ccf7e19008112c0bc11ad/src/Meshes/Meshes.jl#L69-L73">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="ClimaCore.Meshes.elements" href="#ClimaCore.Meshes.elements"><code>ClimaCore.Meshes.elements</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">Meshes.elements(mesh::AbstractMesh)</code></pre><p>An iterator over the elements of a mesh. Elements of a mesh can be of any type.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/CliMA/ClimaCore.jl/blob/b439b15db52a660f465ccf7e19008112c0bc11ad/src/Meshes/Meshes.jl#L76-L80">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="ClimaCore.Meshes.nelements" href="#ClimaCore.Meshes.nelements"><code>ClimaCore.Meshes.nelements</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">nelements(mesh::AbstractMesh)</code></pre><p>The number of elements in the mesh.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/CliMA/ClimaCore.jl/blob/b439b15db52a660f465ccf7e19008112c0bc11ad/src/Meshes/common.jl#L4-L8">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="ClimaCore.Meshes.is_boundary_face" href="#ClimaCore.Meshes.is_boundary_face"><code>ClimaCore.Meshes.is_boundary_face</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">Meshes.is_boundary_face(mesh::AbstractMesh, elem, face::Int)::Bool</code></pre><p>Determine whether face <code>face</code> of element <code>elem</code> is on the boundary of <code>mesh</code>.</p><p><code>elem</code> should be an element of <a href="#ClimaCore.Meshes.elements"><code>elements(mesh)</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/CliMA/ClimaCore.jl/blob/b439b15db52a660f465ccf7e19008112c0bc11ad/src/Meshes/Meshes.jl#L83-L89">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="ClimaCore.Meshes.boundary_face_name" href="#ClimaCore.Meshes.boundary_face_name"><code>ClimaCore.Meshes.boundary_face_name</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">Meshes.boundary_face_name(mesh::AbstractMesh, elem, face::Int)::Union{Symbol,Nothing}</code></pre><p>The name of the boundary facing <code>face</code> of element <code>elem</code>, or <code>nothing</code> if it is not on the boundary.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/CliMA/ClimaCore.jl/blob/b439b15db52a660f465ccf7e19008112c0bc11ad/src/Meshes/Meshes.jl#L92-L97">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="ClimaCore.Meshes.opposing_face" href="#ClimaCore.Meshes.opposing_face"><code>ClimaCore.Meshes.opposing_face</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">opelem, opface, reversed = Meshes.opposing_face(mesh::AbstractMesh, elem, face::Int)</code></pre><p>The element and face (<code>opelem</code>, <code>opface</code>) that oppose face <code>face</code> of element <code>elem</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/CliMA/ClimaCore.jl/blob/b439b15db52a660f465ccf7e19008112c0bc11ad/src/Meshes/Meshes.jl#L100-L104">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="ClimaCore.Meshes.coordinates" href="#ClimaCore.Meshes.coordinates"><code>ClimaCore.Meshes.coordinates</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">Meshes.coordinates(mesh, elem, vert::Int)
Meshes.coordinates(mesh, elem, ξ::SVector)</code></pre><p>Return the physical coordinates of a point in an element <code>elem</code> of <code>mesh</code>. The position of the point can either be a vertex number <code>vert</code> or the coordinates <code>ξ</code> in the reference element.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/CliMA/ClimaCore.jl/blob/b439b15db52a660f465ccf7e19008112c0bc11ad/src/Meshes/common.jl#L164-L171">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="ClimaCore.Meshes.containing_element" href="#ClimaCore.Meshes.containing_element"><code>ClimaCore.Meshes.containing_element</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">elem = Meshes.containing_element(mesh::AbstractMesh, coord)</code></pre><p>The element <code>elem</code> in <code>mesh</code> containing the coordinate <code>coord</code>. If the coordinate falls on the boundary between two or more elements, an arbitrary element is chosen.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/CliMA/ClimaCore.jl/blob/b439b15db52a660f465ccf7e19008112c0bc11ad/src/Meshes/common.jl#L181-L187">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="ClimaCore.Meshes.reference_coordinates" href="#ClimaCore.Meshes.reference_coordinates"><code>ClimaCore.Meshes.reference_coordinates</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">ξ = Meshes.reference_coordinates(mesh::AbstractMesh, elem, coord)</code></pre><p>An <code>SVector</code> of coordinates in the reference element such that</p><pre><code class="nohighlight hljs">Meshes.coordinates(mesh, elem, ξ) == coord</code></pre><p>This can be used for interpolation to a specific point.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/CliMA/ClimaCore.jl/blob/b439b15db52a660f465ccf7e19008112c0bc11ad/src/Meshes/common.jl#L190-L198">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="ClimaCore.Meshes.SharedVertices" href="#ClimaCore.Meshes.SharedVertices"><code>ClimaCore.Meshes.SharedVertices</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">Meshes.SharedVertices(mesh, elem, vert)</code></pre><p>An iterator over (element, vertex) pairs that are shared with <code>(elem,vert)</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/CliMA/ClimaCore.jl/blob/b439b15db52a660f465ccf7e19008112c0bc11ad/src/Meshes/common.jl#L28-L32">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="ClimaCore.Meshes.face_connectivity_matrix" href="#ClimaCore.Meshes.face_connectivity_matrix"><code>ClimaCore.Meshes.face_connectivity_matrix</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">M = Meshes.face_connectivity_matrix(mesh, elemorder = elements(mesh))</code></pre><p>Construct a <code>Bool</code>-valued <code>SparseCSCMatrix</code> containing the face connections of <code>mesh</code>. Elements are indexed according to <code>elemorder</code>.</p><p>Note that <code>M[i,i] == true</code> only if two distinct faces of element <code>i</code> are connected.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/CliMA/ClimaCore.jl/blob/b439b15db52a660f465ccf7e19008112c0bc11ad/src/Meshes/common.jl#L101-L108">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="ClimaCore.Meshes.vertex_connectivity_matrix" href="#ClimaCore.Meshes.vertex_connectivity_matrix"><code>ClimaCore.Meshes.vertex_connectivity_matrix</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">M = Meshes.vertex_connectivity_matrix(mesh, elemorder = elements(mesh))</code></pre><p>Construct a <code>Bool</code>-valued <code>SparseCSCMatrix</code> containing the vertex connections of <code>mesh</code>. Elements are indexed according to <code>elemorder</code>.</p><p>Note that <code>M[i,i] == true</code> only if two distinct vertices of element <code>i</code> are connected.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/CliMA/ClimaCore.jl/blob/b439b15db52a660f465ccf7e19008112c0bc11ad/src/Meshes/common.jl#L132-L139">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="ClimaCore.Meshes.linearindices" href="#ClimaCore.Meshes.linearindices"><code>ClimaCore.Meshes.linearindices</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">Meshes.linearindices(elemorder)</code></pre><p>Given a data structure <code>elemorder[i] = elem</code> that orders elements, construct the inverse map from <code>orderindex = linearindices(elemorder)</code> such that <code>orderindex[elem] = i</code>.</p><p>This will try to use the most efficient structure available.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/CliMA/ClimaCore.jl/blob/b439b15db52a660f465ccf7e19008112c0bc11ad/src/Meshes/common.jl#L75-L83">source</a></section></article><h2 id="Topologies"><a class="docs-heading-anchor" href="#Topologies">Topologies</a><a id="Topologies-1"></a><a class="docs-heading-anchor-permalink" href="#Topologies" title="Permalink"></a></h2><h3 id="Types-2"><a class="docs-heading-anchor" href="#Types-2">Types</a><a class="docs-heading-anchor-permalink" href="#Types-2" title="Permalink"></a></h3><article class="docstring"><header><a class="docstring-binding" id="ClimaCore.Topologies.AbstractTopology" href="#ClimaCore.Topologies.AbstractTopology"><code>ClimaCore.Topologies.AbstractTopology</code></a> — <span class="docstring-category">Type</span></header><section><div><p>AbstractTopology</p><p>Subtypes of <code>AbstractHorizontalTopology</code> define connectiveness of a mesh in the horizontal domain.</p><p><strong>Interfaces</strong></p><ul><li><a href="@ref">`nelems&#39;</a></li><li><a href="#ClimaCore.Topologies.nlocalelems"><code>nlocalelems</code></a></li><li><a href="@ref"><code>nneighbors</code></a></li><li><a href="@ref"><code>nsendelems</code></a></li><li><a href="@ref"><code>nghostelems</code></a></li><li><a href="@ref"><code>localelemindex</code></a></li><li><a href="#ClimaCore.Topologies.vertex_coordinates"><code>vertex_coordinates</code></a></li><li><a href="#ClimaCore.Topologies.opposing_face"><code>opposing_face</code></a></li><li><a href="@ref"><code>face_node_index</code></a></li><li><a href="#ClimaCore.Topologies.interior_faces"><code>interior_faces</code></a></li><li><a href="@ref"><code>ghost_faces</code></a></li><li><a href="@ref"><code>vertex_node_index</code></a></li><li><a href="#ClimaCore.Topologies.vertices"><code>vertices</code></a></li><li><a href="@ref"><code>neighboring_elements</code></a></li><li><a href="@ref"><code>interior_vertices</code></a></li><li><a href="@ref"><code>ghost_vertices</code></a></li><li><a href="@ref"><code>neighbors</code></a></li><li><a href="#ClimaCore.Topologies.boundary_tags"><code>boundary_tags</code></a></li><li><a href="#ClimaCore.Topologies.boundary_tag"><code>boundary_tag</code></a></li><li><a href="#ClimaCore.Topologies.boundary_faces"><code>boundary_faces</code></a></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/CliMA/ClimaCore.jl/blob/b439b15db52a660f465ccf7e19008112c0bc11ad/src/Topologies/Topologies.jl#L7-L36">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="ClimaCore.Topologies.IntervalTopology" href="#ClimaCore.Topologies.IntervalTopology"><code>ClimaCore.Topologies.IntervalTopology</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">IntervalTopology(mesh::IntervalMesh)</code></pre><p>A sequential topology on an <a href="#ClimaCore.Meshes.IntervalMesh"><code>Meshes.IntervalMesh</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/CliMA/ClimaCore.jl/blob/b439b15db52a660f465ccf7e19008112c0bc11ad/src/Topologies/interval.jl#L2-L6">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="ClimaCore.Topologies.Topology2D" href="#ClimaCore.Topologies.Topology2D"><code>ClimaCore.Topologies.Topology2D</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">Topology2D(mesh::AbstractMesh2D, elemorder=Mesh.elements(mesh))</code></pre><p>This is a generic non-distributed topology for 2D meshes. <code>elemorder</code> is a vector or other linear ordering of the <code>Mesh.elements(mesh)</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/CliMA/ClimaCore.jl/blob/b439b15db52a660f465ccf7e19008112c0bc11ad/src/Topologies/topology2d.jl#L1-L6">source</a></section></article><h3 id="Interfaces-3"><a class="docs-heading-anchor" href="#Interfaces-3">Interfaces</a><a class="docs-heading-anchor-permalink" href="#Interfaces-3" title="Permalink"></a></h3><article class="docstring"><header><a class="docstring-binding" id="ClimaCore.Topologies.nlocalelems" href="#ClimaCore.Topologies.nlocalelems"><code>ClimaCore.Topologies.nlocalelems</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">nlocalelems(topology)</code></pre><p>The number of local elements in <code>topology</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/CliMA/ClimaCore.jl/blob/b439b15db52a660f465ccf7e19008112c0bc11ad/src/Topologies/Topologies.jl#L49-L53">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="ClimaCore.Topologies.vertex_coordinates" href="#ClimaCore.Topologies.vertex_coordinates"><code>ClimaCore.Topologies.vertex_coordinates</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">(c1,c2,c3,c4) = vertex_coordinates(topology, elem)</code></pre><p>The coordinates of the 4 vertices of element <code>elem</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/CliMA/ClimaCore.jl/blob/b439b15db52a660f465ccf7e19008112c0bc11ad/src/Topologies/Topologies.jl#L89-L93">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="ClimaCore.Topologies.opposing_face" href="#ClimaCore.Topologies.opposing_face"><code>ClimaCore.Topologies.opposing_face</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">(opelem, opface, reversed) = opposing_face(topology, elem, face)</code></pre><p>The opposing face of face number <code>face</code> of element <code>elem</code> in <code>topology</code>.</p><ul><li><code>opelem</code> is the opposing element number, 0 for a boundary, negative for a ghost element</li><li><code>opface</code> is the opposite face number, or boundary face number if a boundary</li><li><code>reversed</code> indicates whether the opposing face has the opposite orientation.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/CliMA/ClimaCore.jl/blob/b439b15db52a660f465ccf7e19008112c0bc11ad/src/Topologies/Topologies.jl#L96-L104">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="ClimaCore.Topologies.interior_faces" href="#ClimaCore.Topologies.interior_faces"><code>ClimaCore.Topologies.interior_faces</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">interior_faces(topology::AbstractTopology)</code></pre><p>An iterator over the interior faces of <code>topology</code>. Each element of the iterator is a 5-tuple the form</p><pre><code class="nohighlight hljs">(elem1, face1, elem2, face2, reversed)</code></pre><p>where <code>elemX, faceX</code> are the element and face numbers, and <code>reversed</code> indicates whether they have opposing orientations.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/CliMA/ClimaCore.jl/blob/b439b15db52a660f465ccf7e19008112c0bc11ad/src/Topologies/Topologies.jl#L128-L138">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="ClimaCore.Topologies.boundary_tags" href="#ClimaCore.Topologies.boundary_tags"><code>ClimaCore.Topologies.boundary_tags</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">boundary_tags(topology)</code></pre><p>A <code>Tuple</code> or <code>NamedTuple</code> of the boundary tags of the topology. A boundary tag is an integer that uniquely identifies a boundary.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/CliMA/ClimaCore.jl/blob/b439b15db52a660f465ccf7e19008112c0bc11ad/src/Topologies/Topologies.jl#L242-L247">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="ClimaCore.Topologies.boundary_tag" href="#ClimaCore.Topologies.boundary_tag"><code>ClimaCore.Topologies.boundary_tag</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">boundary_tag(topology, name::Symbol)</code></pre><p>The boundary tag of the topology for boundary name <code>name</code>. A boundary tag is an integer that uniquely identifies a boundary.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/CliMA/ClimaCore.jl/blob/b439b15db52a660f465ccf7e19008112c0bc11ad/src/Topologies/Topologies.jl#L250-L255">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="ClimaCore.Topologies.boundary_faces" href="#ClimaCore.Topologies.boundary_faces"><code>ClimaCore.Topologies.boundary_faces</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">boundary_faces(topology, boundarytag)</code></pre><p>An iterator over the faces of <code>topology</code> which face the boundary with tag <code>boundarytag</code>. Each element of the iterator is an <code>(elem, face)</code> pair.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/CliMA/ClimaCore.jl/blob/b439b15db52a660f465ccf7e19008112c0bc11ad/src/Topologies/Topologies.jl#L258-L263">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="ClimaCore.Topologies.vertices" href="#ClimaCore.Topologies.vertices"><code>ClimaCore.Topologies.vertices</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">vertices(topology)</code></pre><p>An iterator over the unique (shared) vertices of the topology <code>topology</code>. Each vertex is an iterator over <code>(element, vertex_number)</code> pairs.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/CliMA/ClimaCore.jl/blob/b439b15db52a660f465ccf7e19008112c0bc11ad/src/Topologies/Topologies.jl#L195-L200">source</a></section></article><h2 id="Spaces"><a class="docs-heading-anchor" href="#Spaces">Spaces</a><a id="Spaces-1"></a><a class="docs-heading-anchor-permalink" href="#Spaces" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-binding" id="ClimaCore.Spaces" href="#ClimaCore.Spaces"><code>ClimaCore.Spaces</code></a> — <span class="docstring-category">Module</span></header><section><div><pre><code class="language-julia hljs">Meshes</code></pre><ul><li>domain</li><li>topology</li><li>coordinates</li><li>metric terms (inverse partial derivatives)</li><li>quadrature rules and weights</li></ul><p><strong>References / notes</strong></p><ul><li><a href="https://ceed.exascaleproject.org/ceed-code/">ceed</a></li><li><a href="https://github.com/CliMA/ClimateMachine.jl/blob/ans/sphere/test/Numerics/DGMethods/compressible_navier_stokes_equations/sphere/sphere_helper_functions.jl">QA</a></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/CliMA/ClimaCore.jl/blob/b439b15db52a660f465ccf7e19008112c0bc11ad/src/Spaces/Spaces.jl#L1-L14">source</a></section></article><h3 id="Quadratures"><a class="docs-heading-anchor" href="#Quadratures">Quadratures</a><a id="Quadratures-1"></a><a class="docs-heading-anchor-permalink" href="#Quadratures" title="Permalink"></a></h3><article class="docstring"><header><a class="docstring-binding" id="ClimaCore.Spaces.Quadratures.QuadratureStyle" href="#ClimaCore.Spaces.Quadratures.QuadratureStyle"><code>ClimaCore.Spaces.Quadratures.QuadratureStyle</code></a> — <span class="docstring-category">Type</span></header><section><div><p>QuadratureStyle</p><p>Quadrature style supertype. See sub-types:</p><ul><li><a href="#ClimaCore.Spaces.Quadratures.GLL"><code>GLL</code></a></li><li><a href="#ClimaCore.Spaces.Quadratures.GL"><code>GL</code></a></li><li><a href="#ClimaCore.Spaces.Quadratures.Uniform"><code>Uniform</code></a></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/CliMA/ClimaCore.jl/blob/b439b15db52a660f465ccf7e19008112c0bc11ad/src/Spaces/quadrature.jl#L11-L18">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="ClimaCore.Spaces.Quadratures.GLL" href="#ClimaCore.Spaces.Quadratures.GLL"><code>ClimaCore.Spaces.Quadratures.GLL</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">GLL{Nq}()</code></pre><p>Gauss-Legendre-Lobatto quadrature using <code>Nq</code> quadrature points.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/CliMA/ClimaCore.jl/blob/b439b15db52a660f465ccf7e19008112c0bc11ad/src/Spaces/quadrature.jl#L44-L48">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="ClimaCore.Spaces.Quadratures.GL" href="#ClimaCore.Spaces.Quadratures.GL"><code>ClimaCore.Spaces.Quadratures.GL</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">GL{Nq}()</code></pre><p>Gauss-Legendre quadrature using <code>Nq</code> quadrature points.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/CliMA/ClimaCore.jl/blob/b439b15db52a660f465ccf7e19008112c0bc11ad/src/Spaces/quadrature.jl#L59-L63">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="ClimaCore.Spaces.Quadratures.Uniform" href="#ClimaCore.Spaces.Quadratures.Uniform"><code>ClimaCore.Spaces.Quadratures.Uniform</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">Uniform{Nq}()</code></pre><p>Uniformly-spaced quadrature.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/CliMA/ClimaCore.jl/blob/b439b15db52a660f465ccf7e19008112c0bc11ad/src/Spaces/quadrature.jl#L74-L78">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="ClimaCore.Spaces.Quadratures.degrees_of_freedom" href="#ClimaCore.Spaces.Quadratures.degrees_of_freedom"><code>ClimaCore.Spaces.Quadratures.degrees_of_freedom</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">degrees_of_freedom(QuadratureStyle) -&gt; Int</code></pre><p>Returns the degrees<em>of</em>freedom of the <code>QuadratureStyle</code> concrete type</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/CliMA/ClimaCore.jl/blob/b439b15db52a660f465ccf7e19008112c0bc11ad/src/Spaces/quadrature.jl#L29-L33">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="ClimaCore.Spaces.Quadratures.polynomial_degree" href="#ClimaCore.Spaces.Quadratures.polynomial_degree"><code>ClimaCore.Spaces.Quadratures.polynomial_degree</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">polynomial_degree(QuadratureStyle) -&gt; Int</code></pre><p>Returns the polynomial degree of the <code>QuadratureStyle</code> concrete type</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/CliMA/ClimaCore.jl/blob/b439b15db52a660f465ccf7e19008112c0bc11ad/src/Spaces/quadrature.jl#L21-L25">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="ClimaCore.Spaces.Quadratures.quadrature_points" href="#ClimaCore.Spaces.Quadratures.quadrature_points"><code>ClimaCore.Spaces.Quadratures.quadrature_points</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">points, weights = quadrature_points(::Type{FT}, quadrature_style)</code></pre><p>The points and weights of the quadrature rule in floating point type <code>FT</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/CliMA/ClimaCore.jl/blob/b439b15db52a660f465ccf7e19008112c0bc11ad/src/Spaces/quadrature.jl#L36-L40">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="ClimaCore.Spaces.Quadratures.barycentric_weights" href="#ClimaCore.Spaces.Quadratures.barycentric_weights"><code>ClimaCore.Spaces.Quadratures.barycentric_weights</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">barycentric_weights(x::SVector{Nq}) where {Nq}</code></pre><p>The barycentric weights associated with the array of point locations <code>x</code>:</p><p class="math-container">\[w_j = \frac{1}{\prod_{k \ne j} (x_i - x_j)}\]</p><p>See <a href="../references/#Berrut2004">Jean-Paul Berrut, Lloyd N Trefethen (2004)</a>, equation 3.2.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/CliMA/ClimaCore.jl/blob/b439b15db52a660f465ccf7e19008112c0bc11ad/src/Spaces/quadrature.jl#L114-L124">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="ClimaCore.Spaces.Quadratures.interpolation_matrix" href="#ClimaCore.Spaces.Quadratures.interpolation_matrix"><code>ClimaCore.Spaces.Quadratures.interpolation_matrix</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">interpolation_matrix(x::SVector, r::SVector{Nq})</code></pre><p>The matrix which interpolates the Lagrange polynomial of degree <code>Nq-1</code> through the points <code>r</code>, to points <code>x</code>. The matrix coefficients are computed using the Barycentric formula of <a href="../references/#Berrut2004">Jean-Paul Berrut, Lloyd N Trefethen (2004)</a>, section 4:</p><p class="math-container">\[I_{ij} = \begin{cases}
1 &amp; \text{if } x_i = r_j, \\
0 &amp; \text{if } x_i = r_k \text{ for } k \ne j, \\
\frac{\displaystyle \frac{w_j}{x_i - r_j}}{\displaystyle \sum_k \frac{w_k}{x_i - r_k}} &amp; \text{otherwise,}
\end{cases}\]</p><p>where <span>$w_j$</span> are the barycentric weights, see <a href="#ClimaCore.Spaces.Quadratures.barycentric_weights"><code>barycentric_weights</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/CliMA/ClimaCore.jl/blob/b439b15db52a660f465ccf7e19008112c0bc11ad/src/Spaces/quadrature.jl#L143-L157">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="ClimaCore.Spaces.Quadratures.differentiation_matrix" href="#ClimaCore.Spaces.Quadratures.differentiation_matrix"><code>ClimaCore.Spaces.Quadratures.differentiation_matrix</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">differentiation_matrix(r::SVector{Nq, T}) where {Nq, T}</code></pre><p>The spectral differentiation matrix for the Lagrange polynomial of degree <code>Nq-1</code> interpolating at points <code>r</code>.</p><p>The matrix coefficients are computed using the <a href="../references/#Berrut2004">Jean-Paul Berrut, Lloyd N Trefethen (2004)</a>, section 9.3:</p><p class="math-container">\[D_{ij} = \begin{cases}
    \displaystyle
    \frac{w_j}{w_i (x_i - x_j)} &amp;\text{ if } i \ne j \\
    -\sum_{k \ne j} D_{kj} &amp;\text{ if } i = j
\end{cases}\]</p><p>where <span>$w_j$</span> are the barycentric weights, see <a href="#ClimaCore.Spaces.Quadratures.barycentric_weights"><code>barycentric_weights</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/CliMA/ClimaCore.jl/blob/b439b15db52a660f465ccf7e19008112c0bc11ad/src/Spaces/quadrature.jl#L231-L246">source</a></section><section><div><pre><code class="nohighlight hljs">differentiation_matrix(FT, quadstyle::QuadratureStyle)</code></pre><p>The spectral differentiation matrix at the quadrature points of <code>quadstyle</code>, using floating point types <code>FT</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/CliMA/ClimaCore.jl/blob/b439b15db52a660f465ccf7e19008112c0bc11ad/src/Spaces/quadrature.jl#L266-L271">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="ClimaCore.Spaces.Quadratures.orthonormal_poly" href="#ClimaCore.Spaces.Quadratures.orthonormal_poly"><code>ClimaCore.Spaces.Quadratures.orthonormal_poly</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">V = orthonormal_poly(points, quad)</code></pre><p><code>V_{ij}</code> contains the <code>j-1</code>th Legendre polynomial evaluated at <code>points[i]</code>. i.e. it is the mapping from the modal to the nodal representation.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/CliMA/ClimaCore.jl/blob/b439b15db52a660f465ccf7e19008112c0bc11ad/src/Spaces/quadrature.jl#L195-L200">source</a></section></article><h2 id="RecursiveApply"><a class="docs-heading-anchor" href="#RecursiveApply">RecursiveApply</a><a id="RecursiveApply-1"></a><a class="docs-heading-anchor-permalink" href="#RecursiveApply" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-binding" id="ClimaCore.RecursiveApply" href="#ClimaCore.RecursiveApply"><code>ClimaCore.RecursiveApply</code></a> — <span class="docstring-category">Module</span></header><section><div><pre><code class="language-julia hljs">RecursiveApply</code></pre><p>This module contains operators to recurse over nested <code>Tuple</code>s or <code>NamedTuple</code>s.</p><p>To extend to another type <code>T</code>, define <code>RecursiveApply.rmap(fn, args::T...)</code></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/CliMA/ClimaCore.jl/blob/b439b15db52a660f465ccf7e19008112c0bc11ad/src/RecursiveApply/RecursiveApply.jl#L1-L7">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="ClimaCore.RecursiveApply.tuplemap" href="#ClimaCore.RecursiveApply.tuplemap"><code>ClimaCore.RecursiveApply.tuplemap</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">tuplemap(fn::Function, tup)</code></pre><p>A <code>map</code> impl for mapping function <code>fn</code> a tuple argument <code>tup</code></p><p>Currently just calls <code>Base.map</code> behind the scenes but is left  stubbed out for potential specialization in the future.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/CliMA/ClimaCore.jl/blob/b439b15db52a660f465ccf7e19008112c0bc11ad/src/RecursiveApply/RecursiveApply.jl#L12-L19">source</a></section><section><div><pre><code class="nohighlight hljs">tuplemap(fn::Function, tup1, tup2)</code></pre><p>A <code>map</code> impl for mapping function <code>fn</code> over <code>tup1</code>, <code>tup2</code> tuple arguments.</p><p>Currently just calls <code>Base.map</code> behind the scenes but is left  stubbed out for potential specialization in the future.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/CliMA/ClimaCore.jl/blob/b439b15db52a660f465ccf7e19008112c0bc11ad/src/RecursiveApply/RecursiveApply.jl#L24-L31">source</a></section></article><h2 id="Fields"><a class="docs-heading-anchor" href="#Fields">Fields</a><a id="Fields-1"></a><a class="docs-heading-anchor-permalink" href="#Fields" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-binding" id="ClimaCore.Fields.Field" href="#ClimaCore.Fields.Field"><code>ClimaCore.Fields.Field</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">Field(values, space)</code></pre><p>A set of <code>values</code> defined at each point of a <code>space</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/CliMA/ClimaCore.jl/blob/b439b15db52a660f465ccf7e19008112c0bc11ad/src/Fields/Fields.jl#L15-L19">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="ClimaCore.Fields.coordinate_field" href="#ClimaCore.Fields.coordinate_field"><code>ClimaCore.Fields.coordinate_field</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">coordinate_field(space::AbstractSpace)</code></pre><p>Construct a <code>Field</code> of the coordinates of the space.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/CliMA/ClimaCore.jl/blob/b439b15db52a660f465ccf7e19008112c0bc11ad/src/Fields/Fields.jl#L231-L235">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="ClimaCore.Fields.local_geometry_field" href="#ClimaCore.Fields.local_geometry_field"><code>ClimaCore.Fields.local_geometry_field</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">local_geometry_field(space::AbstractSpace)</code></pre><p>Construct a <code>Field</code> of the <code>LocalGeometry</code> of the space.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/CliMA/ClimaCore.jl/blob/b439b15db52a660f465ccf7e19008112c0bc11ad/src/Fields/Fields.jl#L240-L244">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Base.zeros-Tuple{ClimaCore.Spaces.AbstractSpace}" href="#Base.zeros-Tuple{ClimaCore.Spaces.AbstractSpace}"><code>Base.zeros</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">zeros(space::AbstractSpace)</code></pre><p>Construct a field on <code>space</code> that is zero everywhere.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/CliMA/ClimaCore.jl/blob/b439b15db52a660f465ccf7e19008112c0bc11ad/src/Fields/Fields.jl#L197-L201">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Base.ones-Tuple{ClimaCore.Spaces.AbstractSpace}" href="#Base.ones-Tuple{ClimaCore.Spaces.AbstractSpace}"><code>Base.ones</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">ones(space::AbstractSpace)</code></pre><p>Construct a field on <code>space</code> that is one everywhere.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/CliMA/ClimaCore.jl/blob/b439b15db52a660f465ccf7e19008112c0bc11ad/src/Fields/Fields.jl#L210-L214">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Base.sum-Tuple{ClimaCore.Fields.Field}" href="#Base.sum-Tuple{ClimaCore.Fields.Field}"><code>Base.sum</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">sum([f=identity,]v::Field)</code></pre><p>Approximate integration of <code>v</code> or <code>f.(v)</code> over the domain. In an <code>AbstractSpectralElementSpace</code>, an integral over the entire space is computed by summation over the elements of the integrand multiplied by the Jacobian determinants and the quadrature weights at each node within an element. Hence, <code>sum</code> is computed by summation of the field values multiplied by the Jacobian determinants and quadrature weights:</p><p class="math-container">\[\sum_i f(v_i) W_i J_i
\approx
\int_\Omega f(v) \, d \Omega\]</p><p>where <span>$v_i$</span> is the value at each node, and <span>$f$</span> is the identity function if not specified.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/CliMA/ClimaCore.jl/blob/b439b15db52a660f465ccf7e19008112c0bc11ad/src/Fields/mapreduce.jl#L8-L23">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Statistics.mean-Tuple{ClimaCore.Fields.Field}" href="#Statistics.mean-Tuple{ClimaCore.Fields.Field}"><code>Statistics.mean</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">mean([f=identity, ]v::Field)</code></pre><p>The mean value of <code>field</code> or <code>f.(field)</code> over the domain, weighted by area. Similar to <code>sum</code>, in an <code>AbstractSpectralElementSpace</code>, this is computed by summation of the field values multiplied by the Jacobian determinants and quadrature weights:</p><p class="math-container">\[\frac{\sum_i f(v_i) W_i J_i}{\sum_i W_i J_i}
\approx
\frac{\int_\Omega f(v) \, d \Omega}{\int_\Omega \, d \Omega}\]</p><p>where <span>$v_i$</span> is the Field value at each node, and <span>$f$</span> is the identity function if not specified.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/CliMA/ClimaCore.jl/blob/b439b15db52a660f465ccf7e19008112c0bc11ad/src/Fields/mapreduce.jl#L50-L63">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="LinearAlgebra.norm-Tuple{ClimaCore.Fields.Field}" href="#LinearAlgebra.norm-Tuple{ClimaCore.Fields.Field}"><code>LinearAlgebra.norm</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">norm(v::Field, p=2; normalize=true)</code></pre><p>The approximate <span>$L^p$</span> norm of <code>v</code>, where <span>$L^p$</span> represents the space of measurable functions for which the p-th power of the absolute value is Lebesgue integrable, that is:</p><p class="math-container">\[\| v \|_p = \left( \int_\Omega |v|^p d \Omega \right)^{1/p}\]</p><p>where <span>$|v|$</span> is defined to be the absolute value if `<code>v</code> is a scalar-valued Field, or the 2-norm if it is a vector-valued Field or composite Field (see <a href="https://docs.julialang.org/en/v1/stdlib/LinearAlgebra/#LinearAlgebra.norm">LinearAlgebra.norm</a>). Similar to <code>sum</code> and <code>mean</code>, in an <code>AbstractSpectralElementSpace</code>, this is computed by summation of the field values multiplied by the Jacobian determinants and quadrature weights. If <code>normalize=true</code> (the default), then internally the discrete norm is divided by the sum of the Jacobian determinants and quadrature weights:</p><p class="math-container">\[\left(\frac{\sum_i |v_i|^p W_i J_i}{\sum_i W_i J_i}\right)^{1/p}
\approx
\left(\frac{\int_\Omega |v|^p \, d \Omega}{\int_\Omega \, d \Omega}\right)^{1/p}\]</p><p>If <code>p=Inf</code>, then the norm is the maximum of the absolute values</p><p class="math-container">\[\max_i |v_i| \approx \sup_{\Omega} |v|\]</p><p>Consequently all norms should have the same units for all <span>$p$</span> (being the same as calling <code>norm</code> on a single value).</p><p>If <code>normalize=false</code>, then the denominator term is omitted, and so the result will be the norm as described above multiplied by the length/area/volume of <span>$\Omega$</span> to the power of <span>$1/p$</span>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/CliMA/ClimaCore.jl/blob/b439b15db52a660f465ccf7e19008112c0bc11ad/src/Fields/mapreduce.jl#L71-L101">source</a></section></article><h2 id="Limiters"><a class="docs-heading-anchor" href="#Limiters">Limiters</a><a id="Limiters-1"></a><a class="docs-heading-anchor-permalink" href="#Limiters" title="Permalink"></a></h2><h3 id="Interfaces-4"><a class="docs-heading-anchor" href="#Interfaces-4">Interfaces</a><a class="docs-heading-anchor-permalink" href="#Interfaces-4" title="Permalink"></a></h3><article class="docstring"><header><a class="docstring-binding" id="ClimaCore.Limiters.quasimonotone_limiter!" href="#ClimaCore.Limiters.quasimonotone_limiter!"><code>ClimaCore.Limiters.quasimonotone_limiter!</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">quasimonotone_limiter!(ρq, ρ, min_ρq, max_ρq; rtol)</code></pre><p>Arguments:</p><ul><li><code>ρq</code>: tracer density Field, where <code>q</code> denotes tracer concentration per unit mass</li><li><code>ρ</code>: fluid density Field</li><li><code>min_ρq</code>: Array of min(ρq) per element</li><li><code>max_ρq</code>: Array of max(ρq) per element</li><li><code>rtol</code>: relative tolerance needed to solve element-wise optimization problem</li></ul><p>This limiter is inspired by the one presented in Guba et al <a href="../references/#GubaOpt2014">Oksana Guba, Mark Taylor, Amik St-Cyr (2014)</a>. In the reference paper, it is denoted by OP1, and is outlined in eqs. (37)-(40). Quasimonotone here is meant to be monotone with respect to the spectral element nodal values. This limiter involves solving a constrained optimization problem (a weighted least square problem up to a fixed tolerance denoted by <code>rtol</code>) that is completely local to each element. As in HOMME, the implementation idea here is the following: we need to find a grid field which is closest to the initial field (in terms of weighted sum), but satisfies the min/max constraints. So, first we find values that do not satisfy constraints and bring these values to a closest constraint. This way we introduce some mass change (<code>mass_change</code>), which we then redistribute so that the l2 error is smallest. This redistribution might violate constraints; thus, we do a few iterations (typically a couple).</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/CliMA/ClimaCore.jl/blob/b439b15db52a660f465ccf7e19008112c0bc11ad/src/Limiters/limiter.jl#L1-L24">source</a></section></article></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../">« Home</a><a class="docs-footer-nextpage" href="../operators/">Operators »</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 0.27.12 on <span class="colophon-date" title="Wednesday 16 February 2022 22:19">Wednesday 16 February 2022</span>. Using Julia version 1.7.2.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
