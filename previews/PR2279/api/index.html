<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>API · ClimaCore.jl</title><meta name="title" content="API · ClimaCore.jl"/><meta property="og:title" content="API · ClimaCore.jl"/><meta property="twitter:title" content="API · ClimaCore.jl"/><meta name="description" content="Documentation for ClimaCore.jl."/><meta property="og:description" content="Documentation for ClimaCore.jl."/><meta property="twitter:description" content="Documentation for ClimaCore.jl."/><script data-outdated-warner src="../assets/warner.js"></script><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.050/juliamono.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.16.8/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL=".."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../assets/documenter.js"></script><script src="../search_index.js"></script><script src="../siteinfo.js"></script><script src="../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/catppuccin-mocha.css" data-theme-name="catppuccin-mocha"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/catppuccin-macchiato.css" data-theme-name="catppuccin-macchiato"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/catppuccin-frappe.css" data-theme-name="catppuccin-frappe"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/catppuccin-latte.css" data-theme-name="catppuccin-latte"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><a class="docs-logo" href="../"><img src="../assets/logo.png" alt="ClimaCore.jl logo"/></a><div class="docs-package-name"><span class="docs-autofit"><a href="../">ClimaCore.jl</a></span></div><button class="docs-search-query input is-rounded is-small is-clickable my-2 mx-auto py-1 px-2" id="documenter-search-query">Search docs (Ctrl + /)</button><ul class="docs-menu"><li><a class="tocitem" href="../">Home</a></li><li><a class="tocitem" href="../intro/">Introduction</a></li><li><a class="tocitem" href="../math_framework/">Mathematical Framework</a></li><li><a class="tocitem" href="../installation_instructions/">Installation and How-to Guides</a></li><li><a class="tocitem" href="../geometry/">Geometry</a></li><li><a class="tocitem" href="../operators/">Operators</a></li><li><a class="tocitem" href="../remapping/">Remapping</a></li><li><a class="tocitem" href="../matrix_fields/">MatrixFields</a></li><li class="is-active"><a class="tocitem" href>API</a><ul class="internal"><li><a class="tocitem" href="#Utilities"><span>Utilities</span></a></li><li><a class="tocitem" href="#DataLayouts"><span>DataLayouts</span></a></li><li><a class="tocitem" href="#Geometry"><span>Geometry</span></a></li><li><a class="tocitem" href="#Domains"><span>Domains</span></a></li><li><a class="tocitem" href="#Meshes"><span>Meshes</span></a></li><li><a class="tocitem" href="#Topologies"><span>Topologies</span></a></li><li><a class="tocitem" href="#Grids"><span>Grids</span></a></li><li><a class="tocitem" href="#Hypsography"><span>Hypsography</span></a></li><li><a class="tocitem" href="#CommonGrids"><span>CommonGrids</span></a></li><li><a class="tocitem" href="#Spaces"><span>Spaces</span></a></li><li><a class="tocitem" href="#CommonSpaces"><span>CommonSpaces</span></a></li><li><a class="tocitem" href="#RecursiveApply"><span>RecursiveApply</span></a></li><li><a class="tocitem" href="#Fields"><span>Fields</span></a></li><li><a class="tocitem" href="#Hypsography-2"><span>Hypsography</span></a></li><li><a class="tocitem" href="#Limiters"><span>Limiters</span></a></li><li><a class="tocitem" href="#InputOutput"><span>InputOutput</span></a></li><li><a class="tocitem" href="#Remapping"><span>Remapping</span></a></li><li><a class="tocitem" href="#Converting-between-devices"><span>Converting between devices</span></a></li><li><a class="tocitem" href="#DebugOnly"><span>DebugOnly</span></a></li></ul></li><li><input class="collapse-toggle" id="menuitem-10" type="checkbox"/><label class="tocitem" for="menuitem-10"><span class="docs-label">Developer docs</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../performance_tips/">Performance tips</a></li><li><a class="tocitem" href="../shmem_design/">Shared memory design</a></li></ul></li><li><input class="collapse-toggle" id="menuitem-11" type="checkbox"/><label class="tocitem" for="menuitem-11"><span class="docs-label">Tutorials</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../tutorials/introduction/">Introduction to ClimaCore.jl</a></li></ul></li><li><a class="tocitem" href="../examples/">Examples</a></li><li><a class="tocitem" href="../masks/">Masks</a></li><li><a class="tocitem" href="../debugging/">Debugging</a></li><li><input class="collapse-toggle" id="menuitem-15" type="checkbox"/><label class="tocitem" for="menuitem-15"><span class="docs-label">Libraries</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../lib/ClimaCorePlots/">ClimaCorePlots.jl</a></li><li><a class="tocitem" href="../lib/ClimaCoreMakie/">ClimaCoreMakie.jl</a></li><li><a class="tocitem" href="../lib/ClimaCoreVTK/">ClimaCoreVTK.jl</a></li><li><a class="tocitem" href="../lib/ClimaCoreTempestRemap/">ClimaCoreTempestRemap.jl</a></li><li><a class="tocitem" href="../lib/ClimaCoreSpectra/">ClimaCoreSpectra.jl</a></li></ul></li><li><a class="tocitem" href="../Contributing/">Contributing guide</a></li><li><a class="tocitem" href="../code_of_conduct/">Code of Conduct</a></li><li><a class="tocitem" href="../faq/">Frequently asked questions</a></li><li><a class="tocitem" href="../references/">References</a></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><a class="docs-sidebar-button docs-navbar-link fa-solid fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a><nav class="breadcrumb"><ul class="is-hidden-mobile"><li class="is-active"><a href>API</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>API</a></li></ul></nav><div class="docs-right"><a class="docs-navbar-link" href="https://github.com/CliMA/ClimaCore.jl" title="View the repository on GitHub"><span class="docs-icon fa-brands"></span><span class="docs-label is-hidden-touch">GitHub</span></a><a class="docs-navbar-link" href="https://github.com/CliMA/ClimaCore.jl/blob/main/docs/src/api.md" title="Edit source on GitHub"><span class="docs-icon fa-solid"></span></a><a class="docs-settings-button docs-navbar-link fa-solid fa-gear" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-article-toggle-button fa-solid fa-chevron-up" id="documenter-article-toggle-button" href="javascript:;" title="Collapse all docstrings"></a></div></header><article class="content" id="documenter-page"><h1 id="API"><a class="docs-heading-anchor" href="#API">API</a><a id="API-1"></a><a class="docs-heading-anchor-permalink" href="#API" title="Permalink"></a></h1><h2 id="Utilities"><a class="docs-heading-anchor" href="#Utilities">Utilities</a><a id="Utilities-1"></a><a class="docs-heading-anchor-permalink" href="#Utilities" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="ClimaCore.Utilities.PlusHalf" href="#ClimaCore.Utilities.PlusHalf"><code>ClimaCore.Utilities.PlusHalf</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">PlusHalf(i)</code></pre><p>Represents <code>i + 1/2</code>, but stored as internally as an integer value. Used for indexing into staggered finite difference meshes: the convention &quot;half&quot; values are indexed at cell faces, whereas centers are indexed at cell centers.</p><p>Supports <code>+</code>, <code>-</code> and inequalities.</p><p>See also <a href="#ClimaCore.Utilities.half"><code>half</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/CliMA/ClimaCore.jl/blob/8819db3f9615df160b53a0d72c6dc80e3eb305f5/src/Utilities/plushalf.jl#L1-L11">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="ClimaCore.Utilities.half" href="#ClimaCore.Utilities.half"><code>ClimaCore.Utilities.half</code></a> — <span class="docstring-category">Constant</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">const half = PlusHalf(0)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/CliMA/ClimaCore.jl/blob/8819db3f9615df160b53a0d72c6dc80e3eb305f5/src/Utilities/plushalf.jl#L17-L19">source</a></section></article><h3 id="Utilities.Cache"><a class="docs-heading-anchor" href="#Utilities.Cache">Utilities.Cache</a><a id="Utilities.Cache-1"></a><a class="docs-heading-anchor-permalink" href="#Utilities.Cache" title="Permalink"></a></h3><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="ClimaCore.Utilities.Cache" href="#ClimaCore.Utilities.Cache"><code>ClimaCore.Utilities.Cache</code></a> — <span class="docstring-category">Module</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><p><strong><code>Utilities.Cache</code></strong></p><p>ClimaCore maintains an internal cache of topology and grid objects: this ensures that if the constructor with the same arguments is invoked again (e.g. by reading from a file), the cached object will be returned (also known as <em>memoization</em>). This has two main advantages:</p><ol><li><p>topology and metric information can be reused, reducing memory usage.</p></li><li><p>it is easy to check if two fields live on the same grid: we can just check if the underlying grid objects are the same (<code>===</code>), rather than checking all the fields are equal (via <code>==</code>).</p></li></ol><p>However this means that objects in the cache will not be removed from the garbage collector, so we provide an interface to remove these.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/CliMA/ClimaCore.jl/blob/8819db3f9615df160b53a0d72c6dc80e3eb305f5/src/Utilities/cache.jl#L1-L17">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="ClimaCore.Utilities.Cache.cached_objects" href="#ClimaCore.Utilities.Cache.cached_objects"><code>ClimaCore.Utilities.Cache.cached_objects</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">Utilities.Cache.cached_objects()</code></pre><p>List all currently cached objects.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/CliMA/ClimaCore.jl/blob/8819db3f9615df160b53a0d72c6dc80e3eb305f5/src/Utilities/cache.jl#L23-L27">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="ClimaCore.Utilities.Cache.clean_cache!" href="#ClimaCore.Utilities.Cache.clean_cache!"><code>ClimaCore.Utilities.Cache.clean_cache!</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">Utilities.Cache.clean_cache!(object)</code></pre><p>Remove <code>object</code> from the cache of created objects. </p><p>In most cases, this function should not need to be called, unless you are constructing many grid objects, for example when doing a sweep over grid paramaters.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/CliMA/ClimaCore.jl/blob/8819db3f9615df160b53a0d72c6dc80e3eb305f5/src/Utilities/cache.jl#L33-L41">source</a></section><section><div><pre><code class="language-julia hljs">Utilities.Cache.clean_cache!()</code></pre><p>Remove all objects from the cache of created objects. </p><p>In most cases, this function should not need to be called, unless you are constructing many grid objects, for example when doing a sweep over grid paramaters.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/CliMA/ClimaCore.jl/blob/8819db3f9615df160b53a0d72c6dc80e3eb305f5/src/Utilities/cache.jl#L49-L57">source</a></section></article><h2 id="DataLayouts"><a class="docs-heading-anchor" href="#DataLayouts">DataLayouts</a><a id="DataLayouts-1"></a><a class="docs-heading-anchor-permalink" href="#DataLayouts" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="ClimaCore.DataLayouts" href="#ClimaCore.DataLayouts"><code>ClimaCore.DataLayouts</code></a> — <span class="docstring-category">Module</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">ClimaCore.DataLayouts</code></pre><p>Defines the following DataLayouts (see individual docs for more info):</p><p>TODO: Add links to these datalayouts</p><ul><li><code>IJKFVH</code></li><li><code>IJFH</code></li><li><code>IJHF</code></li><li><code>IFH</code></li><li><code>IHF</code></li><li><code>DataF</code></li><li><code>IJF</code></li><li><code>IF</code></li><li><code>VF</code></li><li><code>VIJFH</code></li><li><code>VIJHF</code></li><li><code>VIFH</code></li><li><code>VIHF</code></li><li><code>IH1JH2</code></li><li><code>IV1JH2</code></li></ul><p>Notation:</p><ul><li><code>i,j</code> are horizontal node indices within an element</li><li><code>k</code> is the vertical node index within an element</li><li><code>f</code> is the field index (1 if field is scalar, &gt;1 if it is a vector field)</li><li><code>v</code> is the vertical element index in a stack</li><li><code>h</code> is the element stack index</li></ul><p>Data layout is specified by the order in which they appear, e.g. <code>IJKFVH</code> indexes the underlying array as <code>[i,j,k,f,v,h]</code></p><p><strong>Datalayouts that end with the field index</strong></p><p>One of the fundamental features of datalayouts is to be able to store multiple variables in the same array, and then access those variables by name. As such, we occasionally must index into multiple variables when performing operations with a datalayout.</p><p>We can efficiently support linear indexing with datalayouts whose field index (<code>f</code>) is first or last. This is for the same reason as https://docs.julialang.org/en/v1/devdocs/subarrays/#Linear-indexing:</p><pre><code class="nohighlight hljs">Linear indexing can be implemented efficiently when the entire array
has a single stride that separates successive elements, starting from
some offset.</code></pre><p>Therefore, we provide special handling for these datalayouts where possible to leverage efficient linear indexing.</p><p>Here are some references containing relevant discussions and efforts to leverage efficient linear indexing:</p><ul><li>https://github.com/CliMA/ClimaCore.jl/issues/1889</li><li>https://github.com/JuliaLang/julia/issues/28126</li><li>https://github.com/JuliaLang/julia/issues/32051</li><li>https://github.com/maleadt/StaticCartesian.jl</li><li>https://github.com/JuliaGPU/GPUArrays.jl/pull/454#issuecomment-1431575721</li><li>https://github.com/JuliaGPU/GPUArrays.jl/pull/520</li><li>https://github.com/JuliaGPU/GPUArrays.jl/pull/464</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/CliMA/ClimaCore.jl/blob/8819db3f9615df160b53a0d72c6dc80e3eb305f5/src/DataLayouts/DataLayouts.jl#L1-L63">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="ClimaCore.DataLayouts.DataF" href="#ClimaCore.DataLayouts.DataF"><code>ClimaCore.DataLayouts.DataF</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">DataF{S, A} &lt;: Data0D{S}</code></pre><p>Backing <code>DataLayout</code> for 0D point data.</p><pre><code class="nohighlight hljs">DataF{S}(ArrayType[, ones | zeros | rand])</code></pre><p>The <code>ArrayType</code> constructor returns a <code>DataF</code> given the <code>ArrayType</code> and (optionally) an initialization method (one of <code>Base.ones</code>, <code>Base.zeros</code>, <code>Random.rand</code>).</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/CliMA/ClimaCore.jl/blob/8819db3f9615df160b53a0d72c6dc80e3eb305f5/src/DataLayouts/DataLayouts.jl#L847-L857">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="ClimaCore.DataLayouts.IF" href="#ClimaCore.DataLayouts.IF"><code>ClimaCore.DataLayouts.IF</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">IF{S, Ni, A} &lt;: DataSlab1D{S, Ni}</code></pre><p>Backing <code>DataLayout</code> for 1D spectral element slab data.</p><p>Nodal element data (I) are contiguous for each <code>S</code> datatype struct field (F) for a single element slab.</p><p>A <code>DataSlab1D</code> view can be returned from other <code>Data1D</code> objects by calling <code>slab(data, idx...)</code>.</p><pre><code class="nohighlight hljs">IF{S}(ArrayType[, ones | zeros | rand]; Ni)</code></pre><p>The keyword constructor returns a <code>IF</code> given the <code>ArrayType</code> and (optionally) an initialization method (one of <code>Base.ones</code>, <code>Base.zeros</code>, <code>Random.rand</code>) and the keywords:</p><ul><li><code>Ni</code> quadrature degrees of freedom in the horizontal direction</li></ul><div class="admonition is-info"><header class="admonition-header">Note</header><div class="admonition-body"><p>Objects made with the keyword constructor accept integer keyword inputs, so they are dynamically created. You may want to use a different constructor if you&#39;re making the object in a performance-critical section, and if you know the type parameters at compile time.</p></div></div></div><a class="docs-sourcelink" target="_blank" href="https://github.com/CliMA/ClimaCore.jl/blob/8819db3f9615df160b53a0d72c6dc80e3eb305f5/src/DataLayouts/DataLayouts.jl#L1014-L1037">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="ClimaCore.DataLayouts.IJF" href="#ClimaCore.DataLayouts.IJF"><code>ClimaCore.DataLayouts.IJF</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">IJF{S, Nij, A} &lt;: DataSlab2D{S, Nij}</code></pre><p>Backing <code>DataLayout</code> for 2D spectral element slab data.</p><p>Nodal element data (I,J) are contiguous for each <code>S</code> datatype struct field (F) for a single element slab.</p><p>A <code>DataSlab2D</code> view can be returned from other <code>Data2D</code> objects by calling <code>slab(data, idx...)</code>.</p><pre><code class="nohighlight hljs">IJF{S}(ArrayType[, ones | zeros | rand]; Nij)</code></pre><p>The keyword constructor returns a <code>IJF</code> given the <code>ArrayType</code> and (optionally) an initialization method (one of <code>Base.ones</code>, <code>Base.zeros</code>, <code>Random.rand</code>) and the keywords:</p><ul><li><code>Nij</code> quadrature degrees of freedom per horizontal direction</li></ul><div class="admonition is-info"><header class="admonition-header">Note</header><div class="admonition-body"><p>Objects made with the keyword constructor accept integer keyword inputs, so they are dynamically created. You may want to use a different constructor if you&#39;re making the object in a performance-critical section, and if you know the type parameters at compile time.</p></div></div></div><a class="docs-sourcelink" target="_blank" href="https://github.com/CliMA/ClimaCore.jl/blob/8819db3f9615df160b53a0d72c6dc80e3eb305f5/src/DataLayouts/DataLayouts.jl#L934-L957">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="ClimaCore.DataLayouts.VF" href="#ClimaCore.DataLayouts.VF"><code>ClimaCore.DataLayouts.VF</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">VF{S, A} &lt;: DataColumn{S, Nv}</code></pre><p>Backing <code>DataLayout</code> for 1D FV column data.</p><p>Column level data (V) are contiguous for each <code>S</code> datatype struct field (F).</p><p>A <code>DataColumn</code> view can be returned from other <code>Data1DX</code>, <code>Data2DX</code> objects by calling <code>column(data, idx...)</code>.</p><pre><code class="nohighlight hljs">VF{S}(ArrayType[, ones | zeros | rand]; Nv)</code></pre><p>The keyword constructor returns a <code>VF</code> given the <code>ArrayType</code> and (optionally) an initialization method (one of <code>Base.ones</code>, <code>Base.zeros</code>, <code>Random.rand</code>) and the keywords:</p><ul><li><code>Nv</code> number of vertical degrees of freedom</li></ul><div class="admonition is-info"><header class="admonition-header">Note</header><div class="admonition-body"><p>Objects made with the keyword constructor accept integer keyword inputs, so they are dynamically created. You may want to use a different constructor if you&#39;re making the object in a performance-critical section, and if you know the type parameters at compile time.</p></div></div></div><a class="docs-sourcelink" target="_blank" href="https://github.com/CliMA/ClimaCore.jl/blob/8819db3f9615df160b53a0d72c6dc80e3eb305f5/src/DataLayouts/DataLayouts.jl#L1082-L1105">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="ClimaCore.DataLayouts.IFH" href="#ClimaCore.DataLayouts.IFH"><code>ClimaCore.DataLayouts.IFH</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">IFH{S,Ni,Nh,A} &lt;: Data1D{S, Ni}
IFH{S,Ni,Nh}(ArrayType)</code></pre><p>Backing <code>DataLayout</code> for 1D spectral element slabs.</p><p>Element nodal point (I) data is contiguous for each datatype <code>S</code> struct field (F), for each 1D mesh element (H).</p><p>The <code>ArrayType</code>-constructor makes a IFH 1D Spectral DataLayout given the backing <code>ArrayType</code>, quadrature degrees of freedom <code>Ni</code>, and the number of mesh elements <code>Nh</code>.</p><pre><code class="nohighlight hljs">IFH{S}(ArrayType[, ones | zeros | rand]; Ni, Nh)</code></pre><p>The keyword constructor returns a <code>IFH</code> given the <code>ArrayType</code> and (optionally) an initialization method (one of <code>Base.ones</code>, <code>Base.zeros</code>, <code>Random.rand</code>) and the keywords:</p><ul><li><code>Ni</code> quadrature degrees of freedom in the horizontal direction</li><li><code>Nh</code> number of mesh elements</li></ul><div class="admonition is-info"><header class="admonition-header">Note</header><div class="admonition-body"><p>Objects made with the keyword constructor accept integer keyword inputs, so they are dynamically created. You may want to use a different constructor if you&#39;re making the object in a performance-critical section, and if you know the type parameters at compile time.</p></div></div></div><a class="docs-sourcelink" target="_blank" href="https://github.com/CliMA/ClimaCore.jl/blob/8819db3f9615df160b53a0d72c6dc80e3eb305f5/src/DataLayouts/DataLayouts.jl#L682-L712">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="ClimaCore.DataLayouts.IJFH" href="#ClimaCore.DataLayouts.IJFH"><code>ClimaCore.DataLayouts.IJFH</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">IJFH{S, Nij, A} &lt;: Data2D{S, Nij}
IJFH{S,Nij}(ArrayType, nelements)</code></pre><p>Backing <code>DataLayout</code> for 2D spectral element slabs.</p><p>Element nodal point (I,J) data is contiguous for each datatype <code>S</code> struct field (F), for each 2D mesh element slab (H).</p><p>The <code>ArrayType</code>-constructor constructs a IJFH 2D Spectral DataLayout given the backing <code>ArrayType</code>, quadrature degrees of freedom <code>Nij × Nij</code>, and the number of mesh elements <code>nelements</code>.</p><pre><code class="nohighlight hljs">IJFH{S}(ArrayType[, Base.ones | zeros | rand]; Nij, Nh)</code></pre><p>The keyword constructor returns a <code>IJFH</code> given the <code>ArrayType</code> and (optionally) an initialization method (one of <code>Base.ones</code>, <code>Base.zeros</code>, <code>Random.rand</code>) and the keywords:</p><ul><li><code>Nij</code> quadrature degrees of freedom per horizontal direction</li><li><code>Nh</code> number of mesh elements</li></ul><div class="admonition is-info"><header class="admonition-header">Note</header><div class="admonition-body"><p>Objects made with the keyword constructor accept integer keyword inputs, so they are dynamically created. You may want to use a different constructor if you&#39;re making the object in a performance-critical section, and if you know the type parameters at compile time.</p></div></div></div><a class="docs-sourcelink" target="_blank" href="https://github.com/CliMA/ClimaCore.jl/blob/8819db3f9615df160b53a0d72c6dc80e3eb305f5/src/DataLayouts/DataLayouts.jl#L490-L519">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="ClimaCore.DataLayouts.VIFH" href="#ClimaCore.DataLayouts.VIFH"><code>ClimaCore.DataLayouts.VIFH</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">VIFH{S, Nv, Ni, A} &lt;: Data1DX{S, Nv, Ni}</code></pre><p>Backing <code>DataLayout</code> for 1D spectral element slab + extruded 1D FV column data.</p><p>Column levels (V) are contiguous for every element nodal point (I) for each datatype <code>S</code> struct field (F), for each 1D mesh element slab (H).</p><pre><code class="nohighlight hljs">VIFH{S}(ArrayType[, ones | zeros | rand]; Nv, Ni, Nh)</code></pre><p>The keyword constructor returns a <code>VIFH</code> given the <code>ArrayType</code> and (optionally) an initialization method (one of <code>Base.ones</code>, <code>Base.zeros</code>, <code>Random.rand</code>) and the keywords:</p><ul><li><code>Nv</code> number of vertical degrees of freedom</li><li><code>Ni</code> quadrature degrees of freedom in the horizontal direction</li><li><code>Nh</code> number of horizontal elements</li></ul><div class="admonition is-info"><header class="admonition-header">Note</header><div class="admonition-body"><p>Objects made with the keyword constructor accept integer keyword inputs, so they are dynamically created. You may want to use a different constructor if you&#39;re making the object in a performance-critical section, and if you know the type parameters at compile time.</p></div></div></div><a class="docs-sourcelink" target="_blank" href="https://github.com/CliMA/ClimaCore.jl/blob/8819db3f9615df160b53a0d72c6dc80e3eb305f5/src/DataLayouts/DataLayouts.jl#L1384-L1408">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="ClimaCore.DataLayouts.VIJFH" href="#ClimaCore.DataLayouts.VIJFH"><code>ClimaCore.DataLayouts.VIJFH</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">VIJFH{S, Nij, A} &lt;: Data2DX{S, Nij}</code></pre><p>Backing <code>DataLayout</code> for 2D spectral element slab + extruded 1D FV column data.</p><p>Column levels (V) are contiguous for every element nodal point (I, J) for each <code>S</code> datatype struct field (F), for each 2D mesh element slab (H).</p><pre><code class="nohighlight hljs">VIJFH{S}(ArrayType[, ones | zeros | rand]; Nv, Nij, Nh)</code></pre><p>The keyword constructor returns a <code>VIJFH</code> given the <code>ArrayType</code> and (optionally) an initialization method (one of <code>Base.ones</code>, <code>Base.zeros</code>, <code>Random.rand</code>) and the keywords:</p><ul><li><code>Nv</code> number of vertical degrees of freedom</li><li><code>Nij</code> quadrature degrees of freedom per horizontal direction</li><li><code>Nh</code> number of horizontal elements</li></ul><div class="admonition is-info"><header class="admonition-header">Note</header><div class="admonition-body"><p>Objects made with the keyword constructor accept integer keyword inputs, so they are dynamically created. You may want to use a different constructor if you&#39;re making the object in a performance-critical section, and if you know the type parameters at compile time.</p></div></div></div><a class="docs-sourcelink" target="_blank" href="https://github.com/CliMA/ClimaCore.jl/blob/8819db3f9615df160b53a0d72c6dc80e3eb305f5/src/DataLayouts/DataLayouts.jl#L1166-L1190">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="ClimaCore.DataLayouts.IHF" href="#ClimaCore.DataLayouts.IHF"><code>ClimaCore.DataLayouts.IHF</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">IHF{S,Ni,Nh,A} &lt;: Data1D{S, Ni}
IHF{S,Ni,Nh}(ArrayType)</code></pre><p>Backing <code>DataLayout</code> for 1D spectral element slabs.</p><p>Element nodal point (I) data is contiguous for each datatype <code>S</code> struct field (F), for each 1D mesh element (H).</p><p>The <code>ArrayType</code>-constructor makes a IHF 1D Spectral DataLayout given the backing <code>ArrayType</code>, quadrature degrees of freedom <code>Ni</code>, and the number of mesh elements <code>Nh</code>.</p><pre><code class="nohighlight hljs">IHF{S}(ArrayType[, ones | zeros | rand]; Ni, Nh)</code></pre><p>The keyword constructor returns a <code>IHF</code> given the <code>ArrayType</code> and (optionally) an initialization method (one of <code>Base.ones</code>, <code>Base.zeros</code>, <code>Random.rand</code>) and the keywords:</p><ul><li><code>Ni</code> quadrature degrees of freedom in the horizontal direction</li><li><code>Nh</code> number of mesh elements</li></ul><div class="admonition is-info"><header class="admonition-header">Note</header><div class="admonition-body"><p>Objects made with the keyword constructor accept integer keyword inputs, so they are dynamically created. You may want to use a different constructor if you&#39;re making the object in a performance-critical section, and if you know the type parameters at compile time.</p></div></div></div><a class="docs-sourcelink" target="_blank" href="https://github.com/CliMA/ClimaCore.jl/blob/8819db3f9615df160b53a0d72c6dc80e3eb305f5/src/DataLayouts/DataLayouts.jl#L761-L791">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="ClimaCore.DataLayouts.IJHF" href="#ClimaCore.DataLayouts.IJHF"><code>ClimaCore.DataLayouts.IJHF</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">IJHF{S, Nij, A} &lt;: Data2D{S, Nij}
IJHF{S,Nij}(ArrayType, nelements)</code></pre><p>Backing <code>DataLayout</code> for 2D spectral element slabs.</p><p>Element nodal point (I,J) data is contiguous for each datatype <code>S</code> struct field (F), for each 2D mesh element slab (H).</p><p>The <code>ArrayType</code>-constructor constructs a IJHF 2D Spectral DataLayout given the backing <code>ArrayType</code>, quadrature degrees of freedom <code>Nij × Nij</code>, and the number of mesh elements <code>nelements</code>.</p><pre><code class="nohighlight hljs">IJHF{S}(ArrayType[, Base.ones | zeros | rand]; Nij, Nh)</code></pre><p>The keyword constructor returns a <code>IJHF</code> given the <code>ArrayType</code> and (optionally) an initialization method (one of <code>Base.ones</code>, <code>Base.zeros</code>, <code>Random.rand</code>) and the keywords:</p><ul><li><code>Nij</code> quadrature degrees of freedom per horizontal direction</li><li><code>Nh</code> number of mesh elements</li></ul><div class="admonition is-info"><header class="admonition-header">Note</header><div class="admonition-body"><p>Objects made with the keyword constructor accept integer keyword inputs, so they are dynamically created. You may want to use a different constructor if you&#39;re making the object in a performance-critical section, and if you know the type parameters at compile time.</p></div></div></div><a class="docs-sourcelink" target="_blank" href="https://github.com/CliMA/ClimaCore.jl/blob/8819db3f9615df160b53a0d72c6dc80e3eb305f5/src/DataLayouts/DataLayouts.jl#L583-L612">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="ClimaCore.DataLayouts.VIHF" href="#ClimaCore.DataLayouts.VIHF"><code>ClimaCore.DataLayouts.VIHF</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">VIHF{S, Nv, Ni, A} &lt;: Data1DX{S, Nv, Ni}</code></pre><p>Backing <code>DataLayout</code> for 1D spectral element slab + extruded 1D FV column data.</p><p>Column levels (V) are contiguous for every element nodal point (I) for each datatype <code>S</code> struct field (F), for each 1D mesh element slab (H).</p><pre><code class="nohighlight hljs">VIHF{S}(ArrayType[, ones | zeros | rand]; Nv, Ni, Nh)</code></pre><p>The keyword constructor returns a <code>VIHF</code> given the <code>ArrayType</code> and (optionally) an initialization method (one of <code>Base.ones</code>, <code>Base.zeros</code>, <code>Random.rand</code>) and the keywords:</p><ul><li><code>Nv</code> number of vertical degrees of freedom</li><li><code>Ni</code> quadrature degrees of freedom in the horizontal direction</li><li><code>Nh</code> number of horizontal elements</li></ul><div class="admonition is-info"><header class="admonition-header">Note</header><div class="admonition-body"><p>Objects made with the keyword constructor accept integer keyword inputs, so they are dynamically created. You may want to use a different constructor if you&#39;re making the object in a performance-critical section, and if you know the type parameters at compile time.</p></div></div></div><a class="docs-sourcelink" target="_blank" href="https://github.com/CliMA/ClimaCore.jl/blob/8819db3f9615df160b53a0d72c6dc80e3eb305f5/src/DataLayouts/DataLayouts.jl#L1476-L1500">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="ClimaCore.DataLayouts.VIJHF" href="#ClimaCore.DataLayouts.VIJHF"><code>ClimaCore.DataLayouts.VIJHF</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">VIJHF{S, Nij, A} &lt;: Data2DX{S, Nij}</code></pre><p>Backing <code>DataLayout</code> for 2D spectral element slab + extruded 1D FV column data.</p><p>Column levels (V) are contiguous for every element nodal point (I, J) for each <code>S</code> datatype struct field (F), for each 2D mesh element slab (H).</p><pre><code class="nohighlight hljs">VIJHF{S}(ArrayType[, ones | zeros | rand]; Nv, Nij, Nh)</code></pre><p>The keyword constructor returns a <code>VIJHF</code> given the <code>ArrayType</code> and (optionally) an initialization method (one of <code>Base.ones</code>, <code>Base.zeros</code>, <code>Random.rand</code>) and the keywords:</p><ul><li><code>Nv</code> number of vertical degrees of freedom</li><li><code>Nij</code> quadrature degrees of freedom per horizontal direction</li><li><code>Nh</code> number of horizontal elements</li></ul><div class="admonition is-info"><header class="admonition-header">Note</header><div class="admonition-body"><p>Objects made with the keyword constructor accept integer keyword inputs, so they are dynamically created. You may want to use a different constructor if you&#39;re making the object in a performance-critical section, and if you know the type parameters at compile time.</p></div></div></div><a class="docs-sourcelink" target="_blank" href="https://github.com/CliMA/ClimaCore.jl/blob/8819db3f9615df160b53a0d72c6dc80e3eb305f5/src/DataLayouts/DataLayouts.jl#L1273-L1297">source</a></section></article><h2 id="Geometry"><a class="docs-heading-anchor" href="#Geometry">Geometry</a><a id="Geometry-1"></a><a class="docs-heading-anchor-permalink" href="#Geometry" title="Permalink"></a></h2><h3 id="Global-Geometry"><a class="docs-heading-anchor" href="#Global-Geometry">Global Geometry</a><a id="Global-Geometry-1"></a><a class="docs-heading-anchor-permalink" href="#Global-Geometry" title="Permalink"></a></h3><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="ClimaCore.Geometry.AbstractGlobalGeometry" href="#ClimaCore.Geometry.AbstractGlobalGeometry"><code>ClimaCore.Geometry.AbstractGlobalGeometry</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">AbstractGlobalGeometry</code></pre><p>Determines the conversion from local coordinates and vector bases to a Cartesian basis.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/CliMA/ClimaCore.jl/blob/8819db3f9615df160b53a0d72c6dc80e3eb305f5/src/Geometry/globalgeometry.jl#L2-L6">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="ClimaCore.Geometry.CartesianGlobalGeometry" href="#ClimaCore.Geometry.CartesianGlobalGeometry"><code>ClimaCore.Geometry.CartesianGlobalGeometry</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">CartesianGlobalGeometry()</code></pre><p>Specifies that the local coordinates align with the Cartesian coordinates, e.g. <code>XYZPoint</code> aligns with <code>Cartesian123Point</code>, and <code>UVWVector</code> aligns with <code>Cartesian123Vector</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/CliMA/ClimaCore.jl/blob/8819db3f9615df160b53a0d72c6dc80e3eb305f5/src/Geometry/globalgeometry.jl#L22-L28">source</a></section></article><h3 id="Coordinates"><a class="docs-heading-anchor" href="#Coordinates">Coordinates</a><a id="Coordinates-1"></a><a class="docs-heading-anchor-permalink" href="#Coordinates" title="Permalink"></a></h3><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="ClimaCore.Geometry.AbstractPoint" href="#ClimaCore.Geometry.AbstractPoint"><code>ClimaCore.Geometry.AbstractPoint</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">AbstractPoint</code></pre><p>Represents a point in space.</p><p>The following types are supported:</p><ul><li><code>XPoint(x)</code></li><li><code>YPoint(y)</code></li><li><code>ZPoint(z)</code></li><li><code>XYPoint(x, y)</code></li><li><code>XZPoint(x, z)</code></li><li><code>XYZPoint(x, y, z)</code></li><li><code>LatPoint(lat)</code></li><li><code>LongPoint(long)</code></li><li><code>LatLongPoint(lat, long)</code></li><li><code>LatLongZPoint(lat, long, z)</code></li><li><code>Cartesian1Point(x1)</code></li><li><code>Cartesian2Point(x2)</code></li><li><code>Cartesian3Point(x3)</code></li><li><code>Cartesian12Point(x1, x2)</code></li><li><code>Cartesian13Point(x1, x3)</code></li><li><code>Cartesian123Point(x1, x2, x3)</code></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/CliMA/ClimaCore.jl/blob/8819db3f9615df160b53a0d72c6dc80e3eb305f5/src/Geometry/coordinates.jl#L1-L23">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="ClimaCore.Geometry.float_type" href="#ClimaCore.Geometry.float_type"><code>ClimaCore.Geometry.float_type</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">float_type(T)</code></pre><p>Return the floating point type backing <code>T</code>: <code>T</code> can either be an object or a type.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/CliMA/ClimaCore.jl/blob/8819db3f9615df160b53a0d72c6dc80e3eb305f5/src/Geometry/coordinates.jl#L26-L30">source</a></section></article><p>Points represent <em>locations</em> in space, specified by coordinates in a given coordinate system (Cartesian, spherical, etc), whereas vectors, on the other hand, represent <em>displacements</em> in space.</p><p>An analogy with time works well: times (also called instants or datetimes) are <em>locations</em> in time, while, durations are <em>displacements</em> in time.</p><p><strong>Note 1</strong>: Latitude and longitude are specified via angles (and, therefore, trigonometric functions: <code>cosd</code>, <code>sind</code>, <code>acosd</code>, <code>asind</code>, <code>tand</code>,...) in degrees, not in radians. Moreover, <code>lat</code> (usually denoted by <span>$\theta$</span>) <span>$\in [-90.0, 90.0]$</span>, and <code>long</code> (usually denoted by <span>$\lambda$</span>) <span>$\in [-180.0, 180.0]$</span>.</p><p><strong>Note 2:</strong>: In a <code>Geometry.LatLongZPoint(lat, long, z)</code>, <code>z</code> represents the elevation above the surface of the sphere with radius R (implicitly accounted for in the geoemtry).</p><p><strong>Note 3</strong>: There are also a set of specific Cartesian points (<code>Cartesian1Point(x1)</code>, <code>Cartesian2Point(x2)</code>, etc). These are occasionally useful for converting everything to a full Cartesian domain (e.g. for visualization purposes). These are distinct from <code>XYZPoint</code> as <code>ZPoint</code> can mean different things in different domains.</p><h2 id="Domains"><a class="docs-heading-anchor" href="#Domains">Domains</a><a id="Domains-1"></a><a class="docs-heading-anchor-permalink" href="#Domains" title="Permalink"></a></h2><h3 id="Types"><a class="docs-heading-anchor" href="#Types">Types</a><a id="Types-1"></a><a class="docs-heading-anchor-permalink" href="#Types" title="Permalink"></a></h3><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="ClimaCore.Domains.AbstractDomain" href="#ClimaCore.Domains.AbstractDomain"><code>ClimaCore.Domains.AbstractDomain</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">AbstractDomain</code></pre><p>A domain represents a region of space.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/CliMA/ClimaCore.jl/blob/8819db3f9615df160b53a0d72c6dc80e3eb305f5/src/Domains/Domains.jl#L7-L11">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="ClimaCore.Domains.IntervalDomain" href="#ClimaCore.Domains.IntervalDomain"><code>ClimaCore.Domains.IntervalDomain</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">IntervalDomain(coord⁻, coord⁺; periodic=true)
IntervalDomain(coord⁻, coord⁺; boundary_names::Tuple{Symbol,Symbol})</code></pre><p>Construct a <code>IntervalDomain</code>, the closed interval is given by <code>coord⁻</code>, <code>coord⁺</code> coordinate arguments.</p><p>Either a <code>periodic</code> or <code>boundary_names</code> keyword argument is required.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/CliMA/ClimaCore.jl/blob/8819db3f9615df160b53a0d72c6dc80e3eb305f5/src/Domains/Domains.jl#L42-L49">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="ClimaCore.Domains.RectangleDomain" href="#ClimaCore.Domains.RectangleDomain"><code>ClimaCore.Domains.RectangleDomain</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">RectangleDomain(x1::ClosedInterval, x2::ClosedInterval;
    x1boundary::Tuple{Symbol,Symbol},
    x2boundary::Tuple{Symbol,Symbol},
    x1periodic = false,
    x2periodic = false,
)</code></pre><p>Construct a <code>RectangularDomain</code> in the horizontal. If a given x1 or x2 boundary is not periodic, then <code>x1boundary</code> or <code>x2boundary</code> boundary name keyword arguments must be supplied.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/CliMA/ClimaCore.jl/blob/8819db3f9615df160b53a0d72c6dc80e3eb305f5/src/Domains/Domains.jl#L121-L131">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="ClimaCore.Domains.SphereDomain" href="#ClimaCore.Domains.SphereDomain"><code>ClimaCore.Domains.SphereDomain</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">SphereDomain(radius)</code></pre><p>A domain representing the surface of a sphere with radius <code>radius</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/CliMA/ClimaCore.jl/blob/8819db3f9615df160b53a0d72c6dc80e3eb305f5/src/Domains/Domains.jl#L162-L166">source</a></section></article><h3 id="Interfaces"><a class="docs-heading-anchor" href="#Interfaces">Interfaces</a><a id="Interfaces-1"></a><a class="docs-heading-anchor-permalink" href="#Interfaces" title="Permalink"></a></h3><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="ClimaCore.Domains.boundary_names" href="#ClimaCore.Domains.boundary_names"><code>ClimaCore.Domains.boundary_names</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">boundary_names(obj::Union{AbstractDomain, AbstractMesh, AbstractTopology})</code></pre><p>A tuple or vector of unique boundary names of a spatial domain.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/CliMA/ClimaCore.jl/blob/8819db3f9615df160b53a0d72c6dc80e3eb305f5/src/Domains/Domains.jl#L22-L26">source</a></section></article><h2 id="Meshes"><a class="docs-heading-anchor" href="#Meshes">Meshes</a><a id="Meshes-1"></a><a class="docs-heading-anchor-permalink" href="#Meshes" title="Permalink"></a></h2><p>A <code>Mesh</code> is a division of a domain into elements.</p><h3 id="Mesh-types"><a class="docs-heading-anchor" href="#Mesh-types">Mesh types</a><a id="Mesh-types-1"></a><a class="docs-heading-anchor-permalink" href="#Mesh-types" title="Permalink"></a></h3><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="ClimaCore.Meshes.AbstractMesh" href="#ClimaCore.Meshes.AbstractMesh"><code>ClimaCore.Meshes.AbstractMesh</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">AbstractMesh{dim}</code></pre><p>A <code>Mesh</code> is an object which represents how we discretize a domain into elements.</p><p>It should be lightweight (i.e. exists on all MPI ranks), e.g for meshes stored in a file, it would contain the filename.</p><p><strong>Face and vertex numbering</strong></p><p>In 1D, faces and vertices are the same, and both are numbered <code>[1,2]</code>.</p><p>In 2D, a face is a line segment between to vertices, and both are numbered <code>[1,2,3,4]</code>, in a counter-clockwise direction.</p><pre><code class="nohighlight hljs"> v4        f3        v3
   o-----------------o
   |                 |	    face    vertices
   |                 |	      f1 =&gt;  v1 v2
f4 |                 | f2     f2 =&gt;  v2 v3
   |                 |	      f3 =&gt;  v3 v4
   |                 |        f4 =&gt;  v4 v1
   |                 |
   o-----------------o
  v1       f1        v2</code></pre><p><strong>Interface</strong></p><p>A subtype of <code>AbstractMesh</code> should define the following methods:</p><ul><li><a href="#ClimaCore.Meshes.domain"><code>domain(mesh)</code></a></li><li><a href="#ClimaCore.Meshes.elements"><code>elements(mesh)</code></a></li><li><a href="#ClimaCore.Meshes.is_boundary_face"><code>is_boundary_face(mesh, elem, face)</code></a></li><li><a href="#ClimaCore.Meshes.boundary_face_name"><code>boundary_face_name(mesh, elem, face)</code></a></li><li><a href="#ClimaCore.Meshes.opposing_face"><code>opposing_face(mesh, elem, face)</code></a></li><li><a href="#ClimaCore.Meshes.coordinates"><code>coordinates(mesh, elem, vert)</code></a></li><li><a href="#ClimaCore.Meshes.containing_element"><code>containing_element</code></a> (optional)</li></ul><p>The following types/methods are provided by <code>AbstractMesh</code>:</p><ul><li><a href="#ClimaCore.Meshes.SharedVertices"><code>SharedVertices(mesh, elem, vert)</code></a></li><li><a href="#ClimaCore.Meshes.face_connectivity_matrix"><code>face_connectivity_matrix(mesh[,elemorder])</code></a></li><li><a href="#ClimaCore.Meshes.vertex_connectivity_matrix"><code>vertex_connectivity_matrix(mesh[,elemorder])</code></a></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/CliMA/ClimaCore.jl/blob/8819db3f9615df160b53a0d72c6dc80e3eb305f5/src/Meshes/Meshes.jl#L23-L65">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="ClimaCore.Meshes.IntervalMesh" href="#ClimaCore.Meshes.IntervalMesh"><code>ClimaCore.Meshes.IntervalMesh</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">IntervalMesh &lt;: AbstractMesh</code></pre><p>A 1D mesh on an <code>IntervalDomain</code>.</p><p><strong>Constuctors</strong></p><pre><code class="nohighlight hljs">IntervalMesh(domain::IntervalDomain, faces::AbstractVector)</code></pre><p>Construct a 1D mesh with face locations at <code>faces</code>.</p><pre><code class="nohighlight hljs">IntervalMesh(domain::IntervalDomain[, stretching=Uniform()]; nelems=)</code></pre><p>Constuct a 1D mesh on <code>domain</code> with <code>nelems</code> elements, using <code>stretching</code>. Possible values of <code>stretching</code> are:</p><ul><li><a href="#ClimaCore.Meshes.Uniform"><code>Uniform()</code></a></li><li><a href="#ClimaCore.Meshes.ExponentialStretching"><code>ExponentialStretching(H)</code></a></li><li><a href="#ClimaCore.Meshes.GeneralizedExponentialStretching"><code>GeneralizedExponentialStretching(dz_bottom, dz_top)</code></a></li><li><a href="#ClimaCore.Meshes.HyperbolicTangentStretching"><code>HyperbolicTangentStretching(dz_bottom)</code></a></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/CliMA/ClimaCore.jl/blob/8819db3f9615df160b53a0d72c6dc80e3eb305f5/src/Meshes/interval.jl#L1-L20">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="ClimaCore.Meshes.RectilinearMesh" href="#ClimaCore.Meshes.RectilinearMesh"><code>ClimaCore.Meshes.RectilinearMesh</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">RectilinearMesh &lt;: AbstractMesh2D</code></pre><p><strong>Constructors</strong></p><pre><code class="nohighlight hljs">RectilinearMesh(domain::RectangleDomain, n1, n2)</code></pre><p>Construct a <code>RectilinearMesh</code> of equally-spaced <code>n1</code> by <code>n2</code> elements on <code>domain</code>.</p><pre><code class="nohighlight hljs">RectilinearMesh(intervalmesh1::IntervalMesh1, intervalmesh2::IntervalMesh2)</code></pre><p>Construct the product mesh of <code>intervalmesh1</code> and <code>intervalmesh2</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/CliMA/ClimaCore.jl/blob/8819db3f9615df160b53a0d72c6dc80e3eb305f5/src/Meshes/rectangle.jl#L1-L13">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="ClimaCore.Meshes.AbstractCubedSphere" href="#ClimaCore.Meshes.AbstractCubedSphere"><code>ClimaCore.Meshes.AbstractCubedSphere</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">AbstractCubedSphere &lt;: AbstractMesh2D</code></pre><p>This is an abstract type of cubed-sphere meshes on <code>SphereDomain</code>s. A cubed-sphere mesh has 6 panels, laid out as follows:</p><pre><code class="nohighlight hljs">                                          :   Panel 1   :
                            +-------------+-------------+
                            |     +x1     |     +x1     |
                            |             |             |
                            |    Panel    |    Panel    |
                            |+x3   5   -x3|-x2   6   +x2|
                            |     -x2     |     -x3     |
                            |             |             |
                            |     -x1     |     -x1     |
              +-------------+-------------+-------------+
              |     -x2     |     -x2     |
              |             |             |
              |    Panel    |    Panel    |
              |+x1   3   -x1|+x3   4   -x3|
              |     +x3     |     -x1     |
              |             |             |
              |     +x2     |     +x2     |
+-------------+-------------+-------------+
|     +x3     |     +x3     |
|             |             |
|    Panel    |    Panel    |
|-x2   1   +x2|+x1   2   -x1|
|     +x1     |     +x2     |
|             |             |
|     -x3     |     -x3     |
+-------------+-------------+
:   Panel 6   :</code></pre><p>This is the same panel ordering used by the S2 Geometry library (though we use 1-based instead of 0-based numering).</p><p>Elements are indexed by a <code>CartesianIndex{3}</code> object, where the components are:</p><ul><li>horizontal element index (left to right) within each panel.</li><li>vertical element index (bottom to top) within each panel.</li><li>panel number</li></ul><p>Subtypes should have the following fields:</p><ul><li><code>domain</code>: a <code>SphereDomain</code></li><li><code>ne</code>: number of elements across each panel</li></ul><p><strong>External links</strong></p><ul><li><a href="https://s2geometry.io/devguide/s2cell_hierarchy">S2Geometry library</a></li><li><a href="https://mitgcm.readthedocs.io/en/latest/phys_pkgs/exch2.html?highlight=cube%20sphere#fig-48tile">MIT GCM exch2</a></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/CliMA/ClimaCore.jl/blob/8819db3f9615df160b53a0d72c6dc80e3eb305f5/src/Meshes/cubedsphere.jl#L1-L51">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="ClimaCore.Meshes.EquiangularCubedSphere" href="#ClimaCore.Meshes.EquiangularCubedSphere"><code>ClimaCore.Meshes.EquiangularCubedSphere</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">EquiangularCubedSphere &lt;: AbstractCubedSphere</code></pre><p>An equiangular gnomonic mesh proposed by [<a href="../references/#Ronchi1996">8</a>]. Uses the element indexing convention of <a href="#ClimaCore.Meshes.AbstractCubedSphere"><code>AbstractCubedSphere</code></a>.</p><p><strong>Constructors</strong></p><pre><code class="nohighlight hljs">EquiangularCubedSphere(
    domain::Domains.SphereDomain,
    ne::Integer,
    localelementmap=NormalizedBilinearMap()
    )</code></pre><p>Constuct an <code>EquiangularCubedSphere</code> on <code>domain</code> with <code>ne</code> elements across each panel.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/CliMA/ClimaCore.jl/blob/8819db3f9615df160b53a0d72c6dc80e3eb305f5/src/Meshes/cubedsphere.jl#L353-L369">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="ClimaCore.Meshes.EquidistantCubedSphere" href="#ClimaCore.Meshes.EquidistantCubedSphere"><code>ClimaCore.Meshes.EquidistantCubedSphere</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">EquidistantCubedSphere &lt;: AbstractCubedSphere</code></pre><p>An equidistant gnomonic mesh outlined in [<a href="../references/#Rancic1996">9</a>] and [<a href="../references/#Nair2005">10</a>]. Uses the element indexing convention of <a href="#ClimaCore.Meshes.AbstractCubedSphere"><code>AbstractCubedSphere</code></a>.</p><p><strong>Constructors</strong></p><pre><code class="nohighlight hljs">EquidistantCubedSphere(domain::Domains.SphereDomain, ne::Integer)</code></pre><p>Constuct an <code>EquidistantCubedSphere</code> on <code>domain</code> with <code>ne</code> elements across each panel.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/CliMA/ClimaCore.jl/blob/8819db3f9615df160b53a0d72c6dc80e3eb305f5/src/Meshes/cubedsphere.jl#L404-L416">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="ClimaCore.Meshes.ConformalCubedSphere" href="#ClimaCore.Meshes.ConformalCubedSphere"><code>ClimaCore.Meshes.ConformalCubedSphere</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">ConformalCubedSphere &lt;: AbstractCubedSphere</code></pre><p>A conformal mesh outlined in [<a href="../references/#Rancic1996">9</a>]. Uses the element indexing convention of <a href="#ClimaCore.Meshes.AbstractCubedSphere"><code>AbstractCubedSphere</code></a>.</p><p><strong>Constructors</strong></p><pre><code class="nohighlight hljs">ConformalCubedSphere(domain::Domains.SphereDomain, ne::Integer)</code></pre><p>Constuct a <code>ConformalCubedSphere</code> on <code>domain</code> with <code>ne</code> elements across each panel.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/CliMA/ClimaCore.jl/blob/8819db3f9615df160b53a0d72c6dc80e3eb305f5/src/Meshes/cubedsphere.jl#L442-L454">source</a></section></article><h3 id="Local-element-map"><a class="docs-heading-anchor" href="#Local-element-map">Local element map</a><a id="Local-element-map-1"></a><a class="docs-heading-anchor-permalink" href="#Local-element-map" title="Permalink"></a></h3><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="ClimaCore.Meshes.LocalElementMap" href="#ClimaCore.Meshes.LocalElementMap"><code>ClimaCore.Meshes.LocalElementMap</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">LocalElementMap</code></pre><p>An abstract type of mappings from the reference element to a physical domain.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/CliMA/ClimaCore.jl/blob/8819db3f9615df160b53a0d72c6dc80e3eb305f5/src/Meshes/cubedsphere.jl#L54-L58">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="ClimaCore.Meshes.IntrinsicMap" href="#ClimaCore.Meshes.IntrinsicMap"><code>ClimaCore.Meshes.IntrinsicMap</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">IntrinsicMap()</code></pre><p>This <a href="#ClimaCore.Meshes.LocalElementMap"><code>LocalElementMap</code></a> uses the intrinsic mapping of the cubed sphere to map the reference element to the physical domain.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/CliMA/ClimaCore.jl/blob/8819db3f9615df160b53a0d72c6dc80e3eb305f5/src/Meshes/cubedsphere.jl#L61-L66">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="ClimaCore.Meshes.NormalizedBilinearMap" href="#ClimaCore.Meshes.NormalizedBilinearMap"><code>ClimaCore.Meshes.NormalizedBilinearMap</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">NormalizedBilinearMap()</code></pre><p>The <a href="#ClimaCore.Meshes.LocalElementMap"><code>LocalElementMap</code></a> for meshes on spherical domains of [<a href="../references/#Guba2014">11</a>]. It uses bilinear interpolation between the Cartesian coordinates of the element vertices, then normalizes the result to lie on the sphere.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/CliMA/ClimaCore.jl/blob/8819db3f9615df160b53a0d72c6dc80e3eb305f5/src/Meshes/cubedsphere.jl#L69-L76">source</a></section></article><h3 id="Mesh-stretching"><a class="docs-heading-anchor" href="#Mesh-stretching">Mesh stretching</a><a id="Mesh-stretching-1"></a><a class="docs-heading-anchor-permalink" href="#Mesh-stretching" title="Permalink"></a></h3><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="ClimaCore.Meshes.Uniform" href="#ClimaCore.Meshes.Uniform"><code>ClimaCore.Meshes.Uniform</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">Uniform()</code></pre><p>Use uniformly-sized elements.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/CliMA/ClimaCore.jl/blob/8819db3f9615df160b53a0d72c6dc80e3eb305f5/src/Meshes/interval.jl#L147-L151">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="ClimaCore.Meshes.ExponentialStretching" href="#ClimaCore.Meshes.ExponentialStretching"><code>ClimaCore.Meshes.ExponentialStretching</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">ExponentialStretching(H::FT)</code></pre><p>Apply exponential stretching to the domain when constructing elements. <code>H</code> is the scale height (a typical atmospheric scale height <code>H ≈ 7.5</code>km).</p><p>For an interval <span>$[z_0,z_1]$</span>, this makes the elements uniformally spaced in <span>$\zeta$</span>, where</p><p class="math-container">\[\zeta = \frac{1 - e^{-\eta/h}}{1-e^{-1/h}},\]</p><p>where <span>$\eta = \frac{z - z_0}{z_1-z_0}$</span>, and <span>$h = \frac{H}{z_1-z_0}$</span> is the non-dimensional scale height. If <code>reverse_mode</code> is <code>true</code>, the smallest element is at the top, and the largest at the bottom (this is typical for land model configurations).</p><p>Then, the user can define a stretched mesh via</p><pre><code class="nohighlight hljs">ClimaCore.Meshes.IntervalMesh(interval_domain, ExponentialStretching(H); nelems::Int, reverse_mode = false)</code></pre><p><code>faces</code> contain reference z without any warping.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/CliMA/ClimaCore.jl/blob/8819db3f9615df160b53a0d72c6dc80e3eb305f5/src/Meshes/interval.jl#L168-L189">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="ClimaCore.Meshes.GeneralizedExponentialStretching" href="#ClimaCore.Meshes.GeneralizedExponentialStretching"><code>ClimaCore.Meshes.GeneralizedExponentialStretching</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">GeneralizedExponentialStretching(dz_bottom::FT, dz_top::FT)</code></pre><p>Apply a generalized form of exponential stretching to the domain when constructing elements. <code>dz_bottom</code> and <code>dz_top</code> are target element grid spacings at the bottom and at the top of the vertical column domain (m). In typical atmosphere configurations, <code>dz_bottom</code> is the smallest grid spacing and <code>dz_top</code> the largest one. On the other hand, for typical land configurations, <code>dz_bottom</code> is the largest grid spacing and <code>dz_top</code> the smallest one.</p><p>For land configurations, use <code>reverse_mode</code> = <code>true</code> (default value <code>false</code>).</p><p>Then, the user can define a generalized stretched mesh via</p><pre><code class="nohighlight hljs">ClimaCore.Meshes.IntervalMesh(interval_domain, GeneralizedExponentialStretching(dz_bottom, dz_top); nelems::Int, reverse_mode = false)</code></pre><p><code>faces</code> contain reference z without any warping.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/CliMA/ClimaCore.jl/blob/8819db3f9615df160b53a0d72c6dc80e3eb305f5/src/Meshes/interval.jl#L223-L239">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="ClimaCore.Meshes.HyperbolicTangentStretching" href="#ClimaCore.Meshes.HyperbolicTangentStretching"><code>ClimaCore.Meshes.HyperbolicTangentStretching</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">HyperbolicTangentStretching(dz_surface::FT)</code></pre><p>Apply a hyperbolic tangent stretching to the domain when constructing elements. <code>dz_surface</code> is the target element grid spacing at the surface. In typical atmosphere configuration, it is the grid spacing at the bottom of the vertical column domain (m). On the other hand, for typical land configurations, it is the grid spacing at the top of the vertical column domain.</p><p>For an interval <span>$[z_0,z_1]$</span>, this makes the elements uniformally spaced in <span>$\zeta$</span>, where</p><p class="math-container">\[\eta = 1 - \frac{tanh[\gamma(1-\zeta)]}{tanh(\gamma)},\]</p><p>where <span>$\eta = \frac{z - z_0}{z_1-z_0}$</span>. The stretching parameter <span>$\gamma$</span> is chosen to achieve a given resolution <code>dz_surface</code> at the surface. </p><p>Then, the user can define a stretched mesh via</p><pre><code class="nohighlight hljs">ClimaCore.Meshes.IntervalMesh(interval_domain, HyperbolicTangentStretching(dz_surface); nelems::Int, reverse_mode)</code></pre><p><code>reverse_mode</code> is default to false for atmosphere configurations. For land configurations,  use <code>reverse_mode</code> = <code>true</code>.</p><p><code>faces</code> contain reference z without any warping.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/CliMA/ClimaCore.jl/blob/8819db3f9615df160b53a0d72c6dc80e3eb305f5/src/Meshes/interval.jl#L344-L369">source</a></section></article><h3 id="Mesh-utilities"><a class="docs-heading-anchor" href="#Mesh-utilities">Mesh utilities</a><a id="Mesh-utilities-1"></a><a class="docs-heading-anchor-permalink" href="#Mesh-utilities" title="Permalink"></a></h3><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="ClimaCore.Meshes.truncate_mesh" href="#ClimaCore.Meshes.truncate_mesh"><code>ClimaCore.Meshes.truncate_mesh</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">truncate_mesh(
    parent_mesh::AbstractMesh,
    trunc_domain::IntervalDomain{CT},
)</code></pre><p>Constructs an <code>IntervalMesh</code>, truncating the given <code>parent_mesh</code> defined on a truncated <code>trunc_domain</code>. The truncation preserves the number of degrees of freedom covering the space from the <code>trunc_domain</code>&#39;s <code>z_bottom</code> to <code>z_top</code>, adjusting the stretching.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/CliMA/ClimaCore.jl/blob/8819db3f9615df160b53a0d72c6dc80e3eb305f5/src/Meshes/interval.jl#L433-L442">source</a></section></article><h3 id="Interfaces-2"><a class="docs-heading-anchor" href="#Interfaces-2">Interfaces</a><a class="docs-heading-anchor-permalink" href="#Interfaces-2" title="Permalink"></a></h3><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="ClimaCore.Meshes.domain" href="#ClimaCore.Meshes.domain"><code>ClimaCore.Meshes.domain</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">Meshes.domain(mesh::AbstractMesh)</code></pre><p>The domain (a subtype of  <a href="#ClimaCore.Domains.AbstractDomain"><code>Domains.AbstractDomain</code></a>) on which the mesh is defined.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/CliMA/ClimaCore.jl/blob/8819db3f9615df160b53a0d72c6dc80e3eb305f5/src/Meshes/Meshes.jl#L71-L75">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="ClimaCore.Meshes.elements" href="#ClimaCore.Meshes.elements"><code>ClimaCore.Meshes.elements</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">Meshes.elements(mesh::AbstractMesh)</code></pre><p>An iterator over the elements of a mesh. Elements of a mesh can be of any type.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/CliMA/ClimaCore.jl/blob/8819db3f9615df160b53a0d72c6dc80e3eb305f5/src/Meshes/Meshes.jl#L78-L82">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="ClimaCore.Meshes.nelements" href="#ClimaCore.Meshes.nelements"><code>ClimaCore.Meshes.nelements</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">nelements(mesh::AbstractMesh)</code></pre><p>The number of elements in the mesh.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/CliMA/ClimaCore.jl/blob/8819db3f9615df160b53a0d72c6dc80e3eb305f5/src/Meshes/common.jl#L4-L8">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="ClimaCore.Meshes.is_boundary_face" href="#ClimaCore.Meshes.is_boundary_face"><code>ClimaCore.Meshes.is_boundary_face</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">Meshes.is_boundary_face(mesh::AbstractMesh, elem, face::Int)::Bool</code></pre><p>Determine whether face <code>face</code> of element <code>elem</code> is on the boundary of <code>mesh</code>.</p><p><code>elem</code> should be an element of <a href="#ClimaCore.Meshes.elements"><code>elements(mesh)</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/CliMA/ClimaCore.jl/blob/8819db3f9615df160b53a0d72c6dc80e3eb305f5/src/Meshes/Meshes.jl#L85-L91">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="ClimaCore.Meshes.boundary_face_name" href="#ClimaCore.Meshes.boundary_face_name"><code>ClimaCore.Meshes.boundary_face_name</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">Meshes.boundary_face_name(mesh::AbstractMesh, elem, face::Int)::Union{Symbol,Nothing}</code></pre><p>The name of the boundary facing <code>face</code> of element <code>elem</code>, or <code>nothing</code> if it is not on the boundary.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/CliMA/ClimaCore.jl/blob/8819db3f9615df160b53a0d72c6dc80e3eb305f5/src/Meshes/Meshes.jl#L94-L99">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="ClimaCore.Meshes.opposing_face" href="#ClimaCore.Meshes.opposing_face"><code>ClimaCore.Meshes.opposing_face</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">opelem, opface, reversed = Meshes.opposing_face(mesh::AbstractMesh, elem, face::Int)</code></pre><p>The element and face (<code>opelem</code>, <code>opface</code>) that oppose face <code>face</code> of element <code>elem</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/CliMA/ClimaCore.jl/blob/8819db3f9615df160b53a0d72c6dc80e3eb305f5/src/Meshes/Meshes.jl#L102-L106">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="ClimaCore.Meshes.coordinates" href="#ClimaCore.Meshes.coordinates"><code>ClimaCore.Meshes.coordinates</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">Meshes.coordinates(mesh, elem, vert::Int)
Meshes.coordinates(mesh, elem, ξ::SVector)</code></pre><p>Return the physical coordinates of a point in an element <code>elem</code> of <code>mesh</code>. The position of the point can either be a vertex number <code>vert</code> or the coordinates <code>ξ</code> in the reference element.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/CliMA/ClimaCore.jl/blob/8819db3f9615df160b53a0d72c6dc80e3eb305f5/src/Meshes/common.jl#L164-L171">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="ClimaCore.Meshes.containing_element" href="#ClimaCore.Meshes.containing_element"><code>ClimaCore.Meshes.containing_element</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">elem = Meshes.containing_element(mesh::AbstractMesh, coord)</code></pre><p>The element <code>elem</code> in <code>mesh</code> containing the coordinate <code>coord</code>. If the coordinate falls on the boundary between two or more elements, an arbitrary element is chosen.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/CliMA/ClimaCore.jl/blob/8819db3f9615df160b53a0d72c6dc80e3eb305f5/src/Meshes/common.jl#L181-L187">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="ClimaCore.Meshes.reference_coordinates" href="#ClimaCore.Meshes.reference_coordinates"><code>ClimaCore.Meshes.reference_coordinates</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">ξ = Meshes.reference_coordinates(mesh::AbstractMesh, elem, coord)</code></pre><p>An <code>SVector</code> of coordinates in the reference element such that</p><pre><code class="nohighlight hljs">Meshes.coordinates(mesh, elem, ξ) == coord</code></pre><p>This can be used for interpolation to a specific point.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/CliMA/ClimaCore.jl/blob/8819db3f9615df160b53a0d72c6dc80e3eb305f5/src/Meshes/common.jl#L190-L198">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="ClimaCore.Meshes.SharedVertices" href="#ClimaCore.Meshes.SharedVertices"><code>ClimaCore.Meshes.SharedVertices</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">Meshes.SharedVertices(mesh, elem, vert)</code></pre><p>An iterator over (element, vertex) pairs that are shared with <code>(elem,vert)</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/CliMA/ClimaCore.jl/blob/8819db3f9615df160b53a0d72c6dc80e3eb305f5/src/Meshes/common.jl#L28-L32">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="ClimaCore.Meshes.face_connectivity_matrix" href="#ClimaCore.Meshes.face_connectivity_matrix"><code>ClimaCore.Meshes.face_connectivity_matrix</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">M = Meshes.face_connectivity_matrix(mesh, elemorder = elements(mesh))</code></pre><p>Construct a <code>Bool</code>-valued <code>SparseCSCMatrix</code> containing the face connections of <code>mesh</code>. Elements are indexed according to <code>elemorder</code>.</p><p>Note that <code>M[i,i] == true</code> only if two distinct faces of element <code>i</code> are connected.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/CliMA/ClimaCore.jl/blob/8819db3f9615df160b53a0d72c6dc80e3eb305f5/src/Meshes/common.jl#L101-L108">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="ClimaCore.Meshes.vertex_connectivity_matrix" href="#ClimaCore.Meshes.vertex_connectivity_matrix"><code>ClimaCore.Meshes.vertex_connectivity_matrix</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">M = Meshes.vertex_connectivity_matrix(mesh, elemorder = elements(mesh))</code></pre><p>Construct a <code>Bool</code>-valued <code>SparseCSCMatrix</code> containing the vertex connections of <code>mesh</code>. Elements are indexed according to <code>elemorder</code>.</p><p>Note that <code>M[i,i] == true</code> only if two distinct vertices of element <code>i</code> are connected.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/CliMA/ClimaCore.jl/blob/8819db3f9615df160b53a0d72c6dc80e3eb305f5/src/Meshes/common.jl#L132-L139">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="ClimaCore.Meshes.linearindices" href="#ClimaCore.Meshes.linearindices"><code>ClimaCore.Meshes.linearindices</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">Meshes.linearindices(elemorder)</code></pre><p>Given a data structure <code>elemorder[i] = elem</code> that orders elements, construct the inverse map from <code>orderindex = linearindices(elemorder)</code> such that <code>orderindex[elem] = i</code>.</p><p>This will try to use the most efficient structure available.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/CliMA/ClimaCore.jl/blob/8819db3f9615df160b53a0d72c6dc80e3eb305f5/src/Meshes/common.jl#L75-L83">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="ClimaCore.Meshes.element_horizontal_length_scale" href="#ClimaCore.Meshes.element_horizontal_length_scale"><code>ClimaCore.Meshes.element_horizontal_length_scale</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">Meshes.element_horizontal_length_scale(mesh::AbstractMesh)</code></pre><p>The approximate length scale (in units of distance) of the elements of the mesh.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/CliMA/ClimaCore.jl/blob/8819db3f9615df160b53a0d72c6dc80e3eb305f5/src/Meshes/Meshes.jl#L109-L113">source</a></section></article><h2 id="Topologies"><a class="docs-heading-anchor" href="#Topologies">Topologies</a><a id="Topologies-1"></a><a class="docs-heading-anchor-permalink" href="#Topologies" title="Permalink"></a></h2><p>A <code>Topology</code> determines the ordering and connections between elements of a mesh. <img src="../cubedsphere_spacefillingcurve.png" alt="Space-filling curve element ordering for a cubed sphere mesh"/></p><h3 id="Types-2"><a class="docs-heading-anchor" href="#Types-2">Types</a><a class="docs-heading-anchor-permalink" href="#Types-2" title="Permalink"></a></h3><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="ClimaCore.Topologies.AbstractTopology" href="#ClimaCore.Topologies.AbstractTopology"><code>ClimaCore.Topologies.AbstractTopology</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><p>AbstractTopology</p><p>Subtypes of <code>AbstractHorizontalTopology</code> define connectiveness of a mesh in the horizontal domain.</p><p><strong>Interfaces</strong></p><ul><li><a href="#ClimaCore.Topologies.nelems"><code>nelems</code></a></li><li><a href="#ClimaCore.Meshes.domain"><code>domain(topology::AbstractTopology)</code></a></li><li><a href="#ClimaCore.Topologies.mesh"><code>mesh</code></a></li><li><a href="#ClimaCore.Topologies.nlocalelems"><code>nlocalelems</code></a></li><li><a href="#ClimaCore.Topologies.nneighbors"><code>nneighbors</code></a></li><li><a href="#ClimaCore.Topologies.nsendelems"><code>nsendelems</code></a></li><li><a href="#ClimaCore.Topologies.nghostelems"><code>nghostelems</code></a></li><li><a href="#ClimaCore.Topologies.localelemindex"><code>localelemindex</code></a></li><li><a href="#ClimaCore.Topologies.vertex_coordinates"><code>vertex_coordinates</code></a></li><li><a href="#ClimaCore.Topologies.opposing_face"><code>opposing_face</code></a></li><li><a href="#ClimaCore.Topologies.face_node_index"><code>face_node_index</code></a></li><li><a href="#ClimaCore.Topologies.interior_faces"><code>interior_faces</code></a></li><li><a href="#ClimaCore.Topologies.ghost_faces"><code>ghost_faces</code></a></li><li><a href="#ClimaCore.Topologies.vertex_node_index"><code>vertex_node_index</code></a></li><li><a href="#ClimaCore.Topologies.local_neighboring_elements"><code>local_neighboring_elements</code></a></li><li><a href="#ClimaCore.Topologies.ghost_neighboring_elements"><code>ghost_neighboring_elements</code></a></li><li><a href="#ClimaCore.Topologies.local_vertices"><code>local_vertices</code></a></li><li><a href="#ClimaCore.Topologies.ghost_vertices"><code>ghost_vertices</code></a></li><li><a href="#ClimaCore.Topologies.neighbors"><code>neighbors</code></a></li><li><a href="#ClimaCore.Topologies.boundary_tags"><code>boundary_tags</code></a></li><li><a href="#ClimaCore.Topologies.boundary_tag"><code>boundary_tag</code></a></li><li><a href="#ClimaCore.Topologies.boundary_faces"><code>boundary_faces</code></a></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/CliMA/ClimaCore.jl/blob/8819db3f9615df160b53a0d72c6dc80e3eb305f5/src/Topologies/Topologies.jl#L16-L47">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="ClimaCore.Topologies.IntervalTopology" href="#ClimaCore.Topologies.IntervalTopology"><code>ClimaCore.Topologies.IntervalTopology</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">IntervalTopology([context::SingletonCommsContext,] mesh::IntervalMesh)</code></pre><p>A sequential topology on an <a href="#ClimaCore.Meshes.IntervalMesh"><code>Meshes.IntervalMesh</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/CliMA/ClimaCore.jl/blob/8819db3f9615df160b53a0d72c6dc80e3eb305f5/src/Topologies/interval.jl#L3-L7">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="ClimaCore.Topologies.Topology2D" href="#ClimaCore.Topologies.Topology2D"><code>ClimaCore.Topologies.Topology2D</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">Topology2D(mesh::AbstractMesh2D, elemorder=Mesh.elements(mesh))</code></pre><p>This is a distributed topology for 2D meshes. <code>elemorder</code> is a vector or other linear ordering of the <code>Mesh.elements(mesh)</code>. <code>elempid</code> is a sorted vector of the same length as <code>elemorder</code>, each element of which contains the <code>pid</code> of the owning process.</p><p>Internally, we can refer to elements in several different ways:</p><ul><li><code>elem</code>: an element of the <code>mesh</code>. Often a <code>CartesianIndex</code> object.</li><li><code>gidx</code>: &quot;global index&quot;: an enumeration of all elements:<ul><li><code>elemorder[gidx] == elem</code></li><li><code>orderindex[elem] == gidx</code></li></ul></li><li><code>lidx</code>: &quot;local index&quot;: an enumeration of local elements.<ul><li><code>local_elem_gidx[lidx] == gidx</code></li></ul></li><li><code>sidx</code>: &quot;send index&quot;: an index into the send buffer of a local element. A single local element may have multiple <code>sidx</code>s if it needs to be send to multiple processes.<ul><li><code>send_elem_lidx[sidx] == lidx</code></li></ul></li><li><code>ridx</code>: &quot;receive index&quot;: an index into the receive buffer of a ghost element.<ul><li><code>recv_elem_gidx[ridx] == gidx</code></li></ul></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/CliMA/ClimaCore.jl/blob/8819db3f9615df160b53a0d72c6dc80e3eb305f5/src/Topologies/topology2d.jl#L4-L25">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="ClimaCore.Topologies.spacefillingcurve" href="#ClimaCore.Topologies.spacefillingcurve"><code>ClimaCore.Topologies.spacefillingcurve</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">spacefillingcurve(mesh::Meshes.AbstractCubedSphere)</code></pre><p>Generate element ordering, <code>elemorder</code>, based on a space filling curve for a <code>CubedSphere</code> mesh.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/CliMA/ClimaCore.jl/blob/8819db3f9615df160b53a0d72c6dc80e3eb305f5/src/Topologies/topology2d.jl#L185-L191">source</a></section><section><div><pre><code class="language-julia hljs">spacefillingcurve(mesh::Meshes.RectilinearMesh)</code></pre><p>Generate element ordering, <code>elemorder</code>, based on a space filling curve for a <code>Rectilinear</code> mesh.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/CliMA/ClimaCore.jl/blob/8819db3f9615df160b53a0d72c6dc80e3eb305f5/src/Topologies/topology2d.jl#L208-L214">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="ClimaCore.Topologies.nelems" href="#ClimaCore.Topologies.nelems"><code>ClimaCore.Topologies.nelems</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">nelems(topology)</code></pre><p>The total number of elements in <code>topology</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/CliMA/ClimaCore.jl/blob/8819db3f9615df160b53a0d72c6dc80e3eb305f5/src/Topologies/Topologies.jl#L93-L97">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="ClimaCore.Topologies.nneighbors" href="#ClimaCore.Topologies.nneighbors"><code>ClimaCore.Topologies.nneighbors</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">nneighbors(topology)</code></pre><p>The number of neighbors of this process in <code>topology</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/CliMA/ClimaCore.jl/blob/8819db3f9615df160b53a0d72c6dc80e3eb305f5/src/Topologies/Topologies.jl#L107-L111">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="ClimaCore.Topologies.nsendelems" href="#ClimaCore.Topologies.nsendelems"><code>ClimaCore.Topologies.nsendelems</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">nsendelems(topology)</code></pre><p>The number of elements to send to neighbors in <code>topology</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/CliMA/ClimaCore.jl/blob/8819db3f9615df160b53a0d72c6dc80e3eb305f5/src/Topologies/Topologies.jl#L115-L119">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="ClimaCore.Topologies.nghostelems" href="#ClimaCore.Topologies.nghostelems"><code>ClimaCore.Topologies.nghostelems</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">nghostelems(topology)</code></pre><p>The number of ghost elements in <code>topology</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/CliMA/ClimaCore.jl/blob/8819db3f9615df160b53a0d72c6dc80e3eb305f5/src/Topologies/Topologies.jl#L124-L128">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="ClimaCore.Topologies.localelemindex" href="#ClimaCore.Topologies.localelemindex"><code>ClimaCore.Topologies.localelemindex</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">localelemindex(topology, elem)</code></pre><p>The local index for the specified element; useful for distributed topologies.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/CliMA/ClimaCore.jl/blob/8819db3f9615df160b53a0d72c6dc80e3eb305f5/src/Topologies/Topologies.jl#L133-L137">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="ClimaCore.Topologies.face_node_index" href="#ClimaCore.Topologies.face_node_index"><code>ClimaCore.Topologies.face_node_index</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">i,j = face_node_index(face, Nq, q, reversed=false)</code></pre><p>The node indices of the <code>q</code>th node on face <code>face</code>, where <code>Nq</code> is the number of face nodes in each direction.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/CliMA/ClimaCore.jl/blob/8819db3f9615df160b53a0d72c6dc80e3eb305f5/src/Topologies/Topologies.jl#L158-L163">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="ClimaCore.Topologies.ghost_faces" href="#ClimaCore.Topologies.ghost_faces"><code>ClimaCore.Topologies.ghost_faces</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">ghost_faces(topology::AbstractTopology)</code></pre><p>An iterator over the ghost faces of <code>topology</code>. Each element of the iterator is a 5-tuple the form</p><pre><code class="nohighlight hljs">(elem1, face1, elem2, face2, reversed)</code></pre><p>where <code>elemX, faceX</code> are the element and face numbers, and <code>reversed</code> indicates whether they have opposing orientations.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/CliMA/ClimaCore.jl/blob/8819db3f9615df160b53a0d72c6dc80e3eb305f5/src/Topologies/Topologies.jl#L197-L207">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="ClimaCore.Topologies.vertex_node_index" href="#ClimaCore.Topologies.vertex_node_index"><code>ClimaCore.Topologies.vertex_node_index</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">i,j = vertex_node_index(vertex_num, Nq)</code></pre><p>The node indices of <code>vertex_num</code>, where <code>Nq</code> is the number of face nodes in each direction.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/CliMA/ClimaCore.jl/blob/8819db3f9615df160b53a0d72c6dc80e3eb305f5/src/Topologies/Topologies.jl#L231-L236">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="ClimaCore.Topologies.local_vertices" href="#ClimaCore.Topologies.local_vertices"><code>ClimaCore.Topologies.local_vertices</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">local_vertices(topology)</code></pre><p>An iterator over the interior vertices of <code>topology</code>. Each vertex is an iterator over <code>(lidx, vert)</code> pairs.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/CliMA/ClimaCore.jl/blob/8819db3f9615df160b53a0d72c6dc80e3eb305f5/src/Topologies/Topologies.jl#L292-L297">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="ClimaCore.Topologies.ghost_vertices" href="#ClimaCore.Topologies.ghost_vertices"><code>ClimaCore.Topologies.ghost_vertices</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">ghost_vertices(topology)</code></pre><p>An iterator over the ghost vertices of <code>topology</code>. Each vertex is an iterator over <code>(isghost, lidx/ridx, vert)</code> pairs.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/CliMA/ClimaCore.jl/blob/8819db3f9615df160b53a0d72c6dc80e3eb305f5/src/Topologies/Topologies.jl#L300-L305">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="ClimaCore.Topologies.neighbors" href="#ClimaCore.Topologies.neighbors"><code>ClimaCore.Topologies.neighbors</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">neighbors(topology)</code></pre><p>Returns an array of the PIDs of the neighbors of this process.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/CliMA/ClimaCore.jl/blob/8819db3f9615df160b53a0d72c6dc80e3eb305f5/src/Topologies/Topologies.jl#L308-L312">source</a></section></article><h3 id="Interfaces-3"><a class="docs-heading-anchor" href="#Interfaces-3">Interfaces</a><a class="docs-heading-anchor-permalink" href="#Interfaces-3" title="Permalink"></a></h3><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="ClimaCore.Topologies.mesh" href="#ClimaCore.Topologies.mesh"><code>ClimaCore.Topologies.mesh</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">mesh(topology)</code></pre><p>Returns the mesh underlying the <code>topology</code></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/CliMA/ClimaCore.jl/blob/8819db3f9615df160b53a0d72c6dc80e3eb305f5/src/Topologies/Topologies.jl#L86-L90">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="ClimaCore.Topologies.nlocalelems" href="#ClimaCore.Topologies.nlocalelems"><code>ClimaCore.Topologies.nlocalelems</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">nlocalelems(topology)</code></pre><p>The number of local elements in <code>topology</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/CliMA/ClimaCore.jl/blob/8819db3f9615df160b53a0d72c6dc80e3eb305f5/src/Topologies/Topologies.jl#L100-L104">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="ClimaCore.Topologies.vertex_coordinates" href="#ClimaCore.Topologies.vertex_coordinates"><code>ClimaCore.Topologies.vertex_coordinates</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">(c1,c2,c3,c4) = vertex_coordinates(topology, elem)</code></pre><p>The coordinates of the 4 vertices of element <code>elem</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/CliMA/ClimaCore.jl/blob/8819db3f9615df160b53a0d72c6dc80e3eb305f5/src/Topologies/Topologies.jl#L140-L144">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="ClimaCore.Topologies.opposing_face" href="#ClimaCore.Topologies.opposing_face"><code>ClimaCore.Topologies.opposing_face</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">(opelem, opface, reversed) = opposing_face(topology, elem, face)</code></pre><p>The opposing face of face number <code>face</code> of element <code>elem</code> in <code>topology</code>.</p><ul><li><code>opelem</code> is the opposing element number, 0 for a boundary, negative for a ghost element</li><li><code>opface</code> is the opposite face number, or boundary face number if a boundary</li><li><code>reversed</code> indicates whether the opposing face has the opposite orientation.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/CliMA/ClimaCore.jl/blob/8819db3f9615df160b53a0d72c6dc80e3eb305f5/src/Topologies/Topologies.jl#L147-L155">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="ClimaCore.Topologies.interior_faces" href="#ClimaCore.Topologies.interior_faces"><code>ClimaCore.Topologies.interior_faces</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">interior_faces(topology::AbstractTopology)</code></pre><p>An iterator over the interior faces of <code>topology</code>. Each element of the iterator is a 5-tuple the form</p><pre><code class="nohighlight hljs">(elem1, face1, elem2, face2, reversed)</code></pre><p>where <code>elemX, faceX</code> are the element and face numbers, and <code>reversed</code> indicates whether they have opposing orientations.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/CliMA/ClimaCore.jl/blob/8819db3f9615df160b53a0d72c6dc80e3eb305f5/src/Topologies/Topologies.jl#L179-L189">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="ClimaCore.Topologies.boundary_tags" href="#ClimaCore.Topologies.boundary_tags"><code>ClimaCore.Topologies.boundary_tags</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">boundary_tags(topology)</code></pre><p>A <code>Tuple</code> or <code>NamedTuple</code> of the boundary tags of the topology. A boundary tag is an integer that uniquely identifies a boundary.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/CliMA/ClimaCore.jl/blob/8819db3f9615df160b53a0d72c6dc80e3eb305f5/src/Topologies/Topologies.jl#L316-L321">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="ClimaCore.Topologies.boundary_tag" href="#ClimaCore.Topologies.boundary_tag"><code>ClimaCore.Topologies.boundary_tag</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">boundary_tag(topology, name::Symbol)</code></pre><p>The boundary tag of the topology for boundary name <code>name</code>. A boundary tag is an integer that uniquely identifies a boundary.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/CliMA/ClimaCore.jl/blob/8819db3f9615df160b53a0d72c6dc80e3eb305f5/src/Topologies/Topologies.jl#L324-L329">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="ClimaCore.Topologies.boundary_faces" href="#ClimaCore.Topologies.boundary_faces"><code>ClimaCore.Topologies.boundary_faces</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">boundary_faces(topology, boundarytag)</code></pre><p>An iterator over the faces of <code>topology</code> which face the boundary with tag <code>boundarytag</code>. Each element of the iterator is an <code>(elem, face)</code> pair.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/CliMA/ClimaCore.jl/blob/8819db3f9615df160b53a0d72c6dc80e3eb305f5/src/Topologies/Topologies.jl#L332-L337">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="ClimaCore.Topologies.local_neighboring_elements" href="#ClimaCore.Topologies.local_neighboring_elements"><code>ClimaCore.Topologies.local_neighboring_elements</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">local_neighboring_elements(topology::AbstractTopology, lidx::Integer)</code></pre><p>An iterator of the local element indices (lidx) of the local elements which are neighbors of the local element <code>lidx</code> in <code>topology</code> (excluding <code>lidx</code> itself).</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/CliMA/ClimaCore.jl/blob/8819db3f9615df160b53a0d72c6dc80e3eb305f5/src/Topologies/Topologies.jl#L215-L220">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="ClimaCore.Topologies.ghost_neighboring_elements" href="#ClimaCore.Topologies.ghost_neighboring_elements"><code>ClimaCore.Topologies.ghost_neighboring_elements</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">ghost_neighboring_elements(topology::AbstractTopology, ridx::Integer)</code></pre><p>An iterator of the receive buffer indices (ridx) of the ghost elements which are neighbors  of the local element <code>lidx</code> in <code>topology</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/CliMA/ClimaCore.jl/blob/8819db3f9615df160b53a0d72c6dc80e3eb305f5/src/Topologies/Topologies.jl#L223-L228">source</a></section></article><h2 id="Grids"><a class="docs-heading-anchor" href="#Grids">Grids</a><a id="Grids-1"></a><a class="docs-heading-anchor-permalink" href="#Grids" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="ClimaCore.Grids.CellFace" href="#ClimaCore.Grids.CellFace"><code>ClimaCore.Grids.CellFace</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">CellFace()</code></pre><p>Cell face location</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/CliMA/ClimaCore.jl/blob/8819db3f9615df160b53a0d72c6dc80e3eb305f5/src/Grids/finitedifference.jl#L11-L15">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="ClimaCore.Grids.CellCenter" href="#ClimaCore.Grids.CellCenter"><code>ClimaCore.Grids.CellCenter</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">CellCenter()</code></pre><p>Cell center location</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/CliMA/ClimaCore.jl/blob/8819db3f9615df160b53a0d72c6dc80e3eb305f5/src/Grids/finitedifference.jl#L4-L8">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="ClimaCore.Grids.ColumnGrid" href="#ClimaCore.Grids.ColumnGrid"><code>ClimaCore.Grids.ColumnGrid</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">ColumnGrid(
    full_grid :: ExtrudedFiniteDifferenceGrid, 
    colidx    :: ColumnIndex,
)</code></pre><p>A view into a column of a <code>ExtrudedFiniteDifferenceGrid</code>. This can be used as an</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/CliMA/ClimaCore.jl/blob/8819db3f9615df160b53a0d72c6dc80e3eb305f5/src/Grids/column.jl#L23-L30">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="ClimaCore.Grids.FiniteDifferenceGrid" href="#ClimaCore.Grids.FiniteDifferenceGrid"><code>ClimaCore.Grids.FiniteDifferenceGrid</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">FiniteDifferenceGrid(topology::Topologies.IntervalTopology)
FiniteDifferenceGrid(device::ClimaComms.AbstractDevice, mesh::Meshes.IntervalMesh)</code></pre><p>Construct a <code>FiniteDifferenceGrid</code> from an <code>IntervalTopology</code> (or an <code>IntervalMesh</code>).</p><p>This is an object which contains all the necessary geometric information.</p><p>To avoid unnecessary duplication, we memoize the construction of the grid.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/CliMA/ClimaCore.jl/blob/8819db3f9615df160b53a0d72c6dc80e3eb305f5/src/Grids/finitedifference.jl#L21-L31">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="ClimaCore.Grids.ExtrudedFiniteDifferenceGrid" href="#ClimaCore.Grids.ExtrudedFiniteDifferenceGrid"><code>ClimaCore.Grids.ExtrudedFiniteDifferenceGrid</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">ExtrudedFiniteDifferenceGrid(
    horizontal_space::AbstractSpace,
    vertical_space::FiniteDifferenceSpace,
    hypsography::HypsographyAdaption = Flat(),
)</code></pre><p>Construct an <code>ExtrudedFiniteDifferenceGrid</code> from the horizontal and vertical spaces.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/CliMA/ClimaCore.jl/blob/8819db3f9615df160b53a0d72c6dc80e3eb305f5/src/Grids/extruded.jl#L16-L24">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="ClimaCore.Grids.SpectralElementGrid1D" href="#ClimaCore.Grids.SpectralElementGrid1D"><code>ClimaCore.Grids.SpectralElementGrid1D</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">SpectralElementGrid1D(mesh::Meshes.IntervalMesh, quadrature_style::Quadratures.QuadratureStyle)</code></pre><p>A one-dimensional space: within each element the space is represented as a polynomial.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/CliMA/ClimaCore.jl/blob/8819db3f9615df160b53a0d72c6dc80e3eb305f5/src/Grids/spectralelement.jl#L5-L9">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="ClimaCore.Grids.SpectralElementGrid2D" href="#ClimaCore.Grids.SpectralElementGrid2D"><code>ClimaCore.Grids.SpectralElementGrid2D</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">SpectralElementSpace2D &lt;: AbstractSpace</code></pre><p>A two-dimensional space: within each element the space is represented as a polynomial.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/CliMA/ClimaCore.jl/blob/8819db3f9615df160b53a0d72c6dc80e3eb305f5/src/Grids/spectralelement.jl#L119-L123">source</a></section></article><h2 id="Hypsography"><a class="docs-heading-anchor" href="#Hypsography">Hypsography</a><a id="Hypsography-1"></a><a class="docs-heading-anchor-permalink" href="#Hypsography" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="ClimaCore.Grids.Flat" href="#ClimaCore.Grids.Flat"><code>ClimaCore.Grids.Flat</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">Flat()</code></pre><p>No surface hypsography.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/CliMA/ClimaCore.jl/blob/8819db3f9615df160b53a0d72c6dc80e3eb305f5/src/Grids/extruded.jl#L7-L11">source</a></section></article><h2 id="CommonGrids"><a class="docs-heading-anchor" href="#CommonGrids">CommonGrids</a><a id="CommonGrids-1"></a><a class="docs-heading-anchor-permalink" href="#CommonGrids" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="ClimaCore.CommonGrids" href="#ClimaCore.CommonGrids"><code>ClimaCore.CommonGrids</code></a> — <span class="docstring-category">Module</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">CommonGrids</code></pre><p>CommonGrids contains convenience constructors for common grids. Constructors in this module are sometimes dynamically created. You may want to use a different constructor if you&#39;re making the object in a performance-critical section, and if you know the type parameters at compile time.</p><p>If no convenience constructor exists, then you may need to create a custom grid using our low-level compose-able API.</p><p><strong>Transitioning to using CommonGrids</strong></p><p>You may have constructed a grid in the following way:</p><pre><code class="language-julia hljs">using ClimaComms
using ClimaCore: DataLayouts, Geometry, Topologies, Quadratures, Domains, Meshes, Grids
FT = Float64
z_elem = 63
z_min = FT(0)
z_max = FT(1)
radius = FT(6.371229e6)
h_elem = 15
n_quad_points = 4
device = ClimaComms.device()
context = ClimaComms.context(device)
hypsography = Grids.Flat()
global_geometry = Geometry.ShallowSphericalGlobalGeometry{FT}(radius)
quad = Quadratures.GLL{n_quad_points}()
h_mesh = Meshes.EquiangularCubedSphere(Domains.SphereDomain{FT}(radius), h_elem)
h_topology = Topologies.Topology2D(context, h_mesh)
z_boundary_names = (:bottom, :top)
z_domain = Domains.IntervalDomain(
    Geometry.ZPoint{FT}(z_min),
    Geometry.ZPoint{FT}(z_max);
    boundary_names = z_boundary_names,
)
z_mesh = Meshes.IntervalMesh(z_domain; nelems = z_elem)
h_grid = Grids.SpectralElementGrid2D(h_topology, quad)
z_topology = Topologies.IntervalTopology(context, z_mesh)
z_grid = Grids.FiniteDifferenceGrid(z_topology)
grid = Grids.ExtrudedFiniteDifferenceGrid(
    h_grid,
    z_grid,
    hypsography,
    global_geometry,
)</code></pre><p>You may re-write this as:</p><pre><code class="language-julia hljs">using ClimaCore.CommonGrids: ExtrudedCubedSphereGrid
grid = ExtrudedCubedSphereGrid(;
    z_elem = 63,
    z_min = 0,
    z_max = 1,
    radius = 6.371229e6,
    h_elem = 15,
    n_quad_points = 4,
)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/CliMA/ClimaCore.jl/blob/8819db3f9615df160b53a0d72c6dc80e3eb305f5/src/CommonGrids/CommonGrids.jl#L1-L66">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="ClimaCore.CommonGrids.ExtrudedCubedSphereGrid" href="#ClimaCore.CommonGrids.ExtrudedCubedSphereGrid"><code>ClimaCore.CommonGrids.ExtrudedCubedSphereGrid</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">ExtrudedCubedSphereGrid(
    ::Type{&lt;:AbstractFloat}; # defaults to Float64
    z_elem::Integer,
    z_min::Real,
    z_max::Real,
    radius::Real,
    h_elem::Integer,
    n_quad_points::Integer,
    device::ClimaComms.AbstractDevice = ClimaComms.device(),
    context::ClimaComms.AbstractCommsContext = ClimaComms.context(device),
    stretch::Meshes.StretchingRule = Meshes.Uniform(),
    hypsography_fun = (h_grid, z_grid) -&gt; Grids.Flat(),
    global_geometry::Geometry.AbstractGlobalGeometry = Geometry.ShallowSphericalGlobalGeometry{FT}(radius),
    quad::Quadratures.QuadratureStyle = Quadratures.GLL{n_quad_points}(),
    h_mesh = Meshes.EquiangularCubedSphere(Domains.SphereDomain{FT}(radius), h_elem),
    h_topology::Topologies.AbstractDistributedTopology = Topologies.Topology2D(context, h_mesh),
    horizontal_layout_type = DataLayouts.IJFH,
    z_mesh::Meshes.IntervalMesh = DefaultZMesh(FT; z_min, z_max, z_elem, stretch),
    enable_bubble::Bool = false
    enable_mask::Bool = false
)</code></pre><p>A convenience constructor, which builds an <a href="#ClimaCore.Grids.ExtrudedFiniteDifferenceGrid"><code>Grids.ExtrudedFiniteDifferenceGrid</code></a>, given:</p><ul><li><code>FT</code> the floating-point type (defaults to <code>Float64</code>) [<code>Float32</code>, <code>Float64</code>]</li><li><code>z_elem</code> the number of z-points</li><li><code>z_min</code> the domain minimum along the z-direction.</li><li><code>z_max</code> the domain maximum along the z-direction.</li><li><code>radius</code> the radius of the cubed sphere</li><li><code>h_elem</code> the number of horizontal elements per side of every panel (6 panels in total)</li><li><code>n_quad_points</code> the number of quadrature points per horizontal element</li><li><code>device</code> the <code>ClimaComms.device</code></li><li><code>context</code> the <code>ClimaComms.context</code></li><li><code>stretch</code> the mesh <code>Meshes.StretchingRule</code> (defaults to <a href="#ClimaCore.Meshes.Uniform"><code>Meshes.Uniform</code></a>)</li><li><code>hypsography_fun</code> a function or callable object (<code>hypsography_fun(h_grid, z_grid) -&gt; hypsography</code>) for constructing the hypsography model.</li><li><code>global_geometry</code> the global geometry (defaults to <a href="#ClimaCore.Geometry.CartesianGlobalGeometry"><code>Geometry.CartesianGlobalGeometry</code></a>)</li><li><code>quad</code> the quadrature style (defaults to <code>Quadratures.GLL{n_quad_points}</code>)</li><li><code>h_mesh</code> the horizontal mesh (defaults to <code>Meshes.EquiangularCubedSphere</code>)</li><li><code>h_topology</code> the horizontal topology (defaults to <code>Topologies.Topology2D</code>)</li><li><code>horizontal_layout_type</code> the horizontal DataLayout type (defaults to <code>DataLayouts.IJFH</code>). This parameter describes how data is arranged in memory. See <a href="#ClimaCore.Grids.SpectralElementGrid2D"><code>Grids.SpectralElementGrid2D</code></a> for its use.</li><li><code>z_mesh</code> the vertical mesh, defaults to an <code>Meshes.IntervalMesh</code> along <code>z</code> with given <code>stretch</code></li><li><code>enable_bubble</code> enables the &quot;bubble correction&quot; for more accurate element areas when computing the spectral element space. See <a href="#ClimaCore.Grids.SpectralElementGrid2D"><code>Grids.SpectralElementGrid2D</code></a> for more information.</li><li><code>enable_mask</code> enables a horizontal mask, for skipping operations on specified               columns via <code>set_mask!</code>.</li></ul><p><strong>Example usage</strong></p><pre><code class="language-julia hljs">using ClimaCore.CommonGrids
grid = ExtrudedCubedSphereGrid(;
    z_elem = 10,
    z_min = 0,
    z_max = 1,
    radius = 10,
    h_elem = 10,
    n_quad_points = 4,
)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/CliMA/ClimaCore.jl/blob/8819db3f9615df160b53a0d72c6dc80e3eb305f5/src/CommonGrids/CommonGrids.jl#L85-L145">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="ClimaCore.CommonGrids.CubedSphereGrid" href="#ClimaCore.CommonGrids.CubedSphereGrid"><code>ClimaCore.CommonGrids.CubedSphereGrid</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">CubedSphereGrid(
    ::Type{&lt;:AbstractFloat}; # defaults to Float64
    radius::Real,
    h_elem::Integer,
    n_quad_points::Integer,
    device::ClimaComms.AbstractDevice = ClimaComms.device(),
    context::ClimaComms.AbstractCommsContext = ClimaComms.context(device),
    quad::Quadratures.QuadratureStyle = Quadratures.GLL{n_quad_points}(),
    h_mesh = Meshes.EquiangularCubedSphere(Domains.SphereDomain{FT}(radius), h_elem),
    h_topology::Topologies.AbstractDistributedTopology = Topologies.Topology2D(context, h_mesh),
    horizontal_layout_type = DataLayouts.IJFH,
    enable_mask = false,
)</code></pre><p>A convenience constructor, which builds a <a href="#ClimaCore.Grids.SpectralElementGrid2D"><code>Grids.SpectralElementGrid2D</code></a> given:</p><ul><li><code>FT</code> the floating-point type (defaults to <code>Float64</code>) [<code>Float32</code>, <code>Float64</code>]</li><li><code>radius</code> the radius of the cubed sphere</li><li><code>h_elem</code> the number of horizontal elements per side of every panel (6 panels in total)</li><li><code>n_quad_points</code> the number of quadrature points per horizontal element</li><li><code>device</code> the <code>ClimaComms.device</code></li><li><code>context</code> the <code>ClimaComms.context</code></li><li><code>quad</code> the quadrature style (defaults to <code>Quadratures.GLL{n_quad_points}</code>)</li><li><code>h_mesh</code> the horizontal mesh (defaults to <code>Meshes.EquiangularCubedSphere</code>)</li><li><code>h_topology</code> the horizontal topology (defaults to <code>Topologies.Topology2D</code>)</li><li><code>horizontal_layout_type</code> the horizontal DataLayout type (defaults to <code>DataLayouts.IJFH</code>). This parameter describes how data is arranged in memory. See <a href="#ClimaCore.Grids.SpectralElementGrid2D"><code>Grids.SpectralElementGrid2D</code></a> for its use.</li><li><code>enable_mask</code> enables a horizontal mask, for skipping operations on specified               columns via <code>set_mask!</code>.</li></ul><p><strong>Example usage</strong></p><pre><code class="language-julia hljs">using ClimaCore.CommonGrids
grid = CubedSphereGrid(; radius = 10, n_quad_points = 4, h_elem = 10)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/CliMA/ClimaCore.jl/blob/8819db3f9615df160b53a0d72c6dc80e3eb305f5/src/CommonGrids/CommonGrids.jl#L210-L247">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="ClimaCore.CommonGrids.ColumnGrid" href="#ClimaCore.CommonGrids.ColumnGrid"><code>ClimaCore.CommonGrids.ColumnGrid</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">ColumnGrid(
    ::Type{&lt;:AbstractFloat}; # defaults to Float64
    z_elem::Integer,
    z_min::Real,
    z_max::Real,
    device::ClimaComms.AbstractDevice = ClimaComms.device(),
    context::ClimaComms.AbstractCommsContext = ClimaComms.context(device),
    stretch::Meshes.StretchingRule = Meshes.Uniform(),
    z_mesh::Meshes.IntervalMesh = DefaultZMesh(FT; z_min, z_max, z_elem, stretch),
)</code></pre><p>A convenience constructor, which builds a <a href="#ClimaCore.Grids.FiniteDifferenceGrid"><code>Grids.FiniteDifferenceGrid</code></a> given:</p><ul><li><code>FT</code> the floating-point type (defaults to <code>Float64</code>) [<code>Float32</code>, <code>Float64</code>]</li><li><code>z_elem</code> the number of z-points</li><li><code>z_min</code> the domain minimum along the z-direction.</li><li><code>z_max</code> the domain maximum along the z-direction.</li><li><code>device</code> the <code>ClimaComms.device</code></li><li><code>context</code> the <code>ClimaComms.context</code></li><li><code>stretch</code> the mesh <code>Meshes.StretchingRule</code> (defaults to <a href="#ClimaCore.Meshes.Uniform"><code>Meshes.Uniform</code></a>)</li><li><code>z_mesh</code> the vertical mesh, defaults to an <code>Meshes.IntervalMesh</code> along <code>z</code> with given <code>stretch</code></li></ul><p><strong>Example usage</strong></p><pre><code class="language-julia hljs">using ClimaCore.CommonGrids
grid = ColumnGrid(; z_elem = 10, z_min = 0, z_max = 10)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/CliMA/ClimaCore.jl/blob/8819db3f9615df160b53a0d72c6dc80e3eb305f5/src/CommonGrids/CommonGrids.jl#L278-L308">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="ClimaCore.CommonGrids.Box3DGrid" href="#ClimaCore.CommonGrids.Box3DGrid"><code>ClimaCore.CommonGrids.Box3DGrid</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">Box3DGrid(
    ::Type{&lt;:AbstractFloat}; # defaults to Float64
    z_elem::Integer,
    x_min::Real,
    x_max::Real,
    y_min::Real,
    y_max::Real,
    z_min::Real,
    z_max::Real,
    periodic_x::Bool,
    periodic_y::Bool,
    n_quad_points::Integer,
    x_elem::Integer,
    y_elem::Integer,
    device::ClimaComms.AbstractDevice = ClimaComms.device(),
    context::ClimaComms.AbstractCommsContext = ClimaComms.context(device),
    stretch::Meshes.StretchingRule = Meshes.Uniform(),
    hypsography_fun = (h_grid, z_grid) -&gt; Grids.Flat(),
    global_geometry::Geometry.AbstractGlobalGeometry = Geometry.CartesianGlobalGeometry(),
    quad::Quadratures.QuadratureStyle = Quadratures.GLL{n_quad_points}(),
    horizontal_layout_type = DataLayouts.IJFH,
    [h_topology::Topologies.AbstractDistributedTopology], # optional
    [z_mesh::Meshes.IntervalMesh], # optional
    enable_bubble::Bool = false,
    enable_mask::Bool = false,
)</code></pre><p>A convenience constructor, which builds a <a href="#ClimaCore.Grids.ExtrudedFiniteDifferenceGrid"><code>Grids.ExtrudedFiniteDifferenceGrid</code></a> with a <a href="#ClimaCore.Grids.FiniteDifferenceGrid"><code>Grids.FiniteDifferenceGrid</code></a> vertical grid and a <a href="#ClimaCore.Grids.SpectralElementGrid2D"><code>Grids.SpectralElementGrid2D</code></a> horizontal grid, given:</p><ul><li><code>z_elem</code> the number of z-points</li><li><code>x_min</code> the domain minimum along the x-direction.</li><li><code>x_max</code> the domain maximum along the x-direction.</li><li><code>y_min</code> the domain minimum along the y-direction.</li><li><code>y_max</code> the domain maximum along the y-direction.</li><li><code>z_min</code> the domain minimum along the z-direction.</li><li><code>z_max</code> the domain maximum along the z-direction.</li><li><code>periodic_x</code> Bool indicating to use periodic domain along x-direction</li><li><code>periodic_y</code> Bool indicating to use periodic domain along y-direction</li><li><code>n_quad_points</code> the number of quadrature points per horizontal element</li><li><code>x_elem</code> the number of x-points</li><li><code>y_elem</code> the number of y-points</li><li><code>device</code> the <code>ClimaComms.device</code></li><li><code>context</code> the <code>ClimaComms.context</code></li><li><code>stretch</code> the mesh <code>Meshes.StretchingRule</code> (defaults to <a href="#ClimaCore.Meshes.Uniform"><code>Meshes.Uniform</code></a>)</li><li><code>hypsography_fun</code> a function or callable object (<code>hypsography_fun(h_grid, z_grid) -&gt; hypsography</code>) for constructing the hypsography model.</li><li><code>global_geometry</code> the global geometry (defaults to <a href="#ClimaCore.Geometry.CartesianGlobalGeometry"><code>Geometry.CartesianGlobalGeometry</code></a>)</li><li><code>quad</code> the quadrature style (defaults to <code>Quadratures.GLL{n_quad_points}</code>)</li><li><code>h_topology</code> the horizontal topology (defaults to <code>Topologies.Topology2D</code>)</li><li><code>z_mesh</code> the vertical mesh, defaults to an <code>Meshes.IntervalMesh</code> along <code>z</code> with given <code>stretch</code></li><li><code>enable_bubble</code> enables the &quot;bubble correction&quot; for more accurate element areas when computing the spectral element space. See <a href="#ClimaCore.Grids.SpectralElementGrid2D"><code>Grids.SpectralElementGrid2D</code></a> for more information.</li><li><code>horizontal_layout_type</code> the horizontal DataLayout type (defaults to <code>DataLayouts.IJFH</code>). This parameter describes how data is arranged in memory. See <a href="#ClimaCore.Grids.SpectralElementGrid2D"><code>Grids.SpectralElementGrid2D</code></a> for its use.</li><li><code>enable_mask</code> enables a horizontal mask, for skipping operations on specified               columns via <code>set_mask!</code>.</li></ul><p><strong>Example usage</strong></p><pre><code class="language-julia hljs">using ClimaCore.CommonGrids
grid = Box3DGrid(;
    z_elem = 10,
    x_min = 0,
    x_max = 1,
    y_min = 0,
    y_max = 1,
    z_min = 0,
    z_max = 10,
    periodic_x = false,
    periodic_y = false,
    n_quad_points = 4,
    x_elem = 3,
    y_elem = 4,
)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/CliMA/ClimaCore.jl/blob/8819db3f9615df160b53a0d72c6dc80e3eb305f5/src/CommonGrids/CommonGrids.jl#L332-L409">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="ClimaCore.CommonGrids.SliceXZGrid" href="#ClimaCore.CommonGrids.SliceXZGrid"><code>ClimaCore.CommonGrids.SliceXZGrid</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">SliceXZGrid(
    ::Type{&lt;:AbstractFloat}; # defaults to Float64
    z_elem::Integer,
    x_min::Real,
    x_max::Real,
    z_min::Real,
    z_max::Real,
    periodic_x::Bool,
    n_quad_points::Integer,
    x_elem::Integer,
    device::ClimaComms.AbstractDevice = ClimaComms.device(),
    context::ClimaComms.AbstractCommsContext = ClimaComms.context(device),
    stretch::Meshes.StretchingRule = Meshes.Uniform(),
    hypsography_fun = (h_grid, z_grid) -&gt; Grids.Flat(),
    global_geometry::Geometry.AbstractGlobalGeometry = Geometry.CartesianGlobalGeometry(),
    quad::Quadratures.QuadratureStyle = Quadratures.GLL{n_quad_points}(),
)</code></pre><p>A convenience constructor, which builds a <a href="#ClimaCore.Grids.ExtrudedFiniteDifferenceGrid"><code>Grids.ExtrudedFiniteDifferenceGrid</code></a> with a <a href="#ClimaCore.Grids.FiniteDifferenceGrid"><code>Grids.FiniteDifferenceGrid</code></a> vertical grid and a <a href="#ClimaCore.Grids.SpectralElementGrid1D"><code>Grids.SpectralElementGrid1D</code></a> horizontal grid, given:</p><ul><li><code>FT</code> the floating-point type (defaults to <code>Float64</code>) [<code>Float32</code>, <code>Float64</code>]</li><li><code>z_elem</code> the number of z-points</li><li><code>x_min</code> the domain minimum along the x-direction.</li><li><code>x_max</code> the domain maximum along the x-direction.</li><li><code>z_min</code> the domain minimum along the z-direction.</li><li><code>z_max</code> the domain maximum along the z-direction.</li><li><code>periodic_x</code> Bool indicating to use periodic domain along x-direction</li><li><code>n_quad_points</code> the number of quadrature points per horizontal element</li><li><code>x_elem</code> the number of x-points</li><li><code>device</code> the <code>ClimaComms.device</code></li><li><code>context</code> the <code>ClimaComms.context</code></li><li><code>stretch</code> the mesh <code>Meshes.StretchingRule</code> (defaults to <a href="#ClimaCore.Meshes.Uniform"><code>Meshes.Uniform</code></a>)</li><li><code>hypsography_fun</code> a function or callable object (<code>hypsography_fun(h_grid, z_grid) -&gt; hypsography</code>) for constructing the hypsography model.</li><li><code>global_geometry</code> the global geometry (defaults to <a href="#ClimaCore.Geometry.CartesianGlobalGeometry"><code>Geometry.CartesianGlobalGeometry</code></a>)</li><li><code>quad</code> the quadrature style (defaults to <code>Quadratures.GLL{n_quad_points}</code>)</li></ul><p><strong>Example usage</strong></p><pre><code class="language-julia hljs">using ClimaCore.CommonGrids
grid = SliceXZGrid(;
    z_elem = 10,
    x_min = 0,
    x_max = 1,
    z_min = 0,
    z_max = 1,
    periodic_x = false,
    n_quad_points = 4,
    x_elem = 4,
)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/CliMA/ClimaCore.jl/blob/8819db3f9615df160b53a0d72c6dc80e3eb305f5/src/CommonGrids/CommonGrids.jl#L478-L534">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="ClimaCore.CommonGrids.RectangleXYGrid" href="#ClimaCore.CommonGrids.RectangleXYGrid"><code>ClimaCore.CommonGrids.RectangleXYGrid</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">RectangleXYGrid(
    ::Type{&lt;:AbstractFloat}; # defaults to Float64
    x_min::Real,
    x_max::Real,
    y_min::Real,
    y_max::Real,
    periodic_x::Bool,
    periodic_y::Bool,
    n_quad_points::Integer,
    x_elem::Integer, # number of horizontal elements
    y_elem::Integer, # number of horizontal elements
    device::ClimaComms.AbstractDevice = ClimaComms.device(),
    context::ClimaComms.AbstractCommsContext = ClimaComms.context(device),
    hypsography::Grids.HypsographyAdaption = Grids.Flat(),
    global_geometry::Geometry.AbstractGlobalGeometry = Geometry.CartesianGlobalGeometry(),
    quad::Quadratures.QuadratureStyle = Quadratures.GLL{n_quad_points}(),
    enable_mask::Bool = false,
)</code></pre><p>A convenience constructor, which builds a <a href="#ClimaCore.Grids.SpectralElementGrid2D"><code>Grids.SpectralElementGrid2D</code></a> with a horizontal <code>RectilinearMesh</code> mesh, given:</p><ul><li><code>x_min</code> the domain minimum along the x-direction.</li><li><code>x_max</code> the domain maximum along the x-direction.</li><li><code>y_min</code> the domain minimum along the y-direction.</li><li><code>y_max</code> the domain maximum along the y-direction.</li><li><code>periodic_x</code> Bool indicating to use periodic domain along x-direction</li><li><code>periodic_y</code> Bool indicating to use periodic domain along y-direction</li><li><code>n_quad_points</code> the number of quadrature points per horizontal element</li><li><code>x_elem</code> the number of x-points</li><li><code>y_elem</code> the number of y-points</li><li><code>device</code> the <code>ClimaComms.device</code></li><li><code>context</code> the <code>ClimaComms.context</code></li><li><code>hypsography_fun</code> a function or callable object (<code>hypsography_fun(h_grid, z_grid) -&gt; hypsography</code>) for constructing the hypsography model.</li><li><code>global_geometry</code> the global geometry (defaults to <a href="#ClimaCore.Geometry.CartesianGlobalGeometry"><code>Geometry.CartesianGlobalGeometry</code></a>)</li><li><code>quad</code> the quadrature style (defaults to <code>Quadratures.GLL{n_quad_points}</code>)</li><li><code>enable_mask</code> enables a horizontal mask, for skipping operations on specified               columns via <code>set_mask!</code>.</li></ul><p><strong>Example usage</strong></p><pre><code class="language-julia hljs">using ClimaCore.CommonGrids
grid = RectangleXYGrid(;
    x_min = 0,
    x_max = 1,
    y_min = 0,
    y_max = 1,
    periodic_x = false,
    periodic_y = false,
    n_quad_points = 4,
    x_elem = 3,
    y_elem = 4,
)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/CliMA/ClimaCore.jl/blob/8819db3f9615df160b53a0d72c6dc80e3eb305f5/src/CommonGrids/CommonGrids.jl#L590-L647">source</a></section></article><h2 id="Spaces"><a class="docs-heading-anchor" href="#Spaces">Spaces</a><a id="Spaces-1"></a><a class="docs-heading-anchor-permalink" href="#Spaces" title="Permalink"></a></h2><p>A <code>Space</code> represents a discretized function space over some domain. Currently two main discretizations are supported: Spectral Element Discretization (both Continuous Galerkin and Discontinuous Galerkin types) and a staggered Finite Difference Discretization. Combination of these two in the horizontal/vertical directions, respectively, is what we call a <em>hybrid</em> space.</p><p>Sketch of a 2DX hybrid discretization:</p><p><img src="../DiscretizationSketch.png" alt="3D hybrid discretization in a Cartesian domain"/></p><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="ClimaCore.Spaces" href="#ClimaCore.Spaces"><code>ClimaCore.Spaces</code></a> — <span class="docstring-category">Module</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">Meshes</code></pre><ul><li>domain</li><li>topology</li><li>coordinates</li><li>metric terms (inverse partial derivatives)</li><li>quadrature rules and weights</li></ul><p><strong>References / notes</strong></p><ul><li><a href="https://ceed.exascaleproject.org/ceed-code/">ceed</a></li><li><a href="https://github.com/CliMA/ClimateMachine.jl/blob/ans/sphere/test/Numerics/DGMethods/compressible_navier_stokes_equations/sphere/sphere_helper_functions.jl">QA</a></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/CliMA/ClimaCore.jl/blob/8819db3f9615df160b53a0d72c6dc80e3eb305f5/src/Spaces/Spaces.jl#L1-L14">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="ClimaCore.Spaces.Δz_data" href="#ClimaCore.Spaces.Δz_data"><code>ClimaCore.Spaces.Δz_data</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">Δz_data(space::AbstractSpace)</code></pre><p>A DataLayout containing the <code>Δz</code> on a given space <code>space</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/CliMA/ClimaCore.jl/blob/8819db3f9615df160b53a0d72c6dc80e3eb305f5/src/Spaces/finitedifference.jl#L124-L128">source</a></section></article><h3 id="Finite-Difference-Spaces"><a class="docs-heading-anchor" href="#Finite-Difference-Spaces">Finite Difference Spaces</a><a id="Finite-Difference-Spaces-1"></a><a class="docs-heading-anchor-permalink" href="#Finite-Difference-Spaces" title="Permalink"></a></h3><p>ClimaCore.jl supports staggered Finite Difference discretizations. Finite Differences discretize an interval domain by approximating the function by a value at either the center of each element (also referred to as <em>cell</em>) (<code>CenterFiniteDifferenceSpace</code>), or the interfaces (faces in 3D, edges in 2D or points in 1D) between elements (<code>FaceFiniteDifferenceSpace</code>).</p><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="ClimaCore.Spaces.FiniteDifferenceSpace" href="#ClimaCore.Spaces.FiniteDifferenceSpace"><code>ClimaCore.Spaces.FiniteDifferenceSpace</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">FiniteDifferenceSpace(
    grid::Grids.FiniteDifferenceGrid,
    staggering::Staggering
)</code></pre><p>A 1D finite-difference space, that lives on either:</p><ul><li>cell centers (where <code>staggering</code> is <a href="#ClimaCore.Grids.CellCenter"><code>Grids.CellCenter</code></a>) or</li><li>cell faces (where <code>staggering</code> is <a href="#ClimaCore.Grids.CellFace"><code>Grids.CellFace</code></a>)</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/CliMA/ClimaCore.jl/blob/8819db3f9615df160b53a0d72c6dc80e3eb305f5/src/Spaces/finitedifference.jl#L3-L14">source</a></section></article><p>Users should construct either the center or face space from the mesh, then construct the other space from the original one: this internally reuses the same data structures, and avoids allocating additional memory.</p><h4 id="Internals"><a class="docs-heading-anchor" href="#Internals">Internals</a><a id="Internals-1"></a><a class="docs-heading-anchor-permalink" href="#Internals" title="Permalink"></a></h4><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="ClimaCore.Spaces.Δz_metric_component" href="#ClimaCore.Spaces.Δz_metric_component"><code>ClimaCore.Spaces.Δz_metric_component</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">Δz_metric_component(::Type{&lt;:Goemetry.AbstractPoint})</code></pre><p>The index of the z-component of an abstract point in an <code>AxisTensor</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/CliMA/ClimaCore.jl/blob/8819db3f9615df160b53a0d72c6dc80e3eb305f5/src/Spaces/finitedifference.jl#L110-L115">source</a></section></article><h3 id="Spectral-Element-Spaces"><a class="docs-heading-anchor" href="#Spectral-Element-Spaces">Spectral Element Spaces</a><a id="Spectral-Element-Spaces-1"></a><a class="docs-heading-anchor-permalink" href="#Spectral-Element-Spaces" title="Permalink"></a></h3><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="ClimaCore.Spaces.SpectralElementSpace1D" href="#ClimaCore.Spaces.SpectralElementSpace1D"><code>ClimaCore.Spaces.SpectralElementSpace1D</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">SpectralElementSpace1D(grid::SpectralElementGrid1D)
SpectralElementSpace1D(
    topology::Topologies.IntervalTopology,
    quadrature_style::Quadratures.QuadratureStyle;
    kwargs...
)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/CliMA/ClimaCore.jl/blob/8819db3f9615df160b53a0d72c6dc80e3eb305f5/src/Spaces/spectralelement.jl#L51-L59">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="ClimaCore.Spaces.SpectralElementSpace2D" href="#ClimaCore.Spaces.SpectralElementSpace2D"><code>ClimaCore.Spaces.SpectralElementSpace2D</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">SpectralElementSpace2D(grid::SpectralElementGrid1D)
SpectralElementSpace2D(
    topology::Topologies.Topology2D,
    quadrature_style::Quadratures.QuadratureStyle;
    kwargs...,
)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/CliMA/ClimaCore.jl/blob/8819db3f9615df160b53a0d72c6dc80e3eb305f5/src/Spaces/spectralelement.jl#L83-L90">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="ClimaCore.Spaces.SpectralElementSpaceSlab" href="#ClimaCore.Spaces.SpectralElementSpaceSlab"><code>ClimaCore.Spaces.SpectralElementSpaceSlab</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">SpectralElementSpaceSlab &lt;: AbstractSpace</code></pre><p>A view into a <code>SpectralElementSpace2D</code> for a single slab.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/CliMA/ClimaCore.jl/blob/8819db3f9615df160b53a0d72c6dc80e3eb305f5/src/Spaces/spectralelement.jl#L124-L128">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="ClimaCore.Spaces.node_horizontal_length_scale" href="#ClimaCore.Spaces.node_horizontal_length_scale"><code>ClimaCore.Spaces.node_horizontal_length_scale</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">Spaces.node_horizontal_length_scale(space::AbstractSpectralElementSpace)</code></pre><p>The approximate length scale of the distance between nodes. This is defined as the length scale of the mesh (see <a href="#ClimaCore.Meshes.element_horizontal_length_scale"><code>Meshes.element_horizontal_length_scale</code></a>), divided by the number of unique quadrature points along each dimension.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/CliMA/ClimaCore.jl/blob/8819db3f9615df160b53a0d72c6dc80e3eb305f5/src/Spaces/spectralelement.jl#L146-L152">source</a></section></article><h3 id="Extruded-Finite-Difference-Spaces"><a class="docs-heading-anchor" href="#Extruded-Finite-Difference-Spaces">Extruded Finite Difference Spaces</a><a id="Extruded-Finite-Difference-Spaces-1"></a><a class="docs-heading-anchor-permalink" href="#Extruded-Finite-Difference-Spaces" title="Permalink"></a></h3><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="ClimaCore.Spaces.ExtrudedFiniteDifferenceSpace" href="#ClimaCore.Spaces.ExtrudedFiniteDifferenceSpace"><code>ClimaCore.Spaces.ExtrudedFiniteDifferenceSpace</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">ExtrudedFiniteDifferenceSpace(grid, staggering)

ExtrudedFiniteDifferenceSpace(
    horizontal_space::AbstractSpace,
    vertical_space::FiniteDifferenceSpace,
    hypsography::Grids.HypsographyAdaption = Grids.Flat();
    deep::Bool = false,
)</code></pre><p>An extruded finite-difference space, where the extruded direction is <em>staggered</em>, containing grid information at either</p><ul><li>cell centers (where <code>staggering</code> is <a href="#ClimaCore.Grids.CellCenter"><code>Grids.CellCenter</code></a>) or</li><li>cell faces (where <code>staggering</code> is <a href="#ClimaCore.Grids.CellFace"><code>Grids.CellFace</code></a>)</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/CliMA/ClimaCore.jl/blob/8819db3f9615df160b53a0d72c6dc80e3eb305f5/src/Spaces/extruded.jl#L2-L17">source</a></section></article><h2 id="CommonSpaces"><a class="docs-heading-anchor" href="#CommonSpaces">CommonSpaces</a><a id="CommonSpaces-1"></a><a class="docs-heading-anchor-permalink" href="#CommonSpaces" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="ClimaCore.CommonSpaces" href="#ClimaCore.CommonSpaces"><code>ClimaCore.CommonSpaces</code></a> — <span class="docstring-category">Module</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">CommonSpaces</code></pre><p>CommonSpaces contains convenience constructors for common spaces, which builds off of <a href="#CommonGrids"><code>CommonGrids</code></a> and(when appropriate) requires an additional argument, <code>staggering::Staggering</code> to construct the desired space.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/CliMA/ClimaCore.jl/blob/8819db3f9615df160b53a0d72c6dc80e3eb305f5/src/CommonSpaces/CommonSpaces.jl#L1-L7">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="ClimaCore.CommonSpaces.ExtrudedCubedSphereSpace" href="#ClimaCore.CommonSpaces.ExtrudedCubedSphereSpace"><code>ClimaCore.CommonSpaces.ExtrudedCubedSphereSpace</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">ExtrudedCubedSphereSpace(
    ::Type{&lt;:AbstractFloat}; # defaults to Float64
    z_elem::Integer,
    z_min::Real,
    z_max::Real,
    radius::Real,
    h_elem::Integer,
    n_quad_points::Integer,
    device::ClimaComms.AbstractDevice = ClimaComms.device(),
    context::ClimaComms.AbstractCommsContext = ClimaComms.context(device),
    stretch::Meshes.StretchingRule = Meshes.Uniform(),
    hypsography_fun = (h_grid, z_grid) -&gt; Grids.Flat(),
    global_geometry::Geometry.AbstractGlobalGeometry = Geometry.ShallowSphericalGlobalGeometry{FT}(radius),
    quad::Quadratures.QuadratureStyle = Quadratures.GLL{n_quad_points}(),
    h_mesh = Meshes.EquiangularCubedSphere(Domains.SphereDomain{FT}(radius), h_elem),
    h_topology::Topologies.AbstractDistributedTopology = Topologies.Topology2D(context, h_mesh),
    horizontal_layout_type = DataLayouts.IJFH,
    z_mesh::Meshes.IntervalMesh = DefaultZMesh(FT; z_min, z_max, z_elem, stretch),
    enable_bubble::Bool = false
    staggering::Staggering,
)</code></pre><p>Construct an <a href="#ClimaCore.Spaces.ExtrudedFiniteDifferenceSpace"><code>Spaces.ExtrudedFiniteDifferenceSpace</code></a> for a cubed sphere configuration, given:</p><ul><li><code>FT</code> the floating-point type (defaults to <code>Float64</code>) [<code>Float32</code>, <code>Float64</code>]</li><li><code>z_elem</code> the number of z-points</li><li><code>z_min</code> the domain minimum along the z-direction.</li><li><code>z_max</code> the domain maximum along the z-direction.</li><li><code>radius</code> the radius of the cubed sphere</li><li><code>h_elem</code> the number of horizontal elements per side of every panel (6 panels in total)</li><li><code>n_quad_points</code> the number of quadrature points per horizontal element</li><li><code>device</code> the <code>ClimaComms.device</code></li><li><code>context</code> the <code>ClimaComms.context</code></li><li><code>stretch</code> the mesh <code>Meshes.StretchingRule</code> (defaults to <a href="#ClimaCore.Meshes.Uniform"><code>Meshes.Uniform</code></a>)</li><li><code>hypsography_fun</code> a function or callable object (<code>hypsography_fun(h_grid, z_grid) -&gt; hypsography</code>) for constructing the hypsography model.</li><li><code>global_geometry</code> the global geometry (defaults to <a href="#ClimaCore.Geometry.CartesianGlobalGeometry"><code>Geometry.CartesianGlobalGeometry</code></a>)</li><li><code>quad</code> the quadrature style (defaults to <code>Quadratures.GLL{n_quad_points}</code>)</li><li><code>h_mesh</code> the horizontal mesh (defaults to <code>Meshes.EquiangularCubedSphere</code>)</li><li><code>h_topology</code> the horizontal topology (defaults to <code>Topologies.Topology2D</code>)</li><li><code>horizontal_layout_type</code> the horizontal DataLayout type (defaults to <code>DataLayouts.IJFH</code>). This parameter describes how data is arranged in memory. See <a href="#ClimaCore.Grids.SpectralElementGrid2D"><code>Grids.SpectralElementGrid2D</code></a> for its use.</li><li><code>z_mesh</code> the vertical mesh, defaults to an <code>Meshes.IntervalMesh</code> along <code>z</code> with given <code>stretch</code></li><li><code>enable_bubble</code> enables the &quot;bubble correction&quot; for more accurate element areas when computing the spectral element space. See <a href="#ClimaCore.Grids.SpectralElementGrid2D"><code>Grids.SpectralElementGrid2D</code></a> for more information.</li><li><code>staggering</code> vertical staggering, can be one of [<a href="#ClimaCore.Grids.CellFace"><code>Grids.CellFace</code></a>, <a href="#ClimaCore.Grids.CellCenter"><code>Grids.CellCenter</code></a>]</li></ul><p>Note that these arguments are all the same as <a href="#ClimaCore.CommonGrids.ExtrudedCubedSphereGrid"><code>CommonGrids.ExtrudedCubedSphereGrid</code></a>, except for <code>staggering</code>.</p><p><strong>Example usage</strong></p><pre><code class="language-julia hljs">using ClimaCore.CommonSpaces
space = ExtrudedCubedSphereSpace(;
    z_elem = 10,
    z_min = 0,
    z_max = 1,
    radius = 10,
    h_elem = 10,
    n_quad_points = 4,
    staggering = CellCenter()
)</code></pre><p>This will construct a cell-center space. If you wish to create a face centered space:</p><pre><code class="language-julia hljs">using ClimaCore.CommonSpaces
space = ExtrudedCubedSphereSpace(;
    z_elem = 10,
    z_min = 0,
    z_max = 1,
    radius = 10,
    h_elem = 10,
    n_quad_points = 4,
    staggering = CellFace()
)</code></pre><p>alternatively, you can use the <code>Spaces.face_space</code> function.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/CliMA/ClimaCore.jl/blob/8819db3f9615df160b53a0d72c6dc80e3eb305f5/src/CommonSpaces/CommonSpaces.jl#L39-L116">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="ClimaCore.CommonSpaces.CubedSphereSpace" href="#ClimaCore.CommonSpaces.CubedSphereSpace"><code>ClimaCore.CommonSpaces.CubedSphereSpace</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">CubedSphereSpace(
    ::Type{&lt;:AbstractFloat}; # defaults to Float64
    radius::Real,
    h_elem::Integer,
    n_quad_points::Integer,
    device::ClimaComms.AbstractDevice = ClimaComms.device(),
    context::ClimaComms.AbstractCommsContext = ClimaComms.context(device),
    quad::Quadratures.QuadratureStyle = Quadratures.GLL{n_quad_points}(),
    h_mesh = Meshes.EquiangularCubedSphere(Domains.SphereDomain{FT}(radius), h_elem),
    h_topology::Topologies.AbstractDistributedTopology = Topologies.Topology2D(context, h_mesh),
    horizontal_layout_type = DataLayouts.IJFH,
)</code></pre><p>Construct a <a href="#ClimaCore.Spaces.SpectralElementSpace2D"><code>Spaces.SpectralElementSpace2D</code></a> for a cubed sphere configuration, given:</p><ul><li><code>FT</code> the floating-point type (defaults to <code>Float64</code>) [<code>Float32</code>, <code>Float64</code>]</li><li><code>radius</code> the radius of the cubed sphere</li><li><code>h_elem</code> the number of horizontal elements per side of every panel (6 panels in total)</li><li><code>n_quad_points</code> the number of quadrature points per horizontal element</li><li><code>device</code> the <code>ClimaComms.device</code></li><li><code>context</code> the <code>ClimaComms.context</code></li><li><code>quad</code> the quadrature style (defaults to <code>Quadratures.GLL{n_quad_points}</code>)</li><li><code>h_mesh</code> the horizontal mesh (defaults to <code>Meshes.EquiangularCubedSphere</code>)</li><li><code>h_topology</code> the horizontal topology (defaults to <code>Topologies.Topology2D</code>)</li><li><code>horizontal_layout_type</code> the horizontal DataLayout type (defaults to <code>DataLayouts.IJFH</code>). This parameter describes how data is arranged in memory. See <a href="#ClimaCore.Grids.SpectralElementGrid2D"><code>Grids.SpectralElementGrid2D</code></a> for its use.</li></ul><p>Note that these arguments are all the same as <a href="#ClimaCore.CommonGrids.CubedSphereGrid"><code>CommonGrids.CubedSphereGrid</code></a>.</p><p><strong>Example usage</strong></p><pre><code class="language-julia hljs">using ClimaCore.CommonSpaces
space = CubedSphereSpace(;
    radius = 10,
    n_quad_points = 4,
    h_elem = 10,
)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/CliMA/ClimaCore.jl/blob/8819db3f9615df160b53a0d72c6dc80e3eb305f5/src/CommonSpaces/CommonSpaces.jl#L130-L170">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="ClimaCore.CommonSpaces.ColumnSpace" href="#ClimaCore.CommonSpaces.ColumnSpace"><code>ClimaCore.CommonSpaces.ColumnSpace</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">ColumnSpace(
    ::Type{&lt;:AbstractFloat}; # defaults to Float64
    z_elem::Integer,
    z_min::Real,
    z_max::Real,
    device::ClimaComms.AbstractDevice = ClimaComms.device(),
    context::ClimaComms.AbstractCommsContext = ClimaComms.context(device),
    stretch::Meshes.StretchingRule = Meshes.Uniform(),
    z_mesh::Meshes.IntervalMesh = DefaultZMesh(FT; z_min, z_max, z_elem, stretch),
)</code></pre><p>Construct a 1D <a href="#ClimaCore.Spaces.FiniteDifferenceSpace"><code>Spaces.FiniteDifferenceSpace</code></a> for a column configuration, given:</p><ul><li><code>FT</code> the floating-point type (defaults to <code>Float64</code>) [<code>Float32</code>, <code>Float64</code>]</li><li><code>z_elem</code> the number of z-points</li><li><code>z_min</code> the domain minimum along the z-direction.</li><li><code>z_max</code> the domain maximum along the z-direction.</li><li><code>device</code> the <code>ClimaComms.device</code></li><li><code>context</code> the <code>ClimaComms.context</code></li><li><code>stretch</code> the mesh <code>Meshes.StretchingRule</code> (defaults to <a href="#ClimaCore.Meshes.Uniform"><code>Meshes.Uniform</code></a>)</li><li><code>z_mesh</code> the vertical mesh, defaults to an <code>Meshes.IntervalMesh</code> along <code>z</code> with given <code>stretch</code></li><li><code>staggering</code> vertical staggering, can be one of [<a href="#ClimaCore.Grids.CellFace"><code>Grids.CellFace</code></a>, <a href="#ClimaCore.Grids.CellCenter"><code>Grids.CellCenter</code></a>]</li></ul><p>Note that these arguments are all the  same as <a href="#ClimaCore.CommonGrids.ColumnGrid"><code>CommonGrids.ColumnGrid</code></a>, except for <code>staggering</code>.</p><p><strong>Example usage</strong></p><pre><code class="language-julia hljs">using ClimaCore.CommonSpaces
space = ColumnSpace(;
    z_elem = 10,
    z_min = 0,
    z_max = 10,
    staggering = CellCenter()
)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/CliMA/ClimaCore.jl/blob/8819db3f9615df160b53a0d72c6dc80e3eb305f5/src/CommonSpaces/CommonSpaces.jl#L176-L215">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="ClimaCore.CommonSpaces.Box3DSpace" href="#ClimaCore.CommonSpaces.Box3DSpace"><code>ClimaCore.CommonSpaces.Box3DSpace</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">Box3DSpace(
    ::Type{&lt;:AbstractFloat}; # defaults to Float64
    z_elem::Integer,
    x_min::Real,
    x_max::Real,
    y_min::Real,
    y_max::Real,
    z_min::Real,
    z_max::Real,
    periodic_x::Bool,
    periodic_y::Bool,
    n_quad_points::Integer,
    x_elem::Integer,
    y_elem::Integer,
    device::ClimaComms.AbstractDevice = ClimaComms.device(),
    context::ClimaComms.AbstractCommsContext = ClimaComms.context(device),
    stretch::Meshes.StretchingRule = Meshes.Uniform(),
    hypsography_fun = (h_grid, z_grid) -&gt; Grids.Flat(),
    global_geometry::Geometry.AbstractGlobalGeometry = Geometry.CartesianGlobalGeometry(),
    quad::Quadratures.QuadratureStyle = Quadratures.GLL{n_quad_points}(),
    horizontal_layout_type = DataLayouts.IJFH,
    [h_topology::Topologies.AbstractDistributedTopology], # optional
    [z_mesh::Meshes.IntervalMesh], # optional
    enable_bubble::Bool = false,
    staggering::Staggering
)</code></pre><p>Construct a <a href="#ClimaCore.Spaces.ExtrudedFiniteDifferenceSpace"><code>Spaces.ExtrudedFiniteDifferenceSpace</code></a> for a 3D box configuration, given:</p><ul><li><code>z_elem</code> the number of z-points</li><li><code>x_min</code> the domain minimum along the x-direction.</li><li><code>x_max</code> the domain maximum along the x-direction.</li><li><code>y_min</code> the domain minimum along the y-direction.</li><li><code>y_max</code> the domain maximum along the y-direction.</li><li><code>z_min</code> the domain minimum along the z-direction.</li><li><code>z_max</code> the domain maximum along the z-direction.</li><li><code>periodic_x</code> Bool indicating to use periodic domain along x-direction</li><li><code>periodic_y</code> Bool indicating to use periodic domain along y-direction</li><li><code>n_quad_points</code> the number of quadrature points per horizontal element</li><li><code>x_elem</code> the number of x-points</li><li><code>y_elem</code> the number of y-points</li><li><code>device</code> the <code>ClimaComms.device</code></li><li><code>context</code> the <code>ClimaComms.context</code></li><li><code>stretch</code> the mesh <code>Meshes.StretchingRule</code> (defaults to <a href="#ClimaCore.Meshes.Uniform"><code>Meshes.Uniform</code></a>)</li><li><code>hypsography_fun</code> a function or callable object (<code>hypsography_fun(h_grid, z_grid) -&gt; hypsography</code>) for constructing the hypsography model.</li><li><code>global_geometry</code> the global geometry (defaults to <a href="#ClimaCore.Geometry.CartesianGlobalGeometry"><code>Geometry.CartesianGlobalGeometry</code></a>)</li><li><code>quad</code> the quadrature style (defaults to <code>Quadratures.GLL{n_quad_points}</code>)</li><li><code>h_topology</code> the horizontal topology (defaults to <code>Topologies.Topology2D</code>)</li><li><code>z_mesh</code> the vertical mesh, defaults to an <code>Meshes.IntervalMesh</code> along <code>z</code> with given <code>stretch</code></li><li><code>enable_bubble</code> enables the &quot;bubble correction&quot; for more accurate element areas when computing the spectral element space. See <a href="#ClimaCore.Grids.SpectralElementGrid2D"><code>Grids.SpectralElementGrid2D</code></a> for more information.</li><li><code>horizontal_layout_type</code> the horizontal DataLayout type (defaults to <code>DataLayouts.IJFH</code>). This parameter describes how data is arranged in memory. See <a href="#ClimaCore.Grids.SpectralElementGrid2D"><code>Grids.SpectralElementGrid2D</code></a> for its use.</li><li><code>staggering</code> vertical staggering, can be one of [<a href="#ClimaCore.Grids.CellFace"><code>Grids.CellFace</code></a>, <a href="#ClimaCore.Grids.CellCenter"><code>Grids.CellCenter</code></a>]</li></ul><p>Note that these arguments are all  the same as <a href="#ClimaCore.CommonGrids.Box3DGrid"><code>CommonGrids.Box3DGrid</code></a>, except for <code>staggering</code>.</p><p><strong>Example usage</strong></p><pre><code class="language-julia hljs">using ClimaCore.CommonSpaces
space = Box3DSpace(;
    z_elem = 10,
    x_min = 0,
    x_max = 1,
    y_min = 0,
    y_max = 1,
    z_min = 0,
    z_max = 10,
    periodic_x = false,
    periodic_y = false,
    n_quad_points = 4,
    x_elem = 3,
    y_elem = 4,
    staggering = CellCenter()
)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/CliMA/ClimaCore.jl/blob/8819db3f9615df160b53a0d72c6dc80e3eb305f5/src/CommonSpaces/CommonSpaces.jl#L221-L299">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="ClimaCore.CommonSpaces.SliceXZSpace" href="#ClimaCore.CommonSpaces.SliceXZSpace"><code>ClimaCore.CommonSpaces.SliceXZSpace</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">SliceXZSpace(
    ::Type{&lt;:AbstractFloat}; # defaults to Float64
    z_elem::Integer,
    x_min::Real,
    x_max::Real,
    z_min::Real,
    z_max::Real,
    periodic_x::Bool,
    n_quad_points::Integer,
    x_elem::Integer,
    device::ClimaComms.AbstractDevice = ClimaComms.device(),
    context::ClimaComms.AbstractCommsContext = ClimaComms.context(device),
    stretch::Meshes.StretchingRule = Meshes.Uniform(),
    hypsography_fun = (h_grid, z_grid) -&gt; Grids.Flat(),
    global_geometry::Geometry.AbstractGlobalGeometry = Geometry.CartesianGlobalGeometry(),
    quad::Quadratures.QuadratureStyle = Quadratures.GLL{n_quad_points}(),
    staggering::Staggering
)</code></pre><p>Construct a <a href="#ClimaCore.Spaces.ExtrudedFiniteDifferenceSpace"><code>Spaces.ExtrudedFiniteDifferenceSpace</code></a> for a 2D slice configuration, given:</p><ul><li><code>FT</code> the floating-point type (defaults to <code>Float64</code>) [<code>Float32</code>, <code>Float64</code>]</li><li><code>z_elem</code> the number of z-points</li><li><code>x_min</code> the domain minimum along the x-direction.</li><li><code>x_max</code> the domain maximum along the x-direction.</li><li><code>z_min</code> the domain minimum along the z-direction.</li><li><code>z_max</code> the domain maximum along the z-direction.</li><li><code>periodic_x</code> Bool indicating to use periodic domain along x-direction</li><li><code>n_quad_points</code> the number of quadrature points per horizontal element</li><li><code>x_elem</code> the number of x-points</li><li><code>device</code> the <code>ClimaComms.device</code></li><li><code>context</code> the <code>ClimaComms.context</code></li><li><code>stretch</code> the mesh <code>Meshes.StretchingRule</code> (defaults to <a href="#ClimaCore.Meshes.Uniform"><code>Meshes.Uniform</code></a>)</li><li><code>hypsography_fun</code> a function or callable object (<code>hypsography_fun(h_grid, z_grid) -&gt; hypsography</code>) for constructing the hypsography model.</li><li><code>global_geometry</code> the global geometry (defaults to <a href="#ClimaCore.Geometry.CartesianGlobalGeometry"><code>Geometry.CartesianGlobalGeometry</code></a>)</li><li><code>quad</code> the quadrature style (defaults to <code>Quadratures.GLL{n_quad_points}</code>)</li><li><code>staggering</code> vertical staggering, can be one of [<a href="#ClimaCore.Grids.CellFace"><code>Grids.CellFace</code></a>, <a href="#ClimaCore.Grids.CellCenter"><code>Grids.CellCenter</code></a>]</li></ul><p>Note that these arguments are all the same as <a href="#ClimaCore.CommonGrids.SliceXZGrid"><code>CommonGrids.SliceXZGrid</code></a>, except for <code>staggering</code>.</p><p><strong>Example usage</strong></p><pre><code class="language-julia hljs">using ClimaCore.CommonSpaces
space = SliceXZSpace(;
    z_elem = 10,
    x_min = 0,
    x_max = 1,
    z_min = 0,
    z_max = 1,
    periodic_x = false,
    n_quad_points = 4,
    x_elem = 4,
    staggering = CellCenter()
)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/CliMA/ClimaCore.jl/blob/8819db3f9615df160b53a0d72c6dc80e3eb305f5/src/CommonSpaces/CommonSpaces.jl#L305-L364">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="ClimaCore.CommonSpaces.RectangleXYSpace" href="#ClimaCore.CommonSpaces.RectangleXYSpace"><code>ClimaCore.CommonSpaces.RectangleXYSpace</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">RectangleXYSpace(
    ::Type{&lt;:AbstractFloat}; # defaults to Float64
    x_min::Real,
    x_max::Real,
    y_min::Real,
    y_max::Real,
    periodic_x::Bool,
    periodic_y::Bool,
    n_quad_points::Integer,
    x_elem::Integer, # number of horizontal elements
    y_elem::Integer, # number of horizontal elements
    device::ClimaComms.AbstractDevice = ClimaComms.device(),
    context::ClimaComms.AbstractCommsContext = ClimaComms.context(device),
    hypsography::Grids.HypsographyAdaption = Grids.Flat(),
    global_geometry::Geometry.AbstractGlobalGeometry = Geometry.CartesianGlobalGeometry(),
    quad::Quadratures.QuadratureStyle = Quadratures.GLL{n_quad_points}(),
)</code></pre><p>Construct a <a href="#ClimaCore.Spaces.SpectralElementSpace2D"><code>Spaces.SpectralElementSpace2D</code></a> space for a 2D rectangular configuration, given:</p><ul><li><code>x_min</code> the domain minimum along the x-direction.</li><li><code>x_max</code> the domain maximum along the x-direction.</li><li><code>y_min</code> the domain minimum along the y-direction.</li><li><code>y_max</code> the domain maximum along the y-direction.</li><li><code>periodic_x</code> Bool indicating to use periodic domain along x-direction</li><li><code>periodic_y</code> Bool indicating to use periodic domain along y-direction</li><li><code>n_quad_points</code> the number of quadrature points per horizontal element</li><li><code>x_elem</code> the number of x-points</li><li><code>y_elem</code> the number of y-points</li><li><code>device</code> the <code>ClimaComms.device</code></li><li><code>context</code> the <code>ClimaComms.context</code></li><li><code>hypsography_fun</code> a function or callable object (<code>hypsography_fun(h_grid, z_grid) -&gt; hypsography</code>) for constructing the hypsography model.</li><li><code>global_geometry</code> the global geometry (defaults to <a href="#ClimaCore.Geometry.CartesianGlobalGeometry"><code>Geometry.CartesianGlobalGeometry</code></a>)</li><li><code>quad</code> the quadrature style (defaults to <code>Quadratures.GLL{n_quad_points}</code>)</li></ul><p><strong>Example usage</strong></p><pre><code class="language-julia hljs">using ClimaCore.CommonSpaces
space = RectangleXYSpace(;
    x_min = 0,
    x_max = 1,
    y_min = 0,
    y_max = 1,
    periodic_x = false,
    periodic_y = false,
    n_quad_points = 4,
    x_elem = 3,
    y_elem = 4,
)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/CliMA/ClimaCore.jl/blob/8819db3f9615df160b53a0d72c6dc80e3eb305f5/src/CommonSpaces/CommonSpaces.jl#L370-L423">source</a></section></article><h3 id="Quadratures"><a class="docs-heading-anchor" href="#Quadratures">Quadratures</a><a id="Quadratures-1"></a><a class="docs-heading-anchor-permalink" href="#Quadratures" title="Permalink"></a></h3><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="ClimaCore.Quadratures.QuadratureStyle" href="#ClimaCore.Quadratures.QuadratureStyle"><code>ClimaCore.Quadratures.QuadratureStyle</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><p>QuadratureStyle{Nq}</p><p>Quadrature style supertype. See sub-types:</p><ul><li><a href="#ClimaCore.Quadratures.GLL"><code>GLL</code></a></li><li><a href="#ClimaCore.Quadratures.GL"><code>GL</code></a></li><li><a href="#ClimaCore.Quadratures.Uniform"><code>Uniform</code></a></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/CliMA/ClimaCore.jl/blob/8819db3f9615df160b53a0d72c6dc80e3eb305f5/src/Quadratures/Quadratures.jl#L11-L18">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="ClimaCore.Quadratures.GLL" href="#ClimaCore.Quadratures.GLL"><code>ClimaCore.Quadratures.GLL</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">GLL{Nq}()</code></pre><p>Gauss-Legendre-Lobatto quadrature using <code>Nq</code> quadrature points.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/CliMA/ClimaCore.jl/blob/8819db3f9615df160b53a0d72c6dc80e3eb305f5/src/Quadratures/Quadratures.jl#L52-L56">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="ClimaCore.Quadratures.GL" href="#ClimaCore.Quadratures.GL"><code>ClimaCore.Quadratures.GL</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">GL{Nq}()</code></pre><p>Gauss-Legendre quadrature using <code>Nq</code> quadrature points.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/CliMA/ClimaCore.jl/blob/8819db3f9615df160b53a0d72c6dc80e3eb305f5/src/Quadratures/Quadratures.jl#L68-L72">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="ClimaCore.Quadratures.Uniform" href="#ClimaCore.Quadratures.Uniform"><code>ClimaCore.Quadratures.Uniform</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">Uniform{Nq}()</code></pre><p>Uniformly-spaced quadrature.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/CliMA/ClimaCore.jl/blob/8819db3f9615df160b53a0d72c6dc80e3eb305f5/src/Quadratures/Quadratures.jl#L84-L88">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="ClimaCore.Quadratures.degrees_of_freedom" href="#ClimaCore.Quadratures.degrees_of_freedom"><code>ClimaCore.Quadratures.degrees_of_freedom</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">degrees_of_freedom(QuadratureStyle) -&gt; Int</code></pre><p>Returns the degrees<em>of</em>freedom of the <code>QuadratureStyle</code> concrete type</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/CliMA/ClimaCore.jl/blob/8819db3f9615df160b53a0d72c6dc80e3eb305f5/src/Quadratures/Quadratures.jl#L29-L33">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="ClimaCore.Quadratures.polynomial_degree" href="#ClimaCore.Quadratures.polynomial_degree"><code>ClimaCore.Quadratures.polynomial_degree</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">polynomial_degree(QuadratureStyle) -&gt; Int</code></pre><p>Returns the polynomial degree of the <code>QuadratureStyle</code> concrete type</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/CliMA/ClimaCore.jl/blob/8819db3f9615df160b53a0d72c6dc80e3eb305f5/src/Quadratures/Quadratures.jl#L21-L25">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="ClimaCore.Quadratures.quadrature_points" href="#ClimaCore.Quadratures.quadrature_points"><code>ClimaCore.Quadratures.quadrature_points</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">points, weights = quadrature_points(::Type{FT}, quadrature_style)</code></pre><p>The points and weights of the quadrature rule in floating point type <code>FT</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/CliMA/ClimaCore.jl/blob/8819db3f9615df160b53a0d72c6dc80e3eb305f5/src/Quadratures/Quadratures.jl#L44-L48">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="ClimaCore.Quadratures.barycentric_weights" href="#ClimaCore.Quadratures.barycentric_weights"><code>ClimaCore.Quadratures.barycentric_weights</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">barycentric_weights(x::SVector{Nq}) where {Nq}</code></pre><p>The barycentric weights associated with the array of point locations <code>x</code>:</p><p class="math-container">\[w_j = \frac{1}{\prod_{k \ne j} (x_i - x_j)}\]</p><p>See [<a href="../references/#Berrut2004">12</a>], equation 3.2.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/CliMA/ClimaCore.jl/blob/8819db3f9615df160b53a0d72c6dc80e3eb305f5/src/Quadratures/Quadratures.jl#L120-L130">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="ClimaCore.Quadratures.interpolation_matrix" href="#ClimaCore.Quadratures.interpolation_matrix"><code>ClimaCore.Quadratures.interpolation_matrix</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">interpolation_matrix(x::SVector, r::SVector{Nq})</code></pre><p>The matrix which interpolates the Lagrange polynomial of degree <code>Nq-1</code> through the points <code>r</code>, to points <code>x</code>. The matrix coefficients are computed using the Barycentric formula of [<a href="../references/#Berrut2004">12</a>], section 4:</p><p class="math-container">\[I_{ij} = \begin{cases}
1 &amp; \text{if } x_i = r_j, \\
0 &amp; \text{if } x_i = r_k \text{ for } k \ne j, \\
\frac{\displaystyle \frac{w_j}{x_i - r_j}}{\displaystyle \sum_k \frac{w_k}{x_i - r_k}} &amp; \text{otherwise,}
\end{cases}\]</p><p>where <span>$w_j$</span> are the barycentric weights, see <a href="#ClimaCore.Quadratures.barycentric_weights"><code>barycentric_weights</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/CliMA/ClimaCore.jl/blob/8819db3f9615df160b53a0d72c6dc80e3eb305f5/src/Quadratures/Quadratures.jl#L149-L163">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="ClimaCore.Quadratures.differentiation_matrix" href="#ClimaCore.Quadratures.differentiation_matrix"><code>ClimaCore.Quadratures.differentiation_matrix</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">differentiation_matrix(r::SVector{Nq, T}) where {Nq, T}</code></pre><p>The spectral differentiation matrix for the Lagrange polynomial of degree <code>Nq-1</code> interpolating at points <code>r</code>.</p><p>The matrix coefficients are computed using the [<a href="../references/#Berrut2004">12</a>], section 9.3:</p><p class="math-container">\[D_{ij} = \begin{cases}
    \displaystyle
    \frac{w_j}{w_i (x_i - x_j)} &amp;\text{ if } i \ne j \\
    -\sum_{k \ne j} D_{kj} &amp;\text{ if } i = j
\end{cases}\]</p><p>where <span>$w_j$</span> are the barycentric weights, see <a href="#ClimaCore.Quadratures.barycentric_weights"><code>barycentric_weights</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/CliMA/ClimaCore.jl/blob/8819db3f9615df160b53a0d72c6dc80e3eb305f5/src/Quadratures/Quadratures.jl#L260-L275">source</a></section><section><div><pre><code class="language-julia hljs">differentiation_matrix(FT, quadstyle::QuadratureStyle)</code></pre><p>The spectral differentiation matrix at the quadrature points of <code>quadstyle</code>, using floating point types <code>FT</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/CliMA/ClimaCore.jl/blob/8819db3f9615df160b53a0d72c6dc80e3eb305f5/src/Quadratures/Quadratures.jl#L295-L300">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="ClimaCore.Quadratures.orthonormal_poly" href="#ClimaCore.Quadratures.orthonormal_poly"><code>ClimaCore.Quadratures.orthonormal_poly</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">V = orthonormal_poly(points, quad)</code></pre><p><code>V_{ij}</code> contains the <code>j-1</code>th Legendre polynomial evaluated at <code>points[i]</code>. i.e. it is the mapping from the modal to the nodal representation.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/CliMA/ClimaCore.jl/blob/8819db3f9615df160b53a0d72c6dc80e3eb305f5/src/Quadratures/Quadratures.jl#L224-L229">source</a></section></article><h4 id="Internals-2"><a class="docs-heading-anchor" href="#Internals-2">Internals</a><a class="docs-heading-anchor-permalink" href="#Internals-2" title="Permalink"></a></h4><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="ClimaCore.Topologies.dss_transform" href="#ClimaCore.Topologies.dss_transform"><code>ClimaCore.Topologies.dss_transform</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">dss_transform(arg, local_geometry, weight, I)</code></pre><p>Transfrom <code>arg[I]</code> to a basis for direct stiffness summation (DSS). Transformations only apply to vector quantities.</p><ul><li><code>local_geometry[I]</code> is the relevant <code>LocalGeometry</code> object. If it is <code>nothing</code>, then no transformation is performed</li><li><code>weight[I]</code> is the relevant DSS weights. If <code>weight</code> is <code>nothing</code>, then the result is simply summation.</li></ul><p>See <a href="#ClimaCore.Spaces.weighted_dss!"><code>ClimaCore.Spaces.weighted_dss!</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/CliMA/ClimaCore.jl/blob/8819db3f9615df160b53a0d72c6dc80e3eb305f5/src/Topologies/dss_transform.jl#L4-L14">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="ClimaCore.Topologies.dss_transform!" href="#ClimaCore.Topologies.dss_transform!"><code>ClimaCore.Topologies.dss_transform!</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">dss_transform!(
    device::ClimaComms.AbstractDevice,
    dss_buffer::DSSBuffer,
    data::Union{DataLayouts.IJFH, DataLayouts.IJHF, DataLayouts.VIJFH, DataLayouts.VIJHF},
    local_geometry::Union{DataLayouts.IJFH, DataLayouts.IJHF, DataLayouts.VIJFH, DataLayouts.VIJHF},
    dss_weights::Union{DataLayouts.IJFH, DataLayouts.IJHF, DataLayouts.VIJFH, DataLayouts.VIJHF},
    perimeter::Perimeter2D,
    localelems::AbstractVector{Int},
)</code></pre><p>Transforms vectors from Covariant axes to physical (local axis), weights the data at perimeter nodes,  and stores result in the <code>perimeter_data</code> array. This function calls the appropriate version of  <code>dss_transform!</code> based on the data layout of the input arguments.</p><p>Arguments:</p><ul><li><code>dss_buffer</code>: <a href="#ClimaCore.Topologies.DSSBuffer"><code>DSSBuffer</code></a> generated by <code>create_dss_buffer</code> function for field data</li><li><code>data</code>: field data</li><li><code>local_geometry</code>: local metric information defined at each node</li><li><code>dss_weights</code>: local dss weights for horizontal space</li><li><code>perimeter</code>: perimeter iterator</li><li><code>localelems</code>: list of local elements to perform transformation operations on</li></ul><p>Part of <a href="#ClimaCore.Spaces.weighted_dss!"><code>ClimaCore.Spaces.weighted_dss!</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/CliMA/ClimaCore.jl/blob/8819db3f9615df160b53a0d72c6dc80e3eb305f5/src/Topologies/dss.jl#L177-L202">source</a></section><section><div><pre><code class="language-julia hljs">function dss_transform!(
    ::ClimaComms.AbstractCPUDevice,
    perimeter_data::Union{DataLayouts.VIFH, DataLayouts.VIHF},
    data::Union{DataLayouts.IJFH, DataLayouts.IJHF, DataLayouts.VIJFH, DataLayouts.VIJHF},
    perimeter::Perimeter2D,
    local_geometry::Union{DataLayouts.IJFH, DataLayouts.IJHF, DataLayouts.VIJFH, DataLayouts.VIJHF},
    dss_weights::Union{DataLayouts.IJFH, DataLayouts.IJHF, DataLayouts.VIJFH, DataLayouts.VIJHF},
    localelems::Vector{Int},
)</code></pre><p>Transforms vectors from Covariant axes to physical (local axis), weights the data at perimeter nodes, and stores result in the <code>perimeter_data</code> array.</p><p>Arguments:</p><ul><li><code>perimeter_data</code>: contains the perimeter field data, represented on the physical axis, corresponding to the full field data in <code>data</code></li><li><code>data</code>: field data</li><li><code>perimeter</code>: perimeter iterator</li><li><code>local_geometry</code>: local metric information defined at each node</li><li><code>dss_weights</code>: local dss weights for horizontal space</li><li><code>localelems</code>: list of local elements to perform transformation operations on</li></ul><p>Part of <a href="#ClimaCore.Spaces.weighted_dss!"><code>ClimaCore.Spaces.weighted_dss!</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/CliMA/ClimaCore.jl/blob/8819db3f9615df160b53a0d72c6dc80e3eb305f5/src/Topologies/dss.jl#L247-L271">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="ClimaCore.Topologies.dss_untransform!" href="#ClimaCore.Topologies.dss_untransform!"><code>ClimaCore.Topologies.dss_untransform!</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">dss_untransform!(
    device::ClimaComms.AbstractDevice,
    dss_buffer::DSSBuffer,
    data::Union{DataLayouts.IJFH, DataLayouts.IJHF, DataLayouts.VIJFH, DataLayouts.VIJHF},
    local_geometry::Union{DataLayouts.IJFH, DataLayouts.IJHF, DataLayouts.VIJFH, DataLayouts.VIJHF},
    perimeter::AbstractPerimeter,
)</code></pre><p>Transforms the DSS&#39;d local vectors back to Covariant12 vectors, and copies the DSS&#39;d data from the <code>perimeter_data</code> to <code>data</code>. This function calls the appropriate version of <code>dss_transform!</code> function based on the data layout of the input arguments.</p><p>Arguments:</p><ul><li><code>dss_buffer</code>: <a href="#ClimaCore.Topologies.DSSBuffer"><code>DSSBuffer</code></a> generated by <code>create_dss_buffer</code> function for field data</li><li><code>data</code>: field data</li><li><code>local_geometry</code>: local metric information defined at each node</li><li><code>perimeter</code>: perimeter iterator</li><li><code>localelems</code>: list of local elements to perform transformation operations on</li></ul><p>Part of <a href="#ClimaCore.Spaces.weighted_dss!"><code>ClimaCore.Spaces.weighted_dss!</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/CliMA/ClimaCore.jl/blob/8819db3f9615df160b53a0d72c6dc80e3eb305f5/src/Topologies/dss.jl#L301-L323">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="ClimaCore.Topologies.dss_untransform" href="#ClimaCore.Topologies.dss_untransform"><code>ClimaCore.Topologies.dss_untransform</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">dss_untransform(T, targ, local_geometry, I...)</code></pre><p>Transform <code>targ[I...]</code> back to a value of type <code>T</code> after performing direct stiffness summation (DSS).</p><p>See <a href="#ClimaCore.Spaces.weighted_dss!"><code>ClimaCore.Spaces.weighted_dss!</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/CliMA/ClimaCore.jl/blob/8819db3f9615df160b53a0d72c6dc80e3eb305f5/src/Topologies/dss_transform.jl#L132-L138">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="ClimaCore.Topologies.dss_local_vertices!" href="#ClimaCore.Topologies.dss_local_vertices!"><code>ClimaCore.Topologies.dss_local_vertices!</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">dss_local_vertices!(
    perimeter_data::DataLayouts.VIFH,
    perimeter::Perimeter2D,
    topology::Topology2D,
)</code></pre><p>Apply dss to local vertices.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/CliMA/ClimaCore.jl/blob/8819db3f9615df160b53a0d72c6dc80e3eb305f5/src/Topologies/dss.jl#L449-L457">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="ClimaCore.Topologies.dss_local!" href="#ClimaCore.Topologies.dss_local!"><code>ClimaCore.Topologies.dss_local!</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">function dss_local!(
    ::ClimaComms.AbstractCPUDevice,
    perimeter_data::DataLayouts.VIFH,
    perimeter::AbstractPerimeter,
    topology::AbstractTopology,
)</code></pre><p>Performs DSS on local vertices and faces.</p><p>Part of <a href="#ClimaCore.Spaces.weighted_dss!"><code>ClimaCore.Spaces.weighted_dss!</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/CliMA/ClimaCore.jl/blob/8819db3f9615df160b53a0d72c6dc80e3eb305f5/src/Topologies/dss.jl#L426-L437">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="ClimaCore.Topologies.dss_local_ghost!" href="#ClimaCore.Topologies.dss_local_ghost!"><code>ClimaCore.Topologies.dss_local_ghost!</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">function dss_local_ghost!(
    ::ClimaComms.AbstractCPUDevice,
    perimeter_data::DataLayouts.VIFH,
    perimeter::AbstractPerimeter,
    topology::AbstractTopology,
)</code></pre><p>Computes the &quot;local&quot; part of ghost vertex dss. (i.e. it computes the summation of all the shared local vertices of a unique ghost vertex and stores the value in each of the local vertex locations in  <code>perimeter_data</code>)</p><p>Part of <a href="#ClimaCore.Spaces.weighted_dss!"><code>ClimaCore.Spaces.weighted_dss!</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/CliMA/ClimaCore.jl/blob/8819db3f9615df160b53a0d72c6dc80e3eb305f5/src/Topologies/dss.jl#L514-L527">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="ClimaCore.Topologies.dss_ghost!" href="#ClimaCore.Topologies.dss_ghost!"><code>ClimaCore.Topologies.dss_ghost!</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">dss_ghost!(
    device::ClimaComms.AbstractCPUDevice,
    perimeter_data::DataLayouts.VIFH,
    perimeter::AbstractPerimeter,
    topology::AbstractTopology,
)</code></pre><p>Sets the value for all local vertices of each unique ghost vertex, in <code>perimeter_data</code>, to that of  the representative ghost vertex.</p><p>Part of <a href="#ClimaCore.Spaces.weighted_dss!"><code>ClimaCore.Spaces.weighted_dss!</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/CliMA/ClimaCore.jl/blob/8819db3f9615df160b53a0d72c6dc80e3eb305f5/src/Topologies/dss.jl#L572-L584">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="ClimaCore.Topologies.create_dss_buffer" href="#ClimaCore.Topologies.create_dss_buffer"><code>ClimaCore.Topologies.create_dss_buffer</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">create_dss_buffer(data, space)</code></pre><p>Creates a <a href="#ClimaCore.Topologies.DSSBuffer"><code>DSSBuffer</code></a> for the field data corresponding to <code>data</code></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/CliMA/ClimaCore.jl/blob/8819db3f9615df160b53a0d72c6dc80e3eb305f5/src/Spaces/dss.jl#L24-L28">source</a></section><section><div><pre><code class="language-julia hljs">Spaces.create_dss_buffer(fv::FieldVector)</code></pre><p>Create a NamedTuple of buffers for communicating neighbour information of each Field in <code>fv</code>. In this NamedTuple, the name of each field is mapped to the buffer.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/CliMA/ClimaCore.jl/blob/8819db3f9615df160b53a0d72c6dc80e3eb305f5/src/Fields/fieldvector.jl#L183-L189">source</a></section><section><div><pre><code class="language-julia hljs">Spaces.create_dss_buffer(field::Field)</code></pre><p>Create a buffer for communicating neighbour information of <code>field</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/CliMA/ClimaCore.jl/blob/8819db3f9615df160b53a0d72c6dc80e3eb305f5/src/Fields/Fields.jl#L487-L491">source</a></section><section><div><pre><code class="language-julia hljs">create_dss_buffer(
    data::Union{DataLayouts.IJFH{S}, DataLayouts.IJHF{S}, DataLayouts.VIJFH{S}, DataLayouts.VIJHF{S}},
    topology::Topology2D,
    local_geometry::Union{DataLayouts.IJFH, DataLayouts.IJHF, DataLayouts.VIJFH, DataLayouts.VIJHF, Nothing} = nothing,
    dss_weights::Union{DataLayouts.IJFH, DataLayouts.IJHF, DataLayouts.VIJFH, DataLayouts.VIJHF, Nothing} = nothing,
) where {S}</code></pre><p>Creates a <a href="#ClimaCore.Topologies.DSSBuffer"><code>DSSBuffer</code></a> for the field data corresponding to <code>data</code></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/CliMA/ClimaCore.jl/blob/8819db3f9615df160b53a0d72c6dc80e3eb305f5/src/Topologies/dss.jl#L53-L62">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="ClimaCore.Topologies.fill_send_buffer!" href="#ClimaCore.Topologies.fill_send_buffer!"><code>ClimaCore.Topologies.fill_send_buffer!</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">fill_send_buffer!(::ClimaComms.AbstractCPUDevice, dss_buffer::DSSBuffer; synchronize=true)</code></pre><p>Loads the send buffer from <code>perimeter_data</code>. For unique ghost vertices, only data from the representative vertices which store result of &quot;ghost local&quot; DSS are loaded.</p><p>Part of <a href="#ClimaCore.Spaces.weighted_dss!"><code>ClimaCore.Spaces.weighted_dss!</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/CliMA/ClimaCore.jl/blob/8819db3f9615df160b53a0d72c6dc80e3eb305f5/src/Topologies/dss.jl#L615-L622">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="ClimaCore.Topologies.DSSBuffer" href="#ClimaCore.Topologies.DSSBuffer"><code>ClimaCore.Topologies.DSSBuffer</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">DSSBuffer{G, D, A, B}</code></pre><p><strong>Fields</strong></p><ul><li><code>graph_context</code>: ClimaComms graph context for communication</li><li><code>perimeter_data</code>: Perimeter <code>DataLayout</code> object: typically a  <code>VIFH{TT,Nv,Np,Nh}</code> or <code>VIHF{TT,Nv,Np,Nh}</code>, where <code>TT</code> is the transformed  type, <code>Nv</code> is the number of vertical levels, and <code>Np</code> is the length of the  perimeter</li><li><code>send_date</code>: send buffer <code>AbstractVector{FT}</code></li><li><code>recv_data</code>: recv buffer <code>AbstractVector{FT}</code></li><li><code>send_buf_idx</code>: indexing array for loading send buffer from <code>perimeter_data</code></li><li><code>recv_buf_idx</code>: indexing array for loading (and summing) data from recv buffer to</li><li><code>internal_elems</code>: internal local elements (lidx)</li><li><code>perimeter_elems</code>: local elements (lidx) located on process boundary</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/CliMA/ClimaCore.jl/blob/8819db3f9615df160b53a0d72c6dc80e3eb305f5/src/Topologies/dss.jl#L14-L30">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="ClimaCore.Topologies.load_from_recv_buffer!" href="#ClimaCore.Topologies.load_from_recv_buffer!"><code>ClimaCore.Topologies.load_from_recv_buffer!</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">load_from_recv_buffer!(::ClimaComms.AbstractCPUDevice, dss_buffer::DSSBuffer)</code></pre><p>Adds data from the recv buffer to the corresponding location in <code>perimeter_data</code>. For ghost vertices, this data is added only to the representative vertices. The values are  then scattered to other local vertices corresponding to each unique ghost vertex in <code>dss_local_ghost</code>.</p><p>Part of <a href="#ClimaCore.Spaces.weighted_dss!"><code>ClimaCore.Spaces.weighted_dss!</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/CliMA/ClimaCore.jl/blob/8819db3f9615df160b53a0d72c6dc80e3eb305f5/src/Topologies/dss.jl#L644-L652">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="ClimaCore.Topologies.dss!" href="#ClimaCore.Topologies.dss!"><code>ClimaCore.Topologies.dss!</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">dss!(data, topology)</code></pre><p>Computed unweighted/pure DSS of <code>data</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/CliMA/ClimaCore.jl/blob/8819db3f9615df160b53a0d72c6dc80e3eb305f5/src/Topologies/dss.jl#L675-L679">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="ClimaCore.Spaces.weighted_dss_start!" href="#ClimaCore.Spaces.weighted_dss_start!"><code>ClimaCore.Spaces.weighted_dss_start!</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">weighted_dss_start!(
    data::Union{
        DataLayouts.IFH,
        DataLayouts.IHF,
        DataLayouts.VIFH,
        DataLayouts.VIHF,
        DataLayouts.IJFH,
        DataLayouts.IJHF,
        DataLayouts.VIJFH,
        DataLayouts.VIJHF,
    },
    space::Union{
        AbstractSpectralElementSpace,
        ExtrudedFiniteDifferenceSpace,
    },
    dss_buffer::Union{DSSBuffer, Nothing},
)</code></pre><p>It comprises of the following steps:</p><p>1). Apply <a href="#ClimaCore.Topologies.dss_transform!"><code>Spaces.dss_transform!</code></a> on perimeter elements. This weights and tranforms vector  fields to physical basis if needed. Scalar fields are weighted. The transformed and/or weighted  perimeter <code>data</code> is stored in <code>perimeter_data</code>.</p><p>2). Apply <a href="#ClimaCore.Topologies.dss_local_ghost!"><code>Spaces.dss_local_ghost!</code></a> This computes partial weighted DSS on ghost vertices, using only the information from <code>local</code> vertices.</p><p>3). <a href="#ClimaCore.Topologies.fill_send_buffer!"><code>Spaces.fill_send_buffer!</code></a>  Loads the send buffer from <code>perimeter_data</code>. For unique ghost vertices, only data from the representative ghost vertices which store result of &quot;ghost local&quot; DSS are loaded.</p><p>4). Start DSS communication with neighboring processes</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/CliMA/ClimaCore.jl/blob/8819db3f9615df160b53a0d72c6dc80e3eb305f5/src/Spaces/dss.jl#L136-L169">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="ClimaCore.Spaces.weighted_dss_internal!" href="#ClimaCore.Spaces.weighted_dss_internal!"><code>ClimaCore.Spaces.weighted_dss_internal!</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">weighted_dss_internal!(
    data::Union{
        DataLayouts.IFH,
        DataLayouts.IHF,
        DataLayouts.VIFH,
        DataLayouts.VIHF,
        DataLayouts.IJFH,
        DataLayouts.IJHF,
        DataLayouts.VIJFH,
        DataLayouts.VIJHF,
    },
    space::Union{
        AbstractSpectralElementSpace,
        ExtrudedFiniteDifferenceSpace,
    },
    dss_buffer::DSSBuffer,
)</code></pre><p>1). Apply <a href="#ClimaCore.Topologies.dss_transform!"><code>Spaces.dss_transform!</code></a> on interior elements. Local elements are split into interior  and perimeter elements to facilitate overlapping of communication with computation.</p><p>2). Probe communication</p><p>3). <a href="#ClimaCore.Topologies.dss_local!"><code>Spaces.dss_local!</code></a> computes the weighted DSS on local vertices and faces.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/CliMA/ClimaCore.jl/blob/8819db3f9615df160b53a0d72c6dc80e3eb305f5/src/Spaces/dss.jl#L190-L215">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="ClimaCore.Spaces.weighted_dss_ghost!" href="#ClimaCore.Spaces.weighted_dss_ghost!"><code>ClimaCore.Spaces.weighted_dss_ghost!</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">weighted_dss_ghost!(
    data::Union{
        DataLayouts.IFH,
        DataLayouts.IHF,
        DataLayouts.VIFH,
        DataLayouts.VIHF,
        DataLayouts.IJFH,
        DataLayouts.IJHF,
        DataLayouts.VIJFH,
        DataLayouts.VIJHF,
    },
    space::Union{
        AbstractSpectralElementSpace,
        ExtrudedFiniteDifferenceSpace,
    },
    dss_buffer::Union{DSSBuffer, Nothing},
)</code></pre><p>1). Finish communications.</p><p>2). Call <a href="#ClimaCore.Topologies.load_from_recv_buffer!"><code>Spaces.load_from_recv_buffer!</code></a> After the communication is complete, this adds data from the recv buffer to the corresponding location in  <code>perimeter_data</code>. For ghost vertices, this data is added only to the representative vertices. The values are  then scattered to other local vertices corresponding to each unique ghost vertex in <code>dss_local_ghost</code>.</p><p>3). Call <a href="#ClimaCore.Topologies.dss_untransform!"><code>Spaces.dss_untransform!</code></a> on all local elements. This transforms the DSS&#39;d local vectors back to Covariant12 vectors, and copies the DSS&#39;d data from the <code>perimeter_data</code> to <code>data</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/CliMA/ClimaCore.jl/blob/8819db3f9615df160b53a0d72c6dc80e3eb305f5/src/Spaces/dss.jl#L270-L299">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="ClimaCore.Spaces.weighted_dss!" href="#ClimaCore.Spaces.weighted_dss!"><code>ClimaCore.Spaces.weighted_dss!</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">function weighted_dss!(
    data::Union{
        DataLayouts.IFH,
        DataLayouts.IHF,
        DataLayouts.VIFH,
        DataLayouts.VIHF,
        DataLayouts.IJFH,
        DataLayouts.IJHF,
        DataLayouts.VIJFH,
        DataLayouts.VIJHF,
    },
    space::Union{
        AbstractSpectralElementSpace,
        ExtrudedFiniteDifferenceSpace,
    },
    dss_buffer::Union{DSSBuffer, Nothing},
)</code></pre><p>Computes weighted dss of <code>data</code>. </p><p>It comprises of the following steps:</p><p>1). <a href="#ClimaCore.Spaces.weighted_dss_start!"><code>Spaces.weighted_dss_start!</code></a></p><p>2). <a href="#ClimaCore.Spaces.weighted_dss_internal!"><code>Spaces.weighted_dss_internal!</code></a></p><p>3). <a href="#ClimaCore.Spaces.weighted_dss_ghost!"><code>Spaces.weighted_dss_ghost!</code></a></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/CliMA/ClimaCore.jl/blob/8819db3f9615df160b53a0d72c6dc80e3eb305f5/src/Spaces/dss.jl#L58-L86">source</a></section><section><div><pre><code class="language-julia hljs">Spaces.weighted_dss!(fv::FieldVector, dss_buffer = Spaces.create_dss_buffer(fv))</code></pre><p>Apply weighted direct stiffness summation (DSS) to each field in <code>fv</code>. If a <code>dss_buffer</code> object is not provided, a buffer will be created for each field in <code>fv</code>. Note that using the <code>Pair</code> interface here parallelizes the <code>weighted_dss!</code> calls.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/CliMA/ClimaCore.jl/blob/8819db3f9615df160b53a0d72c6dc80e3eb305f5/src/Fields/fieldvector.jl#L199-L206">source</a></section><section><div><pre><code class="language-julia hljs">Spaces.weighted_dss!(f::Field, dss_buffer = Spaces.create_dss_buffer(field))</code></pre><p>Apply weighted direct stiffness summation (DSS) to <code>f</code>. This operates in-place (i.e. it modifies the <code>f</code>). <code>ghost_buffer</code> contains the necessary information for communication in a distributed setting, see <a href="#ClimaCore.Topologies.create_dss_buffer"><code>Spaces.create_dss_buffer</code></a>.</p><p>This is a projection operation from the piecewise polynomial space <span>$\mathcal{V}_0$</span> to the continuous space <span>$\mathcal{V}_1 = \mathcal{V}_0 \cap \mathcal{C}_0$</span>, defined as the field <span>$\theta \in \mathcal{V}_1$</span> such that for all <span>$\phi \in \mathcal{V}_1$</span></p><p class="math-container">\[\int_\Omega \phi \theta \,d\Omega = \int_\Omega \phi f \,d\Omega\]</p><p>In matrix form, we define <span>$\bar \theta$</span> to be the unique global node representation, and <span>$Q$</span> to be the &quot;scatter&quot; operator which maps to the redundant node representation <span>$\theta$</span></p><p class="math-container">\[\theta = Q \bar \theta\]</p><p>Then the problem can be written as</p><p class="math-container">\[(Q \bar\phi)^\top W J Q \bar\theta = (Q \bar\phi)^\top W J f\]</p><p>which reduces to</p><p class="math-container">\[\theta = Q \bar\theta = Q (Q^\top W J Q)^{-1} Q^\top W J f\]</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/CliMA/ClimaCore.jl/blob/8819db3f9615df160b53a0d72c6dc80e3eb305f5/src/Fields/Fields.jl#L396-L425">source</a></section><section><div><pre><code class="language-julia hljs">Spaces.weighted_dss!(field1 =&gt; ghost_buffer1, field2 =&gt; ghost_buffer2, ...)</code></pre><p>Call <a href="#ClimaCore.Spaces.weighted_dss!"><code>Spaces.weighted_dss!</code></a> on multiple fields at once, overlapping communication as much as possible.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/CliMA/ClimaCore.jl/blob/8819db3f9615df160b53a0d72c6dc80e3eb305f5/src/Fields/Fields.jl#L442-L447">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="ClimaCore.Spaces.unique_nodes" href="#ClimaCore.Spaces.unique_nodes"><code>ClimaCore.Spaces.unique_nodes</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">unique_nodes(space::SpectralElementSpace2D)</code></pre><p>An iterator over the unique nodes of <code>space</code>. Each node is represented by the first <code>((i,j), e)</code> triple.</p><p>This function is experimental, and may change in future.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/CliMA/ClimaCore.jl/blob/8819db3f9615df160b53a0d72c6dc80e3eb305f5/src/Spaces/spectralelement.jl#L195-L202">source</a></section></article><h4 id="Utilities-2"><a class="docs-heading-anchor" href="#Utilities-2">Utilities</a><a class="docs-heading-anchor-permalink" href="#Utilities-2" title="Permalink"></a></h4><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="ClimaCore.Spaces.area" href="#ClimaCore.Spaces.area"><code>ClimaCore.Spaces.area</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">Spaces.area(space::Spaces.AbstractSpace)</code></pre><p>The length/area/volume of <code>space</code>. This is computed as the sum of the quadrature weights <span>$W_i$</span> multiplied by the Jacobian determinants <span>$J_i$</span>:</p><p class="math-container">\[\sum_i W_i J_i \approx \int_\Omega \, d \Omega\]</p><p>If <code>space</code> is distributed, this uses a <code>ClimaComms.allreduce</code> operation.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/CliMA/ClimaCore.jl/blob/8819db3f9615df160b53a0d72c6dc80e3eb305f5/src/Spaces/Spaces.jl#L124-L134">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="ClimaCore.Spaces.local_area" href="#ClimaCore.Spaces.local_area"><code>ClimaCore.Spaces.local_area</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">Spaces.local_area(space::Spaces.AbstractSpace)</code></pre><p>The length/area/volume of <code>space</code> local to the current context. See <a href="#ClimaCore.Spaces.area"><code>Spaces.area</code></a></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/CliMA/ClimaCore.jl/blob/8819db3f9615df160b53a0d72c6dc80e3eb305f5/src/Spaces/Spaces.jl#L116-L121">source</a></section></article><h2 id="RecursiveApply"><a class="docs-heading-anchor" href="#RecursiveApply">RecursiveApply</a><a id="RecursiveApply-1"></a><a class="docs-heading-anchor-permalink" href="#RecursiveApply" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="ClimaCore.RecursiveApply" href="#ClimaCore.RecursiveApply"><code>ClimaCore.RecursiveApply</code></a> — <span class="docstring-category">Module</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">RecursiveApply</code></pre><p>This module contains operators to recurse over nested <code>Tuple</code>s or <code>NamedTuple</code>s.</p><p>To extend to another type <code>T</code>, define <code>RecursiveApply.rmap(fn, args::T...)</code></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/CliMA/ClimaCore.jl/blob/8819db3f9615df160b53a0d72c6dc80e3eb305f5/src/RecursiveApply/RecursiveApply.jl#L1-L7">source</a></section></article><h2 id="Fields"><a class="docs-heading-anchor" href="#Fields">Fields</a><a id="Fields-1"></a><a class="docs-heading-anchor-permalink" href="#Fields" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="ClimaCore.Fields.Field" href="#ClimaCore.Fields.Field"><code>ClimaCore.Fields.Field</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">Field(values, space)</code></pre><p>A set of <code>values</code> defined at each point of a <code>space</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/CliMA/ClimaCore.jl/blob/8819db3f9615df160b53a0d72c6dc80e3eb305f5/src/Fields/Fields.jl#L36-L40">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="ClimaCore.Fields.coordinate_field" href="#ClimaCore.Fields.coordinate_field"><code>ClimaCore.Fields.coordinate_field</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">coordinate_field(space::AbstractSpace)</code></pre><p>Return a pointer to the input space&#39;s coordinates <code>Field</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/CliMA/ClimaCore.jl/blob/8819db3f9615df160b53a0d72c6dc80e3eb305f5/src/Fields/Fields.jl#L348-L352">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="ClimaCore.Fields.local_geometry_field" href="#ClimaCore.Fields.local_geometry_field"><code>ClimaCore.Fields.local_geometry_field</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">local_geometry_field(space::AbstractSpace)</code></pre><p>Return a pointer to the input space&#39;s <code>LocalGeometry</code> <code>Field</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/CliMA/ClimaCore.jl/blob/8819db3f9615df160b53a0d72c6dc80e3eb305f5/src/Fields/Fields.jl#L357-L361">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Base.zeros-Tuple{ClimaCore.Spaces.AbstractSpace}" href="#Base.zeros-Tuple{ClimaCore.Spaces.AbstractSpace}"><code>Base.zeros</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">zeros(space::AbstractSpace)</code></pre><p>Create a new field on <code>space</code> that is zero everywhere.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/CliMA/ClimaCore.jl/blob/8819db3f9615df160b53a0d72c6dc80e3eb305f5/src/Fields/Fields.jl#L314-L318">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Base.ones-Tuple{ClimaCore.Spaces.AbstractSpace}" href="#Base.ones-Tuple{ClimaCore.Spaces.AbstractSpace}"><code>Base.ones</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">ones(space::AbstractSpace)</code></pre><p>Create a new field on <code>space</code> that is one everywhere.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/CliMA/ClimaCore.jl/blob/8819db3f9615df160b53a0d72c6dc80e3eb305f5/src/Fields/Fields.jl#L327-L331">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Base.sum-Tuple{ClimaCore.Fields.Field}" href="#Base.sum-Tuple{ClimaCore.Fields.Field}"><code>Base.sum</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">sum([f=identity,] v::Field)</code></pre><p>Approximate integration of <code>v</code> or <code>f.(v)</code> over the domain. In an <code>AbstractSpectralElementSpace</code>, an integral over the entire space is computed by summation over the elements of the integrand multiplied by the Jacobian determinants and the quadrature weights at each node within an element. Hence, <code>sum</code> is computed by summation of the field values multiplied by the Jacobian determinants and quadrature weights:</p><p class="math-container">\[\sum_i f(v_i) W_i J_i
\approx
\int_\Omega f(v) \, d \Omega\]</p><p>where <span>$v_i$</span> is the value at each node, and <span>$f$</span> is the identity function if not specified.</p><p>If <code>v</code> is a distributed field, this uses a <code>ClimaComms.allreduce</code> operation.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/CliMA/ClimaCore.jl/blob/8819db3f9615df160b53a0d72c6dc80e3eb305f5/src/Fields/mapreduce.jl#L30-L47">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="ClimaCore.Fields.local_sum" href="#ClimaCore.Fields.local_sum"><code>ClimaCore.Fields.local_sum</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">Fields.local_sum(v::Field)</code></pre><p>Compute the approximate integral of <code>v</code> over the domain local to the current context.</p><p>See <a href="#Base.sum-Tuple{ClimaCore.Fields.Field}"><code>sum</code></a> for the integral over the full domain.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/CliMA/ClimaCore.jl/blob/8819db3f9615df160b53a0d72c6dc80e3eb305f5/src/Fields/mapreduce.jl#L5-L12">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Statistics.mean-Tuple{ClimaCore.Fields.Field}" href="#Statistics.mean-Tuple{ClimaCore.Fields.Field}"><code>Statistics.mean</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">mean([f=identity, ]v::Field)</code></pre><p>The mean value of <code>field</code> or <code>f.(field)</code> over the domain, weighted by area. Similar to <code>sum</code>, in an <code>AbstractSpectralElementSpace</code>, this is computed by summation of the field values multiplied by the Jacobian determinants and quadrature weights:</p><p class="math-container">\[\frac{\sum_i f(v_i) W_i J_i}{\sum_i W_i J_i}
\approx
\frac{\int_\Omega f(v) \, d \Omega}{\int_\Omega \, d \Omega}\]</p><p>where <span>$v_i$</span> is the Field value at each node, and <span>$f$</span> is the identity function if not specified.</p><p>If <code>v</code> is a distributed field, this uses a <code>ClimaComms.allreduce</code> operation.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/CliMA/ClimaCore.jl/blob/8819db3f9615df160b53a0d72c6dc80e3eb305f5/src/Fields/mapreduce.jl#L98-L113">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="LinearAlgebra.norm-Tuple{ClimaCore.Fields.Field}" href="#LinearAlgebra.norm-Tuple{ClimaCore.Fields.Field}"><code>LinearAlgebra.norm</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">norm(v::Field, p=2; normalize=true)</code></pre><p>The approximate <span>$L^p$</span> norm of <code>v</code>, where <span>$L^p$</span> represents the space of measurable functions for which the p-th power of the absolute value is Lebesgue integrable, that is:</p><p class="math-container">\[\| v \|_p = \left( \int_\Omega |v|^p d \Omega \right)^{1/p}\]</p><p>where <span>$|v|$</span> is defined to be the absolute value if <span>$v$</span> is a scalar-valued Field, or the 2-norm if it is a vector-valued Field or composite Field (see <a href="https://docs.julialang.org/en/v1/stdlib/LinearAlgebra/#LinearAlgebra.norm">LinearAlgebra.norm</a>). Similar to <code>sum</code> and <code>mean</code>, in an <code>AbstractSpectralElementSpace</code>, this is computed by summation of the field values multiplied by the Jacobian determinants and quadrature weights. If <code>normalize=true</code> (the default), then internally the discrete norm is divided by the sum of the Jacobian determinants and quadrature weights:</p><p class="math-container">\[\left(\frac{\sum_i |v_i|^p W_i J_i}{\sum_i W_i J_i}\right)^{1/p}
\approx
\left(\frac{\int_\Omega |v|^p \, d \Omega}{\int_\Omega \, d \Omega}\right)^{1/p}\]</p><p>If <code>p=Inf</code>, then the norm is the maximum of the absolute values</p><p class="math-container">\[\max_i |v_i| \approx \sup_{\Omega} |v|\]</p><p>Consequently all norms should have the same units for all <span>$p$</span> (being the same as calling <code>norm</code> on a single value).</p><p>If <code>normalize=false</code>, then the denominator term is omitted, and so the result will be the norm as described above multiplied by the length/area/volume of <span>$\Omega$</span> to the power of <span>$1/p$</span>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/CliMA/ClimaCore.jl/blob/8819db3f9615df160b53a0d72c6dc80e3eb305f5/src/Fields/mapreduce.jl#L135-L165">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="ClimaCore.Fields.set!" href="#ClimaCore.Fields.set!"><code>ClimaCore.Fields.set!</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">set!(f::Function, field::Field, args = ())</code></pre><p>Apply function <code>f</code> to populate values in field <code>field</code>. <code>f</code> must have a function signature with signature <code>f(::LocalGeometry[, args...])</code>. Additional arguments may be passed to <code>f</code> with <code>args</code>.</p><p><strong>Example</strong></p><pre><code class="language-julia hljs">using ClimaCore.Fields
using ClimaCore.CommonSpaces
ᶜspace = ExtrudedCubedSphereSpace(Float64;
    z_elem = 10,
    z_min = 0,
    z_max = 1,
    radius = 10,
    h_elem = 10,
    n_quad_points = 4,
    staggering = CellCenter(),
)
x = Fields.Field(Float64, ᶜspace)
Fields.set!(x) do lg
    sin(lg.coordinates.z)
end</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/CliMA/ClimaCore.jl/blob/8819db3f9615df160b53a0d72c6dc80e3eb305f5/src/Fields/Fields.jl#L522-L548">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="ClimaCore.Grids.ColumnIndex" href="#ClimaCore.Grids.ColumnIndex"><code>ClimaCore.Grids.ColumnIndex</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">ColumnIndex(ij,h)</code></pre><p>An index into a column of a field. This can be used as an argument to <code>getindex</code> of a <code>Field</code>, to return a field on that column.</p><p><strong>Example</strong></p><pre><code class="language-julia hljs">colidx = ColumnIndex((1,1),1)
field[colidx]</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/CliMA/ClimaCore.jl/blob/8819db3f9615df160b53a0d72c6dc80e3eb305f5/src/Grids/column.jl#L5-L16">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="ClimaCore.Fields.bycolumn" href="#ClimaCore.Fields.bycolumn"><code>ClimaCore.Fields.bycolumn</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">Fields.bycolumn(fn, space)</code></pre><p>Call <code>fn(colidx)</code> to every <a href="#ClimaCore.Grids.ColumnIndex"><code>ColumnIndex</code></a> <code>colidx</code> of <code>space</code>. This can be used to apply multiple column-wise operations in a single pass, making use of multiple threads.</p><div class="admonition is-info"><header class="admonition-header">Note</header><div class="admonition-body"><p>On GPUs this will simply evaluate <code>f</code> once with <code>colidx=:</code> (i.e. it doesn&#39;t perform evaluation by columns). This may change in future.</p></div></div><p><strong>Example</strong></p><pre><code class="language-julia hljs">∇ = GradientF2C()
div = DivergenceC2F()

bycolumn(axes(f)) do colidx
    @. ∇f[colidx] = ∇(f[colidx])
    @. df[colidx] = div(∇f[colidx])
end</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/CliMA/ClimaCore.jl/blob/8819db3f9615df160b53a0d72c6dc80e3eb305f5/src/Fields/indices.jl#L8-L31">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="ClimaCore.Fields.Δz_field" href="#ClimaCore.Fields.Δz_field"><code>ClimaCore.Fields.Δz_field</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">Δz_field(field::Field)
Δz_field(space::AbstractSpace)</code></pre><p>Return a pointer to the input space&#39;s <code>Field</code> containing the <code>Δz</code> values on the same space as the given field.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/CliMA/ClimaCore.jl/blob/8819db3f9615df160b53a0d72c6dc80e3eb305f5/src/Fields/Fields.jl#L366-L372">source</a></section></article><h2 id="Hypsography-2"><a class="docs-heading-anchor" href="#Hypsography-2">Hypsography</a><a class="docs-heading-anchor-permalink" href="#Hypsography-2" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="ClimaCore.Hypsography.LinearAdaption" href="#ClimaCore.Hypsography.LinearAdaption"><code>ClimaCore.Hypsography.LinearAdaption</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">LinearAdaption(surface)</code></pre><p>Locate the levels by linear interpolation between the surface and the top of the domain, using the method of [<a href="../references/#GalChen1975">13</a>]. The surface can be specified as a <code>ZPoint</code> or a <code>Field</code> of <code>ZPoint</code>s.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/CliMA/ClimaCore.jl/blob/8819db3f9615df160b53a0d72c6dc80e3eb305f5/src/Hypsography/Hypsography.jl#L70-L76">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="ClimaCore.Hypsography.SLEVEAdaption" href="#ClimaCore.Hypsography.SLEVEAdaption"><code>ClimaCore.Hypsography.SLEVEAdaption</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">SLEVEAdaption(surface, ηₕ, s)</code></pre><p>Locate vertical levels using an exponential function between the surface and the top of the domain, using the method of [<a href="../references/#Schar2002">14</a>].  The surface can be specified as a <code>ZPoint</code> or a <code>Field</code> of <code>ZPoint</code>s.</p><p>This method is modified such no warping is applied above the generalized coordinate <code>ηₕ</code>, where <code>0 ≤ ηₕ &lt; 1</code>. <code>s</code> governs the decay rate. If the decay-scale is poorly specified (i.e., <code>s * zₜ</code> is lower than the maximum surface elevation), a warning is thrown and <code>s</code> is adjusted such that it <code>szₜ &gt; maximum(z_surface)</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/CliMA/ClimaCore.jl/blob/8819db3f9615df160b53a0d72c6dc80e3eb305f5/src/Hypsography/Hypsography.jl#L105-L116">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="ClimaCore.Hypsography.diffuse_surface_elevation!" href="#ClimaCore.Hypsography.diffuse_surface_elevation!"><code>ClimaCore.Hypsography.diffuse_surface_elevation!</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">diffuse_surface_elevation!(f::Field; κ::T, iter::Int, dt::T)</code></pre><p>Option for 2nd order diffusive smoothing of generated terrain. Mutate (smooth) a given elevation profile <code>f</code> before assigning the surface elevation to the <code>HypsographyAdaption</code> type. A spectral second-order diffusion operator is applied with forward-Euler updates to generate profiles for each new iteration. Steps to generate smoothed terrain ( represented as a ClimaCore Field) are as follows:</p><ul><li>Compute discrete elevation profile f</li><li>Compute diffuse<em>surface</em>elevation!(f, κ, iter). f is mutated.</li><li>Define <code>Hypsography.LinearAdaption(f)</code></li><li>Define <code>ExtrudedFiniteDifferenceSpace</code> with new surface elevation.</li></ul><p>Default diffusion parameters are appropriate for spherical arrangements. For <code>zmax-zsfc</code> == 𝒪(10^4), κ == 𝒪(10^8), dt == 𝒪(10⁻¹).</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/CliMA/ClimaCore.jl/blob/8819db3f9615df160b53a0d72c6dc80e3eb305f5/src/Hypsography/Hypsography.jl#L268-L283">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="ClimaCore.Hypsography.ref_z_to_physical_z" href="#ClimaCore.Hypsography.ref_z_to_physical_z"><code>ClimaCore.Hypsography.ref_z_to_physical_z</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">ref_z_to_physical_z(adaption::HypsographyAdaption, z_ref::ZPoint, z_top::ZPoint) :: ZPoint</code></pre><p>Convert reference <code>z</code>s to physical <code>z</code>s as prescribed by the given adaption.</p><p>This function has to be the inverse of <code>physical_z_to_ref_z</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/CliMA/ClimaCore.jl/blob/8819db3f9615df160b53a0d72c6dc80e3eb305f5/src/Hypsography/Hypsography.jl#L26-L32">source</a></section></article><h2 id="Limiters"><a class="docs-heading-anchor" href="#Limiters">Limiters</a><a id="Limiters-1"></a><a class="docs-heading-anchor-permalink" href="#Limiters" title="Permalink"></a></h2><p>The limiters supertype is</p><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="ClimaCore.Limiters.AbstractLimiter" href="#ClimaCore.Limiters.AbstractLimiter"><code>ClimaCore.Limiters.AbstractLimiter</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">AbstractLimiter</code></pre><p>Supertype for all limiters.</p><p><strong>Interfaces</strong></p><ul><li><a href="#ClimaCore.Limiters.apply_limiter!"><code>apply_limiter!</code></a></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/CliMA/ClimaCore.jl/blob/8819db3f9615df160b53a0d72c6dc80e3eb305f5/src/Limiters/Limiters.jl#L10-L18">source</a></section></article><p>This class of flux-limiters is applied only in the horizontal direction (on spectral advection operators).</p><h3 id="Interfaces-4"><a class="docs-heading-anchor" href="#Interfaces-4">Interfaces</a><a class="docs-heading-anchor-permalink" href="#Interfaces-4" title="Permalink"></a></h3><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="ClimaCore.Limiters.QuasiMonotoneLimiter" href="#ClimaCore.Limiters.QuasiMonotoneLimiter"><code>ClimaCore.Limiters.QuasiMonotoneLimiter</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">QuasiMonotoneLimiter</code></pre><p>This limiter is inspired by the one presented in Guba et al [<a href="../references/#GubaOpt2014">15</a>]. In the reference paper, it is denoted by OP1, and is outlined in eqs. (37)-(40). Quasimonotone here is meant to be monotone with respect to the spectral element nodal values. This limiter involves solving a constrained optimization problem (a weighted least square problem up to a fixed tolerance) that is completely local to each element.</p><p>As in HOMME, the implementation idea here is the following: we need to find a grid field which is closest to the initial field (in terms of weighted sum), but satisfies the min/max constraints. So, first we find values that do not satisfy constraints and bring these values to a closest constraint. This way we introduce some change in the tracer mass, which we then redistribute so that the l2 error is smallest. This redistribution might violate constraints; thus, we do a few iterations (until <code>abs(Δtracer_mass) &lt;= rtol * tracer_mass</code>).</p><ul><li><code>ρq</code>: tracer density Field, where <code>q</code> denotes tracer concentration per unit mass. This can be a scalar field, or a struct-valued field.</li><li><code>ρ</code>: fluid density Field (scalar).</li></ul><p><strong>Constructor</strong></p><pre><code class="nohighlight hljs">limiter = QuasiMonotoneLimiter(
    ρq::Field;
    rtol = eps(eltype(parent(ρq))),
    convergence_stats = LimiterConvergenceStats()
)</code></pre><p>Creates a limiter instance for the field <code>ρq</code> with relative tolerance <code>rtol</code>, and <code>convergence_stats</code>, which collects statistics in <code>apply_limiter!</code> (e.g., number of times that convergence is met or not). Users can call</p><p><code>Limiters.print_convergence_stats(::QuasiMonotoneLimiter)</code> to print the convergence stats.</p><p><strong>Usage</strong></p><p>Call <a href="#ClimaCore.Limiters.compute_bounds!"><code>compute_bounds!</code></a> on the input fields:</p><pre><code class="nohighlight hljs">compute_bounds!(limiter, ρq, ρ)</code></pre><p>Then call <a href="#ClimaCore.Limiters.apply_limiter!"><code>apply_limiter!</code></a> on the output fields:</p><pre><code class="nohighlight hljs">apply_limiter!(ρq, ρ, limiter)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/CliMA/ClimaCore.jl/blob/8819db3f9615df160b53a0d72c6dc80e3eb305f5/src/Limiters/quasimonotone.jl#L53-L99">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="ClimaCore.Limiters.compute_bounds!" href="#ClimaCore.Limiters.compute_bounds!"><code>ClimaCore.Limiters.compute_bounds!</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">compute_bounds!(limiter::QuasiMonotoneLimiter, ρq::Field, ρ::Field)</code></pre><p>Compute the desired bounds for the tracer concentration per unit mass <code>q</code>, based on the tracer density, <code>ρq</code>, and density, <code>ρ</code>, fields.</p><p>This is computed by</p><ol><li><a href="#ClimaCore.Limiters.compute_element_bounds!"><code>compute_element_bounds!</code></a></li><li>starts the ghost exchange (if distributed)</li><li><a href="#ClimaCore.Limiters.compute_neighbor_bounds_local!"><code>compute_neighbor_bounds_local!</code></a></li><li>completes the ghost exchange (if distributed)</li><li><a href="#ClimaCore.Limiters.compute_neighbor_bounds_ghost!"><code>compute_neighbor_bounds_ghost!</code></a> (if distributed)</li></ol></div><a class="docs-sourcelink" target="_blank" href="https://github.com/CliMA/ClimaCore.jl/blob/8819db3f9615df160b53a0d72c6dc80e3eb305f5/src/Limiters/quasimonotone.jl#L301-L313">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="ClimaCore.Limiters.apply_limiter!" href="#ClimaCore.Limiters.apply_limiter!"><code>ClimaCore.Limiters.apply_limiter!</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">apply_limiter!(ρq, ρ, limiter::QuasiMonotoneLimiter)</code></pre><p>Apply the limiter on the tracer density  <code>ρq</code>, using the computed desired bounds on the concentration <code>q</code> and density <code>ρ</code> as an optimal weight. This iterates over each element, calling <a href="#ClimaCore.Limiters.apply_limit_slab!"><code>apply_limit_slab!</code></a>. If the limiter fails to converge for any element, a warning is issued.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/CliMA/ClimaCore.jl/blob/8819db3f9615df160b53a0d72c6dc80e3eb305f5/src/Limiters/quasimonotone.jl#L340-L347">source</a></section></article><h3 id="Internals-3"><a class="docs-heading-anchor" href="#Internals-3">Internals</a><a class="docs-heading-anchor-permalink" href="#Internals-3" title="Permalink"></a></h3><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="ClimaCore.Limiters.compute_element_bounds!" href="#ClimaCore.Limiters.compute_element_bounds!"><code>ClimaCore.Limiters.compute_element_bounds!</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">compute_element_bounds!(limiter::QuasiMonotoneLimiter, ρq, ρ)</code></pre><p>Given two fields <code>ρq</code> and <code>ρ</code>, computes the min and max of <code>q</code> in each element, storing it in <code>limiter.q_bounds</code>.</p><p>Part of <a href="#ClimaCore.Limiters.compute_bounds!"><code>compute_bounds!</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/CliMA/ClimaCore.jl/blob/8819db3f9615df160b53a0d72c6dc80e3eb305f5/src/Limiters/quasimonotone.jl#L171-L178">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="ClimaCore.Limiters.compute_neighbor_bounds_local!" href="#ClimaCore.Limiters.compute_neighbor_bounds_local!"><code>ClimaCore.Limiters.compute_neighbor_bounds_local!</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">compute_neighbor_bounds_local!(limiter::QuasiMonotoneLimiter, topology)</code></pre><p>Update the field <code>limiter.q_bounds_nbr</code> based on <code>limiter.q_bounds</code> in the local neighbors.</p><p>Part of <a href="#ClimaCore.Limiters.compute_bounds!"><code>compute_bounds!</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/CliMA/ClimaCore.jl/blob/8819db3f9615df160b53a0d72c6dc80e3eb305f5/src/Limiters/quasimonotone.jl#L223-L230">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="ClimaCore.Limiters.compute_neighbor_bounds_ghost!" href="#ClimaCore.Limiters.compute_neighbor_bounds_ghost!"><code>ClimaCore.Limiters.compute_neighbor_bounds_ghost!</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">compute_neighbor_bounds_ghost!(limiter::QuasiMonotoneLimiter, topology)</code></pre><p>Update the field <code>limiter.q_bounds_nbr</code> based on <code>limiter.q_bounds</code> in the ghost neighbors. This should be called after the ghost exchange has completed.</p><p>Part of <a href="#ClimaCore.Limiters.compute_bounds!"><code>compute_bounds!</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/CliMA/ClimaCore.jl/blob/8819db3f9615df160b53a0d72c6dc80e3eb305f5/src/Limiters/quasimonotone.jl#L263-L270">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="ClimaCore.Limiters.apply_limit_slab!" href="#ClimaCore.Limiters.apply_limit_slab!"><code>ClimaCore.Limiters.apply_limit_slab!</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">apply_limit_slab!(slab_ρq, slab_ρ, slab_WJ, slab_q_bounds, rtol)</code></pre><p>Apply the computed bounds of the tracer concentration (<code>slab_q_bounds</code>) in the limiter to <code>slab_ρq</code>, given the total mass <code>slab_ρ</code>, metric terms <code>slab_WJ</code>, and relative tolerance <code>rtol</code>. Return whether the tolerance condition could be satisfied.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/CliMA/ClimaCore.jl/blob/8819db3f9615df160b53a0d72c6dc80e3eb305f5/src/Limiters/quasimonotone.jl#L400-L407">source</a></section></article><h2 id="InputOutput"><a class="docs-heading-anchor" href="#InputOutput">InputOutput</a><a id="InputOutput-1"></a><a class="docs-heading-anchor-permalink" href="#InputOutput" title="Permalink"></a></h2><h3 id="Writers"><a class="docs-heading-anchor" href="#Writers">Writers</a><a id="Writers-1"></a><a class="docs-heading-anchor-permalink" href="#Writers" title="Permalink"></a></h3><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="ClimaCore.InputOutput.HDF5Writer" href="#ClimaCore.InputOutput.HDF5Writer"><code>ClimaCore.InputOutput.HDF5Writer</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">HDF5Writer(filename::AbstractString[,
           context::ClimaComms.AbstractCommsContext];
           overwrite::Bool = true)
HDF5Writer(::Function,
           filename::AbstractString[,
           context::ClimaComms.AbstractCommsContext];
           overwrite::Bool = true)</code></pre><p>An <code>AbstractWriter</code> for writing to HDF5-formatted files using the ClimaCore storage conventions. An internal cache is used to avoid writing duplicate domains, meshes, topologies and spaces to the file. Use <a href="#ClimaCore.InputOutput.HDF5Reader"><code>HDF5Reader</code></a> to load the data from the file.</p><p>The optional <code>context</code> can be used for writing distributed fields: in this case, the <code>MPICommsContext</code> used passed as an argument: this must match the context used for distributing the <code>Field</code>.</p><p>The writer overwrites or appends to existing files depending on the value of the <code>overwrite</code> keyword argument. When <code>overwrite</code> is <code>false</code>, the writer appends to <code>filename</code> if the file already exists, otherwise it creates a new one.</p><div class="admonition is-info"><header class="admonition-header">Note</header><div class="admonition-body"><p>The default Julia HDF5 binaries are not built with MPI support. To use the distributed functionality, you will need to configure HDF5.jl with an MPI-enabled HDF5 library, see <a href="https://juliaio.github.io/HDF5.jl/stable/#Parallel-HDF5">the HDF5.jl documentation</a>.</p></div></div><p><strong>Interface</strong></p><p><a href="#ClimaCore.InputOutput.write!"><code>write!</code></a></p><p><strong>Usage</strong></p><pre><code class="language-julia hljs">InputOutput.HDF5Writer(filename) do writer
    InputOutput.write!(writer, Y, &quot;Y&quot;)
end</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/CliMA/ClimaCore.jl/blob/8819db3f9615df160b53a0d72c6dc80e3eb305f5/src/InputOutput/writers.jl#L3-L43">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="ClimaCore.InputOutput.write!" href="#ClimaCore.InputOutput.write!"><code>ClimaCore.InputOutput.write!</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">write!(writer::AbstractWriter, obj[, preferredname])</code></pre><p>Write the object <code>obj</code> using <code>writer</code>. An optional <code>preferredname</code> can be provided, otherwise <a href="#ClimaCore.InputOutput.defaultname"><code>defaultname</code></a> will be used to generate a name. The name of the object will be returned.</p><p>A cache of domains, meshes, topologies and spaces is kept: if one of these objects has already been written, then the file will not be modified: instead the name under which the object was first written will be returned. Note that <code>Field</code>s and <code>FieldVector</code>s are <em>not</em> cached, and so can be written multiple times.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/CliMA/ClimaCore.jl/blob/8819db3f9615df160b53a0d72c6dc80e3eb305f5/src/InputOutput/writers.jl#L116-L128">source</a></section><section><div><pre><code class="language-julia hljs">write!(writer::HDF5Writer, field::Fields.Field, name::AbstractString)</code></pre><p>Write the <code>field</code> to the HDF5 in <code>writer</code> and assign it the given <code>name</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/CliMA/ClimaCore.jl/blob/8819db3f9615df160b53a0d72c6dc80e3eb305f5/src/InputOutput/writers.jl#L454-L458">source</a></section><section><div><pre><code class="language-julia hljs">write!(
    writer::HDF5Writer,
    field::Fields.Field,
    name::AbstractString,
    space::Spaces.AbstractPointSpace,
)</code></pre><p>Write a <code>Field</code>, with <code>axes</code> of type <code>PointSpace</code>,  to the HDF5 file. The field is written to the <code>fields</code> group in the file, with the name <code>name</code>. The local geometry data of the <code>PointSpace</code> is written to the <code>local_geometry_data</code> group with name <code>name</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/CliMA/ClimaCore.jl/blob/8819db3f9615df160b53a0d72c6dc80e3eb305f5/src/InputOutput/writers.jl#L463-L475">source</a></section><section><div><pre><code class="language-julia hljs">write!(
    writer::HDF5Writer,
    field::Fields.Field,
    name::AbstractString,
    space::Spaces.AbstractSpace,
)</code></pre><p>Write an object of type &#39;Field&#39; and name &#39;name&#39; to the HDF5 file.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/CliMA/ClimaCore.jl/blob/8819db3f9615df160b53a0d72c6dc80e3eb305f5/src/InputOutput/writers.jl#L514-L523">source</a></section><section><div><pre><code class="language-julia hljs">write!(writer::HDF5Writer, name =&gt; value...)</code></pre><p>Write one or more <code>name =&gt; value</code> pairs to <code>writer</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/CliMA/ClimaCore.jl/blob/8819db3f9615df160b53a0d72c6dc80e3eb305f5/src/InputOutput/writers.jl#L596-L600">source</a></section><section><div><pre><code class="language-julia hljs">write!(filename::AbstractString, name =&gt; value...)</code></pre><p>Write one or more <code>name =&gt; value</code> pairs to the HDF5 file <code>filename</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/CliMA/ClimaCore.jl/blob/8819db3f9615df160b53a0d72c6dc80e3eb305f5/src/InputOutput/writers.jl#L609-L613">source</a></section></article><h3 id="Readers"><a class="docs-heading-anchor" href="#Readers">Readers</a><a id="Readers-1"></a><a class="docs-heading-anchor-permalink" href="#Readers" title="Permalink"></a></h3><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="ClimaCore.InputOutput.HDF5Reader" href="#ClimaCore.InputOutput.HDF5Reader"><code>ClimaCore.InputOutput.HDF5Reader</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">HDF5Reader(filename::AbstractString[, context::ClimaComms.AbstractCommsContext])
HDF5Reader(::Function, filename::AbstractString[, context::ClimaComms.AbstractCommsContext])</code></pre><p>An <code>AbstractReader</code> for reading from HDF5 files created by <a href="#ClimaCore.InputOutput.HDF5Writer"><code>HDF5Writer</code></a>. The reader object contains an internal cache of domains, meshes, topologies and spaces that are read so that duplicate objects are not created.</p><p>The optional <code>context</code> can be used for reading distributed fields: in this case, the <code>MPICommsContext</code> used passed as an argument: resulting <code>Field</code>s will be distributed using this context. As with <a href="#ClimaCore.InputOutput.HDF5Writer"><code>HDF5Writer</code></a>, this requires a HDF5 library with MPI support.</p><p><strong>Interface</strong></p><ul><li><a href="#ClimaCore.InputOutput.read_domain"><code>read_domain</code></a></li><li><a href="#ClimaCore.InputOutput.read_mesh"><code>read_mesh</code></a></li><li><a href="#ClimaCore.InputOutput.read_topology"><code>read_topology</code></a></li><li><a href="#ClimaCore.InputOutput.read_space"><code>read_space</code></a></li><li><a href="#ClimaCore.InputOutput.read_field"><code>read_field</code></a></li></ul><p><strong>Usage</strong></p><pre><code class="language-julia hljs">InputOutput.HDF5Reader(filename) do reader
    Y = read_field(reader, &quot;Y&quot;)
    Y.c |&gt; propertynames
    Y.f |&gt; propertynames
    ρ_field = read_field(reader, &quot;Y.c.ρ&quot;)
    w_field = read_field(reader, &quot;Y.f.w&quot;)
end</code></pre><p>To explore the contents of the <code>reader</code>, use either</p><pre><code class="language-julia hljs">julia&gt; reader |&gt; propertynames</code></pre><p>e.g, to explore the components of the <code>space</code>,</p><pre><code class="language-julia hljs">julia&gt; reader.space_cache
Dict{Any, Any} with 3 entries:
  &quot;center_extruded_finite_difference_space&quot; =&gt; CenterExtrudedFiniteDifferenceSpace:…
  &quot;horizontal_space&quot;                        =&gt; SpectralElementSpace2D:…
  &quot;face_extruded_finite_difference_space&quot;   =&gt; FaceExtrudedFiniteDifferenceSpace:…</code></pre><p>Once &quot;unpacked&quot; as shown above, <code>ClimaCorePlots</code> or <code>ClimaCoreMakie</code> can be used to visualise fields. <code>ClimaCoreTempestRemap</code> supports interpolation onto user-specified grids if necessary.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/CliMA/ClimaCore.jl/blob/8819db3f9615df160b53a0d72c6dc80e3eb305f5/src/InputOutput/readers.jl#L80-L128">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="ClimaCore.InputOutput.read_domain" href="#ClimaCore.InputOutput.read_domain"><code>ClimaCore.InputOutput.read_domain</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">read_domain(reader::AbstractReader, name)</code></pre><p>Reads a domain named <code>name</code> from <code>reader</code>. Domain objects are cached in the reader to avoid creating duplicate objects.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/CliMA/ClimaCore.jl/blob/8819db3f9615df160b53a0d72c6dc80e3eb305f5/src/InputOutput/readers.jl#L263-L268">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="ClimaCore.InputOutput.read_mesh" href="#ClimaCore.InputOutput.read_mesh"><code>ClimaCore.InputOutput.read_mesh</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">read_mesh(reader::AbstractReader, name)</code></pre><p>Reads a mesh named <code>name</code> from <code>reader</code>, or from the reader cache if it has already been read.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/CliMA/ClimaCore.jl/blob/8819db3f9615df160b53a0d72c6dc80e3eb305f5/src/InputOutput/readers.jl#L298-L303">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="ClimaCore.InputOutput.read_topology" href="#ClimaCore.InputOutput.read_topology"><code>ClimaCore.InputOutput.read_topology</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">read_topology(reader::AbstractReader, name)</code></pre><p>Reads a topology named <code>name</code> from <code>reader</code>, or from the reader cache if it has already been read.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/CliMA/ClimaCore.jl/blob/8819db3f9615df160b53a0d72c6dc80e3eb305f5/src/InputOutput/readers.jl#L351-L356">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="ClimaCore.InputOutput.read_space" href="#ClimaCore.InputOutput.read_space"><code>ClimaCore.InputOutput.read_space</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">read_space(reader::AbstractReader, name)</code></pre><p>Reads a space named <code>name</code> from <code>reader</code>, or from the reader cache if it has already been read.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/CliMA/ClimaCore.jl/blob/8819db3f9615df160b53a0d72c6dc80e3eb305f5/src/InputOutput/readers.jl#L478-L483">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="ClimaCore.InputOutput.read_field" href="#ClimaCore.InputOutput.read_field"><code>ClimaCore.InputOutput.read_field</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">read_field(reader, name)</code></pre><p>Reads a <code>Field</code> or <code>FieldVector</code> named <code>name</code> from <code>reader</code>. Fields are <em>not</em> cached, so that reading the same field multiple times will create multiple distinct objects.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/CliMA/ClimaCore.jl/blob/8819db3f9615df160b53a0d72c6dc80e3eb305f5/src/InputOutput/readers.jl#L533-L539">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="ClimaCore.InputOutput.defaultname" href="#ClimaCore.InputOutput.defaultname"><code>ClimaCore.InputOutput.defaultname</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">defaultname(obj)</code></pre><p>Default name of object for InputOutput writers.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/CliMA/ClimaCore.jl/blob/8819db3f9615df160b53a0d72c6dc80e3eb305f5/src/InputOutput/writers.jl#L136-L140">source</a></section></article><h2 id="Remapping"><a class="docs-heading-anchor" href="#Remapping">Remapping</a><a id="Remapping-1"></a><a class="docs-heading-anchor-permalink" href="#Remapping" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="ClimaCore.Remapping.interpolate_array" href="#ClimaCore.Remapping.interpolate_array"><code>ClimaCore.Remapping.interpolate_array</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">interpolate_array(field, xpts, ypts)
interpolate_array(field, xpts, ypts, zpts)</code></pre><p>Interpolate a field to a regular array using pointwise interpolation.</p><p>This is primarily used for plotting and diagnostics.</p><p><strong>Examples</strong></p><pre><code class="language-julia hljs">longpts = range(Geometry.LongPoint(-180.0), Geometry.LongPoint(180.0), length = 21)
latpts = range(Geometry.LatPoint(-80.0), Geometry.LatPoint(80.0), length = 21)
zpts = range(Geometry.ZPoint(0.0), Geometry.ZPoint(1000.0), length = 21)

interpolate_array(field, longpts, latpts, zpts)</code></pre><div class="admonition is-info"><header class="admonition-header">Note</header><div class="admonition-body"><p>Hypsography is not currently handled correctly.</p></div></div></div><a class="docs-sourcelink" target="_blank" href="https://github.com/CliMA/ClimaCore.jl/blob/8819db3f9615df160b53a0d72c6dc80e3eb305f5/src/Remapping/interpolate_array.jl#L235-L255">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="ClimaCore.Remapping.interpolate" href="#ClimaCore.Remapping.interpolate"><code>ClimaCore.Remapping.interpolate</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><p>interpolate(remapper::Remapper, fields)    interpolate!(dest, remapper::Remapper, fields)</p><p>Interpolate the given <code>field</code>(s) as prescribed by <code>remapper</code>.</p><p>The optimal number of fields passed is the <code>buffer_length</code> of the <code>remapper</code>. If more fields are passed, the <code>remapper</code> will batch work with size up to its <code>buffer_length</code>.</p><p>This call mutates the internal (private) state of the <code>remapper</code>.</p><p>Horizontally, interpolation is performed with the barycentric formula in [<a href="../references/#Berrut2004">12</a>], equation (3.2). Vertical interpolation is linear except in the boundary elements where it is 0th order.</p><p><code>interpolate!</code> writes the output to the given <code>dest</code>iniation. <code>dest</code> is expected to be defined on the root process and to be <code>nothing</code> for the other processes.</p><p>Note: <code>interpolate</code> allocates new arrays and has some internal type-instability, <code>interpolate!</code> is non-allocating and type-stable.</p><p>When using <code>interpolate!</code>, the <code>dest</code>ination has to be the same array type as the device in use (e.g., <code>CuArray</code> for CUDA runs).</p><p><strong>Example</strong></p><p>Given <code>field1</code>,<code>field2</code>, two <code>Field</code> defined on a cubed sphere.</p><pre><code class="language-julia hljs">longpts = range(-180.0, 180.0, 21)
latpts = range(-80.0, 80.0, 21)
zpts = range(0.0, 1000.0, 21)

hcoords = [Geometry.LatLongPoint(lat, long) for long in longpts, lat in latpts]
zcoords = [Geometry.ZPoint(z) for z in zpts]

space = axes(field1)

remapper = Remapper(space, hcoords, zcoords)

int1 = interpolate(remapper, field1)
int2 = interpolate(remapper, field2)

# Or
int12 = interpolate(remapper, [field1, field2])
# With int1 = int12[1, :, :, :]</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/CliMA/ClimaCore.jl/blob/8819db3f9615df160b53a0d72c6dc80e3eb305f5/src/Remapping/distributed_remapping.jl#L801-L850">source</a></section><section><div><pre><code class="language-julia hljs">   interpolate(field::ClimaCore.Fields;
               hresolution = 180,
               zresolution = nothing,
               target_hcoords = default_target_hcoords(space; hresolution),
               target_zcoords = default_target_zcoords(space; zresolution)
               )</code></pre><p>Interpolate the given fields on the Cartesian product of <code>target_hcoords</code> with <code>target_zcoords</code>. For <code>Space</code>s without horizontal/vertical component, the relevant <code>target_*coords</code> are ignored.</p><p>When <code>zresolution</code> is set to <code>nothing</code>, do not perform any interpolation in the vertical direction. When <code>zresolution</code>, perform linear interpolation with uniformly spaced levels.</p><p>Coordinates have to be <code>ClimaCore.Geometry.Points</code>.</p><p>Note: do not use this method when performance is important. Instead, define a <code>Remapper</code> and call <code>interpolate(remapper, fields)</code>. Different <code>Field</code>s defined on the same <code>Space</code> can share a <code>Remapper</code>, so that interpolation can be optimized.</p><p><strong>Example</strong></p><p>Given <code>field</code>, a <code>Field</code> defined on a cubed sphere.</p><p>By default, a target uniform grid is chosen (with resolution <code>hresolution</code> and <code>zresolution</code>), so remapping is simply</p><pre><code class="language-julia hljs">julia&gt; interpolate(field)</code></pre><p>This will return an array of interpolated values.</p><p>Resolution can be specified</p><pre><code class="language-julia hljs">julia&gt; interpolate(field; hresolution = 100, zresolution = 50)</code></pre><p>Coordinates can be also specified directly:</p><pre><code class="language-julia hljs">julia&gt; longpts = range(-180.0, 180.0, 21)
julia&gt; latpts = range(-80.0, 80.0, 21)
julia&gt; zpts = range(0.0, 1000.0, 21)

julia&gt; hcoords = [Geometry.LatLongPoint(lat, long) for long in longpts, lat in latpts]
julia&gt; zcoords = [Geometry.ZPoint(z) for z in zpts]

julia&gt; interpolate(field, target_hcoords, target_zcoords)</code></pre><p>If you need the array of coordinates, you can call <code>default_target_hcoords</code> (or <code>default_target_zcoords</code>) passing <code>axes(field)</code>. This will return an array of <code>Geometry.Point</code>s. The functions <code>Geometry.Components</code> and <code>Geometry.Component</code> can be used to extract the components as numeric values. For example,</p><pre><code class="language-julia hljs">julia&gt; Geometry.components.(Geometry.components.([
           Geometry.LatLongPoint(x, y) for x in range(-180.0, 180.0, length = 180),
           y in range(-90.0, 90.0, length = 180)
       ]))
180×180 Matrix{StaticArraysCore.SVector{2, Float64}}:
 [-180.0, -90.0]    [-180.0, -88.9944]    …  [-180.0, 88.9944]    [-180.0, 90.0]
  ⋮                                        ⋱
 [180.0, -90.0]     [180.0, -88.9944]        [180.0, 88.9944]     [180.0, 90.0]</code></pre><p>To extract only long or lat, one can broadcast <code>getindex</code></p><pre><code class="language-julia hljs">julia&gt; lats = getindex.(Geometry.components.([Geometry.LatLongPoint(x, y)
                                              for x in range(-180.0, 180.0, length = 180),
                                                  y in range(-90.0, 90.0, length = 180)
                                             ]),
                        1)</code></pre><p>This can be used directly for plotting.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/CliMA/ClimaCore.jl/blob/8819db3f9615df160b53a0d72c6dc80e3eb305f5/src/Remapping/distributed_remapping.jl#L945-L1017">source</a></section></article><h2 id="Converting-between-devices"><a class="docs-heading-anchor" href="#Converting-between-devices">Converting between devices</a><a id="Converting-between-devices-1"></a><a class="docs-heading-anchor-permalink" href="#Converting-between-devices" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="ClimaCore.to_device" href="#ClimaCore.to_device"><code>ClimaCore.to_device</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">out = to_device(device, x::Union{
    DataLayouts.AbstractData,
    Spaces.AbstractSpace,
    Fields.Field,
    Fields.FieldVector,
})</code></pre><p>Move <code>x</code> to the given <code>device</code>.</p><p>This is particularly useful to move different types of <code>Space.AbstractSpace</code>s, <code>Fields.Field</code>s, and <code>Fields.FieldVector</code>s from CPUs to GPUs and viceversa.</p><p>If the input is already defined on the target device, returns a copy.</p><p>This means that <code>out === x</code> will not in general be satisfied.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/CliMA/ClimaCore.jl/blob/8819db3f9615df160b53a0d72c6dc80e3eb305f5/src/to_device.jl#L4-L20">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="ClimaCore.to_cpu" href="#ClimaCore.to_cpu"><code>ClimaCore.to_cpu</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">out = to_cpu(x::Union{
    DataLayouts.AbstractData,
    Spaces.AbstractSpace,
    Fields.Field,
    Fields.FieldVector,
})</code></pre><p>Move <code>x</code> backing data to the CPU.</p><p>This is particularly useful for <code>Space.AbstractSpace</code>s, <code>Fields.Field</code>s, and <code>Fields.FieldVector</code>s.</p><p>Returns a copy.</p><p>This means that <code>out === x</code> will not in general be satisfied.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/CliMA/ClimaCore.jl/blob/8819db3f9615df160b53a0d72c6dc80e3eb305f5/src/to_device.jl#L36-L52">source</a></section></article><h2 id="DebugOnly"><a class="docs-heading-anchor" href="#DebugOnly">DebugOnly</a><a id="DebugOnly-1"></a><a class="docs-heading-anchor-permalink" href="#DebugOnly" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="ClimaCore.DebugOnly" href="#ClimaCore.DebugOnly"><code>ClimaCore.DebugOnly</code></a> — <span class="docstring-category">Module</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">DebugOnly</code></pre><p>A module for debugging tools. Note that any tools in here are subject to sudden changes without warning. So, please, do <em>not</em> use any of these tools in production as support for them are not guaranteed.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/CliMA/ClimaCore.jl/blob/8819db3f9615df160b53a0d72c6dc80e3eb305f5/src/DebugOnly/DebugOnly.jl#L1-L7">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="ClimaCore.DebugOnly.call_post_op_callback" href="#ClimaCore.DebugOnly.call_post_op_callback"><code>ClimaCore.DebugOnly.call_post_op_callback</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">call_post_op_callback()</code></pre><p>Returns a Bool. Meant to be overloaded so that <code>ClimaCore.DataLayouts.post_op_callback(result, args...; kwargs...)</code> is called after every data operation.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/CliMA/ClimaCore.jl/blob/8819db3f9615df160b53a0d72c6dc80e3eb305f5/src/DebugOnly/DebugOnly.jl#L25-L31">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="ClimaCore.DebugOnly.post_op_callback" href="#ClimaCore.DebugOnly.post_op_callback"><code>ClimaCore.DebugOnly.post_op_callback</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">post_op_callback(result, args...; kwargs...)</code></pre><p>A callback that is called, if <code>ClimaCore.DataLayouts.call_post_op_callback() = true</code>, on the result of every data operation.</p><p>There is purposely no implementation– this is a debugging tool, and users may want to check different things.</p><p>Note that, since this method is called in so many places, this is a performance-critical code path and expensive operations performed in <code>post_op_callback</code> may significantly slow down your code.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/CliMA/ClimaCore.jl/blob/8819db3f9615df160b53a0d72c6dc80e3eb305f5/src/DebugOnly/DebugOnly.jl#L10-L22">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="ClimaCore.DebugOnly.example_debug_post_op_callback" href="#ClimaCore.DebugOnly.example_debug_post_op_callback"><code>ClimaCore.DebugOnly.example_debug_post_op_callback</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">example_debug_post_op_callback(result, args...; kwargs...)</code></pre><p>An example <code>post_op_callback</code> method, that checks for <code>NaN</code>s and <code>Inf</code>s.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/CliMA/ClimaCore.jl/blob/8819db3f9615df160b53a0d72c6dc80e3eb305f5/src/DebugOnly/DebugOnly.jl#L36-L40">source</a></section></article></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../matrix_fields/">« MatrixFields</a><a class="docs-footer-nextpage" href="../performance_tips/">Performance tips »</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="auto">Automatic (OS)</option><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option><option value="catppuccin-latte">catppuccin-latte</option><option value="catppuccin-frappe">catppuccin-frappe</option><option value="catppuccin-macchiato">catppuccin-macchiato</option><option value="catppuccin-mocha">catppuccin-mocha</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 1.10.1 on <span class="colophon-date" title="Friday 4 April 2025 16:59">Friday 4 April 2025</span>. Using Julia version 1.10.9.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
