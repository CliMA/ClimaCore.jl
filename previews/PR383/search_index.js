var documenterSearchIndex = {"docs":
[{"location":"api/#API","page":"API","title":"API","text":"","category":"section"},{"location":"api/","page":"API","title":"API","text":"CurrentModule = ClimaCore","category":"page"},{"location":"api/#DataLayouts","page":"API","title":"DataLayouts","text":"","category":"section"},{"location":"api/","page":"API","title":"API","text":"DataLayouts\nDataLayouts.IJFH","category":"page"},{"location":"api/#ClimaCore.DataLayouts","page":"API","title":"ClimaCore.DataLayouts","text":"ClimaCore.DataLayouts\n\nNotation:\n\ni,j are horizontal node indices within an element\nk is the vertical node index within an element\nf is the field index\nv is the vertical element index in a stack\nh is the element stack index\n\nData layout is specified by the order in which they appear, e.g. IJKFVH indexes the underlying array as [i,j,k,f,v,h]\n\n\n\n\n\n","category":"module"},{"location":"api/#ClimaCore.DataLayouts.IJFH","page":"API","title":"ClimaCore.DataLayouts.IJFH","text":"IJFH{S, Nij, A} <: Data2D{S, Nij}\n\nBacking DataLayout for 2D spectral element slabs.\n\nElement nodal point (I,J) data is contiguous for each datatype S struct field (F), for each 2D mesh element slab (H).\n\n\n\n\n\n","category":"type"},{"location":"api/#Geometry","page":"API","title":"Geometry","text":"","category":"section"},{"location":"api/#Coordinates","page":"API","title":"Coordinates","text":"","category":"section"},{"location":"api/","page":"API","title":"API","text":"Geometry.AbstractPoint\nGeometry.float_type","category":"page"},{"location":"api/#ClimaCore.Geometry.AbstractPoint","page":"API","title":"ClimaCore.Geometry.AbstractPoint","text":"AbstractPoint\n\nRepresents a point in space.\n\nThe following types are supported:\n\nXPoint(x)\nYPoint(y)\nZPoint(z)\nXYPoint(x, y)\nXZPoint(x, z)\nXYZPoint(x, y, z)\nLatLongPoint(lat, long)\nLatLongZPoint(lat, long, z)\nCartesian1Point(x1)\nCartesian2Point(x2)\nCartesian3Point(x3)\nCartesian12Point(x1, x2)\nCartesian13Point(x1, x3)\nCartesian123Point(x1, x2, x3)\n\n\n\n\n\n","category":"type"},{"location":"api/#ClimaCore.Geometry.float_type","page":"API","title":"ClimaCore.Geometry.float_type","text":"float_type(T)\n\nReturn the floating point type backing T: T can either be an object or a type.\n\n\n\n\n\n","category":"function"},{"location":"api/#Domains","page":"API","title":"Domains","text":"","category":"section"},{"location":"api/#Types","page":"API","title":"Types","text":"","category":"section"},{"location":"api/","page":"API","title":"API","text":"Domains.AbstractDomain\nDomains.IntervalDomain\nDomains.RectangleDomain\nDomains.SphereDomain","category":"page"},{"location":"api/#ClimaCore.Domains.AbstractDomain","page":"API","title":"ClimaCore.Domains.AbstractDomain","text":"AbstractDomain\n\nA domain represents a region of space.\n\n\n\n\n\n","category":"type"},{"location":"api/#ClimaCore.Domains.IntervalDomain","page":"API","title":"ClimaCore.Domains.IntervalDomain","text":"IntervalDomain(coord⁻, coord⁺; periodic=true)\nIntervalDomain(coord⁻, coord⁺; boundary_names::Tuple{Symbol,Symbol})\n\nConstruct a IntervalDomain, the closed interval is given by coord⁻, coord⁺ coordinate arguments.\n\nEither a periodic or boundary_names keyword argument is required.\n\n\n\n\n\n","category":"type"},{"location":"api/#ClimaCore.Domains.RectangleDomain","page":"API","title":"ClimaCore.Domains.RectangleDomain","text":"RectangleDomain(x1::ClosedInterval, x2::ClosedInterval;\n    x1boundary::Tuple{Symbol,Symbol},\n    x2boundary::Tuple{Symbol,Symbol},\n    x1periodic = false,\n    x2periodic = false,\n)\n\nConstruct a RectangularDomain in the horizontal. If a given x1 or x2 boundary is not periodic, then x1boundary or x2boundary boundary name keyword arguments must be supplied.\n\n\n\n\n\n","category":"type"},{"location":"api/#ClimaCore.Domains.SphereDomain","page":"API","title":"ClimaCore.Domains.SphereDomain","text":"SphereDomain(radius)\n\nA domain representing the surface of a sphere with radius radius.\n\n\n\n\n\n","category":"type"},{"location":"api/#Interfaces","page":"API","title":"Interfaces","text":"","category":"section"},{"location":"api/","page":"API","title":"API","text":"Domains.boundary_names","category":"page"},{"location":"api/#ClimaCore.Domains.boundary_names","page":"API","title":"ClimaCore.Domains.boundary_names","text":"boundary_names(obj::Union{AbstractDomain, AbstractMesh, AbstractTopology})\n\nA tuple or vector of unique boundary names of a spatial domain.\n\n\n\n\n\n","category":"function"},{"location":"api/#Meshes","page":"API","title":"Meshes","text":"","category":"section"},{"location":"api/#Mesh-types","page":"API","title":"Mesh types","text":"","category":"section"},{"location":"api/","page":"API","title":"API","text":"Meshes.AbstractMesh\nMeshes.IntervalMesh\nMeshes.RectilinearMesh\nMeshes.AbstractCubedSphere\nMeshes.EquiangularCubedSphere\nMeshes.EquidistantCubedSphere\nMeshes.ConformalCubedSphere","category":"page"},{"location":"api/#ClimaCore.Meshes.AbstractMesh","page":"API","title":"ClimaCore.Meshes.AbstractMesh","text":"AbstractMesh{dim}\n\nA Mesh is an object which represents how we discretize a domain into elements.\n\nIt should be lightweight (i.e. exists on all MPI ranks), e.g for meshes stored in a file, it would contain the filename.\n\nFace and vertex numbering\n\nIn 1D, faces and vertices are the same, and both are numbered [1,2].\n\nIn 2D, a face is a line segment between to vertices, and both are numbered [1,2,3,4], in a counter-clockwise direction.\n\n v4        f3        v3\n   o-----------------o\n   |                 |\t    face    vertices\n   |                 |\t      f1 =>  v1 v2\nf4 |                 | f2     f2 =>  v2 v3\n   |                 |\t      f3 =>  v3 v4\n   |                 |        f4 =>  v4 v1\n   |                 |\n   o-----------------o\n  v1       f1        v2\n\nInterface\n\nA subtype of AbstractMesh should define the following methods:\n\ndomain(mesh)\nelements(mesh)\nis_boundary_face(mesh, elem, face)\nboundary_face_name(mesh, elem, face)\nopposing_face(mesh, elem, face)\ncoordinates(mesh, elem, vert)\ncontaining_element (optional)\n\nThe following types/methods are provided by AbstractMesh:\n\nSharedVertices(mesh, elem, vert)\n[face_connectivity_matrix(mesh[,elemorder])]\n[vertex_connectivity_matrix(mesh[,elemorder])]\n\n\n\n\n\n","category":"type"},{"location":"api/#ClimaCore.Meshes.IntervalMesh","page":"API","title":"ClimaCore.Meshes.IntervalMesh","text":"IntervalMesh <: AbstractMesh\n\nA 1D mesh on an IntervalDomain.\n\nConstuctors\n\nIntervalMesh(domain::IntervalDomain, faces::AbstractVector)\n\nConstruct a 1D mesh with face locations at faces.\n\nIntervalMesh(domain::IntervalDomain[, stetching=Uniform()]; nelems=)\n\nConstuct a 1D mesh on domain with nelems elements, using stretching. Possible values of stretching are:\n\nUniform()\nExponentialStretching(H)\n\n\n\n\n\n","category":"type"},{"location":"api/#ClimaCore.Meshes.RectilinearMesh","page":"API","title":"ClimaCore.Meshes.RectilinearMesh","text":"RectilinearMesh <: AbstractMesh2D\n\nConstructors\n\nRectilinearMesh(domain::RectangleDomain, n1, n2)\n\nConstruct a RectilinearMesh of equally-spaced n1 by n2 elements on domain.\n\nRectilinearMesh(intervalmesh1::IntervalMesh1, intervalmesh2::IntervalMesh2)\n\nConstruct the product mesh of intervalmesh1 and intervalmesh2.\n\n\n\n\n\n","category":"type"},{"location":"api/#ClimaCore.Meshes.AbstractCubedSphere","page":"API","title":"ClimaCore.Meshes.AbstractCubedSphere","text":"AbstractCubedSphere <: AbstractMesh2D\n\nThis is an abstract type of cubed-sphere meshes on SphereDomains. A cubed-sphere mesh has 6 panels, laid out as follows:\n\n                                          :   Panel 1   :\n                            +-------------+-------------+\n                            |     +x1     |     +x1     |\n                            |             |             |\n                            |    Panel    |    Panel    |\n                            |+x3   5   -x3|-x2   6   +x2|\n                            |     -x2     |     -x3     |\n                            |             |             |\n                            |     -x1     |     -x1     |\n              +-------------+-------------+-------------+\n              |     -x2     |     -x2     |\n              |             |             |\n              |    Panel    |    Panel    |\n              |+x1   3   -x1|+x3   4   -x3|\n              |     +x3     |     -x1     |\n              |             |             |\n              |     +x2     |     +x2     |\n+-------------+-------------+-------------+\n|     +x3     |     +x3     |\n|             |             |\n|    Panel    |    Panel    |\n|-x2   1   +x2|+x1   2   -x1|\n|     +x1     |     +x2     |\n|             |             |\n|     -x3     |     -x3     |\n+-------------+-------------+\n:   Panel 6   :\n\nThis is the same panel ordering used by the (though we use 1-based instead of 0-based numering).\n\nElements are indexed by a CartesianIndex{3} object, where the components are:\n\nhorizontal element index (left to right) within each panel.\nvertical element index (bottom to top) within each panel.\npanel number\n\nSubtypes should have the following fields:\n\ndomain: a SphereDomain\nne: number of elements across each panel\n\nExternal links\n\nS2Geometry library\nMIT GCM exch2\n\n\n\n\n\n","category":"type"},{"location":"api/#ClimaCore.Meshes.EquiangularCubedSphere","page":"API","title":"ClimaCore.Meshes.EquiangularCubedSphere","text":"EquiangularCubedSphere <: AbstractCubedSphere\n\nAn equiangular gnomonic mesh proposed by [Ronchi1996] Uses the element indexing convention of AbstractCubedSphere.\n\nConstructors\n\nEquiangularCubedSphere(domain::Domains.SphereDomain, ne::Integer)\n\nConstuct an EquiangularCubedSphere on domain with ne elements across each panel.\n\nReferences\n\nThe \"Cubed Sphere\": A New Method for the Solution of Partial Differential Equations in Spherical Geometry C. RONCHI, R. IACONO, AND P. S. PAOLUCCI JOURNAL OF COMPUTATIONAL PHYSICS 124, 93–114 (1996)\n\n\n\n\n\n","category":"type"},{"location":"api/#ClimaCore.Meshes.EquidistantCubedSphere","page":"API","title":"ClimaCore.Meshes.EquidistantCubedSphere","text":"EquidistantCubedSphere <: AbstractCubedSphere\n\nAn equidistant gnomonic mesh outlined in [Rancic1996] and [Nair2005]. Uses the element indexing convention of AbstractCubedSphere.\n\nConstructors\n\nEquidistantCubedSphere(domain::Domains.SphereDomain, ne::Integer)\n\nConstuct an EquidistantCubedSphere on domain with ne elements across each panel.\n\nReferences\n\nA global shallow-water model using an expanded spherical cube: Gnomonic versus conformal coordinates Rančić M., Purser R. J., Mesinger F. https://doi.org/10.1002/qj.49712253209\nA Discontinuous Galerkin Transport Scheme on the Cubed Sphere Ramachandran D. Nair, Stephen J. Thomas, and Richard D. Loft https://doi.org/10.1175/MWR2890.1\n\n\n\n\n\n","category":"type"},{"location":"api/#ClimaCore.Meshes.ConformalCubedSphere","page":"API","title":"ClimaCore.Meshes.ConformalCubedSphere","text":"ConformalCubedSphere <: AbstractCubedSphere\n\nA conformal mesh outlined in [Rancic1996] and [Nair2005] Uses the element indexing convention of AbstractCubedSphere.\n\nConstructors\n\nConformalCubedSphere(domain::Domains.SphereDomain, ne::Integer)\n\nConstuct an ConformalCubedSphere on domain with ne elements across each panel.\n\nReferences\n\nA global shallow-water model using an expanded spherical cube: Gnomonic versus conformal coordinates Rančić M., Purser R. J., Mesinger F. https://doi.org/10.1002/qj.49712253209\n\n\n\n\n\n","category":"type"},{"location":"api/#Mesh-stretching","page":"API","title":"Mesh stretching","text":"","category":"section"},{"location":"api/","page":"API","title":"API","text":"Meshes.Uniform\nMeshes.ExponentialStretching","category":"page"},{"location":"api/#ClimaCore.Meshes.Uniform","page":"API","title":"ClimaCore.Meshes.Uniform","text":"Uniform()\n\nUse uniformly-sized elements.\n\n\n\n\n\n","category":"type"},{"location":"api/#ClimaCore.Meshes.ExponentialStretching","page":"API","title":"ClimaCore.Meshes.ExponentialStretching","text":"ExponentialStretching(H)\n\nApply exponential stretching to the domain when constructing elements. H is the scale height (a typical atmospheric scale height H ≈ 7.5km).\n\nFor an interval z_0z_1, this makes the elements uniformally spaced in zeta, where\n\nzeta = frac1 - e^-etah1-e^-1h\n\nwhere eta = fracz - z_0z_1-z_0, and h = fracHz_1-z_0 is the non-dimensional scale height.\n\n\n\n\n\n","category":"type"},{"location":"api/#Interfaces-2","page":"API","title":"Interfaces","text":"","category":"section"},{"location":"api/","page":"API","title":"API","text":"Meshes.domain\nMeshes.elements\nMeshes.nelements\nMeshes.is_boundary_face\nMeshes.boundary_face_name\nMeshes.opposing_face\nMeshes.containing_element\nMeshes.SharedVertices\nMeshes.face_connectivity_matrix\nMeshes.vertex_connectivity_matrix\nMeshes.linearindices","category":"page"},{"location":"api/#ClimaCore.Meshes.domain","page":"API","title":"ClimaCore.Meshes.domain","text":"Meshes.domain(mesh::AbstractMesh)\n\nThe Domains.AbstractDomain on which the mesh is defined.\n\n\n\n\n\n","category":"function"},{"location":"api/#ClimaCore.Meshes.elements","page":"API","title":"ClimaCore.Meshes.elements","text":"Meshes.elements(mesh::AbstractMesh)\n\nAn iterator over the elements of a mesh. Elements of a mesh can be of any type.\n\n\n\n\n\n","category":"function"},{"location":"api/#ClimaCore.Meshes.is_boundary_face","page":"API","title":"ClimaCore.Meshes.is_boundary_face","text":"Meshes.is_boundary_face(mesh::AbstractMesh, elem, face::Int)::Bool\n\nDetermine whether face face of element elem is on the boundary of mesh.\n\nelem should be an element of elements(mesh).\n\n\n\n\n\n","category":"function"},{"location":"api/#ClimaCore.Meshes.boundary_face_name","page":"API","title":"ClimaCore.Meshes.boundary_face_name","text":"Meshes.boundary_face_name(mesh::AbstractMesh, elem, face::Int)::Union{Symbol,Nothing}\n\nThe name of the boundary facing face of element elem, or nothing if it is not on the boundary.\n\n\n\n\n\n","category":"function"},{"location":"api/#ClimaCore.Meshes.opposing_face","page":"API","title":"ClimaCore.Meshes.opposing_face","text":"opelem, opface, reversed = Meshes.opposing_face(mesh::AbstractMesh, elem, face::Int)\n\nThe element and face (opelem, opface) that oppose face face of element elem.\n\n\n\n\n\n","category":"function"},{"location":"api/#ClimaCore.Meshes.containing_element","page":"API","title":"ClimaCore.Meshes.containing_element","text":"elem, (ξ1, ξ2) = Meshes.containing_element(mesh::AbstractCubedSphere, coord)\n\nReturn the element (elem) in mesh containing the coordinate coord, and the position (ξ1, ξ2) within the reference element.\n\n\n\n\n\n","category":"function"},{"location":"api/#ClimaCore.Meshes.SharedVertices","page":"API","title":"ClimaCore.Meshes.SharedVertices","text":"Meshes.SharedVertices(mesh, elem, vert)\n\nAn iterator over (element, vertex) pairs that are shared with (elem,vert).\n\n\n\n\n\n","category":"type"},{"location":"api/#ClimaCore.Meshes.face_connectivity_matrix","page":"API","title":"ClimaCore.Meshes.face_connectivity_matrix","text":"M = Meshes.face_connectivity_matrix(mesh, elemorder = elements(mesh))\n\nConstruct a Bool-valued SparseCSCMatrix containing the face connections of mesh. Elements are indexed according to elemorder.\n\nNote that M[i,i] == true only if two distinct faces of element i are connected.\n\n\n\n\n\n","category":"function"},{"location":"api/#ClimaCore.Meshes.vertex_connectivity_matrix","page":"API","title":"ClimaCore.Meshes.vertex_connectivity_matrix","text":"M = Meshes.vertex_connectivity_matrix(mesh, elemorder = elements(mesh))\n\nConstruct a Bool-valued SparseCSCMatrix containing the vertex connections of mesh. Elements are indexed according to elemorder.\n\nNote that M[i,i] == true only if two distinct vertices of element i are connected.\n\n\n\n\n\n","category":"function"},{"location":"api/#ClimaCore.Meshes.linearindices","page":"API","title":"ClimaCore.Meshes.linearindices","text":"Meshes.linearindices(elemorder)\n\nGiven a data structure elemorder[i] = elem that orders elements, construct the inverse map from orderindex = linearindices(elemorder) such that orderindex[elem] = i.\n\nThis will try to use the most efficient structure available.\n\n\n\n\n\n","category":"function"},{"location":"api/#Topologies","page":"API","title":"Topologies","text":"","category":"section"},{"location":"api/#Types-2","page":"API","title":"Types","text":"","category":"section"},{"location":"api/","page":"API","title":"API","text":"Topologies.AbstractTopology\nTopologies.IntervalTopology\nTopologies.Topology2D","category":"page"},{"location":"api/#ClimaCore.Topologies.AbstractTopology","page":"API","title":"ClimaCore.Topologies.AbstractTopology","text":"AbstractTopology\n\nSubtypes of AbstractHorizontalTopology define connectiveness of a mesh in the horizontal domain.\n\nInterfaces\n\nnlocalelems\nvertex_coordinates\ninterior_faces\nvertices\nboundary_tags\nboundary_tag\nboundary_faces\n\n\n\n\n\n","category":"type"},{"location":"api/#ClimaCore.Topologies.IntervalTopology","page":"API","title":"ClimaCore.Topologies.IntervalTopology","text":"IntervalTopology(mesh::IntervalMesh)\n\nA sequential topology on an Meshes.IntervalMesh.\n\n\n\n\n\n","category":"type"},{"location":"api/#ClimaCore.Topologies.Topology2D","page":"API","title":"ClimaCore.Topologies.Topology2D","text":"Topology2D(mesh::AbstractMesh2D, elemorder=Mesh.elements(mesh))\n\nThis is a generic non-distributed topology for 2D meshes. elemorder is a vector or other linear ordering of the Mesh.elements(mesh).\n\n\n\n\n\n","category":"type"},{"location":"api/#Interfaces-3","page":"API","title":"Interfaces","text":"","category":"section"},{"location":"api/","page":"API","title":"API","text":"Topologies.nlocalelems\nTopologies.vertex_coordinates\nTopologies.opposing_face\nTopologies.interior_faces\nTopologies.boundary_tags\nTopologies.boundary_tag\nTopologies.boundary_faces\nTopologies.vertices","category":"page"},{"location":"api/#ClimaCore.Topologies.nlocalelems","page":"API","title":"ClimaCore.Topologies.nlocalelems","text":"nlocalelems(topology)\n\nThe number of local elements in topology.\n\n\n\n\n\n","category":"function"},{"location":"api/#ClimaCore.Topologies.vertex_coordinates","page":"API","title":"ClimaCore.Topologies.vertex_coordinates","text":"(c1,c2,c3,c4) = vertex_coordinates(topology, elem)\n\nThe coordinates of the 4 vertices of element elem.\n\n\n\n\n\n","category":"function"},{"location":"api/#ClimaCore.Topologies.opposing_face","page":"API","title":"ClimaCore.Topologies.opposing_face","text":"(opelem, opface, reversed) = opposing_face(topology, elem, face)\n\nThe opposing face of face number face of element elem in topology.\n\nopelem is the opposing element number, 0 for a boundary, negative for a ghost element\nopface is the opposite face number, or boundary face number if a boundary\nreversed indicates whether the opposing face has the opposite orientation.\n\n\n\n\n\n","category":"function"},{"location":"api/#ClimaCore.Topologies.interior_faces","page":"API","title":"ClimaCore.Topologies.interior_faces","text":"interior_faces(topology::AbstractTopology)\n\nAn iterator over the interior faces of topology. Each element of the iterator is a 5-tuple the form\n\n(elem1, face1, elem2, face2, reversed)\n\nwhere elemX, faceX are the element and face numbers, and reversed indicates whether they have opposing orientations.\n\n\n\n\n\n","category":"function"},{"location":"api/#ClimaCore.Topologies.boundary_tags","page":"API","title":"ClimaCore.Topologies.boundary_tags","text":"boundary_tags(topology)\n\nA Tuple or NamedTuple of the boundary tags of the topology. A boundary tag is an integer that uniquely identifies a boundary.\n\n\n\n\n\n","category":"function"},{"location":"api/#ClimaCore.Topologies.boundary_tag","page":"API","title":"ClimaCore.Topologies.boundary_tag","text":"boundary_tag(topology, name::Symbol)\n\nThe boundary tag of the topology for boundary name name. A boundary tag is an integer that uniquely identifies a boundary.\n\n\n\n\n\n","category":"function"},{"location":"api/#ClimaCore.Topologies.boundary_faces","page":"API","title":"ClimaCore.Topologies.boundary_faces","text":"boundary_faces(topology, boundarytag)\n\nAn iterator over the faces of topology which face the boundary with tag boundarytag. Each element of the iterator is an (elem, face) pair.\n\n\n\n\n\n","category":"function"},{"location":"api/#ClimaCore.Topologies.vertices","page":"API","title":"ClimaCore.Topologies.vertices","text":"vertices(topology)\n\nAn iterator over the unique (shared) vertices of the topology topology. Each vertex is an iterator over (element, vertex_number) pairs.\n\n\n\n\n\n","category":"function"},{"location":"api/#Spaces","page":"API","title":"Spaces","text":"","category":"section"},{"location":"api/","page":"API","title":"API","text":"Spaces\nSpaces.Quadratures.degrees_of_freedom\nSpaces.Quadratures.GL\nSpaces.Quadratures.Uniform\nSpaces.Quadratures.quadrature_points\nSpaces.Quadratures.GLL\nSpaces.Quadratures.polynomial_degree\nSpaces.Quadratures.QuadratureStyle","category":"page"},{"location":"api/#ClimaCore.Spaces","page":"API","title":"ClimaCore.Spaces","text":"Meshes\n\ndomain\ntopology\ncoordinates\nmetric terms (inverse partial derivatives)\nquadrature rules and weights\n\nReferences / notes\n\nceed\nQA\n\n\n\n\n\n","category":"module"},{"location":"api/#ClimaCore.Spaces.Quadratures.degrees_of_freedom","page":"API","title":"ClimaCore.Spaces.Quadratures.degrees_of_freedom","text":"degrees_of_freedom(QuadratureStyle) -> Int\n\nReturns the degreesoffreedom of the QuadratureStyle concrete type\n\n\n\n\n\n","category":"function"},{"location":"api/#ClimaCore.Spaces.Quadratures.GL","page":"API","title":"ClimaCore.Spaces.Quadratures.GL","text":"GL{Nq}()\n\nGauss-Legendre quadrature using Nq quadrature points.\n\n\n\n\n\n","category":"type"},{"location":"api/#ClimaCore.Spaces.Quadratures.Uniform","page":"API","title":"ClimaCore.Spaces.Quadratures.Uniform","text":"Uniform{Nq}()\n\nUniformly-spaced quadrature.\n\n\n\n\n\n","category":"type"},{"location":"api/#ClimaCore.Spaces.Quadratures.quadrature_points","page":"API","title":"ClimaCore.Spaces.Quadratures.quadrature_points","text":"points, weights = quadrature_points(::Type{FT}, quadrature_style)\n\nThe points and weights of the quadrature rule in floating point type FT.\n\n\n\n\n\n","category":"function"},{"location":"api/#ClimaCore.Spaces.Quadratures.GLL","page":"API","title":"ClimaCore.Spaces.Quadratures.GLL","text":"GLL{Nq}()\n\nGauss-Legendre-Lobatto quadrature using Nq quadrature points.\n\n\n\n\n\n","category":"type"},{"location":"api/#ClimaCore.Spaces.Quadratures.polynomial_degree","page":"API","title":"ClimaCore.Spaces.Quadratures.polynomial_degree","text":"polynomial_degree(QuadratureStyle) -> Int\n\nReturns the polynomial degree of the QuadratureStyle concrete type\n\n\n\n\n\n","category":"function"},{"location":"api/#ClimaCore.Spaces.Quadratures.QuadratureStyle","page":"API","title":"ClimaCore.Spaces.Quadratures.QuadratureStyle","text":"QuadratureStyle\n\nQuadrature style supertype. See sub-types:\n\nGLL\nGL\nUniform\n\n\n\n\n\n","category":"type"},{"location":"api/#RecursiveApply","page":"API","title":"RecursiveApply","text":"","category":"section"},{"location":"api/","page":"API","title":"API","text":"RecursiveApply","category":"page"},{"location":"api/#ClimaCore.RecursiveApply","page":"API","title":"ClimaCore.RecursiveApply","text":"RecursiveApply\n\nThis module contains operators to recurse over nested Tuples or NamedTuples.\n\nTo extend to another type T, define RecursiveApply.rmap(fn, args::T...)\n\n\n\n\n\n","category":"module"},{"location":"operators/#Operators","page":"Operators","title":"Operators","text":"","category":"section"},{"location":"operators/","page":"Operators","title":"Operators","text":"CurrentModule = ClimaCore.Operators","category":"page"},{"location":"operators/#Spectral-element-operators","page":"Operators","title":"Spectral element operators","text":"","category":"section"},{"location":"operators/#Differential-Operators","page":"Operators","title":"Differential Operators","text":"","category":"section"},{"location":"operators/","page":"Operators","title":"Operators","text":"Divergence\nWeakDivergence\nGradient\nWeakGradient\nCurl\nWeakCurl","category":"page"},{"location":"operators/#ClimaCore.Operators.Divergence","page":"Operators","title":"ClimaCore.Operators.Divergence","text":"div = Divergence()\ndiv.(u)\n\nComputes the per-element spectral (strong) divergence of a vector field u.\n\nThe divergence of a vector field u is defined as\n\nnabla cdot u = sum_i frac1J fracpartial (J u^i)partial xi^i\n\nwhere J is the Jacobian determinant, u^i is the ith contravariant component of u.\n\nThis is discretized by\n\nsum_i I leftfrac1J fracpartial (IJ u^i)partial xi^i right\n\nwhere Ix is the interpolation operator that projects to the unique polynomial interpolating x at the quadrature points. In matrix form, this can be written as\n\nJ^-1 sum_i D_i J u^i\n\nwhere D_i is the derivative matrix along the ith dimension\n\nReferences\n\nTaylor and Fournier (2010), equation 15\n\n\n\n\n\n","category":"type"},{"location":"operators/#ClimaCore.Operators.WeakDivergence","page":"Operators","title":"ClimaCore.Operators.WeakDivergence","text":"wdiv = WeakDivergence()\nwdiv.(u)\n\nComputes the \"weak divergence\" of a vector field u.\n\nThis is defined as the scalar field theta in mathcalV_0 such that for all phiin mathcalV_0\n\nint_Omega phi theta  d Omega\n=\n- int_Omega (nabla phi) cdot u d Omega\n\nwhere mathcalV_0 is the space of u.\n\nThis arises as the contribution of the volume integral after by applying integration by parts to the weak form expression of the divergence\n\nint_Omega phi (nabla cdot u)  d Omega\n=\n- int_Omega (nabla phi) cdot u d Omega\n+ oint_partial Omega phi (u cdot n) d sigma\n\nIt can be written in matrix form as\n\nϕ^top WJ θ = - sum_i (D_i ϕ)^top WJ u^i\n\nwhich reduces to\n\nθ = -(WJ)^-1 sum_i D_i^top WJ u^i\n\nwhere\n\nJ is the diagonal Jacobian matrix\nW is the diagonal matrix of quadrature weights\nD_i is the derivative matrix along the ith dimension\n\n\n\n\n\n","category":"type"},{"location":"operators/#ClimaCore.Operators.Gradient","page":"Operators","title":"ClimaCore.Operators.Gradient","text":"grad = Gradient()\ngrad.(f)\n\nCompute the (strong) gradient of f on each element, returning a CovariantVector-field.\n\nThe ith covariant component of the gradient is the partial derivative with respect to the reference element:\n\n(nabla f)_i = fracpartial fpartial xi^i\n\nDiscretely, this can be written in matrix form as\n\nD_i f\n\nwhere D_i is the derivative matrix along the ith dimension\n\n\n\n\n\n","category":"type"},{"location":"operators/#ClimaCore.Operators.WeakGradient","page":"Operators","title":"ClimaCore.Operators.WeakGradient","text":"wgrad = WeakGradient()\nwgrad.(f)\n\nCompute the \"weak gradient\" of f on each element.\n\nThis is defined as the the vector field theta in mathcalV_0 such that for all phi in mathcalV_0\n\nint_Omega phi cdot theta  d Omega\n=\n- int_Omega (nabla cdot phi) f  dOmega\n\nwhere mathcalV_0 is the space of f.\n\nThis arises from the contribution of the volume integral after by applying integration by parts to the weak form expression of the gradient\n\nint_Omega phi cdot (nabla f)  d Omega\n=\n- int_Omega f (nabla cdot phi)  dOmega\n+ oint_partial Omega f (phi cdot n)  d sigma\n\nIn matrix form, this becomes\n\nphi^i^top W J theta_i = - ( J^-1 D_i J phi^i )^top W J f\n\nwhich reduces to\n\ntheta_i = -W^-1 D_i^top W f\n\nwhere D_i is the derivative matrix along the ith dimension.\n\n\n\n\n\n","category":"type"},{"location":"operators/#ClimaCore.Operators.Curl","page":"Operators","title":"ClimaCore.Operators.Curl","text":"curl = Curl()\ncurl.(u)\n\nComputes the per-element spectral (strong) curl of a vector field u.\n\nThe curl of a vector field u is a vector field with contravariant components\n\n(nabla times u)^i = frac1J sum_jk epsilon^ijk fracpartial u_kpartial xi^j\n\nwhere J is the Jacobian determinant, u_k is the kth covariant component of u, and epsilon^ijk are the Levi-Civita symbols. In other words\n\nbeginbmatrix\n  (nabla times u)^1 \n  (nabla times u)^2 \n  (nabla times u)^3\nendbmatrix\n=\nfrac1J beginbmatrix\n  fracpartial u_3partial xi^2 - fracpartial u_2partial xi^3 \n  fracpartial u_1partial xi^3 - fracpartial u_3partial xi^1 \n  fracpartial u_2partial xi^1 - fracpartial u_1partial xi^2\nendbmatrix\n\nIn matrix form, this becomes\n\nepsilon^ijk J^-1 D_j u_k\n\nNote that unused dimensions will be dropped: e.g. the 2D curl of a Covariant12Vector-field will return a Contravariant3Vector.\n\n\n\n\n\n","category":"type"},{"location":"operators/#ClimaCore.Operators.WeakCurl","page":"Operators","title":"ClimaCore.Operators.WeakCurl","text":"wcurl = WeakCurl()\nwcurl.(u)\n\nComputes the \"weak curl\" on each element of a vector field u.\n\nThis is defined as the vector field theta in mathcalV_0 such that for all phi in mathcalV_0\n\nint_Omega phi cdot theta  d Omega\n=\nint_Omega (nabla times phi) cdot u d Omega\n\nwhere mathcalV_0 is the space of f.\n\nThis arises from the contribution of the volume integral after by applying integration by parts to the weak form expression of the curl\n\nint_Omega phi cdot (nabla times u) dOmega\n=\nint_Omega (nabla times phi) cdot u d Omega\n- oint_partial Omega (phi times u) cdot n dsigma\n\nIn matrix form, this becomes\n\nphi_i^top W J theta^i = (J^-1 epsilon^kji D_j phi_i)^top W J u_k\n\nwhich, by using the anti-symmetry of the Levi-Civita symbol, reduces to\n\ntheta^i = - epsilon^ijk (WJ)^-1 D_j^top W u_k\n\n\n\n\n\n","category":"type"},{"location":"operators/#Interpolation-Operators","page":"Operators","title":"Interpolation Operators","text":"","category":"section"},{"location":"operators/","page":"Operators","title":"Operators","text":"Interpolate\nRestrict","category":"page"},{"location":"operators/#ClimaCore.Operators.Interpolate","page":"Operators","title":"ClimaCore.Operators.Interpolate","text":"i = Interpolate(space)\ni.(f)\n\nInterpolates f to the space. If space has equal or higher polynomial degree as the space of f, this is exact, otherwise it will be lossy.\n\nIn matrix form, it is the linear operator\n\nI = bigotimes_i I_i\n\nwhere I_i is the barycentric interpolation matrix in the ith dimension.\n\nSee also Restrict.\n\n\n\n\n\n","category":"type"},{"location":"operators/#ClimaCore.Operators.Restrict","page":"Operators","title":"ClimaCore.Operators.Restrict","text":"r = Restrict(space)\nr.(f)\n\nComputes the projection of a field f on mathcalV_0 to a lower degree polynomial space space (mathcalV_0^*). space must be on the same topology as the space of f, but have a lower polynomial degree.\n\nIt is defined as the field theta in mathcalV_0^* such that for all phi in mathcalV_0^*\n\nint_Omega phi theta dOmega = int_Omega phi f dOmega\n\nIn matrix form, this is\n\nphi^top W^* J^* theta = (I phi)^top WJ f\n\nwhere W^* and J^* are the quadrature weights and Jacobian determinant of mathcalV_0^*, and I is the interpolation operator (see Interpolate) from mathcalV_0^* to mathcalV_0. This reduces to\n\ntheta = (W^* J^*)^-1 I^top WJ f\n\n\n\n\n\n","category":"type"},{"location":"operators/#DSS","page":"Operators","title":"DSS","text":"","category":"section"},{"location":"operators/","page":"Operators","title":"Operators","text":"Spaces.weighted_dss!","category":"page"},{"location":"operators/#ClimaCore.Spaces.weighted_dss!","page":"Operators","title":"ClimaCore.Spaces.weighted_dss!","text":"Spaces.weighted_dss!(f::Field)\n\nApply weighted direct stiffness summation (DSS) to f. This operates in-place (i.e. it modifies the f).\n\nThis is a projection operation from the piecewise polynomial space mathcalV_0 to the continuous space mathcalV_1 = mathcalV_0 cap mathcalC_0, defined as the field theta in mathcalV_1 such that for all phi in mathcalV_1\n\nint_Omega phi theta dOmega = int_Omega phi f dOmega\n\nIn matrix form, we define bar theta to be the unique global node representation, and Q to be the \"scatter\" operator which maps to the redundant node representation theta\n\ntheta = Q bar theta\n\nThen the problem can be written as\n\n(Q barphi)^top W J Q bartheta = (Q barphi)^top W J f\n\nwhich reduces to\n\ntheta = Q bartheta = Q (Q^top W J Q)^-1 Q^top W J f\n\n\n\n\n\n","category":"function"},{"location":"operators/#Finite-difference-operators","page":"Operators","title":"Finite difference operators","text":"","category":"section"},{"location":"operators/#Interpolation-operators","page":"Operators","title":"Interpolation operators","text":"","category":"section"},{"location":"operators/","page":"Operators","title":"Operators","text":"InterpolateC2F\nInterpolateF2C\nUpwindBiasedProductC2F\nLeftBiasedC2F\nRightBiasedC2F","category":"page"},{"location":"operators/#ClimaCore.Operators.InterpolateC2F","page":"Operators","title":"ClimaCore.Operators.InterpolateC2F","text":"I = InterpolateC2F(;boundaries..)\nI.(x)\n\nInterpolate a center-valued field x to faces, using the stencil\n\nI(x)i = frac12 (xi+tfrac12 + xi-tfrac12)\n\nSupported boundary conditions are:\n\nSetValue(x₀): set the value at the boundary face to be x₀. On the left boundary the stencil is\n\nI(x)tfrac12 = x₀\n\nSetGradient(v): set the value at the boundary such that the gradient is v. At the left boundary the stencil is\n\nI(x)tfrac12 = x1 - frac12 v³\n\nExtrapolate: use the closest interior point as the boundary value. At the left boundary the stencil is\n\nI(x)tfrac12 = x1\n\n\n\n\n\n","category":"type"},{"location":"operators/#ClimaCore.Operators.InterpolateF2C","page":"Operators","title":"ClimaCore.Operators.InterpolateF2C","text":"InterpolateF2C()\n\nInterpolate from face to center mesh. No boundary conditions are required (or supported).\n\n\n\n\n\n","category":"type"},{"location":"operators/#ClimaCore.Operators.UpwindBiasedProductC2F","page":"Operators","title":"ClimaCore.Operators.UpwindBiasedProductC2F","text":"U = UpwindBiasedProductC2F(;boundaries)\nU.(v, x)\n\nCompute the product of a face-valued vector field v and a center-valued field x at cell faces by upwinding x according to v\n\nU(vx)i = begincases\n  vi xi-tfrac12 quad v^3i  0 \n  vi xi+tfrac12 quad v^3i  0\n  endcases\n\nSupported boundary conditions are:\n\nSetValue(x₀): set the value of x to be x₀ on the boundary. On the left boundary the stencil is\nU(vx)tfrac12 = begincases\n  vtfrac12 x_0 quad v^3tfrac12  0 \n  vtfrac12 x1 quad v^3tfrac12  0\n  endcases\nExtrapolate(): set the value of x to be the same as the closest interior point. On the left boundary, the stencil is\nU(vx)tfrac12 = U(vx)1 + tfrac12\n\n\n\n\n\n","category":"type"},{"location":"operators/#ClimaCore.Operators.LeftBiasedC2F","page":"Operators","title":"ClimaCore.Operators.LeftBiasedC2F","text":"L = LeftBiasedC2F(;boundaries)\nL.(x)\n\nInterpolate a center-value field to a face-valued field from the left.\n\nL(x)i = xi-tfrac12\n\nOnly the left boundary condition should be set. Currently supported is:\n\nSetValue(x₀): set the value to be x₀ on the boundary.\n\nL(x)tfrac12 = x_0\n\n\n\n\n\n","category":"type"},{"location":"operators/#ClimaCore.Operators.RightBiasedC2F","page":"Operators","title":"ClimaCore.Operators.RightBiasedC2F","text":"R = RightBiasedC2F(;boundaries)\nR.(x)\n\nInterpolate a center-valued field to a face-valued field from the right.\n\nR(x)i = xi+tfrac12\n\nOnly the right boundary condition should be set. Currently supported is:\n\nSetValue(x₀): set the value to be x₀ on the boundary.\n\nR(x)n+tfrac12 = x_0\n\n\n\n\n\n","category":"type"},{"location":"operators/#Derivative-operators","page":"Operators","title":"Derivative operators","text":"","category":"section"},{"location":"operators/","page":"Operators","title":"Operators","text":"AdvectionF2F\nAdvectionC2C\nDivergenceF2C\nDivergenceC2F\nGradientF2C\nGradientC2F\nCurlC2F","category":"page"},{"location":"operators/#ClimaCore.Operators.AdvectionF2F","page":"Operators","title":"ClimaCore.Operators.AdvectionF2F","text":"A = AdvectionF2F(;boundaries)\nA.(v, θ)\n\nVertical advection operator at cell faces, for a face-valued velocity field v and face-valued variables θ, approximating v^3 partial_3 theta.\n\nIt uses the following stencil\n\nA(vθ)i = frac12 (θi+1 - θi-1) v³i\n\nNo boundary conditions are currently supported.\n\n\n\n\n\n","category":"type"},{"location":"operators/#ClimaCore.Operators.AdvectionC2C","page":"Operators","title":"ClimaCore.Operators.AdvectionC2C","text":"A = AdvectionC2C(;boundaries)\nA.(v, θ)\n\nVertical advection operator at cell centers, for cell face velocity field v cell center variables θ, approximating v^3 partial_3 theta.\n\nIt uses the following stencil\n\nA(vθ)i = frac12  (θi+1 - θi) v³i+tfrac12 + (θi - θi-1)v³i-tfrac12\n\nSupported boundary conditions:\n\nSetValue(θ₀): set the value of θ at the boundary face to be θ₀. At the lower boundary, this is:\n\nA(vθ)1 = frac12  (θ2 - θ1) v³1 + tfrac12 + (θ1 - θ₀)v³tfrac12\n\nExtrapolate: use the closest interior point as the boundary value. At the lower boundary, this is:\n\nA(vθ)1 = (θ2 - θ1) v³1 + tfrac12 \n\n\n\n\n\n","category":"type"},{"location":"operators/#ClimaCore.Operators.DivergenceF2C","page":"Operators","title":"ClimaCore.Operators.DivergenceF2C","text":"D = DivergenceF2C(;boundaryname=boundarycondition...)\nD.(v)\n\nCompute the vertical contribution to the divergence of a face-valued field vector v, returning a center-valued scalar field, using the stencil\n\nD(v)i = (Jv³i+tfrac12 - Jv³i-tfrac12)  Ji\n\nwhere Jv³ is the Jacobian multiplied by the third contravariant component of v.\n\nThe following boundary conditions are supported:\n\nby default, the value of v at the boundary face will be used.\nSetValue(v₀): calculate the divergence assuming the value at the boundary is v₀. For the left boundary, this becomes:\n\nD(v)1 = (Jv³1+tfrac12 - Jv³₀)  Ji\n\nExtrapolate(): set the value at the center closest to the boundary to be the same as the neighbouring interior value. For the left boundary, this becomes:\n\nD(v)1³ = D(v)2³\n\n\n\n\n\n","category":"type"},{"location":"operators/#ClimaCore.Operators.DivergenceC2F","page":"Operators","title":"ClimaCore.Operators.DivergenceC2F","text":"D = DivergenceC2F(;boundaryname=boundarycondition...)\nD.(v)\n\nCompute the vertical contribution to the divergence of a center-valued field vector v, returning a face-valued scalar field, using the stencil\n\nD(v)i = (Jv³i+tfrac12 - Jv³i-tfrac12)  Ji\n\nwhere Jv³ is the Jacobian multiplied by the third contravariant component of v.\n\nThe following boundary conditions are supported:\n\nSetValue(v₀): calculate the divergence assuming the value at the  boundary is v₀. For the left boundary, this becomes:\nD(v)tfrac12 = frac12 (Jv³1 - Jv³₀)  Ji\nSetDivergence(x): set the value of the divergence at the boundary to be x.\nD(v)tfrac12 = x\n\n\n\n\n\n","category":"type"},{"location":"operators/#ClimaCore.Operators.GradientF2C","page":"Operators","title":"ClimaCore.Operators.GradientF2C","text":"G = GradientF2C(;boundaryname=boundarycondition...)\nG.(x)\n\nCompute the gradient of a face-valued field x, returning a center-valued Covariant3 vector field, using the stencil:\n\nG(x)i^3 = xi+tfrac12 - xi-tfrac12\n\nThe following boundary conditions are supported:\n\nby default, the value of x at the boundary face will be used.\nSetValue(x₀): calculate the gradient assuming the value at the boundary is x₀. For the left boundary, this becomes:\n\nG(x)1³ = x1+tfrac12 - x₀\n\nExtrapolate(): set the value at the center closest to the boundary\n\nto be the same as the neighbouring interior value. For the left boundary, this becomes:\n\nG(x)1³ = G(x)2³\n\n\n\n\n\n","category":"type"},{"location":"operators/#ClimaCore.Operators.GradientC2F","page":"Operators","title":"ClimaCore.Operators.GradientC2F","text":"G = GradientC2F(;boundaryname=boundarycondition...)\nG.(x)\n\nCompute the gradient of a center-valued field x, returning a face-valued Covariant3 vector field, using the stencil:\n\nG(x)i^3 = xi+tfrac12 - xi-tfrac12\n\nThe following boundary conditions are supported:\n\nSetValue(x₀): calculate the gradient assuming the value at the boundary is x₀. For the left boundary, this becomes:\nG(x)tfrac12³ = 2 (x1 - x₀)\nSetGradient(v₀): set the value of the gradient at the boundary to be v₀. For the left boundary, this becomes:\nG(x)tfrac12 = v₀\n\n\n\n\n\n","category":"type"},{"location":"operators/#ClimaCore.Operators.CurlC2F","page":"Operators","title":"ClimaCore.Operators.CurlC2F","text":"C = CurlC2F(;boundaryname=boundarycondition...)\nC.(v)\n\nCompute the vertical-derivative contribution to the curl of a center-valued covariant vector field v. It acts on the horizontal covariant components of v (that is it only depends on v₁ and v₂), and will return a face-valued horizontal contravariant vector field (that is C(v)³ = 0).\n\nSpecifically it approximates:\n\nbeginalign*\nC(v)^1 = -frac1J fracpartial v_2partial xi^3  \nC(v)^2 = frac1J fracpartial v_1partial xi^3 \nendalign*\n\nusing the stencils\n\nbeginalign*\nC(v)i^1 = - frac1Ji (v₂i+tfrac12 - v₂i-tfrac12) \nC(v)i^2 = frac1Ji  (v₁i+tfrac12 - v₁i-tfrac12)\nendalign*\n\nwhere v₁ andv₂are the 1st and 2nd covariant components ofv andJ`` is the Jacobian determinant.\n\nThe following boundary conditions are supported:\n\nSetValue(v₀): calculate the curl assuming the value of v at the  boundary is v₀. For the left boundary, this becomes:\nC(v)tfrac12^1 = -frac2Ji (v_21 - (v₀)_2)\nC(v)tfrac12^2 = frac2Ji (v_11 - (v₀)_1)\n\n\n\n\n\n","category":"type"},{"location":"operators/#Other","page":"Operators","title":"Other","text":"","category":"section"},{"location":"operators/","page":"Operators","title":"Operators","text":"SetBoundaryOperator","category":"page"},{"location":"operators/#ClimaCore.Operators.SetBoundaryOperator","page":"Operators","title":"ClimaCore.Operators.SetBoundaryOperator","text":"SetBoundaryOperator(;boundaries...)\n\nThis operator only modifies the values at the boundary:\n\nSetValue(val): set the value to be val on the boundary.\n\n\n\n\n\n","category":"type"},{"location":"operators/#Finite-difference-boundary-conditions","page":"Operators","title":"Finite difference boundary conditions","text":"","category":"section"},{"location":"operators/","page":"Operators","title":"Operators","text":"SetValue\nSetGradient\nSetDivergence\nExtrapolate","category":"page"},{"location":"operators/#ClimaCore.Operators.SetValue","page":"Operators","title":"ClimaCore.Operators.SetValue","text":"SetValue(val)\n\nSet the value at the boundary to be val. In the case of gradient operators, this will set the input value from which the gradient is computed.\n\n\n\n\n\n","category":"type"},{"location":"operators/#ClimaCore.Operators.SetGradient","page":"Operators","title":"ClimaCore.Operators.SetGradient","text":"SetGradient(val)\n\nSet the gradient at the boundary to be val. In the case of gradient operators this will set the output value of the gradient.\n\n\n\n\n\n","category":"type"},{"location":"operators/#ClimaCore.Operators.SetDivergence","page":"Operators","title":"ClimaCore.Operators.SetDivergence","text":"SetDivergence(val)\n\nSet the divergence at the boundary to be val.\n\n\n\n\n\n","category":"type"},{"location":"operators/#ClimaCore.Operators.Extrapolate","page":"Operators","title":"ClimaCore.Operators.Extrapolate","text":"Extrapolate()\n\nSet the value at the boundary to be the same as the closest interior point.\n\n\n\n\n\n","category":"type"},{"location":"#ClimaCore.jl","page":"Home","title":"ClimaCore.jl","text":"","category":"section"},{"location":"tutorials/introduction/","page":"Introduction to ClimaCore.jl","title":"Introduction to ClimaCore.jl","text":"EditURL = \"https://github.com/CliMA/ClimaCore.jl/blob/master/docs/tutorials/introduction.jl\"","category":"page"},{"location":"tutorials/introduction/#Introduction-to-ClimaCore.jl","page":"Introduction to ClimaCore.jl","title":"Introduction to ClimaCore.jl","text":"","category":"section"},{"location":"tutorials/introduction/","page":"Introduction to ClimaCore.jl","title":"Introduction to ClimaCore.jl","text":"This tutorial is available as a Jupyter notebook.","category":"page"},{"location":"tutorials/introduction/#What-is-ClimaCore?","page":"Introduction to ClimaCore.jl","title":"What is ClimaCore?","text":"","category":"section"},{"location":"tutorials/introduction/","page":"Introduction to ClimaCore.jl","title":"Introduction to ClimaCore.jl","text":"A suite of tools for constructing spatial discretizations","category":"page"},{"location":"tutorials/introduction/","page":"Introduction to ClimaCore.jl","title":"Introduction to ClimaCore.jl","text":"primarily aimed at climate and weather models\ninitial aim:\nspectral element discretization in the horizontal\nstaggered finite difference in the vertical\ncurrently under development","category":"page"},{"location":"tutorials/introduction/","page":"Introduction to ClimaCore.jl","title":"Introduction to ClimaCore.jl","text":"using ClimaCore, LinearAlgebra, IntervalSets, UnPack, Plots, OrdinaryDiffEq","category":"page"},{"location":"tutorials/introduction/#.-Constructing-a-discretization","page":"Introduction to ClimaCore.jl","title":"1. Constructing a discretization","text":"","category":"section"},{"location":"tutorials/introduction/#.1-Domains","page":"Introduction to ClimaCore.jl","title":"1.1 Domains","text":"","category":"section"},{"location":"tutorials/introduction/","page":"Introduction to ClimaCore.jl","title":"Introduction to ClimaCore.jl","text":"A domain a region of space (think of a mathematical domain).","category":"page"},{"location":"tutorials/introduction/","page":"Introduction to ClimaCore.jl","title":"Introduction to ClimaCore.jl","text":"column_domain = ClimaCore.Domains.IntervalDomain(\n    ClimaCore.Geometry.ZPoint(0.0) .. ClimaCore.Geometry.ZPoint(10.0),\n    boundary_tags = (:bottom, :top),\n)","category":"page"},{"location":"tutorials/introduction/","page":"Introduction to ClimaCore.jl","title":"Introduction to ClimaCore.jl","text":"rectangle_domain = ClimaCore.Domains.RectangleDomain(\n    ClimaCore.Geometry.XPoint(-2π) .. ClimaCore.Geometry.XPoint(2π),\n    ClimaCore.Geometry.YPoint(-2π) .. ClimaCore.Geometry.YPoint(2π),\n    x1periodic = true,\n    x2periodic = true,\n)","category":"page"},{"location":"tutorials/introduction/#.2-Meshes","page":"Introduction to ClimaCore.jl","title":"1.2 Meshes","text":"","category":"section"},{"location":"tutorials/introduction/","page":"Introduction to ClimaCore.jl","title":"Introduction to ClimaCore.jl","text":"A mesh is a division of a domain into elements","category":"page"},{"location":"tutorials/introduction/","page":"Introduction to ClimaCore.jl","title":"Introduction to ClimaCore.jl","text":"column_mesh = ClimaCore.Meshes.IntervalMesh(column_domain, nelems = 32)","category":"page"},{"location":"tutorials/introduction/","page":"Introduction to ClimaCore.jl","title":"Introduction to ClimaCore.jl","text":"rectangle_mesh = ClimaCore.Meshes.RectilinearMesh(rectangle_domain, 16, 16)","category":"page"},{"location":"tutorials/introduction/#.3-Topologies","page":"Introduction to ClimaCore.jl","title":"1.3 Topologies","text":"","category":"section"},{"location":"tutorials/introduction/","page":"Introduction to ClimaCore.jl","title":"Introduction to ClimaCore.jl","text":"A topology determines the ordering and connections between elements of a mesh","category":"page"},{"location":"tutorials/introduction/","page":"Introduction to ClimaCore.jl","title":"Introduction to ClimaCore.jl","text":"At the moment, this is only required for 2D meshes","category":"page"},{"location":"tutorials/introduction/","page":"Introduction to ClimaCore.jl","title":"Introduction to ClimaCore.jl","text":"rectangle_topology = ClimaCore.Topologies.Topology2D(rectangle_mesh)","category":"page"},{"location":"tutorials/introduction/#.4-Spaces","page":"Introduction to ClimaCore.jl","title":"1.4 Spaces","text":"","category":"section"},{"location":"tutorials/introduction/","page":"Introduction to ClimaCore.jl","title":"Introduction to ClimaCore.jl","text":"A space represents a discretized function space over some domain. Currently two discretizations are supported.","category":"page"},{"location":"tutorials/introduction/#.4.1-Staggered-finite-difference-discretization","page":"Introduction to ClimaCore.jl","title":"1.4.1 Staggered finite difference discretization","text":"","category":"section"},{"location":"tutorials/introduction/","page":"Introduction to ClimaCore.jl","title":"Introduction to ClimaCore.jl","text":"This discretizes an interval domain by approximating the function by a value at either the center of each element (CenterFiniteDifferenceSpace), or the faces between elements (FaceFiniteDifferenceSpace).","category":"page"},{"location":"tutorials/introduction/","page":"Introduction to ClimaCore.jl","title":"Introduction to ClimaCore.jl","text":"You can construct either the center or face space from the mesh, then construct the opposite space from the original one (this is to avoid allocating additional memory).","category":"page"},{"location":"tutorials/introduction/","page":"Introduction to ClimaCore.jl","title":"Introduction to ClimaCore.jl","text":"column_center_space = ClimaCore.Spaces.CenterFiniteDifferenceSpace(column_mesh)\n# construct the face space from the center one\ncolumn_face_space =\n    ClimaCore.Spaces.FaceFiniteDifferenceSpace(column_center_space)","category":"page"},{"location":"tutorials/introduction/#.4.2-Spectral-element-discretization","page":"Introduction to ClimaCore.jl","title":"1.4.2 Spectral element discretization","text":"","category":"section"},{"location":"tutorials/introduction/","page":"Introduction to ClimaCore.jl","title":"Introduction to ClimaCore.jl","text":"A spectral element space approximates the function with polynomials in each element. The polynomials are represented using a nodal discretization, which stores the values of the polynomials at particular points in each element (termed nodes or degrees of freedom).","category":"page"},{"location":"tutorials/introduction/","page":"Introduction to ClimaCore.jl","title":"Introduction to ClimaCore.jl","text":"These nodes are chosen by a particular quadrature rule, which allows us to integrate functions over the domain. The only supported choice for now is a Gauss-Legendre-Lobatto rule.","category":"page"},{"location":"tutorials/introduction/","page":"Introduction to ClimaCore.jl","title":"Introduction to ClimaCore.jl","text":"# Gauss-Legendre-Lobatto quadrature with 4 nodes in each direction, so 16 in each element\nquad = ClimaCore.Spaces.Quadratures.GLL{4}()\nrectangle_space =\n    ClimaCore.Spaces.SpectralElementSpace2D(rectangle_topology, quad)","category":"page"},{"location":"tutorials/introduction/#.5-Fields","page":"Introduction to ClimaCore.jl","title":"1.5 Fields","text":"","category":"section"},{"location":"tutorials/introduction/","page":"Introduction to ClimaCore.jl","title":"Introduction to ClimaCore.jl","text":"Finally, we can construct a field: a function in a space. A field is simply a space and the values at each node in the space.","category":"page"},{"location":"tutorials/introduction/","page":"Introduction to ClimaCore.jl","title":"Introduction to ClimaCore.jl","text":"The easiest field to construct is the coordinate field","category":"page"},{"location":"tutorials/introduction/","page":"Introduction to ClimaCore.jl","title":"Introduction to ClimaCore.jl","text":"coord = ClimaCore.Fields.coordinate_field(rectangle_space)","category":"page"},{"location":"tutorials/introduction/","page":"Introduction to ClimaCore.jl","title":"Introduction to ClimaCore.jl","text":"This is a struct-value field: it contains coordinates in a struct at each point. We can extract just the x coordinate, to get a scalar field:","category":"page"},{"location":"tutorials/introduction/","page":"Introduction to ClimaCore.jl","title":"Introduction to ClimaCore.jl","text":"x = coord.x","category":"page"},{"location":"tutorials/introduction/","page":"Introduction to ClimaCore.jl","title":"Introduction to ClimaCore.jl","text":"Although you can't index directly into a field, it can be used in some other ways similar to a Julia Array. For example, broadcasting can be used to define new fields in terms of other ones:","category":"page"},{"location":"tutorials/introduction/","page":"Introduction to ClimaCore.jl","title":"Introduction to ClimaCore.jl","text":"sinx = sin.(x)","category":"page"},{"location":"tutorials/introduction/","page":"Introduction to ClimaCore.jl","title":"Introduction to ClimaCore.jl","text":"Fields can be easily vizualized with Plots.jl:","category":"page"},{"location":"tutorials/introduction/","page":"Introduction to ClimaCore.jl","title":"Introduction to ClimaCore.jl","text":"import Plots\nPlots.plot(sinx)","category":"page"},{"location":"tutorials/introduction/","page":"Introduction to ClimaCore.jl","title":"Introduction to ClimaCore.jl","text":"If you're using the terminal, UnicodePlots is also supported.","category":"page"},{"location":"tutorials/introduction/","page":"Introduction to ClimaCore.jl","title":"Introduction to ClimaCore.jl","text":"This works similarly for finite difference discretizations","category":"page"},{"location":"tutorials/introduction/","page":"Introduction to ClimaCore.jl","title":"Introduction to ClimaCore.jl","text":"column_center_coords = ClimaCore.Fields.coordinate_field(column_center_space)\ncolumn_face_coords = ClimaCore.Fields.coordinate_field(column_face_space)","category":"page"},{"location":"tutorials/introduction/","page":"Introduction to ClimaCore.jl","title":"Introduction to ClimaCore.jl","text":"plot(sin.(column_center_coords.z), ylim = (0.0, 10.0))\nplot!(cos.(column_face_coords.z), ylim = (0.0, 10.0))","category":"page"},{"location":"tutorials/introduction/","page":"Introduction to ClimaCore.jl","title":"Introduction to ClimaCore.jl","text":"Reduction operations are defined anologously:","category":"page"},{"location":"tutorials/introduction/","page":"Introduction to ClimaCore.jl","title":"Introduction to ClimaCore.jl","text":"sum will give the integral of the function","category":"page"},{"location":"tutorials/introduction/","page":"Introduction to ClimaCore.jl","title":"Introduction to ClimaCore.jl","text":"int_D f(x) dx","category":"page"},{"location":"tutorials/introduction/","page":"Introduction to ClimaCore.jl","title":"Introduction to ClimaCore.jl","text":"norm will give the L² function norm","category":"page"},{"location":"tutorials/introduction/","page":"Introduction to ClimaCore.jl","title":"Introduction to ClimaCore.jl","text":"sqrtint_D f(x)^2 dx","category":"page"},{"location":"tutorials/introduction/","page":"Introduction to ClimaCore.jl","title":"Introduction to ClimaCore.jl","text":"sum(sinx) ## integral","category":"page"},{"location":"tutorials/introduction/","page":"Introduction to ClimaCore.jl","title":"Introduction to ClimaCore.jl","text":"norm(sinx) ## L² norm","category":"page"},{"location":"tutorials/introduction/#.6-Vectors-and-vector-fields","page":"Introduction to ClimaCore.jl","title":"1.6 Vectors and vector fields","text":"","category":"section"},{"location":"tutorials/introduction/","page":"Introduction to ClimaCore.jl","title":"Introduction to ClimaCore.jl","text":"A vector field is a field with vector-valued quantity, i.e. at every point in space, you have a vector.","category":"page"},{"location":"tutorials/introduction/","page":"Introduction to ClimaCore.jl","title":"Introduction to ClimaCore.jl","text":"However one of the key requirements of ClimaCore is to support vectors specified in curvilinear or non-Cartesian coordinates. We will discuss this in a bit further, but for now, you can define a 2-dimensional vector field using Geometry.Cartesian12Vector:","category":"page"},{"location":"tutorials/introduction/","page":"Introduction to ClimaCore.jl","title":"Introduction to ClimaCore.jl","text":"v = ClimaCore.Geometry.Cartesian12Vector.(coord.y, .-coord.x)","category":"page"},{"location":"tutorials/introduction/#.-Operators","page":"Introduction to ClimaCore.jl","title":"2. Operators","text":"","category":"section"},{"location":"tutorials/introduction/","page":"Introduction to ClimaCore.jl","title":"Introduction to ClimaCore.jl","text":"Operators can compute spatial derivative operations.","category":"page"},{"location":"tutorials/introduction/","page":"Introduction to ClimaCore.jl","title":"Introduction to ClimaCore.jl","text":"for performance reasons, we need to be able to \"fuse\" multiple operators and function applications\nJulia provides a tool for this: broadcasting, with a very flexible API","category":"page"},{"location":"tutorials/introduction/","page":"Introduction to ClimaCore.jl","title":"Introduction to ClimaCore.jl","text":"Can think of operators are \"pseudo-functions\": can't be called directly, but act similar to functions in the context of broadcasting.","category":"page"},{"location":"tutorials/introduction/#.1-Spectral-element-operators","page":"Introduction to ClimaCore.jl","title":"2.1 Spectral element operators","text":"","category":"section"},{"location":"tutorials/introduction/","page":"Introduction to ClimaCore.jl","title":"Introduction to ClimaCore.jl","text":"The Gradient operator takes the gradient of a scalar field, and returns a vector field.","category":"page"},{"location":"tutorials/introduction/","page":"Introduction to ClimaCore.jl","title":"Introduction to ClimaCore.jl","text":"grad = ClimaCore.Operators.Gradient()\n∇sinx = grad.(sinx)","category":"page"},{"location":"tutorials/introduction/","page":"Introduction to ClimaCore.jl","title":"Introduction to ClimaCore.jl","text":"plot(∇sinx.components.data.:1, clim = (-1, 1))","category":"page"},{"location":"tutorials/introduction/","page":"Introduction to ClimaCore.jl","title":"Introduction to ClimaCore.jl","text":"This returns the gradient in covariant coordinates","category":"page"},{"location":"tutorials/introduction/","page":"Introduction to ClimaCore.jl","title":"Introduction to ClimaCore.jl","text":"(nabla f)_i = fracpartial fpartial xi^i","category":"page"},{"location":"tutorials/introduction/","page":"Introduction to ClimaCore.jl","title":"Introduction to ClimaCore.jl","text":"where (xi^1xi^2) are the coordinates in the reference element: a square -11^2.","category":"page"},{"location":"tutorials/introduction/","page":"Introduction to ClimaCore.jl","title":"Introduction to ClimaCore.jl","text":"This can be converted to a Cartesian basis by multiplying by the partial derivative matrix","category":"page"},{"location":"tutorials/introduction/","page":"Introduction to ClimaCore.jl","title":"Introduction to ClimaCore.jl","text":"fracpartial xipartial x","category":"page"},{"location":"tutorials/introduction/","page":"Introduction to ClimaCore.jl","title":"Introduction to ClimaCore.jl","text":"This can be done calling `ClimaCore.Geometry.CartesianVector:","category":"page"},{"location":"tutorials/introduction/","page":"Introduction to ClimaCore.jl","title":"Introduction to ClimaCore.jl","text":"∇sinx_cart = ClimaCore.Geometry.CartesianVector.(∇sinx)","category":"page"},{"location":"tutorials/introduction/","page":"Introduction to ClimaCore.jl","title":"Introduction to ClimaCore.jl","text":"plot(∇sinx_cart.components.data.:1, clim = (-1, 1))","category":"page"},{"location":"tutorials/introduction/","page":"Introduction to ClimaCore.jl","title":"Introduction to ClimaCore.jl","text":"plot(∇sinx_cart.components.data.:2, clim = (-1, 1))","category":"page"},{"location":"tutorials/introduction/","page":"Introduction to ClimaCore.jl","title":"Introduction to ClimaCore.jl","text":"∇sinx_ref = ClimaCore.Geometry.Cartesian12Vector.(cos.(x), 0.0)\nnorm(∇sinx_cart .- ∇sinx_ref)","category":"page"},{"location":"tutorials/introduction/","page":"Introduction to ClimaCore.jl","title":"Introduction to ClimaCore.jl","text":"Similarly, the Divergence operator takes the divergence of vector field, and returns a scalar field.","category":"page"},{"location":"tutorials/introduction/","page":"Introduction to ClimaCore.jl","title":"Introduction to ClimaCore.jl","text":"If we take the divergence of a gradient, we can get a Laplacian:","category":"page"},{"location":"tutorials/introduction/","page":"Introduction to ClimaCore.jl","title":"Introduction to ClimaCore.jl","text":"div = ClimaCore.Operators.Divergence()\n∇²sinx = div.(grad.(sinx))\nplot(∇²sinx)","category":"page"},{"location":"tutorials/introduction/","page":"Introduction to ClimaCore.jl","title":"Introduction to ClimaCore.jl","text":"Note: In curvilinear coordinates, the divergence is defined in terms of the contravariant components u^i:","category":"page"},{"location":"tutorials/introduction/","page":"Introduction to ClimaCore.jl","title":"Introduction to ClimaCore.jl","text":"nabla cdot u = frac1J sum_i fracpartialpartial xi^i (J u^i)","category":"page"},{"location":"tutorials/introduction/","page":"Introduction to ClimaCore.jl","title":"Introduction to ClimaCore.jl","text":"The Divergence operator handles this conversion internally.","category":"page"},{"location":"tutorials/introduction/#.1.1-Direct-stiffness-summation","page":"Introduction to ClimaCore.jl","title":"2.1.1 Direct stiffness summation","text":"","category":"section"},{"location":"tutorials/introduction/","page":"Introduction to ClimaCore.jl","title":"Introduction to ClimaCore.jl","text":"Spectral element operators only operate within a single element, and so the result may be discontinuous. To address this, the usual fix is direct stiffness summation (DSS), which averages the values at the element boundaries.","category":"page"},{"location":"tutorials/introduction/","page":"Introduction to ClimaCore.jl","title":"Introduction to ClimaCore.jl","text":"This corresponds to the L^2 projection onto the subset of continuous functions in our function space.","category":"page"},{"location":"tutorials/introduction/","page":"Introduction to ClimaCore.jl","title":"Introduction to ClimaCore.jl","text":"∇²sinx_dss = ClimaCore.Spaces.weighted_dss!(copy(∇²sinx))\nplot(∇²sinx_dss)","category":"page"},{"location":"tutorials/introduction/","page":"Introduction to ClimaCore.jl","title":"Introduction to ClimaCore.jl","text":"plot(∇²sinx_dss .- ∇²sinx)","category":"page"},{"location":"tutorials/introduction/#.2-Finite-difference-operators","page":"Introduction to ClimaCore.jl","title":"2.2 Finite difference operators","text":"","category":"section"},{"location":"tutorials/introduction/","page":"Introduction to ClimaCore.jl","title":"Introduction to ClimaCore.jl","text":"Finite difference operators are similar with some subtle differences:","category":"page"},{"location":"tutorials/introduction/","page":"Introduction to ClimaCore.jl","title":"Introduction to ClimaCore.jl","text":"they can change staggering (center to face, or vice versa)\nthey can span multiple elements\nno DSS is required\nboundary handling may be required","category":"page"},{"location":"tutorials/introduction/","page":"Introduction to ClimaCore.jl","title":"Introduction to ClimaCore.jl","text":"We use the following convention:","category":"page"},{"location":"tutorials/introduction/","page":"Introduction to ClimaCore.jl","title":"Introduction to ClimaCore.jl","text":"centers are indexed by integers 1, 2, ..., n\nfaces are indexed by half integers ½, 1+½, ..., n+½","category":"page"},{"location":"tutorials/introduction/","page":"Introduction to ClimaCore.jl","title":"Introduction to ClimaCore.jl","text":"Face to center gradient","category":"page"},{"location":"tutorials/introduction/","page":"Introduction to ClimaCore.jl","title":"Introduction to ClimaCore.jl","text":"An finite-difference operator defines a stencil. For example, the gradient operator","category":"page"},{"location":"tutorials/introduction/","page":"Introduction to ClimaCore.jl","title":"Introduction to ClimaCore.jl","text":"nablathetai = fractheta i+tfrac12 - thetai-tfrac12Delta z","category":"page"},{"location":"tutorials/introduction/","page":"Introduction to ClimaCore.jl","title":"Introduction to ClimaCore.jl","text":"(actually, a little more complicated as it gives a vector in a covariant basis)","category":"page"},{"location":"tutorials/introduction/","page":"Introduction to ClimaCore.jl","title":"Introduction to ClimaCore.jl","text":"        ...\n      /\nθ[2+½]\n      \\\n        ∇θ[2]\n      /\nθ[1+½]\n      \\\n        ∇θ[1]\n      /\nθ[½]","category":"page"},{"location":"tutorials/introduction/","page":"Introduction to ClimaCore.jl","title":"Introduction to ClimaCore.jl","text":"Every center value is well-defined, so boundary handling is optional.","category":"page"},{"location":"tutorials/introduction/","page":"Introduction to ClimaCore.jl","title":"Introduction to ClimaCore.jl","text":"cosz = cos.(column_face_coords.z)\ngradf2c = ClimaCore.Operators.GradientF2C()\n∇cosz = gradf2c.(cosz)","category":"page"},{"location":"tutorials/introduction/","page":"Introduction to ClimaCore.jl","title":"Introduction to ClimaCore.jl","text":"plot(\n    ClimaCore.Geometry.CartesianVector.(∇cosz).components.data.:1,\n    ylim = (0, 10),\n)","category":"page"},{"location":"tutorials/introduction/","page":"Introduction to ClimaCore.jl","title":"Introduction to ClimaCore.jl","text":"Center to face gradient","category":"page"},{"location":"tutorials/introduction/","page":"Introduction to ClimaCore.jl","title":"Introduction to ClimaCore.jl","text":"Uses the same stencil, but doesn't work directly:","category":"page"},{"location":"tutorials/introduction/","page":"Introduction to ClimaCore.jl","title":"Introduction to ClimaCore.jl","text":"sinz = sin.(column_center_coords.z)\ngradc2f = ClimaCore.Operators.GradientC2F()\n# ∇sinz = gradc2f.(sinz) ## this would throw an error","category":"page"},{"location":"tutorials/introduction/","page":"Introduction to ClimaCore.jl","title":"Introduction to ClimaCore.jl","text":"This throws an error because face values at the boundary are not well-defined:","category":"page"},{"location":"tutorials/introduction/","page":"Introduction to ClimaCore.jl","title":"Introduction to ClimaCore.jl","text":"...\n      \\\n        ∇θ[2+½]\n      /\nθ[2]\n      \\\n        ∇θ[1+½]\n      /\nθ[1]\n      \\\n        ????","category":"page"},{"location":"tutorials/introduction/","page":"Introduction to ClimaCore.jl","title":"Introduction to ClimaCore.jl","text":"To handle boundaries we need to modify the stencil. Two options:","category":"page"},{"location":"tutorials/introduction/","page":"Introduction to ClimaCore.jl","title":"Introduction to ClimaCore.jl","text":"provide the value theta^* of theta at the boundary:","category":"page"},{"location":"tutorials/introduction/","page":"Introduction to ClimaCore.jl","title":"Introduction to ClimaCore.jl","text":"nablathetatfrac12 = fractheta1 - theta^*Delta z 2","category":"page"},{"location":"tutorials/introduction/","page":"Introduction to ClimaCore.jl","title":"Introduction to ClimaCore.jl","text":"provide the gradient nablatheta^* of theta at the boundary:","category":"page"},{"location":"tutorials/introduction/","page":"Introduction to ClimaCore.jl","title":"Introduction to ClimaCore.jl","text":"nablathetatfrac12 = nablatheta^*","category":"page"},{"location":"tutorials/introduction/","page":"Introduction to ClimaCore.jl","title":"Introduction to ClimaCore.jl","text":"These modified stencils are provided as keyword arguments to the operator (based on the boundary label names):","category":"page"},{"location":"tutorials/introduction/","page":"Introduction to ClimaCore.jl","title":"Introduction to ClimaCore.jl","text":"sinz = sin.(column_center_coords.z)\ngradc2f = ClimaCore.Operators.GradientC2F(\n    bottom = ClimaCore.Operators.SetValue(sin(0.0)),\n    top = ClimaCore.Operators.SetGradient(\n        ClimaCore.Geometry.Cartesian3Vector(cos(10.0)),\n    ),\n)\n∇sinz = gradc2f.(sinz)","category":"page"},{"location":"tutorials/introduction/","page":"Introduction to ClimaCore.jl","title":"Introduction to ClimaCore.jl","text":"plot(\n    ClimaCore.Geometry.CartesianVector.(∇sinz).components.data.:1,\n    ylim = (0, 10),\n)","category":"page"},{"location":"tutorials/introduction/","page":"Introduction to ClimaCore.jl","title":"Introduction to ClimaCore.jl","text":"As before, multiple operators (or functions) can be fused together with broadcasting.","category":"page"},{"location":"tutorials/introduction/","page":"Introduction to ClimaCore.jl","title":"Introduction to ClimaCore.jl","text":"One extra advantage of this is that boundaries of the inner operators only need to be specified if they would affect the final result.","category":"page"},{"location":"tutorials/introduction/","page":"Introduction to ClimaCore.jl","title":"Introduction to ClimaCore.jl","text":"Consider the center-to-center Laplacian:","category":"page"},{"location":"tutorials/introduction/","page":"Introduction to ClimaCore.jl","title":"Introduction to ClimaCore.jl","text":"...\n      \\       /\n        ∇θ[2+½]\n      /       \\\nθ[2]            ∇⋅∇θ[2]\n      \\       /\n        ∇θ[1+½]\n      /       \\\nθ[1]            ∇⋅∇θ[1]\n              /\n         ∇θ*","category":"page"},{"location":"tutorials/introduction/","page":"Introduction to ClimaCore.jl","title":"Introduction to ClimaCore.jl","text":"sinz = sin.(column_center_coords.z)\n# we don't need to specify boundaries, as the stencil won't reach that far\ngradc2f = ClimaCore.Operators.GradientC2F()\ndivf2c = ClimaCore.Operators.DivergenceF2C(\n    bottom = ClimaCore.Operators.SetValue(\n        ClimaCore.Geometry.Cartesian3Vector(cos(0.0)),\n    ),\n    top = ClimaCore.Operators.SetValue(\n        ClimaCore.Geometry.Cartesian3Vector(cos(10.0)),\n    ),\n)\n∇∇sinz = divf2c.(gradc2f.(sinz))","category":"page"},{"location":"tutorials/introduction/","page":"Introduction to ClimaCore.jl","title":"Introduction to ClimaCore.jl","text":"plot(∇∇sinz, ylim = (0, 10))","category":"page"},{"location":"tutorials/introduction/#.-Solving-PDEs","page":"Introduction to ClimaCore.jl","title":"3. Solving PDEs","text":"","category":"section"},{"location":"tutorials/introduction/","page":"Introduction to ClimaCore.jl","title":"Introduction to ClimaCore.jl","text":"ClimaCore can be used for spatial discretizations of PDEs. For temporal discretization, we can use the OrdinaryDiffEq package, which we aim to be compatibile with.","category":"page"},{"location":"tutorials/introduction/","page":"Introduction to ClimaCore.jl","title":"Introduction to ClimaCore.jl","text":"using OrdinaryDiffEq","category":"page"},{"location":"tutorials/introduction/#.1-Heat-equation-using-finite-differences","page":"Introduction to ClimaCore.jl","title":"3.1 Heat equation using finite differences","text":"","category":"section"},{"location":"tutorials/introduction/","page":"Introduction to ClimaCore.jl","title":"Introduction to ClimaCore.jl","text":"We will use a cell-center discretization of the heat equation:","category":"page"},{"location":"tutorials/introduction/","page":"Introduction to ClimaCore.jl","title":"Introduction to ClimaCore.jl","text":"fracpartial ypartial t = alpha nabla cdot nabla y","category":"page"},{"location":"tutorials/introduction/","page":"Introduction to ClimaCore.jl","title":"Introduction to ClimaCore.jl","text":"At the bottom we will use a Dirichlet condition y(0) = 1at the bottom: since we don't actually have a value located at the bottom, we will use aSetValue` boundary modifier on the inner gradient.","category":"page"},{"location":"tutorials/introduction/","page":"Introduction to ClimaCore.jl","title":"Introduction to ClimaCore.jl","text":"At the top we will use a Neumann condition fracpartial ypartial z(10) = 0. We can do this two equivalent ways:","category":"page"},{"location":"tutorials/introduction/","page":"Introduction to ClimaCore.jl","title":"Introduction to ClimaCore.jl","text":"a SetGradient on the gradient operator\na SetValue on the divergence operator","category":"page"},{"location":"tutorials/introduction/","page":"Introduction to ClimaCore.jl","title":"Introduction to ClimaCore.jl","text":"either will work.","category":"page"},{"location":"tutorials/introduction/","page":"Introduction to ClimaCore.jl","title":"Introduction to ClimaCore.jl","text":"y0 = zeros(column_center_space)\n\n# define the tendency function\nfunction heat_fd_tendency!(dydt, y, α, t)\n    gradc2f = ClimaCore.Operators.GradientC2F(\n        bottom = ClimaCore.Operators.SetValue(1.0),\n        top = ClimaCore.Operators.SetGradient(\n            ClimaCore.Geometry.Cartesian3Vector(0.0),\n        ),\n    )\n    divf2c = ClimaCore.Operators.DivergenceF2C()\n    # the @. macro \"dots\" the whole expression\n    # i.e.  dydt .= α .* divf2c.(gradc2f.(y))\n    @. dydt = α * divf2c(gradc2f(y))\nend\n\nheat_fd_prob = ODEProblem(heat_fd_tendency!, y0, (0.0, 5.0), 0.1)\nheat_fd_sol = solve(heat_fd_prob, SSPRK33(), dt = 0.1, saveat = 0.25)","category":"page"},{"location":"tutorials/introduction/","page":"Introduction to ClimaCore.jl","title":"Introduction to ClimaCore.jl","text":"anim = Plots.@animate for u in heat_fd_sol.u\n    plot(u, xlim = (0, 1), ylim = (0, 10))\nend\nmp4(anim)","category":"page"},{"location":"tutorials/introduction/#.2-Heat-equation-using-continuous-Galerkin-(CG)-spectral-element","page":"Introduction to ClimaCore.jl","title":"3.2 Heat equation using continuous Galerkin (CG) spectral element","text":"","category":"section"},{"location":"tutorials/introduction/","page":"Introduction to ClimaCore.jl","title":"Introduction to ClimaCore.jl","text":"function heat_cg_tendency!(dydt, y, α, t)\n    grad = ClimaCore.Operators.Gradient()\n    wdiv = ClimaCore.Operators.WeakDivergence()\n    # apply element operators\n    @. dydt = α * wdiv(grad(y))\n\n    # direct stiffness summation (DSS): project to continuous function space\n    ClimaCore.Spaces.weighted_dss!(dydt)\n    return dydt\nend\n\ny0 = exp.(.-(coord.y .^ 2 .+ coord.x .^ 2) ./ 2)\n\nheat_cg_prob = ODEProblem(heat_cg_tendency!, y0, (0.0, 5.0), 0.1)\nheat_cg_sol = solve(heat_cg_prob, SSPRK33(), dt = 0.1, saveat = 0.5)","category":"page"},{"location":"tutorials/introduction/","page":"Introduction to ClimaCore.jl","title":"Introduction to ClimaCore.jl","text":"anim = Plots.@animate for u in heat_cg_sol.u\n    Plots.plot(u, c = :thermal)\nend\nmp4(anim)","category":"page"},{"location":"tutorials/introduction/#.3-Shallow-water-equations","page":"Introduction to ClimaCore.jl","title":"3.3 Shallow water equations","text":"","category":"section"},{"location":"tutorials/introduction/","page":"Introduction to ClimaCore.jl","title":"Introduction to ClimaCore.jl","text":"The shallow water equations in vector invariant form can be written as","category":"page"},{"location":"tutorials/introduction/","page":"Introduction to ClimaCore.jl","title":"Introduction to ClimaCore.jl","text":"beginalign*\n    fracpartial rhopartial t + nabla cdot (rho u) = 0\n    fracpartial u_ipartial t + nabla (Phi + tfrac12u^2)_i  = J (u times (nabla times u))_i\nendalign*","category":"page"},{"location":"tutorials/introduction/","page":"Introduction to ClimaCore.jl","title":"Introduction to ClimaCore.jl","text":"where J is the Jacobian determinant, and Phi = g rho.","category":"page"},{"location":"tutorials/introduction/","page":"Introduction to ClimaCore.jl","title":"Introduction to ClimaCore.jl","text":"Note that the velocity u is specified in covariant coordinates u_i.","category":"page"},{"location":"tutorials/introduction/","page":"Introduction to ClimaCore.jl","title":"Introduction to ClimaCore.jl","text":"For vizualization purposes, we can model a passive tracer theta as","category":"page"},{"location":"tutorials/introduction/","page":"Introduction to ClimaCore.jl","title":"Introduction to ClimaCore.jl","text":"fracpartial rho thetapartial t + nabla cdot (rho theta u) = 0","category":"page"},{"location":"tutorials/introduction/","page":"Introduction to ClimaCore.jl","title":"Introduction to ClimaCore.jl","text":"using ClimaCore.Geometry\n\nparameters = (\n    ϵ = 0.1,  ## perturbation size for initial condition\n    l = 0.5, ## Gaussian width\n    k = 0.5, ## Sinusoidal wavenumber\n    ρ₀ = 1.0, ## reference density\n    c = 2,\n    g = 10,\n    D₄ = 1e-4, ## hyperdiffusion coefficient\n)\n\nfunction init_state(local_geometry, p)\n    coord = local_geometry.coordinates\n    @unpack x, y = coord\n    # set initial state\n    ρ = p.ρ₀\n\n    # set initial velocity\n    U₁ = cosh(y)^(-2)\n\n    # Ψ′ = exp(-(x2 + p.l / 10)^2 / 2p.l^2) * cos(p.k * x) * cos(p.k * y)\n    # Vortical velocity fields (u₁′, u₂′) = (-∂²Ψ′, ∂¹Ψ′)\n    ϕ = exp(-(y + p.l / 10)^2 / 2p.l^2)\n    u₁′ = ϕ * (y + p.l / 10) / p.l^2 * cos(p.k * x) * cos(p.k * y)\n    u₁′ += p.k * ϕ * cos(p.k * x) * sin(p.k * y)\n    u₂′ = -p.k * ϕ * sin(p.k * x) * cos(p.k * y)\n\n    u = Geometry.Covariant12Vector(\n        Geometry.Cartesian12Vector(U₁ + p.ϵ * u₁′, p.ϵ * u₂′),\n        local_geometry,\n    )\n\n    # set initial tracer\n    θ = sin(p.k * y)\n    return (ρ = ρ, u = u, ρθ = ρ * θ)\nend\n\n\ny0 =\n    init_state.(\n        ClimaCore.Fields.local_geometry_field(rectangle_space),\n        Ref(parameters),\n    )\n\n# plot initial tracer\nPlots.plot(y0.ρθ)","category":"page"},{"location":"tutorials/introduction/","page":"Introduction to ClimaCore.jl","title":"Introduction to ClimaCore.jl","text":"function shallow_water_tendency!(dydt, y, _, t)\n\n    @unpack D₄, g = parameters\n\n    sdiv = ClimaCore.Operators.Divergence()\n    wdiv = ClimaCore.Operators.WeakDivergence()\n    grad = ClimaCore.Operators.Gradient()\n    wgrad = ClimaCore.Operators.WeakGradient()\n    curl = ClimaCore.Operators.Curl()\n    wcurl = ClimaCore.Operators.WeakCurl()\n\n\n    # compute hyperviscosity first\n    @. dydt.u =\n        wgrad(sdiv(y.u)) -\n        Geometry.Covariant12Vector(wcurl(Geometry.Covariant3Vector(curl(y.u))))\n    @. dydt.ρθ = wdiv(grad(y.ρθ))\n\n    ClimaCore.Spaces.weighted_dss!(dydt)\n\n    @. dydt.u =\n        -D₄ *\n        (wgrad(sdiv(dydt.u)) - Geometry.Covariant12Vector(wcurl(curl(dydt.u))))\n    @. dydt.ρθ = -D₄ * wdiv(grad(dydt.ρθ))\n\n    # comute rest of tendency\n    @. begin\n        dydt.ρ = -wdiv(y.ρ * y.u)\n        dydt.u += -grad(g * y.ρ + norm(y.u)^2 / 2) + y.u × curl(y.u)\n        dydt.ρθ += -wdiv(y.ρθ * y.u)\n    end\n    ClimaCore.Spaces.weighted_dss!(dydt)\n    return dydt\nend","category":"page"},{"location":"tutorials/introduction/","page":"Introduction to ClimaCore.jl","title":"Introduction to ClimaCore.jl","text":"shallow_water_prob = ODEProblem(shallow_water_tendency!, y0, (0.0, 20.0))\n@time shallow_water_sol =\n    solve(shallow_water_prob, SSPRK33(), dt = 0.05, saveat = 1.0)\nanim = Plots.@animate for u in shallow_water_sol.u\n    Plots.plot(u.ρθ, clim = (-1, 1))\nend\nmp4(anim)","category":"page"},{"location":"tutorials/introduction/","page":"Introduction to ClimaCore.jl","title":"Introduction to ClimaCore.jl","text":"","category":"page"},{"location":"tutorials/introduction/","page":"Introduction to ClimaCore.jl","title":"Introduction to ClimaCore.jl","text":"This page was generated using Literate.jl.","category":"page"}]
}
