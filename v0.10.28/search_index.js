var documenterSearchIndex = {"docs":
[{"location":"references/#References","page":"References","title":"References","text":"","category":"section"},{"location":"references/","page":"References","title":"References","text":"","category":"page"},{"location":"lib/ClimaCoreSpectra/#ClimaCoreSpectra.jl","page":"ClimaCoreSpectra.jl","title":"ClimaCoreSpectra.jl","text":"","category":"section"},{"location":"lib/ClimaCoreSpectra/","page":"ClimaCoreSpectra.jl","title":"ClimaCoreSpectra.jl","text":"CurrentModule = ClimaCoreSpectra","category":"page"},{"location":"lib/ClimaCoreSpectra/","page":"ClimaCoreSpectra.jl","title":"ClimaCoreSpectra.jl","text":"ClimaCoreSpectra.jl provides functionality for calculating kinetic energy spectra using spherical harmonics.","category":"page"},{"location":"lib/ClimaCoreSpectra/#Interface","page":"ClimaCoreSpectra.jl","title":"Interface","text":"","category":"section"},{"location":"lib/ClimaCoreSpectra/","page":"ClimaCoreSpectra.jl","title":"ClimaCoreSpectra.jl","text":"ClimaCoreSpectra.SpectralSphericalMesh\nClimaCoreSpectra.power_spectrum_1d\nClimaCoreSpectra.power_spectrum_2d\nClimaCoreSpectra.compute_gaussian!\nClimaCoreSpectra.compute_legendre!\nClimaCoreSpectra.trans_grid_to_spherical!\nClimaCoreSpectra.compute_wave_numbers!","category":"page"},{"location":"lib/ClimaCoreSpectra/#ClimaCoreSpectra.SpectralSphericalMesh","page":"ClimaCoreSpectra.jl","title":"ClimaCoreSpectra.SpectralSphericalMesh","text":"SpectralSphericalMesh\n\nSpherical mesh data structure for calculating spectra. The mesh represents a regular lat-long grid.\n\n\n\n\n\n","category":"type"},{"location":"lib/ClimaCoreSpectra/#ClimaCoreSpectra.power_spectrum_1d","page":"ClimaCoreSpectra.jl","title":"ClimaCoreSpectra.power_spectrum_1d","text":"power_spectrum_1d(FT, var_grid, z, lat, lon, weight)\n\nFor a variable var_grid on a (lon,lat,z) grid, given an array of weights, compute the zonal (1D) power spectrum using a Fourier transform at each Gaussian latitude. The input field must be first intepolated to a Gaussian grid.\n\nArguments\n\nFT: FloatType\nvar_grid: variable on a Gaussian (lon, lat, z) grid to be transformed\nz: Array with uniform z levels\nlat: Array with uniform lats\nlon: Array with uniform longs\nweight: Array with weights for mass-weighted calculations\n\n\n\n\n\n","category":"function"},{"location":"lib/ClimaCoreSpectra/#ClimaCoreSpectra.power_spectrum_2d","page":"ClimaCoreSpectra.jl","title":"ClimaCoreSpectra.power_spectrum_2d","text":"power_spectrum_2d(FT, var_grid, mass_weight)\n\nTransform a variable defined on a regular lat long grid to the 2d spectral space using fft on latitude circles (as for the 1D spectrum) and Legendre polynomials for meridians, and calculate spectra.\n\nArguments\n\nFT: FloatType\nvar_grid: variable on a Gaussian (lon, lat, z) grid to be transformed\nmass_weight: Array with weights for mass-weighted calculations.\n\nReferences\n\nFerdinand Baer (1972)\n\n\n\n\n\n","category":"function"},{"location":"lib/ClimaCoreSpectra/#ClimaCoreSpectra.compute_gaussian!","page":"ClimaCoreSpectra.jl","title":"ClimaCoreSpectra.compute_gaussian!","text":"compute_gaussian!(FT, n)\n\nCompute sin(latitude) and the weight factors for Gaussian integration.\n\nArguments\n\nFT: FloatType\nn: Int, number of Gaussian latitudes\n\nReferences\n\nEhrendorfer, M., Spectral Numerical Weather Prediction Models, Appendix B, Society for Industrial and Applied Mathematics, 2011\n\nDetails (following notation from Ehrendorfer, 2011):\n\nPn(x) is an odd function\nsolve half of the n roots and weightes of Pn(x) # n = 2n_half\nP_{-1}(x) = 0\nP_0(x) = 1\nP_1(x) = x\nnP_n(x) = (2n-1)xP_{n-1}(x) - (n-1)P_{n-2}(x)\nP'_n(x) = n/(x^2-1)(xP_{n}(x) - P_{n-1}(x))\nx -= P_n(x)/P'_{n}()\nInitial guess xi^{0} = cos(π(i-0.25)/(n+0.5))\nwi = 2/(1-xi^2)/P_n'(xi)^2\n\n\n\n\n\n","category":"function"},{"location":"lib/ClimaCoreSpectra/#ClimaCoreSpectra.compute_legendre!","page":"ClimaCoreSpectra.jl","title":"ClimaCoreSpectra.compute_legendre!","text":"compute_legendre!(FT, num_fourier, num_spherical, sinθ, nθ)\n\nNormalized associated Legendre polynomials, P_{m,l} = qnm.\n\nArguments:\n\nFT: FloatType\nnum_fourier: Int, number of truncated zonal wavenumbers (m)\nnum_spherical: Int, number of total wavenumbers (n)\nsinθ: Array{FT} with sin(latitude)\nnθ: Int, number of Gaussian latitudes\n\nReferences:\n\nEhrendorfer, M. (2011) Spectral Numerical Weather Prediction Models, Appendix B, Society for Industrial and Applied Mathematics\nWinch, D. (2007) Spherical harmonics, in Encyclopedia of Geomagnetism and Paleomagnetism, Eds Gubbins D. and Herrero-Bervera, E., Springer\n\nDetails (using notation and Eq. references from Ehrendorfer, 2011):\n\nl=0,1...∞    and m = -l, -l+1, ... l-1, l\nP_{0,0} = 1, such that 1/4π ∫∫YYdS = δ (where Y = spherical harmonics, S = domain surface area)\nP_{m,m} = sqrt((2m+1)/2m) cosθ P_{m-1,m-1}\nP_{m+1,m} = sqrt(2m+3) sinθ P_{m,m}\nsqrt((l^2-m^2)/(4l^2-1))P_{l,m} = P_{l-1, m} -  sqrt(((l-1)^2-m^2)/(4(l-1)^2 - 1))P_{l-2,m}\nTHe normalization assures that 1/2 ∫_{-1}^1 P_{l,m}(sinθ) P_{n,m}(sinθ) dsinθ = δ_{n,l}\nJulia index starts with 1, so qnm[m+1,l+1] = P_l^m\n\n\n\n\n\n","category":"function"},{"location":"lib/ClimaCoreSpectra/#ClimaCoreSpectra.trans_grid_to_spherical!","page":"ClimaCoreSpectra.jl","title":"ClimaCoreSpectra.trans_grid_to_spherical!","text":"trans_grid_to_spherical!(mesh::SpectralSphericalMesh, pfield::Arr{FT,2})\n\nTransforms a variable on a Gaussian grid (pfield[nλ, nθ]) into the spherical harmonics domain (varspherical2d[numfourier+1, num_spherical+1]).\n\nDetails:\n\nHere λ = longitude, θ = latitude, η = sinθ, m = zonal wavenumber, n = total wavenumber:\nvar_spherical2d = F_{m,n}    # Output variable in spectral space (Complex{FT}[num_fourier+1, num_spherical+1])\nqwg = P_{m,n}(η)w(η)         # Weighted Legendre polynomials (FT[num_fourier+1, num_spherical+1, nθ])\nvar_fourier2d = g_{m, θ}     # Untruncated Fourier transformation (Complex{FT} [nλ, nθ])\npfield = F(λ, η)             # Input variable on Gaussian grid FT[nλ, nθ]\n\nArguments\n\nmesh: struct with mesh information\npfield: variable on Gaussian grid to be transformed\n\nReferences\n\nEhrendorfer, M., Spectral Numerical Weather Prediction Models, Appendix B, Society for Industrial and Applied Mathematics, 2011\nAksel WIIN-NIELSEN (1967)\n\n\n\n\n\n","category":"function"},{"location":"lib/ClimaCoreSpectra/#ClimaCoreSpectra.compute_wave_numbers!","page":"ClimaCoreSpectra.jl","title":"ClimaCoreSpectra.compute_wave_numbers!","text":"compute_wave_numbers!(wave_numbers, num_fourier::Int, num_spherical::Int)\n\nStore the total wave number n for this basis in a matrix wave_numbers of shape [m,n].\n\nArguments:\n\nwavenumbers: Matrix of [Int, Int] to store the wave wavenumbers\nnum_fourier: Int, number of truncated zonal wavenumbers (m)\nnum_spherical: Int, number of total wavenumbers (n)\n\n\n\n\n\n","category":"function"},{"location":"lib/ClimaCoreSpectra/#Examples","page":"ClimaCoreSpectra.jl","title":"Examples","text":"","category":"section"},{"location":"lib/ClimaCoreSpectra/","page":"ClimaCoreSpectra.jl","title":"ClimaCoreSpectra.jl","text":"import ClimaCore\nfn = joinpath(pkgdir(ClimaCore), \"lib\", \"ClimaCoreSpectra\", \"test\", \"gcm_visual_test.jl\")\n@show fn\nENV[\"BUILD_DOCS\"]=true\ninclude(fn)","category":"page"},{"location":"lib/ClimaCoreSpectra/#D-Spectrum-Test","page":"ClimaCoreSpectra.jl","title":"1D Spectrum Test","text":"","category":"section"},{"location":"lib/ClimaCoreSpectra/#Input-wave-frequency","page":"ClimaCoreSpectra.jl","title":"Input wave frequency","text":"","category":"section"},{"location":"lib/ClimaCoreSpectra/","page":"ClimaCoreSpectra.jl","title":"ClimaCoreSpectra.jl","text":"(Image: A 1D wave.)","category":"page"},{"location":"lib/ClimaCoreSpectra/#Raw-data-on-rll-grid","page":"ClimaCoreSpectra.jl","title":"Raw data on rll grid","text":"","category":"section"},{"location":"lib/ClimaCoreSpectra/","page":"ClimaCoreSpectra.jl","title":"ClimaCoreSpectra.jl","text":"(Image: The 1D raw data to be transformed.)","category":"page"},{"location":"lib/ClimaCoreSpectra/#D-Spectrum","page":"ClimaCoreSpectra.jl","title":"1D Spectrum","text":"","category":"section"},{"location":"lib/ClimaCoreSpectra/","page":"ClimaCoreSpectra.jl","title":"ClimaCoreSpectra.jl","text":"(Image: The 1D spectrum calculated from the data.)","category":"page"},{"location":"lib/ClimaCoreSpectra/#D-Spectrum-Test-2","page":"ClimaCoreSpectra.jl","title":"2D Spectrum Test","text":"","category":"section"},{"location":"lib/ClimaCoreSpectra/#Raw-data-on-rll-grid-2","page":"ClimaCoreSpectra.jl","title":"Raw data on rll grid","text":"","category":"section"},{"location":"lib/ClimaCoreSpectra/","page":"ClimaCoreSpectra.jl","title":"ClimaCoreSpectra.jl","text":"(Image: The 2D raw data to be transformed.)","category":"page"},{"location":"lib/ClimaCoreSpectra/#Reconstruct-onto-spectral-space-and-transform-back-to-original","page":"ClimaCoreSpectra.jl","title":"Reconstruct onto spectral space and transform back to original","text":"","category":"section"},{"location":"lib/ClimaCoreSpectra/","page":"ClimaCoreSpectra.jl","title":"ClimaCoreSpectra.jl","text":"(Image: The 2D transformed data.)","category":"page"},{"location":"lib/ClimaCoreSpectra/#Error","page":"ClimaCoreSpectra.jl","title":"Error","text":"","category":"section"},{"location":"lib/ClimaCoreSpectra/","page":"ClimaCoreSpectra.jl","title":"ClimaCoreSpectra.jl","text":"(Image: The error between the transformed and initial data.)","category":"page"},{"location":"lib/ClimaCoreSpectra/#D-Spectra","page":"ClimaCoreSpectra.jl","title":"2D Spectra","text":"","category":"section"},{"location":"lib/ClimaCoreSpectra/","page":"ClimaCoreSpectra.jl","title":"ClimaCoreSpectra.jl","text":"(Image: The 2D spectrum calculated from the data.)","category":"page"},{"location":"lib/ClimaCorePlots/#ClimaCorePlots.jl","page":"ClimaCorePlots.jl","title":"ClimaCorePlots.jl","text":"","category":"section"},{"location":"lib/ClimaCorePlots/","page":"ClimaCorePlots.jl","title":"ClimaCorePlots.jl","text":"CurrentModule = ClimaCorePlots","category":"page"},{"location":"lib/ClimaCorePlots/","page":"ClimaCorePlots.jl","title":"ClimaCorePlots.jl","text":"ClimaCorePlots.jl provides functionality for plotting ClimaCore fields extending the Plots.jl package.","category":"page"},{"location":"lib/ClimaCoreVTK/#ClimaCoreVTK.jl","page":"ClimaCoreVTK.jl","title":"ClimaCoreVTK.jl","text":"","category":"section"},{"location":"lib/ClimaCoreVTK/","page":"ClimaCoreVTK.jl","title":"ClimaCoreVTK.jl","text":"CurrentModule = ClimaCoreVTK","category":"page"},{"location":"lib/ClimaCoreVTK/","page":"ClimaCoreVTK.jl","title":"ClimaCoreVTK.jl","text":"ClimaCoreVTK.jl provides functionality for writing ClimaCore fields to VTK files, using the WriteVTK.jl package.","category":"page"},{"location":"lib/ClimaCoreVTK/#Interface","page":"ClimaCoreVTK.jl","title":"Interface","text":"","category":"section"},{"location":"lib/ClimaCoreVTK/","page":"ClimaCoreVTK.jl","title":"ClimaCoreVTK.jl","text":"writevtk\nwritepvd","category":"page"},{"location":"lib/ClimaCoreVTK/#ClimaCoreVTK.writevtk","page":"ClimaCoreVTK.jl","title":"ClimaCoreVTK.writevtk","text":"writevtk(\n    basename::String,\n    fields;\n    basis=:cell,\n    latlong=false,\n    vtkargs...\n)\n\nWrite fields to as an unstructured mesh VTK file named basename.vtu.\n\nfields can be either:\n\na ClimaCore Field object,\na FieldVector object,\na NamedTuple of Fields.\n\nThe basis keyword option determines the type of cells used to write.:\n\n:cell (default): output values at cell centers (interpolating where necessary).\n:point: output values at cell vertices.\n:lagrange: output values at Lagrange nodes (valid only for spectral element spaces), using Use VTK Lagrange cells to accurately represent high-order elements.\n\nThe latlong=true keyword option will output a spherical or spherical shell domain using the Mercator projection, with longitude along the x-axis, latitude along the y-axis, and altitude along the z-axis (if applicable). Note this currently only displays correctly if the number of elements across the cubed sphere face is even.\n\nAny additional keyword arguments are passed to WriteVTK.vtk_grid.\n\n\n\n\n\n","category":"function"},{"location":"lib/ClimaCoreVTK/#ClimaCoreVTK.writepvd","page":"ClimaCoreVTK.jl","title":"ClimaCoreVTK.writepvd","text":"writepvd(\n    basename::String,\n    times,\n    fields;\n    vtkargs...\n)\n\nWrite a sequence of fields at times as a Paraview collection (.pvd) file, along with VTK files.\n\nfields can be either be an iterable collection of fields, or a NamedTuple of collections.\n\n\n\n\n\n","category":"function"},{"location":"lib/ClimaCoreVTK/#Internal-functions","page":"ClimaCoreVTK.jl","title":"Internal functions","text":"","category":"section"},{"location":"lib/ClimaCoreVTK/","page":"ClimaCoreVTK.jl","title":"ClimaCoreVTK.jl","text":"vtk_grid\nvtk_cells_lagrange\nvtk_cells_linear\nvtk_grid_space\nvtk_cell_space\naddfield!","category":"page"},{"location":"lib/ClimaCoreVTK/#WriteVTK.vtk_grid","page":"ClimaCoreVTK.jl","title":"WriteVTK.vtk_grid","text":"vtk_grid(basename, gridspace::ClimaCore.Spaces.AbstractSpace;\n    basis=:cell, vtkargs...)\n\nConstruct a VTK grid from a ClimaCore.Spaces.AbstractSpace. If basis=:lagrange, it will construct a mesh made of Lagrange cells (valid only for spectral element spaces), otherwise it will it subdivide the space into quads, with vertices at nodal points.\n\n\n\n\n\n","category":"function"},{"location":"lib/ClimaCoreVTK/#ClimaCoreVTK.vtk_cells_lagrange","page":"ClimaCoreVTK.jl","title":"ClimaCoreVTK.vtk_cells_lagrange","text":"vtkcellslagrange(space)\n\nConstruct a vector of MeshCell objects representing the elements of space as an unstuctured mesh of Lagrange polynomial cells, suitable for passing to vtk_grid.\n\n\n\n\n\n","category":"function"},{"location":"lib/ClimaCoreVTK/#ClimaCoreVTK.vtk_cells_linear","page":"ClimaCoreVTK.jl","title":"ClimaCoreVTK.vtk_cells_linear","text":"vtkcellslinear(space)\n\nConstruct a vector of MeshCell objects representing the elements of space as an unstuctured mesh of linear cells, suitable for passing to vtk_grid.\n\n\n\n\n\n","category":"function"},{"location":"lib/ClimaCoreVTK/#ClimaCoreVTK.vtk_grid_space","page":"ClimaCoreVTK.jl","title":"ClimaCoreVTK.vtk_grid_space","text":"vtk_grid_space(space::ClimaCore.Spaces.AbstractSpace)\n\nThe space for the grid used by VTK, for any field on space.\n\nThis generally does two things:\n\nModifies the horizontal space to use a ClosedUniform quadrature rule, which will use equispaced nodal points in the reference element. This is required for using VTK Lagrange elements (see 1).\nModifies the vertical space to be on the faces.\n\n\n\n\n\n","category":"function"},{"location":"lib/ClimaCoreVTK/#ClimaCoreVTK.vtk_cell_space","page":"ClimaCoreVTK.jl","title":"ClimaCoreVTK.vtk_cell_space","text":"vtk_cell_space(gridspace::ClimaCore.Spaces.AbstractSpace)\n\nConstruct a space for outputting cell data, when using outputting a grid gridspace. be stored.\n\nThis generally does two things:\n\nModifies the horizontal space to use a Uniform quadrature rule, which will use equispaced nodal points in the reference element (excluding the boundary).\nModifies the vertical space to be on the centers.\n\n\n\n\n\n","category":"function"},{"location":"lib/ClimaCoreVTK/#ClimaCoreVTK.addfield!","page":"ClimaCoreVTK.jl","title":"ClimaCoreVTK.addfield!","text":"addfield!(vtkfile, prefix::Union{String,Nothing}, f, dataspace)\n\nAdd a field or fields f, optionally prefixing the name with prefix to the VTK file vtkfile, interpolating to dataspace.\n\nf can be any of the following:\n\na scalar or vector field (if no prefix is provided, then the field will be named \"data\")\na composite field, which will be named accordingly\na NamedTuple of fields\n\n\n\n\n\n","category":"function"},{"location":"installation_instructions/#Installation","page":"Installation and How-to Guides","title":"Installation","text":"","category":"section"},{"location":"installation_instructions/","page":"Installation and How-to Guides","title":"Installation and How-to Guides","text":"ClimaCore.jl is a registered Julia package. You can install the latest version of ClimaCore.jl through the built-in package manager. Press ] in the Julia REPL command prompt and","category":"page"},{"location":"installation_instructions/","page":"Installation and How-to Guides","title":"Installation and How-to Guides","text":"julia> ]\n(v1.8) pkg> add ClimaCore\n(v1.8) pkg> instantiate","category":"page"},{"location":"installation_instructions/","page":"Installation and How-to Guides","title":"Installation and How-to Guides","text":"This will install the latest tagged release of the package.","category":"page"},{"location":"installation_instructions/","page":"Installation and How-to Guides","title":"Installation and How-to Guides","text":"info: But I wanna be on the bleeding edge...\nIf you want the most recent developer's version of the package thenjulia> ]\n(v1.8) pkg> add ClimaCore#main\n(v1.8) pkg> instantiate","category":"page"},{"location":"installation_instructions/","page":"Installation and How-to Guides","title":"Installation and How-to Guides","text":"You can run the tests via the package manager by:","category":"page"},{"location":"installation_instructions/","page":"Installation and How-to Guides","title":"Installation and How-to Guides","text":"julia> ]\n(v1.8) pkg> test ClimaCore","category":"page"},{"location":"installation_instructions/#Running-examples","page":"Installation and How-to Guides","title":"Running examples","text":"","category":"section"},{"location":"installation_instructions/","page":"Installation and How-to Guides","title":"Installation and How-to Guides","text":"We have a selection of examples, found within the examples/ directory to demonstrate different use of our library. Each example directory contains a Project.toml","category":"page"},{"location":"installation_instructions/","page":"Installation and How-to Guides","title":"Installation and How-to Guides","text":"To build with the latest ClimaCore.jl release:","category":"page"},{"location":"installation_instructions/","page":"Installation and How-to Guides","title":"Installation and How-to Guides","text":"> cd examples/\n> julia --project -e 'using Pkg; Pkg.instantiate()'\n> julia --project example_file_name.jl","category":"page"},{"location":"installation_instructions/","page":"Installation and How-to Guides","title":"Installation and How-to Guides","text":"If you wish to run a local modified version of ClimaCore.jl then try the following (starting from the ClimaCore.jl package root)","category":"page"},{"location":"installation_instructions/","page":"Installation and How-to Guides","title":"Installation and How-to Guides","text":"> cd examples/\n> julia --project\n> julia> ]\n> (examples)> rm ClimaCore.jl\n> (examples)> dev ../\n> (examples)> instantiate","category":"page"},{"location":"installation_instructions/","page":"Installation and How-to Guides","title":"Installation and How-to Guides","text":"followed by","category":"page"},{"location":"installation_instructions/","page":"Installation and How-to Guides","title":"Installation and How-to Guides","text":"> julia --project example_file_name.jl","category":"page"},{"location":"installation_instructions/#Attribution-and-Credits","page":"Installation and How-to Guides","title":"Attribution and Credits","text":"","category":"section"},{"location":"installation_instructions/","page":"Installation and How-to Guides","title":"Installation and How-to Guides","text":"These instructions and how-to guides are heavily based on the excellent EnsembleKalmanProcesses.jl Installation Instructions","category":"page"},{"location":"intro/#Introduction-to-ClimaCore.jl's-API-concepts","page":"Introduction","title":"Introduction to ClimaCore.jl's API concepts","text":"","category":"section"},{"location":"intro/#What-is-ClimaCore.jl?","page":"Introduction","title":"What is ClimaCore.jl?","text":"","category":"section"},{"location":"intro/","page":"Introduction","title":"Introduction","text":"A suite of tools for constructing spatial discretizations, entirely written in Julia.","category":"page"},{"location":"intro/","page":"Introduction","title":"Introduction","text":"primarily aimed at climate and weather models\ninitial aim:\nspectral element discretizations (both Continuous Galerkin and Discontinuous Galerkin) in the horizontal\nstaggered finite difference in the vertical\nsupport for Cartesian and spherical domains\ncurrently under development.","category":"page"},{"location":"intro/","page":"Introduction","title":"Introduction","text":"A sketch of some fundamental API objects in ClimaCore.jl:","category":"page"},{"location":"intro/","page":"Introduction","title":"Introduction","text":"(Image: ClimaCore.jl API objects)","category":"page"},{"location":"performance_tips/#Performance-tips-and-monitoring","page":"Performance tips","title":"Performance tips and monitoring","text":"","category":"section"},{"location":"performance_tips/","page":"Performance tips","title":"Performance tips","text":"This document outlines some performance tips and performance monitoring strategies.","category":"page"},{"location":"performance_tips/","page":"Performance tips","title":"Performance tips","text":"For the most part, this document focuses on some of the common performance gotcha's that we've observed in the CliMA codebase.","category":"page"},{"location":"performance_tips/","page":"Performance tips","title":"Performance tips","text":"There is a very good and thorough overview of performance tips in Julia's docs.","category":"page"},{"location":"performance_tips/#Avoiding-global-variables","page":"Performance tips","title":"Avoiding global variables","text":"","category":"section"},{"location":"performance_tips/","page":"Performance tips","title":"Performance tips","text":"Julia allows for function closures, which can be very handy, but can also result in performance cliffs, specifically if the captured variable is a non-constant global variable. So, for that reason, it's recommended to avoid closures when possible.","category":"page"},{"location":"performance_tips/#Dynamic-memory-allocations","page":"Performance tips","title":"Dynamic memory allocations","text":"","category":"section"},{"location":"performance_tips/","page":"Performance tips","title":"Performance tips","text":"Some Julia functions incur allocations. For example, push! dynamically allocates memory. Sometimes, we can avoid using push! if the length of the container we're pushing to is known. If the length is unknown, then one can use alternative methods, for example, map. In addition, if push! is the only viable option, it's recommended to specify (if possible) the container type. For example, Float64[] and not []. see these docs for more details.","category":"page"},{"location":"performance_tips/#Tracking-allocations","page":"Performance tips","title":"Tracking allocations","text":"","category":"section"},{"location":"performance_tips/","page":"Performance tips","title":"Performance tips","text":"Julia's performance docs above recommends to pay close attention to allocations. Allocations can be coarsely reported with the @time macro and more finely reported by using julia --track-allocation=all. From CodeCov.jl's docs:","category":"page"},{"location":"performance_tips/","page":"Performance tips","title":"Performance tips","text":"Start julia with","category":"page"},{"location":"performance_tips/","page":"Performance tips","title":"Performance tips","text":"julia --track-allocation=user","category":"page"},{"location":"performance_tips/","page":"Performance tips","title":"Performance tips","text":"Then:","category":"page"},{"location":"performance_tips/","page":"Performance tips","title":"Performance tips","text":"Run whatever commands you wish to test. This first run is to ensure that everything is compiled (because compilation allocates memory).\nCall Profile.clear_malloc_data()\nRun your commands again\nQuit julia","category":"page"},{"location":"performance_tips/","page":"Performance tips","title":"Performance tips","text":"Finally, navigate to the directory holding your source code. Start julia (without command-line flags), and analyze the results using","category":"page"},{"location":"performance_tips/","page":"Performance tips","title":"Performance tips","text":"using Coverage\nanalyze_malloc(dirnames)  # could be \".\" for the current directory, or \"src\", etc.","category":"page"},{"location":"performance_tips/","page":"Performance tips","title":"Performance tips","text":"This will return a vector of MallocInfo objects, specifying the number of bytes allocated, the file name, and the line number. These are sorted in increasing order of allocation size.","category":"page"},{"location":"performance_tips/#ReportMetrics.jl","page":"Performance tips","title":"ReportMetrics.jl","text":"","category":"section"},{"location":"performance_tips/","page":"Performance tips","title":"Performance tips","text":"CliMA's ReportMetrics.jl applies the strategy in the above section and provides a re-useable interface for reporting the top-most important allocations. Here is an example of it in use:","category":"page"},{"location":"performance_tips/","page":"Performance tips","title":"Performance tips","text":"rep_workload.jl\nperf.jl","category":"page"},{"location":"performance_tips/","page":"Performance tips","title":"Performance tips","text":"# File: rep_workload.jl\nimport Profile\n\nx = rand(1000)\n\nfunction foo()\n    s = 0.0\n    for i in x\n        s += i - rand()\n    end\n    return s\nend\n\nfor i in 1:100\n    foo()\nend\nProfile.clear_malloc_data()\nfor i in 1:100\n    foo()\nend","category":"page"},{"location":"performance_tips/","page":"Performance tips","title":"Performance tips","text":"# perf.jl\nimport ReportMetrics\nReportMetrics.report_allocs(;\n    job_name = \"RA_example\",\n    run_cmd = `$(Base.julia_cmd()) --track-allocation=all rep_workload.jl`,\n    dirs_to_monitor = [pwd()],\n)","category":"page"},{"location":"performance_tips/","page":"Performance tips","title":"Performance tips","text":"This will print out something like the following:","category":"page"},{"location":"performance_tips/","page":"Performance tips","title":"Performance tips","text":"[ Info: RA_example: Number of unique allocating sites: 2\n┌───────────────┬─────────────┬─────────────────────────────────────────┐\n│ Allocations % │ Allocations │                    <file>:<line number> │\n│       (xᵢ/∑x) │     (bytes) │                                         │\n├───────────────┼─────────────┼─────────────────────────────────────────┤\n│            77 │     7996800 │ ReportMetrics.jl/test/rep_workload.jl:7 │\n│            23 │     2387200 │ ReportMetrics.jl/test/rep_workload.jl:6 │\n└───────────────┴─────────────┴─────────────────────────────────────────┘","category":"page"},{"location":"performance_tips/","page":"Performance tips","title":"Performance tips","text":"From here, one can investigate where the most important allocations are coming from. Often, allocations arise from either:","category":"page"},{"location":"performance_tips/","page":"Performance tips","title":"Performance tips","text":"Using functions that inherently allocate\nFor example, push! inherently allocates\nAnother example: defining a new variable a = c .+ b. Here, a is a newly allocated variable. It could be put into a cache and computed in-place via a .= c .+ b, which is non-allocating for Julia-native types (e.g., Arrays).\nType instabilities. Sometimes type-instabilities can trigger the compiler to perform runtime inference, which results in allocations. So, fixing type instabilities is one way to fix / remove allocations.","category":"page"},{"location":"performance_tips/#References","page":"Performance tips","title":"References","text":"","category":"section"},{"location":"performance_tips/","page":"Performance tips","title":"Performance tips","text":"General julia-specific performance tips\nCode-coverage while tracking allocations\nCliMA's ReportMetrics.jl","category":"page"},{"location":"lib/ClimaCoreMakie/#ClimaCoreMakie.jl","page":"ClimaCoreMakie.jl","title":"ClimaCoreMakie.jl","text":"","category":"section"},{"location":"lib/ClimaCoreMakie/","page":"ClimaCoreMakie.jl","title":"ClimaCoreMakie.jl","text":"CurrentModule = ClimaCoreMakie","category":"page"},{"location":"lib/ClimaCoreMakie/","page":"ClimaCoreMakie.jl","title":"ClimaCoreMakie.jl","text":"ClimaCoreMakie.jl provides functionality for plotting ClimaCore fields extending the Makie.jl package.","category":"page"},{"location":"lib/ClimaCoreMakie/","page":"ClimaCoreMakie.jl","title":"ClimaCoreMakie.jl","text":"fieldheatmap!\nfieldcontourf!","category":"page"},{"location":"lib/ClimaCoreMakie/#ClimaCoreMakie.fieldheatmap!","page":"ClimaCoreMakie.jl","title":"ClimaCoreMakie.fieldheatmap!","text":"fieldheatmap(field)\n\nPlots a heatmap of a field.\n\nAttributes\n\nInherited from Makie.mesh. \n\ncolormap::Union{Symbol, Vector{<:Colorant}} = :viridis` sets the colormap that is sampled for numeric colors.\ncolorrange::Tuple{<:Real, <:Real} sets the values representing the start and end points of colormap.\nnan_color::Union{Symbol, <:Colorant} = RGBAf(0,0,0,0) sets a replacement color for color = NaN.\nlowclip::Union{Automatic, Symbol, <:Colorant} = automatic sets a color for any value below the colorrange.\nhighclip::Union{Automatic, Symbol, <:Colorant} = automatic sets a color for any value above the colorrange.\n\n\n\n\n\n","category":"function"},{"location":"lib/ClimaCoreMakie/#ClimaCoreMakie.fieldcontourf!","page":"ClimaCoreMakie.jl","title":"ClimaCoreMakie.fieldcontourf!","text":"fieldcontourf(field::Field)\n\nPlots a 2D filled contour plot of a field.\n\nAttributes\n\nThese are inherited from Makie.tricontourf:\n\nlevels = 10 can be either an Int which results in n bands delimited by n+1 equally spaced levels, or it can be an AbstractVector{<:Real} that lists n consecutive edges from low to high, which result in n-1 bands.\nmode = :normal sets the way in which a vector of levels is interpreted, if it's set to :relative, each number is interpreted as a fraction between the minimum and maximum values of zs. For example, levels = 0.1:0.1:1.0 would exclude the lower 10% of data.\nextendlow = nothing. This sets the color of an optional additional band from minimum(zs) to the lowest value in levels. If it's :auto, the lower end of the colormap is picked and the remaining colors are shifted accordingly. If it's any color representation, this color is used. If it's nothing, no band is added.\nextendhigh = nothing. This sets the color of an optional additional band from the highest value of levels to maximum(zs). If it's :auto, the high end of the colormap is picked and the remaining colors are shifted accordingly. If it's any color representation, this color is used. If it's nothing, no band is added.\ncolor sets the color of the plot. It can be given as a named color Symbol or a Colors.Colorant. Transparency can be included either directly as an alpha value in the Colorant or as an additional float in a tuple (color, alpha). The color can also be set for each scattered marker by passing a Vector of colors or be used to index the colormap by passing a Real number or Vector{<: Real}.\ncolormap::Union{Symbol, Vector{<:Colorant}} = :viridis sets the colormap from which the band colors are sampled.\n\n\n\n\n\n","category":"function"},{"location":"Contributing/#Contributing-Guide","page":"Contributing guide","title":"Contributing Guide","text":"","category":"section"},{"location":"Contributing/","page":"Contributing guide","title":"Contributing guide","text":"Thank you for considering contributing to ClimaCore.jl! We hope this guide helps you make a contribution.","category":"page"},{"location":"Contributing/#What-to-contribute?","page":"Contributing guide","title":"What to contribute?","text":"","category":"section"},{"location":"Contributing/","page":"Contributing guide","title":"Contributing guide","text":"The easiest way to contribute is by running ClimaCore.jl, identifying problems and opening issues.\nYou can tackle an existing issue. See our open Issues. We try to keep a list of good first issues accessible to new contributors.\nWrite an example or tutorial.\nImprove documentation or comments if you found something hard to use.\nImplement a new feature for ClimaCore.jl and its users.","category":"page"},{"location":"Contributing/","page":"Contributing guide","title":"Contributing guide","text":"If you're interested in working on something, let us know by commenting on existing issues or by opening a new issue. This is to make sure no one else is working on the same issue and so we can help and guide you in case there is anything you need to know beforehand.","category":"page"},{"location":"Contributing/#How-to-contribute-and-bug-reporting","page":"Contributing guide","title":"How to contribute and bug reporting","text":"","category":"section"},{"location":"Contributing/","page":"Contributing guide","title":"Contributing guide","text":"The simplest way to contribute to ClimaCore.jl is to create or comment on issues, requesting something you think is missing or reporting something you think is not functioning properly.","category":"page"},{"location":"Contributing/","page":"Contributing guide","title":"Contributing guide","text":"The most useful issues or bug reports:","category":"page"},{"location":"Contributing/","page":"Contributing guide","title":"Contributing guide","text":"Head over to the issues page.\nSearch to see if your issue already exists or has even been solved previously.\nIf you indeed have a new issue or request, click the \"New Issue\" button and select the Bug report template.\nProvide an explicit code snippet of code that reproduces the bug in the latest tagged version of ClimaCore.jl. Please be as specific as possible. Include the version of the code you were using, as well as what operating system you are running. The output of Julia's versioninfo() and ] status is helpful to include. Try your best to include a complete, \"minimal working example\" that reproduces the issue. Reducing bug-producing code to a minimal example can dramatically decrease the time it takes to resolve an issue.\nPaste the entire error received when running the code snippet, even if it's unbelievably long.\nUse triple backticks (e.g., ```some_code; and_some_more_code;```) to enclose code snippets, and other markdown formatting syntax to make your issue easy and quick to read.\nReport the ClimaCore.jl version, Julia version, machine (especially if using a GPU) and any other possibly useful details of the computational environment in which the bug was created.","category":"page"},{"location":"Contributing/","page":"Contributing guide","title":"Contributing guide","text":"Discussions are recommended for asking questions about (for example) the user interface, implementation details, science, and life in general.","category":"page"},{"location":"Contributing/#But-I-want-to-*code*!","page":"Contributing guide","title":"But I want to code!","text":"","category":"section"},{"location":"Contributing/","page":"Contributing guide","title":"Contributing guide","text":"New users help write ClimaCore.jl code and documentation by forking the ClimaCore.jl repository, using git to edit code and docs, and then creating a pull request. Pull requests are reviewed by ClimaCore.jl collaborators.\nA pull request can be merged once it is reviewed and approved by collaborators. If the pull request author has write access, they have the reponsibility of merging their pull request. Otherwise, ClimaCore.jl collabators will execute the merge with permission from the pull request author.\nNote: for small or minor changes (such as fixing a typo in documentation), the GitHub editor is super useful for forking and opening a pull request with a single click.\nWrite your code with love and care. In particular, conform to existing ClimaCore.jl style and formatting conventions. For example, we love verbose and explicit variable names, use TitleCase for types, snake_case for objects, and always.put.spaces.after.commas. For formatting decisions we loosely follow the YASGuide. It's worth few extra minutes of our time to leave future generations with well-written, readable code.","category":"page"},{"location":"Contributing/#Using-git","page":"Contributing guide","title":"Using git","text":"","category":"section"},{"location":"Contributing/","page":"Contributing guide","title":"Contributing guide","text":"If you are unfamiliar with git and version control, the following guides can be helpful:","category":"page"},{"location":"Contributing/","page":"Contributing guide","title":"Contributing guide","text":"Atlassian (bitbucket) git tutorials. A set of tips and tricks for getting started with git.\nGitHub's git tutorials. A set of resources from GitHub to learn git.","category":"page"},{"location":"Contributing/","page":"Contributing guide","title":"Contributing guide","text":"We provide a brief git tutorial in the Introduction to Best Practices of our ClimaWorkshops series.","category":"page"},{"location":"Contributing/#General-coding-guidelines","page":"Contributing guide","title":"General coding guidelines","text":"","category":"section"},{"location":"Contributing/","page":"Contributing guide","title":"Contributing guide","text":"Keep the number of members of Julia structs small if possible (less than 8 members).\nCode should reflect \"human intuition\" if possible. This mean abstraction should reflect how humans reason about the problem under consideration.\nCode with small blast radius. If your code needs to be modified or extendended, the resulting required changes should be as small and as localized as possible.\nWhen you write code, write it with testing and debugging in mind.\nIdeally, the lowest level structs have no defaults for their member fields. Nobody can remember all the defaults, so it is better to introduce them at the high-level API only.\nMake sure that module imports are specific so that it is easy to trace back where functions that are used inside a module are coming from.\nConsider naming abstract Julia types \"AbstractMyType\" in order to avoid confusion for the reader of your code.\nComments in your code should explain why the code exists and clarify if necessary, not just restate the line of code in words.\nBe mindful of namespace issues when writing functional code, especially when writing function code that represents mathematical or physical concepts.\nCondider using keywords in your structs to allow readers to more effectively reason about your code.","category":"page"},{"location":"Contributing/#Who-is-a-\"collaborator\"-and-how-can-I-become-one?","page":"Contributing guide","title":"Who is a \"collaborator\" and how can I become one?","text":"","category":"section"},{"location":"Contributing/","page":"Contributing guide","title":"Contributing guide","text":"Collaborators have permissions to review pull requests and status allows a contributor to review pull requests in addition to opening them. Collaborators can also create branches in the main ClimaCore.jl repository.\nWe ask that new contributors try their hand at forking ClimaCore.jl, and opening and merging a pull request before requesting collaborator status.","category":"page"},{"location":"Contributing/#Ground-Rules","page":"Contributing guide","title":"Ground Rules","text":"","category":"section"},{"location":"Contributing/","page":"Contributing guide","title":"Contributing guide","text":"Each pull request should consist of a logical collection of changes. You can include multiple bug fixes in a single pull request, but they should be related. For unrelated changes, please submit multiple pull requests.\nDo not commit changes to files that are irrelevant to your feature or bugfix (eg: .gitignore).\nBe willing to accept criticism and work on improving your code; we don't want to break other users' code, so care must be taken not to introduce bugs. We discuss pull requests and keep working on them until we believe we've done a good job.\nBe aware that the pull request review process is not immediate, and is generally proportional to the size of the pull request.","category":"page"},{"location":"Contributing/#Setting-up-your-development-environment","page":"Contributing guide","title":"Setting up your development environment","text":"","category":"section"},{"location":"Contributing/","page":"Contributing guide","title":"Contributing guide","text":"Install Julia on your system.\nInstall git on your system if it is not already there (install XCode command line tools on a Mac or git bash on Windows).\nLogin to your GitHub account and make a fork of the ClimaCore.jl repository by clicking the \"Fork\" button.\nClone your fork of the ClimaCore.jl repository (in terminal on Mac/Linux or git shell/ GUI on Windows) in the location you'd like to keep it.\ngit clone https://github.com/your-user-name/ClimaCore.jl.git\nNavigate to that folder in the terminal or in Anaconda Prompt if you're on Windows.\nConnect your repository to the upstream (main project).\ngit remote add `ClimaCore.jl` https://github.com/CLiMA/ClimaCore.jl.git\nCreate the development environment by opening Julia via julia --project then typing in ] instantiate. This will install all the dependencies in the Project.toml file.\nYou can test to make sure ClimaCore.jl works by typing in ] test. Doing so will run all the tests (and this can take a while).","category":"page"},{"location":"Contributing/","page":"Contributing guide","title":"Contributing guide","text":"Your development environment is now ready!","category":"page"},{"location":"Contributing/#Pull-Requests","page":"Contributing guide","title":"Pull Requests","text":"","category":"section"},{"location":"Contributing/","page":"Contributing guide","title":"Contributing guide","text":"We follow the ColPrac guide for collaborative practices. We ask that new contributors read that guide before submitting a pull request.","category":"page"},{"location":"Contributing/","page":"Contributing guide","title":"Contributing guide","text":"Changes and contributions should be made via GitHub pull requests against the main branch.","category":"page"},{"location":"Contributing/","page":"Contributing guide","title":"Contributing guide","text":"When you're done making changes, commit the changes you made. Chris Beams has written a guide on how to write good commit messages.","category":"page"},{"location":"Contributing/","page":"Contributing guide","title":"Contributing guide","text":"When you think your changes are ready to be merged into the main repository, push to your fork and submit a pull request.","category":"page"},{"location":"Contributing/","page":"Contributing guide","title":"Contributing guide","text":"Working on your first Pull Request? You can learn how from this free video series How to Contribute to an Open Source Project on GitHub, Aaron Meurer's tutorial on the git workflow, or the guide “How to Contribute to Open Source\".","category":"page"},{"location":"Contributing/#Unit-testing","page":"Contributing guide","title":"Unit testing","text":"","category":"section"},{"location":"Contributing/","page":"Contributing guide","title":"Contributing guide","text":"Currently a number of checks are run per commit for a given PR.","category":"page"},{"location":"Contributing/","page":"Contributing guide","title":"Contributing guide","text":"JuliaFormatter checks if the PR is formatted with .dev/climaformat.jl.\nDocumentation rebuilds the documentation for the PR and checks if the docs are consistent and generate valid output.\nUnit Tests run subsets of the unit tests defined in tests/, using Pkg.test(). The tests are run in parallel to ensure that they finish in a reasonable time. The tests only run the latest commit for a PR, branch and will kill any stale jobs on push. These tests are only run on linux (Ubuntu LTS).","category":"page"},{"location":"Contributing/","page":"Contributing guide","title":"Contributing guide","text":"Unit tests are run against every new commit for a given PR, the status of the unit-tests are not checked during the merge process but act as a sanity check for developers and reviewers. Depending on the content changed in the PR, some CI checks that are not necessary will be skipped.  For example doc only changes do not require the unit tests to be run.","category":"page"},{"location":"Contributing/#The-merge-process","page":"Contributing guide","title":"The merge process","text":"","category":"section"},{"location":"Contributing/","page":"Contributing guide","title":"Contributing guide","text":"We use bors to manage merging PR's in the the ClimaCore.jl repo. If you're a collaborator and have the necessary permissions, you can type bors try in a comment on a PR to have integration test suite run on that PR, or bors r+ to try and merge the code.  Bors ensures that all integration tests for a given PR always pass before merging into master.","category":"page"},{"location":"Contributing/#Integration-testing","page":"Contributing guide","title":"Integration testing","text":"","category":"section"},{"location":"Contributing/","page":"Contributing guide","title":"Contributing guide","text":"Currently a number of checks are run during integration testing before being merged into master.","category":"page"},{"location":"Contributing/","page":"Contributing guide","title":"Contributing guide","text":"JuliaFormatter checks if the PR is formatted with .dev/climaformat.jl.\nDocumentation checks that the documentation correctly builds for the merged PR.\nOS Unit Tests checks that ClimaCore.jl package unit tests can pass  on every OS supported with a pre-compiled system image (Linux, macOS, Windows).\nClimaCore CI computationally expensive integration testing on CPU and GPU hardware using HPC cluster resources.","category":"page"},{"location":"Contributing/","page":"Contributing guide","title":"Contributing guide","text":"Integration tests are run when triggered by a reviewer through bors. Integration tests are more computationally heavyweight than unit-tests and can exercise tests using accelerator hardware (GPUs).","category":"page"},{"location":"Contributing/","page":"Contributing guide","title":"Contributing guide","text":"Currently HPC cluster integration tests are run using the Buildkite CI service. Tests are parallelized and run as individual Slurm batch jobs on the HPC cluster and defined in .buildkite/pipeline.yml.","category":"page"},{"location":"Contributing/#Contributing-to-Documentation","page":"Contributing guide","title":"Contributing to Documentation","text":"","category":"section"},{"location":"Contributing/","page":"Contributing guide","title":"Contributing guide","text":"Documentation is written in Julia-flavored markdown and generated from two sources:","category":"page"},{"location":"Contributing/","page":"Contributing guide","title":"Contributing guide","text":"$CLIMACORE_HOME/docs/src","category":"page"},{"location":"Contributing/","page":"Contributing guide","title":"Contributing guide","text":"And Literate.jl tutorials:","category":"page"},{"location":"Contributing/","page":"Contributing guide","title":"Contributing guide","text":"$$CLIMACORE_HOME/tutorials","category":"page"},{"location":"Contributing/","page":"Contributing guide","title":"Contributing guide","text":"To locally build the documentation you need to create a new docs project to build and install the documentation related dependencies:","category":"page"},{"location":"Contributing/","page":"Contributing guide","title":"Contributing guide","text":"cd $CLIMACORE_HOME\njulia --project=docs/ -e 'using Pkg; Pkg.instantiate()'\njulia --project=docs docs/make.jl","category":"page"},{"location":"Contributing/","page":"Contributing guide","title":"Contributing guide","text":"The makefile script will generate the appropriate markdown files and static html from both the docs/src and tutorials/ directories, saving the output in docs/src/generated.","category":"page"},{"location":"Contributing/#How-to-generate-a-literate-tutorial-file","page":"Contributing guide","title":"How to generate a literate tutorial file","text":"","category":"section"},{"location":"Contributing/","page":"Contributing guide","title":"Contributing guide","text":"To create a tutorial using ClimaCore.jl, please use Literate.jl, and consult the Literate documentation for questions. For now, all literate tutorials are held in the tutorials directory.","category":"page"},{"location":"Contributing/","page":"Contributing guide","title":"Contributing guide","text":"With Literate, all comments turn into markdown text and any Julia code is read and run as if it is in the Julia REPL. As a small caveat to this, you might need to suppress the output of certain commands. For example, if you define and run the following function","category":"page"},{"location":"Contributing/","page":"Contributing guide","title":"Contributing guide","text":"function f()\n    return x = [i * i for i in 1:10]\nend\nx = f()","category":"page"},{"location":"Contributing/","page":"Contributing guide","title":"Contributing guide","text":"The entire list will be output, while","category":"page"},{"location":"Contributing/","page":"Contributing guide","title":"Contributing guide","text":"f();","category":"page"},{"location":"Contributing/","page":"Contributing guide","title":"Contributing guide","text":"does not (because of the ;).","category":"page"},{"location":"Contributing/","page":"Contributing guide","title":"Contributing guide","text":"To show plots, you may do something like the following:","category":"page"},{"location":"Contributing/","page":"Contributing guide","title":"Contributing guide","text":"using Plots\nplot(x)","category":"page"},{"location":"Contributing/","page":"Contributing guide","title":"Contributing guide","text":"Please consider writing the comments in your tutorial as if they are meant to be read as an article explaining the topic the tutorial is meant to explain. If there are any specific nuances to writing Literate documentation for ClimaCore.jl, please let us know!","category":"page"},{"location":"Contributing/#Credits","page":"Contributing guide","title":"Credits","text":"","category":"section"},{"location":"Contributing/","page":"Contributing guide","title":"Contributing guide","text":"This contributor's guide is heavily based on the excellent ClimateMachine.jl contributor's guide and ClimaAtmos.jl contributor's guide, which is heavily based on the excellent Oceananigans.jl contributor's guide which, in turn, is heavily based on the excellent MetPy contributor's guide.","category":"page"},{"location":"api/#API","page":"API","title":"API","text":"","category":"section"},{"location":"api/","page":"API","title":"API","text":"CurrentModule = ClimaCore","category":"page"},{"location":"api/#DataLayouts","page":"API","title":"DataLayouts","text":"","category":"section"},{"location":"api/","page":"API","title":"API","text":"DataLayouts\nDataLayouts.DataF\nDataLayouts.IF\nDataLayouts.IJF\nDataLayouts.VF\nDataLayouts.IFH\nDataLayouts.IJFH\nDataLayouts.VIFH\nDataLayouts.VIJFH","category":"page"},{"location":"api/#ClimaCore.DataLayouts","page":"API","title":"ClimaCore.DataLayouts","text":"ClimaCore.DataLayouts\n\nNotation:\n\ni,j are horizontal node indices within an element\nk is the vertical node index within an element\nf is the field index (1 if field is scalar, >1 if it is a vector field)\nv is the vertical element index in a stack\nh is the element stack index\n\nData layout is specified by the order in which they appear, e.g. IJKFVH indexes the underlying array as [i,j,k,f,v,h]\n\n\n\n\n\n","category":"module"},{"location":"api/#ClimaCore.DataLayouts.DataF","page":"API","title":"ClimaCore.DataLayouts.DataF","text":"DataF{S, A} <: Data0D{S}\n\nBacking DataLayout for 0D point data.\n\n\n\n\n\n","category":"type"},{"location":"api/#ClimaCore.DataLayouts.IF","page":"API","title":"ClimaCore.DataLayouts.IF","text":"IF{S, Ni, A} <: DataSlab1D{S, Ni}\n\nBacking DataLayout for 1D spectral element slab data.\n\nNodal element data (I) are contiguous for each S datatype struct field (F) for a single element slab.\n\nA DataSlab1D view can be returned from other Data1D objects by calling slab(data, idx...).\n\n\n\n\n\n","category":"type"},{"location":"api/#ClimaCore.DataLayouts.IJF","page":"API","title":"ClimaCore.DataLayouts.IJF","text":"IJF{S, Nij, A} <: DataSlab2D{S, Nij}\n\nBacking DataLayout for 2D spectral element slab data.\n\nNodal element data (I,J) are contiguous for each S datatype struct field (F) for a single element slab.\n\nA DataSlab2D view can be returned from other Data2D objects by calling slab(data, idx...).\n\n\n\n\n\n","category":"type"},{"location":"api/#ClimaCore.DataLayouts.VF","page":"API","title":"ClimaCore.DataLayouts.VF","text":"VF{S, A} <: DataColumn{S}\n\nBacking DataLayout for 1D FV column data.\n\nColumn level data (V) are contiguous for each S datatype struct field (F).\n\nA DataColumn view can be returned from other Data1DX, Data2DX objects by calling column(data, idx...).\n\n\n\n\n\n","category":"type"},{"location":"api/#ClimaCore.DataLayouts.IFH","page":"API","title":"ClimaCore.DataLayouts.IFH","text":"IFH{S, Ni, A} <: Data1D{S, Ni}\n\nBacking DataLayout for 1D spectral element slabs.\n\nElement nodal point (I) data is contiguous for each datatype S struct field (F), for each 1D mesh element (H).\n\n\n\n\n\n","category":"type"},{"location":"api/#ClimaCore.DataLayouts.IJFH","page":"API","title":"ClimaCore.DataLayouts.IJFH","text":"IJFH{S, Nij, A} <: Data2D{S, Nij}\n\nBacking DataLayout for 2D spectral element slabs.\n\nElement nodal point (I,J) data is contiguous for each datatype S struct field (F), for each 2D mesh element slab (H).\n\n\n\n\n\n","category":"type"},{"location":"api/#ClimaCore.DataLayouts.VIFH","page":"API","title":"ClimaCore.DataLayouts.VIFH","text":"VIFH{S, Ni, A} <: Data1DX{S, Ni}\n\nBacking DataLayout for 1D spectral element slab + extruded 1D FV column data.\n\nColumn levels (V) are contiguous for every element nodal point (I) for each datatype S struct field (F), for each 1D mesh element slab (H).\n\n\n\n\n\n","category":"type"},{"location":"api/#ClimaCore.DataLayouts.VIJFH","page":"API","title":"ClimaCore.DataLayouts.VIJFH","text":"VIJFH{S, Nij, A} <: Data2DX{S, Nij}\n\nBacking DataLayout for 2D spectral element slab + extruded 1D FV column data.\n\nColumn levels (V) are contiguous for every element nodal point (I, J) for each S datatype struct field (F), for each 2D mesh element slab (H).\n\n\n\n\n\n","category":"type"},{"location":"api/#Geometry","page":"API","title":"Geometry","text":"","category":"section"},{"location":"api/#Coordinates","page":"API","title":"Coordinates","text":"","category":"section"},{"location":"api/","page":"API","title":"API","text":"Geometry.AbstractPoint\nGeometry.float_type","category":"page"},{"location":"api/#ClimaCore.Geometry.AbstractPoint","page":"API","title":"ClimaCore.Geometry.AbstractPoint","text":"AbstractPoint\n\nRepresents a point in space.\n\nThe following types are supported:\n\nXPoint(x)\nYPoint(y)\nZPoint(z)\nXYPoint(x, y)\nXZPoint(x, z)\nXYZPoint(x, y, z)\nLatLongPoint(lat, long)\nLatLongZPoint(lat, long, z)\nCartesian1Point(x1)\nCartesian2Point(x2)\nCartesian3Point(x3)\nCartesian12Point(x1, x2)\nCartesian13Point(x1, x3)\nCartesian123Point(x1, x2, x3)\n\n\n\n\n\n","category":"type"},{"location":"api/#ClimaCore.Geometry.float_type","page":"API","title":"ClimaCore.Geometry.float_type","text":"float_type(T)\n\nReturn the floating point type backing T: T can either be an object or a type.\n\n\n\n\n\n","category":"function"},{"location":"api/","page":"API","title":"API","text":"Points represent locations in space, specified by coordinates in a given coordinate system (Cartesian, spherical, etc), whereas vectors, on the other hand, represent displacements in space.","category":"page"},{"location":"api/","page":"API","title":"API","text":"An analogy with time works well: times (also called instants or datetimes) are locations in time, while, durations are displacements in time.","category":"page"},{"location":"api/","page":"API","title":"API","text":"Note 1: Latitude and longitude are specified via angles (and, therefore, trigonometric functions: cosd, sind, acosd, asind, tand,...) in degrees, not in radians. Moreover, lat (usually denoted by theta) in -900 900, and long (usually denoted by lambda) in -1800 1800.","category":"page"},{"location":"api/","page":"API","title":"API","text":"Note 2:: In a Geometry.LatLongZPoint(lat, long, z), z represents the elevation above the surface of the sphere with radius R (implicitly accounted for in the geoemtry).","category":"page"},{"location":"api/","page":"API","title":"API","text":"Note 3: There are also a set of specific Cartesian points (Cartesian1Point(x1), Cartesian2Point(x2), etc). These are occasionally useful for converting everything to a full Cartesian domain (e.g. for visualization purposes). These are distinct from XYZPoint as ZPoint can mean different things in different domains.","category":"page"},{"location":"api/#Domains","page":"API","title":"Domains","text":"","category":"section"},{"location":"api/#Types","page":"API","title":"Types","text":"","category":"section"},{"location":"api/","page":"API","title":"API","text":"Domains.AbstractDomain\nDomains.IntervalDomain\nDomains.RectangleDomain\nDomains.SphereDomain","category":"page"},{"location":"api/#ClimaCore.Domains.AbstractDomain","page":"API","title":"ClimaCore.Domains.AbstractDomain","text":"AbstractDomain\n\nA domain represents a region of space.\n\n\n\n\n\n","category":"type"},{"location":"api/#ClimaCore.Domains.IntervalDomain","page":"API","title":"ClimaCore.Domains.IntervalDomain","text":"IntervalDomain(coord⁻, coord⁺; periodic=true)\nIntervalDomain(coord⁻, coord⁺; boundary_names::Tuple{Symbol,Symbol})\n\nConstruct a IntervalDomain, the closed interval is given by coord⁻, coord⁺ coordinate arguments.\n\nEither a periodic or boundary_names keyword argument is required.\n\n\n\n\n\n","category":"type"},{"location":"api/#ClimaCore.Domains.RectangleDomain","page":"API","title":"ClimaCore.Domains.RectangleDomain","text":"RectangleDomain(x1::ClosedInterval, x2::ClosedInterval;\n    x1boundary::Tuple{Symbol,Symbol},\n    x2boundary::Tuple{Symbol,Symbol},\n    x1periodic = false,\n    x2periodic = false,\n)\n\nConstruct a RectangularDomain in the horizontal. If a given x1 or x2 boundary is not periodic, then x1boundary or x2boundary boundary name keyword arguments must be supplied.\n\n\n\n\n\n","category":"type"},{"location":"api/#ClimaCore.Domains.SphereDomain","page":"API","title":"ClimaCore.Domains.SphereDomain","text":"SphereDomain(radius)\n\nA domain representing the surface of a sphere with radius radius.\n\n\n\n\n\n","category":"type"},{"location":"api/#Interfaces","page":"API","title":"Interfaces","text":"","category":"section"},{"location":"api/","page":"API","title":"API","text":"Domains.boundary_names","category":"page"},{"location":"api/#ClimaCore.Domains.boundary_names","page":"API","title":"ClimaCore.Domains.boundary_names","text":"boundary_names(obj::Union{AbstractDomain, AbstractMesh, AbstractTopology})\n\nA tuple or vector of unique boundary names of a spatial domain.\n\n\n\n\n\n","category":"function"},{"location":"api/#Meshes","page":"API","title":"Meshes","text":"","category":"section"},{"location":"api/","page":"API","title":"API","text":"A Mesh is a division of a domain into elements.","category":"page"},{"location":"api/#Mesh-types","page":"API","title":"Mesh types","text":"","category":"section"},{"location":"api/","page":"API","title":"API","text":"Meshes.AbstractMesh\nMeshes.IntervalMesh\nMeshes.RectilinearMesh\nMeshes.AbstractCubedSphere\nMeshes.EquiangularCubedSphere\nMeshes.EquidistantCubedSphere\nMeshes.ConformalCubedSphere","category":"page"},{"location":"api/#ClimaCore.Meshes.AbstractMesh","page":"API","title":"ClimaCore.Meshes.AbstractMesh","text":"AbstractMesh{dim}\n\nA Mesh is an object which represents how we discretize a domain into elements.\n\nIt should be lightweight (i.e. exists on all MPI ranks), e.g for meshes stored in a file, it would contain the filename.\n\nFace and vertex numbering\n\nIn 1D, faces and vertices are the same, and both are numbered [1,2].\n\nIn 2D, a face is a line segment between to vertices, and both are numbered [1,2,3,4], in a counter-clockwise direction.\n\n v4        f3        v3\n   o-----------------o\n   |                 |\t    face    vertices\n   |                 |\t      f1 =>  v1 v2\nf4 |                 | f2     f2 =>  v2 v3\n   |                 |\t      f3 =>  v3 v4\n   |                 |        f4 =>  v4 v1\n   |                 |\n   o-----------------o\n  v1       f1        v2\n\nInterface\n\nA subtype of AbstractMesh should define the following methods:\n\ndomain(mesh)\nelements(mesh)\nis_boundary_face(mesh, elem, face)\nboundary_face_name(mesh, elem, face)\nopposing_face(mesh, elem, face)\ncoordinates(mesh, elem, vert)\ncontaining_element (optional)\n\nThe following types/methods are provided by AbstractMesh:\n\nSharedVertices(mesh, elem, vert)\nface_connectivity_matrix(mesh[,elemorder])\nvertex_connectivity_matrix(mesh[,elemorder])\n\n\n\n\n\n","category":"type"},{"location":"api/#ClimaCore.Meshes.IntervalMesh","page":"API","title":"ClimaCore.Meshes.IntervalMesh","text":"IntervalMesh <: AbstractMesh\n\nA 1D mesh on an IntervalDomain.\n\nConstuctors\n\nIntervalMesh(domain::IntervalDomain, faces::AbstractVector)\n\nConstruct a 1D mesh with face locations at faces.\n\nIntervalMesh(domain::IntervalDomain[, stretching=Uniform()]; nelems=)\n\nConstuct a 1D mesh on domain with nelems elements, using stretching. Possible values of stretching are:\n\nUniform()\nExponentialStretching(H)\nGeneralizedExponentialStretching(dz_bottom, dz_top)\n\n\n\n\n\n","category":"type"},{"location":"api/#ClimaCore.Meshes.RectilinearMesh","page":"API","title":"ClimaCore.Meshes.RectilinearMesh","text":"RectilinearMesh <: AbstractMesh2D\n\nConstructors\n\nRectilinearMesh(domain::RectangleDomain, n1, n2)\n\nConstruct a RectilinearMesh of equally-spaced n1 by n2 elements on domain.\n\nRectilinearMesh(intervalmesh1::IntervalMesh1, intervalmesh2::IntervalMesh2)\n\nConstruct the product mesh of intervalmesh1 and intervalmesh2.\n\n\n\n\n\n","category":"type"},{"location":"api/#ClimaCore.Meshes.AbstractCubedSphere","page":"API","title":"ClimaCore.Meshes.AbstractCubedSphere","text":"AbstractCubedSphere <: AbstractMesh2D\n\nThis is an abstract type of cubed-sphere meshes on SphereDomains. A cubed-sphere mesh has 6 panels, laid out as follows:\n\n                                          :   Panel 1   :\n                            +-------------+-------------+\n                            |     +x1     |     +x1     |\n                            |             |             |\n                            |    Panel    |    Panel    |\n                            |+x3   5   -x3|-x2   6   +x2|\n                            |     -x2     |     -x3     |\n                            |             |             |\n                            |     -x1     |     -x1     |\n              +-------------+-------------+-------------+\n              |     -x2     |     -x2     |\n              |             |             |\n              |    Panel    |    Panel    |\n              |+x1   3   -x1|+x3   4   -x3|\n              |     +x3     |     -x1     |\n              |             |             |\n              |     +x2     |     +x2     |\n+-------------+-------------+-------------+\n|     +x3     |     +x3     |\n|             |             |\n|    Panel    |    Panel    |\n|-x2   1   +x2|+x1   2   -x1|\n|     +x1     |     +x2     |\n|             |             |\n|     -x3     |     -x3     |\n+-------------+-------------+\n:   Panel 6   :\n\nThis is the same panel ordering used by the S2 Geometry library (though we use 1-based instead of 0-based numering).\n\nElements are indexed by a CartesianIndex{3} object, where the components are:\n\nhorizontal element index (left to right) within each panel.\nvertical element index (bottom to top) within each panel.\npanel number\n\nSubtypes should have the following fields:\n\ndomain: a SphereDomain\nne: number of elements across each panel\n\nExternal links\n\nS2Geometry library\nMIT GCM exch2\n\n\n\n\n\n","category":"type"},{"location":"api/#ClimaCore.Meshes.EquiangularCubedSphere","page":"API","title":"ClimaCore.Meshes.EquiangularCubedSphere","text":"EquiangularCubedSphere <: AbstractCubedSphere\n\nAn equiangular gnomonic mesh proposed by C. Ronchi, R. Iacono, P. S. Paolucci (1996). Uses the element indexing convention of AbstractCubedSphere.\n\nConstructors\n\nEquiangularCubedSphere(\n    domain::Domains.SphereDomain,\n    ne::Integer,\n    localelementmap=NormalizedBilinearMap()\n    )\n\nConstuct an EquiangularCubedSphere on domain with ne elements across each panel.\n\n\n\n\n\n","category":"type"},{"location":"api/#ClimaCore.Meshes.EquidistantCubedSphere","page":"API","title":"ClimaCore.Meshes.EquidistantCubedSphere","text":"EquidistantCubedSphere <: AbstractCubedSphere\n\nAn equidistant gnomonic mesh outlined in M. Rančić, R. J. Purser, F. Mesinger (1996) and Ramachandran D Nair, Stephen J Thomas, Richard D Loft (2005). Uses the element indexing convention of AbstractCubedSphere.\n\nConstructors\n\nEquidistantCubedSphere(domain::Domains.SphereDomain, ne::Integer)\n\nConstuct an EquidistantCubedSphere on domain with ne elements across each panel.\n\n\n\n\n\n","category":"type"},{"location":"api/#ClimaCore.Meshes.ConformalCubedSphere","page":"API","title":"ClimaCore.Meshes.ConformalCubedSphere","text":"ConformalCubedSphere <: AbstractCubedSphere\n\nA conformal mesh outlined in M. Rančić, R. J. Purser, F. Mesinger (1996). Uses the element indexing convention of AbstractCubedSphere.\n\nConstructors\n\nConformalCubedSphere(domain::Domains.SphereDomain, ne::Integer)\n\nConstuct a ConformalCubedSphere on domain with ne elements across each panel.\n\n\n\n\n\n","category":"type"},{"location":"api/#Local-element-map","page":"API","title":"Local element map","text":"","category":"section"},{"location":"api/","page":"API","title":"API","text":"Meshes.LocalElementMap\nMeshes.IntrinsicMap\nMeshes.NormalizedBilinearMap","category":"page"},{"location":"api/#ClimaCore.Meshes.LocalElementMap","page":"API","title":"ClimaCore.Meshes.LocalElementMap","text":"LocalElementMap\n\nAn abstract type of mappings from the reference element to a physical domain.\n\n\n\n\n\n","category":"type"},{"location":"api/#ClimaCore.Meshes.IntrinsicMap","page":"API","title":"ClimaCore.Meshes.IntrinsicMap","text":"IntrinsicMap()\n\nThis LocalElementMap uses the intrinsic mapping of the cubed sphere to map the reference element to the physical domain.\n\n\n\n\n\n","category":"type"},{"location":"api/#ClimaCore.Meshes.NormalizedBilinearMap","page":"API","title":"ClimaCore.Meshes.NormalizedBilinearMap","text":"NormalizedBilinearMap()\n\nThe LocalElementMap for meshes on spherical domains of O. Guba, M. A. Taylor, P. A. Ullrich, J. R. Overfelt, M. N. Levy (2014). It uses bilinear interpolation between the Cartesian coordinates of the element vertices, then normalizes the result to lie on the sphere.\n\n\n\n\n\n","category":"type"},{"location":"api/#Mesh-stretching","page":"API","title":"Mesh stretching","text":"","category":"section"},{"location":"api/","page":"API","title":"API","text":"Meshes.Uniform\nMeshes.ExponentialStretching\nMeshes.GeneralizedExponentialStretching","category":"page"},{"location":"api/#ClimaCore.Meshes.Uniform","page":"API","title":"ClimaCore.Meshes.Uniform","text":"Uniform()\n\nUse uniformly-sized elements.\n\n\n\n\n\n","category":"type"},{"location":"api/#ClimaCore.Meshes.ExponentialStretching","page":"API","title":"ClimaCore.Meshes.ExponentialStretching","text":"ExponentialStretching(H::FT)\n\nApply exponential stretching to the domain when constructing elements. H is the scale height (a typical atmospheric scale height H ≈ 7.5km).\n\nFor an interval z_0z_1, this makes the elements uniformally spaced in zeta, where\n\nzeta = frac1 - e^-etah1-e^-1h\n\nwhere eta = fracz - z_0z_1-z_0, and h = fracHz_1-z_0 is the non-dimensional scale height. If reverse_mode is true, the smallest element is at the top, and the largest at the bottom (this is typical for land model configurations).\n\nThen, the user can define a stretched mesh via\n\nClimaCore.Meshes.IntervalMesh(interval_domain, ExponentialStretching(H); nelems::Int, reverse_mode = false)\n\n\n\n\n\n","category":"type"},{"location":"api/#ClimaCore.Meshes.GeneralizedExponentialStretching","page":"API","title":"ClimaCore.Meshes.GeneralizedExponentialStretching","text":"GeneralizedExponentialStretching(dz_bottom::FT, dz_top::FT)\n\nApply a generalized form of exponential stretching to the domain when constructing elements. dz_bottom and dz_top are target element grid spacings at the bottom and at the top of the vertical column domain (m). In typical atmosphere configurations, dz_bottom is the smallest grid spacing and dz_top the largest one. On the other hand, for typical land configurations, dz_bottom is the largest grid spacing and dz_top the smallest one.\n\nFor land configurations, use reverse_mode = true (default value false).\n\nThen, the user can define a generalized stretched mesh via\n\nClimaCore.Meshes.IntervalMesh(interval_domain, GeneralizedExponentialStretching(dz_bottom, dz_top); nelems::Int, reverse_mode = false)\n\n\n\n\n\n","category":"type"},{"location":"api/#Mesh-utilities","page":"API","title":"Mesh utilities","text":"","category":"section"},{"location":"api/","page":"API","title":"API","text":"Meshes.truncate_mesh","category":"page"},{"location":"api/#ClimaCore.Meshes.truncate_mesh","page":"API","title":"ClimaCore.Meshes.truncate_mesh","text":"truncate_mesh(\n    parent_mesh::AbstractMesh,\n    trunc_domain::IntervalDomain{CT},\n)\n\nConstructs an IntervalMesh, truncating the given parent_mesh defined on a truncated trunc_domain. The truncation preserves the number of degrees of freedom covering the space from the trunc_domain's z_bottom to z_top, adjusting the stretching.\n\n\n\n\n\n","category":"function"},{"location":"api/#Interfaces-2","page":"API","title":"Interfaces","text":"","category":"section"},{"location":"api/","page":"API","title":"API","text":"Meshes.domain\nMeshes.elements\nMeshes.nelements\nMeshes.is_boundary_face\nMeshes.boundary_face_name\nMeshes.opposing_face\nMeshes.coordinates\nMeshes.containing_element\nMeshes.reference_coordinates\nMeshes.SharedVertices\nMeshes.face_connectivity_matrix\nMeshes.vertex_connectivity_matrix\nMeshes.linearindices","category":"page"},{"location":"api/#ClimaCore.Meshes.domain","page":"API","title":"ClimaCore.Meshes.domain","text":"Meshes.domain(mesh::AbstractMesh)\n\nThe domain (a subtype of  Domains.AbstractDomain) on which the mesh is defined.\n\n\n\n\n\n","category":"function"},{"location":"api/#ClimaCore.Meshes.elements","page":"API","title":"ClimaCore.Meshes.elements","text":"Meshes.elements(mesh::AbstractMesh)\n\nAn iterator over the elements of a mesh. Elements of a mesh can be of any type.\n\n\n\n\n\n","category":"function"},{"location":"api/#ClimaCore.Meshes.nelements","page":"API","title":"ClimaCore.Meshes.nelements","text":"nelements(mesh::AbstractMesh)\n\nThe number of elements in the mesh.\n\n\n\n\n\n","category":"function"},{"location":"api/#ClimaCore.Meshes.is_boundary_face","page":"API","title":"ClimaCore.Meshes.is_boundary_face","text":"Meshes.is_boundary_face(mesh::AbstractMesh, elem, face::Int)::Bool\n\nDetermine whether face face of element elem is on the boundary of mesh.\n\nelem should be an element of elements(mesh).\n\n\n\n\n\n","category":"function"},{"location":"api/#ClimaCore.Meshes.boundary_face_name","page":"API","title":"ClimaCore.Meshes.boundary_face_name","text":"Meshes.boundary_face_name(mesh::AbstractMesh, elem, face::Int)::Union{Symbol,Nothing}\n\nThe name of the boundary facing face of element elem, or nothing if it is not on the boundary.\n\n\n\n\n\n","category":"function"},{"location":"api/#ClimaCore.Meshes.opposing_face","page":"API","title":"ClimaCore.Meshes.opposing_face","text":"opelem, opface, reversed = Meshes.opposing_face(mesh::AbstractMesh, elem, face::Int)\n\nThe element and face (opelem, opface) that oppose face face of element elem.\n\n\n\n\n\n","category":"function"},{"location":"api/#ClimaCore.Meshes.coordinates","page":"API","title":"ClimaCore.Meshes.coordinates","text":"Meshes.coordinates(mesh, elem, vert::Int)\nMeshes.coordinates(mesh, elem, ξ::SVector)\n\nReturn the physical coordinates of a point in an element elem of mesh. The position of the point can either be a vertex number vert or the coordinates ξ in the reference element.\n\n\n\n\n\n","category":"function"},{"location":"api/#ClimaCore.Meshes.containing_element","page":"API","title":"ClimaCore.Meshes.containing_element","text":"elem = Meshes.containing_element(mesh::AbstractMesh, coord)\n\nThe element elem in mesh containing the coordinate coord. If the coordinate falls on the boundary between two or more elements, an arbitrary element is chosen.\n\n\n\n\n\n","category":"function"},{"location":"api/#ClimaCore.Meshes.reference_coordinates","page":"API","title":"ClimaCore.Meshes.reference_coordinates","text":"ξ = Meshes.reference_coordinates(mesh::AbstractMesh, elem, coord)\n\nAn SVector of coordinates in the reference element such that\n\nMeshes.coordinates(mesh, elem, ξ) == coord\n\nThis can be used for interpolation to a specific point.\n\n\n\n\n\n","category":"function"},{"location":"api/#ClimaCore.Meshes.SharedVertices","page":"API","title":"ClimaCore.Meshes.SharedVertices","text":"Meshes.SharedVertices(mesh, elem, vert)\n\nAn iterator over (element, vertex) pairs that are shared with (elem,vert).\n\n\n\n\n\n","category":"type"},{"location":"api/#ClimaCore.Meshes.face_connectivity_matrix","page":"API","title":"ClimaCore.Meshes.face_connectivity_matrix","text":"M = Meshes.face_connectivity_matrix(mesh, elemorder = elements(mesh))\n\nConstruct a Bool-valued SparseCSCMatrix containing the face connections of mesh. Elements are indexed according to elemorder.\n\nNote that M[i,i] == true only if two distinct faces of element i are connected.\n\n\n\n\n\n","category":"function"},{"location":"api/#ClimaCore.Meshes.vertex_connectivity_matrix","page":"API","title":"ClimaCore.Meshes.vertex_connectivity_matrix","text":"M = Meshes.vertex_connectivity_matrix(mesh, elemorder = elements(mesh))\n\nConstruct a Bool-valued SparseCSCMatrix containing the vertex connections of mesh. Elements are indexed according to elemorder.\n\nNote that M[i,i] == true only if two distinct vertices of element i are connected.\n\n\n\n\n\n","category":"function"},{"location":"api/#ClimaCore.Meshes.linearindices","page":"API","title":"ClimaCore.Meshes.linearindices","text":"Meshes.linearindices(elemorder)\n\nGiven a data structure elemorder[i] = elem that orders elements, construct the inverse map from orderindex = linearindices(elemorder) such that orderindex[elem] = i.\n\nThis will try to use the most efficient structure available.\n\n\n\n\n\n","category":"function"},{"location":"api/#Topologies","page":"API","title":"Topologies","text":"","category":"section"},{"location":"api/","page":"API","title":"API","text":"A Topology determines the ordering and connections between elements of a mesh. (Image: Space-filling curve element ordering for a cubed sphere mesh)","category":"page"},{"location":"api/#Types-2","page":"API","title":"Types","text":"","category":"section"},{"location":"api/","page":"API","title":"API","text":"Topologies.AbstractTopology\nTopologies.IntervalTopology\nTopologies.Topology2D\nTopologies.spacefillingcurve","category":"page"},{"location":"api/#ClimaCore.Topologies.AbstractTopology","page":"API","title":"ClimaCore.Topologies.AbstractTopology","text":"AbstractTopology\n\nSubtypes of AbstractHorizontalTopology define connectiveness of a mesh in the horizontal domain.\n\nInterfaces\n\nnelems\ndomain(topology::AbstractTopology)\nmesh\nnlocalelems\nnneighbors\nnsendelems\nnghostelems\nlocalelemindex\nvertex_coordinates\nopposing_face\nface_node_index\ninterior_faces\nghost_faces\nvertex_node_index\nlocal_neighboring_elements\nghost_neighboring_elements\nlocal_vertices\nghost_vertices\nneighbors\nboundary_tags\nboundary_tag\nboundary_faces\n\n\n\n\n\n","category":"type"},{"location":"api/#ClimaCore.Topologies.IntervalTopology","page":"API","title":"ClimaCore.Topologies.IntervalTopology","text":"IntervalTopology(mesh::IntervalMesh)\n\nA sequential topology on an Meshes.IntervalMesh.\n\n\n\n\n\n","category":"type"},{"location":"api/#ClimaCore.Topologies.Topology2D","page":"API","title":"ClimaCore.Topologies.Topology2D","text":"Topology2D(mesh::AbstractMesh2D, elemorder=Mesh.elements(mesh))\n\nThis is a distributed topology for 2D meshes. elemorder is a vector or other linear ordering of the Mesh.elements(mesh). elempid is a sorted vector of the same length as elemorder, each element of which contains the pid of the owning process.\n\nInternally, we can refer to elements in several different ways:\n\nelem: an element of the mesh. Often a CartesianIndex object.\ngidx: \"global index\": an enumeration of all elements:\nelemorder[gidx] == elem\norderindex[elem] == gidx\nlidx: \"local index\": an enumeration of local elements.\nlocal_elem_gidx[lidx] == gidx\nsidx: \"send index\": an index into the send buffer of a local element. A single local element may have multiple sidxs if it needs to be send to multiple processes.\nsend_elem_lidx[sidx] == lidx\nridx: \"receive index\": an index into the receive buffer of a ghost element.\nrecv_elem_gidx[ridx] == gidx\n\n\n\n\n\n","category":"type"},{"location":"api/#ClimaCore.Topologies.spacefillingcurve","page":"API","title":"ClimaCore.Topologies.spacefillingcurve","text":"spacefillingcurve(mesh::Meshes.AbstractCubedSphere)\n\nGenerate element ordering, elemorder, based on a space filling curve for a CubedSphere mesh.\n\n\n\n\n\nspacefillingcurve(mesh::Meshes.RectilinearMesh)\n\nGenerate element ordering, elemorder, based on a space filling curve for a Rectilinear mesh.\n\n\n\n\n\n","category":"function"},{"location":"api/#Interfaces-3","page":"API","title":"Interfaces","text":"","category":"section"},{"location":"api/","page":"API","title":"API","text":"Topologies.mesh\nTopologies.nlocalelems\nTopologies.vertex_coordinates\nTopologies.opposing_face\nTopologies.interior_faces\nTopologies.boundary_tags\nTopologies.boundary_tag\nTopologies.boundary_faces\nTopologies.local_neighboring_elements\nTopologies.ghost_neighboring_elements","category":"page"},{"location":"api/#ClimaCore.Topologies.mesh","page":"API","title":"ClimaCore.Topologies.mesh","text":"mesh(topology)\n\nReturns the mesh underlying the topology\n\n\n\n\n\n","category":"function"},{"location":"api/#ClimaCore.Topologies.nlocalelems","page":"API","title":"ClimaCore.Topologies.nlocalelems","text":"nlocalelems(topology)\n\nThe number of local elements in topology.\n\n\n\n\n\n","category":"function"},{"location":"api/#ClimaCore.Topologies.vertex_coordinates","page":"API","title":"ClimaCore.Topologies.vertex_coordinates","text":"(c1,c2,c3,c4) = vertex_coordinates(topology, elem)\n\nThe coordinates of the 4 vertices of element elem.\n\n\n\n\n\n","category":"function"},{"location":"api/#ClimaCore.Topologies.opposing_face","page":"API","title":"ClimaCore.Topologies.opposing_face","text":"(opelem, opface, reversed) = opposing_face(topology, elem, face)\n\nThe opposing face of face number face of element elem in topology.\n\nopelem is the opposing element number, 0 for a boundary, negative for a ghost element\nopface is the opposite face number, or boundary face number if a boundary\nreversed indicates whether the opposing face has the opposite orientation.\n\n\n\n\n\n","category":"function"},{"location":"api/#ClimaCore.Topologies.interior_faces","page":"API","title":"ClimaCore.Topologies.interior_faces","text":"interior_faces(topology::AbstractTopology)\n\nAn iterator over the interior faces of topology. Each element of the iterator is a 5-tuple the form\n\n(elem1, face1, elem2, face2, reversed)\n\nwhere elemX, faceX are the element and face numbers, and reversed indicates whether they have opposing orientations.\n\n\n\n\n\n","category":"function"},{"location":"api/#ClimaCore.Topologies.boundary_tags","page":"API","title":"ClimaCore.Topologies.boundary_tags","text":"boundary_tags(topology)\n\nA Tuple or NamedTuple of the boundary tags of the topology. A boundary tag is an integer that uniquely identifies a boundary.\n\n\n\n\n\n","category":"function"},{"location":"api/#ClimaCore.Topologies.boundary_tag","page":"API","title":"ClimaCore.Topologies.boundary_tag","text":"boundary_tag(topology, name::Symbol)\n\nThe boundary tag of the topology for boundary name name. A boundary tag is an integer that uniquely identifies a boundary.\n\n\n\n\n\n","category":"function"},{"location":"api/#ClimaCore.Topologies.boundary_faces","page":"API","title":"ClimaCore.Topologies.boundary_faces","text":"boundary_faces(topology, boundarytag)\n\nAn iterator over the faces of topology which face the boundary with tag boundarytag. Each element of the iterator is an (elem, face) pair.\n\n\n\n\n\n","category":"function"},{"location":"api/#ClimaCore.Topologies.local_neighboring_elements","page":"API","title":"ClimaCore.Topologies.local_neighboring_elements","text":"local_neighboring_elements(topology::AbstractTopology, lidx::Integer)\n\nAn iterator of the local element indices (lidx) of the local elements which are neighbors of the local element lidx in topology (excluding lidx itself).\n\n\n\n\n\n","category":"function"},{"location":"api/#ClimaCore.Topologies.ghost_neighboring_elements","page":"API","title":"ClimaCore.Topologies.ghost_neighboring_elements","text":"ghost_neighboring_elements(topology::AbstractTopology, ridx::Integer)\n\nAn iterator of the receive buffer indices (ridx) of the ghost elements which are neighbors  of the local element lidx in topology.\n\n\n\n\n\n","category":"function"},{"location":"api/#Spaces","page":"API","title":"Spaces","text":"","category":"section"},{"location":"api/","page":"API","title":"API","text":"A Space represents a discretized function space over some domain. Currently two main discretizations are supported: Spectral Element Discretization (both Continuous Galerkin and Discontinuous Galerkin types) and a staggered Finite Difference Discretization. Combination of these two in the horizontal/vertical directions, respectively, is what we call a hybrid space.","category":"page"},{"location":"api/","page":"API","title":"API","text":"Sketch of a 2DX hybrid discretization:","category":"page"},{"location":"api/","page":"API","title":"API","text":"(Image: 3D hybrid discretization in a Cartesian domain)","category":"page"},{"location":"api/","page":"API","title":"API","text":"Spaces\nSpaces.Δz_data","category":"page"},{"location":"api/#ClimaCore.Spaces","page":"API","title":"ClimaCore.Spaces","text":"Meshes\n\ndomain\ntopology\ncoordinates\nmetric terms (inverse partial derivatives)\nquadrature rules and weights\n\nReferences / notes\n\nceed\nQA\n\n\n\n\n\n","category":"module"},{"location":"api/#ClimaCore.Spaces.Δz_data","page":"API","title":"ClimaCore.Spaces.Δz_data","text":"Δz_data(space::AbstractSpace)\n\nA DataLayout containing the Δz on a given space space.\n\n\n\n\n\n","category":"function"},{"location":"api/#Finite-Difference-Spaces","page":"API","title":"Finite Difference Spaces","text":"","category":"section"},{"location":"api/","page":"API","title":"API","text":"ClimaCore.jl supports staggered Finite Difference discretizations. Finite Differences discretize an interval domain by approximating the function by a value at either the center of each element (also referred to as cell) (CenterFiniteDifferenceSpace), or the interfaces (faces in 3D, edges in 2D or points in 1D) between elements (FaceFiniteDifferenceSpace).","category":"page"},{"location":"api/","page":"API","title":"API","text":"Users should construct either the center or face space from the mesh, then construct the other space from the original one: this internally reuses the same data structures, and avoids allocating additional memory.","category":"page"},{"location":"api/#Internals","page":"API","title":"Internals","text":"","category":"section"},{"location":"api/","page":"API","title":"API","text":"Spaces.Δz_metric_component","category":"page"},{"location":"api/#ClimaCore.Spaces.Δz_metric_component","page":"API","title":"ClimaCore.Spaces.Δz_metric_component","text":"Δz_metric_component(::Type{<:Goemetry.AbstractPoint})\n\nThe index of the z-component of an abstract point in an AxisTensor.\n\n\n\n\n\n","category":"function"},{"location":"api/#Spectral-Element-Spaces","page":"API","title":"Spectral Element Spaces","text":"","category":"section"},{"location":"api/","page":"API","title":"API","text":"Spaces.SpectralElementSpace1D\nSpaces.SpectralElementSpace2D\nSpaces.SpectralElementSpace2D(topology, quadrature_style; enable_bubble)\nSpaces.SpectralElementSpaceSlab","category":"page"},{"location":"api/#ClimaCore.Spaces.SpectralElementSpace1D","page":"API","title":"ClimaCore.Spaces.SpectralElementSpace1D","text":"SpectralElementSpace1D <: AbstractSpace\n\nA one-dimensional space: within each element the space is represented as a polynomial.\n\n\n\n\n\n","category":"type"},{"location":"api/#ClimaCore.Spaces.SpectralElementSpace2D","page":"API","title":"ClimaCore.Spaces.SpectralElementSpace2D","text":"SpectralElementSpace2D <: AbstractSpace\n\nA two-dimensional space: within each element the space is represented as a polynomial.\n\n\n\n\n\n","category":"type"},{"location":"api/#ClimaCore.Spaces.SpectralElementSpace2D-Tuple{Any, Any}","page":"API","title":"ClimaCore.Spaces.SpectralElementSpace2D","text":"SpectralElementSpace2D(topology, quadrature_style; enable_bubble)\n\nConstruct a SpectralElementSpace2D instance given a topology and quadrature. The flag enable_bubble enables the bubble correction for more accurate element areas.\n\nInput arguments:\n\ntopology: Topology2D\nquadrature_style: QuadratureStyle\nenable_bubble: Bool\n\nThe idea behind the so-called bubble_correction is that the numerical area of the domain (e.g., the sphere) is given by the sum of nodal integration weights times their corresponding Jacobians. However, this discrete sum is not exactly equal to the exact geometric area  (4pi*radius^2 for the sphere). To make these equal, the \"epsilon bubble\" approach modifies the inner weights in each element so that geometric and numerical areas of each element match.\n\nLet Delta A^e = A^e_exact - A^e_approx, then, in the case of linear elements, we correct W_ij J^e_ij by:\n\nwidehatW_ij J^e_ij = W_ij J^e_ij + Delta A^e * W_ij  Nq^2 \n\nand the case of non linear elements, by\n\nwidehatW_ij J^e_ij = W_ij J^e_ij left( 1 + tildeA^e right) \n\nwhere tildeA^e is the approximated area given by the sum of the interior nodal integration weights.\n\nNote: This is accurate only for cubed-spheres of the Meshes.EquiangularCubedSphere and Meshes.EquidistantCubedSphere type, not for Meshes.ConformalCubedSphere.\n\n\n\n\n\n","category":"method"},{"location":"api/#ClimaCore.Spaces.SpectralElementSpaceSlab","page":"API","title":"ClimaCore.Spaces.SpectralElementSpaceSlab","text":"SpectralElementSpaceSlab <: AbstractSpace\n\nA view into a SpectralElementSpace2D for a single slab.\n\n\n\n\n\n","category":"type"},{"location":"api/#Quadratures","page":"API","title":"Quadratures","text":"","category":"section"},{"location":"api/","page":"API","title":"API","text":"Spaces.Quadratures.QuadratureStyle\nSpaces.Quadratures.GLL\nSpaces.Quadratures.GL\nSpaces.Quadratures.Uniform\nSpaces.Quadratures.degrees_of_freedom\nSpaces.Quadratures.polynomial_degree\nSpaces.Quadratures.quadrature_points\nSpaces.Quadratures.barycentric_weights\nSpaces.Quadratures.interpolation_matrix\nSpaces.Quadratures.differentiation_matrix\nSpaces.Quadratures.orthonormal_poly","category":"page"},{"location":"api/#ClimaCore.Spaces.Quadratures.QuadratureStyle","page":"API","title":"ClimaCore.Spaces.Quadratures.QuadratureStyle","text":"QuadratureStyle\n\nQuadrature style supertype. See sub-types:\n\nGLL\nGL\nUniform\n\n\n\n\n\n","category":"type"},{"location":"api/#ClimaCore.Spaces.Quadratures.GLL","page":"API","title":"ClimaCore.Spaces.Quadratures.GLL","text":"GLL{Nq}()\n\nGauss-Legendre-Lobatto quadrature using Nq quadrature points.\n\n\n\n\n\n","category":"type"},{"location":"api/#ClimaCore.Spaces.Quadratures.GL","page":"API","title":"ClimaCore.Spaces.Quadratures.GL","text":"GL{Nq}()\n\nGauss-Legendre quadrature using Nq quadrature points.\n\n\n\n\n\n","category":"type"},{"location":"api/#ClimaCore.Spaces.Quadratures.Uniform","page":"API","title":"ClimaCore.Spaces.Quadratures.Uniform","text":"Uniform{Nq}()\n\nUniformly-spaced quadrature.\n\n\n\n\n\n","category":"type"},{"location":"api/#ClimaCore.Spaces.Quadratures.degrees_of_freedom","page":"API","title":"ClimaCore.Spaces.Quadratures.degrees_of_freedom","text":"degrees_of_freedom(QuadratureStyle) -> Int\n\nReturns the degreesoffreedom of the QuadratureStyle concrete type\n\n\n\n\n\n","category":"function"},{"location":"api/#ClimaCore.Spaces.Quadratures.polynomial_degree","page":"API","title":"ClimaCore.Spaces.Quadratures.polynomial_degree","text":"polynomial_degree(QuadratureStyle) -> Int\n\nReturns the polynomial degree of the QuadratureStyle concrete type\n\n\n\n\n\n","category":"function"},{"location":"api/#ClimaCore.Spaces.Quadratures.quadrature_points","page":"API","title":"ClimaCore.Spaces.Quadratures.quadrature_points","text":"points, weights = quadrature_points(::Type{FT}, quadrature_style)\n\nThe points and weights of the quadrature rule in floating point type FT.\n\n\n\n\n\n","category":"function"},{"location":"api/#ClimaCore.Spaces.Quadratures.barycentric_weights","page":"API","title":"ClimaCore.Spaces.Quadratures.barycentric_weights","text":"barycentric_weights(x::SVector{Nq}) where {Nq}\n\nThe barycentric weights associated with the array of point locations x:\n\nw_j = frac1prod_k ne j (x_i - x_j)\n\nSee Jean-Paul Berrut, Lloyd N Trefethen (2004), equation 3.2.\n\n\n\n\n\n","category":"function"},{"location":"api/#ClimaCore.Spaces.Quadratures.interpolation_matrix","page":"API","title":"ClimaCore.Spaces.Quadratures.interpolation_matrix","text":"interpolation_matrix(x::SVector, r::SVector{Nq})\n\nThe matrix which interpolates the Lagrange polynomial of degree Nq-1 through the points r, to points x. The matrix coefficients are computed using the Barycentric formula of Jean-Paul Berrut, Lloyd N Trefethen (2004), section 4:\n\nI_ij = begincases\n1  textif  x_i = r_j \n0  textif  x_i = r_k text for  k ne j \nfracdisplaystyle fracw_jx_i - r_jdisplaystyle sum_k fracw_kx_i - r_k  textotherwise\nendcases\n\nwhere w_j are the barycentric weights, see barycentric_weights.\n\n\n\n\n\n","category":"function"},{"location":"api/#ClimaCore.Spaces.Quadratures.differentiation_matrix","page":"API","title":"ClimaCore.Spaces.Quadratures.differentiation_matrix","text":"differentiation_matrix(r::SVector{Nq, T}) where {Nq, T}\n\nThe spectral differentiation matrix for the Lagrange polynomial of degree Nq-1 interpolating at points r.\n\nThe matrix coefficients are computed using the Jean-Paul Berrut, Lloyd N Trefethen (2004), section 9.3:\n\nD_ij = begincases\n    displaystyle\n    fracw_jw_i (x_i - x_j) text if  i ne j \n    -sum_k ne j D_kj text if  i = j\nendcases\n\nwhere w_j are the barycentric weights, see barycentric_weights.\n\n\n\n\n\ndifferentiation_matrix(FT, quadstyle::QuadratureStyle)\n\nThe spectral differentiation matrix at the quadrature points of quadstyle, using floating point types FT.\n\n\n\n\n\n","category":"function"},{"location":"api/#ClimaCore.Spaces.Quadratures.orthonormal_poly","page":"API","title":"ClimaCore.Spaces.Quadratures.orthonormal_poly","text":"V = orthonormal_poly(points, quad)\n\nV_{ij} contains the j-1th Legendre polynomial evaluated at points[i]. i.e. it is the mapping from the modal to the nodal representation.\n\n\n\n\n\n","category":"function"},{"location":"api/#Internals-2","page":"API","title":"Internals","text":"","category":"section"},{"location":"api/","page":"API","title":"API","text":"Spaces.dss_transform\nSpaces.dss_untransform\nSpaces.dss_interior_faces!\nSpaces.dss_local_vertices!\nSpaces.dss_ghost_faces!\nSpaces.dss_ghost_vertices!\nSpaces.dss_local!\nSpaces.dss_local_ghost!\nSpaces.dss_ghost!\nSpaces.create_dss_buffer\nSpaces.DSSBuffer\nSpaces.weighted_dss_start!\nSpaces.weighted_dss_internal!\nSpaces.weighted_dss_ghost!\nSpaces.weighted_dss!\nSpaces.dss!\nSpaces.unique_nodes","category":"page"},{"location":"api/#ClimaCore.Spaces.dss_transform","page":"API","title":"ClimaCore.Spaces.dss_transform","text":"dss_transform(arg, local_geometry, weight, I...)\n\nTransfrom arg[I...] to a basis for direct stiffness summation (DSS). Transformations only apply to vector quantities.\n\nlocal_geometry[I...] is the relevant LocalGeometry object. If it is nothing, then no transformation is performed\nweight[I...] is the relevant DSS weights. If weight is nothing, then the result is simply summation.\n\nSee Spaces.weighted_dss!.\n\n\n\n\n\n","category":"function"},{"location":"api/#ClimaCore.Spaces.dss_untransform","page":"API","title":"ClimaCore.Spaces.dss_untransform","text":"dss_untransform(T, targ, local_geometry, I...)\n\nTransform targ[I...] back to a value of type T after performing direct stiffness summation (DSS).\n\nSee Spaces.weighted_dss!.\n\n\n\n\n\n","category":"function"},{"location":"api/#ClimaCore.Spaces.dss_local!","page":"API","title":"ClimaCore.Spaces.dss_local!","text":"function dss_local!(\n    ::ClimaComms.CPU,\n    perimeter_data::DataLayouts.VIFH,\n    perimeter::AbstractPerimeter,\n    topology::Topologies.AbstractTopology,\n)\n\nPerforms DSS on local vertices and faces.\n\nPart of Spaces.weighted_dss!.\n\n\n\n\n\n","category":"function"},{"location":"api/#ClimaCore.Spaces.dss_local_ghost!","page":"API","title":"ClimaCore.Spaces.dss_local_ghost!","text":"function dss_local_ghost!(\n    ::ClimaComms.CPU,\n    perimeter_data::DataLayouts.VIFH,\n    perimeter::AbstractPerimeter,\n    topology::Topologies.AbstractTopology,\n)\n\nComputes the \"local\" part of ghost vertex dss. (i.e. it computes the summation of all the shared local vertices of a unique ghost vertex and stores the value in each of the local vertex locations in  perimeter_data)\n\nPart of Spaces.weighted_dss!.\n\n\n\n\n\n","category":"function"},{"location":"api/#ClimaCore.Spaces.dss_ghost!","page":"API","title":"ClimaCore.Spaces.dss_ghost!","text":"dss_ghost!(\n    device::ClimaComms.CPU,\n    perimeter_data::DataLayouts.VIFH,\n    perimeter::AbstractPerimeter,\n    topology::Topologies.AbstractTopology,\n)\n\nSets the value for all local vertices of each unique ghost vertex, in perimeter_data, to that of  the representative ghost vertex.\n\nPart of Spaces.weighted_dss!.\n\n\n\n\n\n","category":"function"},{"location":"api/#ClimaCore.Spaces.create_dss_buffer","page":"API","title":"ClimaCore.Spaces.create_dss_buffer","text":"create_dss_buffer(\n    data::Union{DataLayouts.IJFH{S, Nij}, DataLayouts.VIJFH{S, Nij}},\n    hspace::AbstractSpectralElementSpace,\n) where {S, Nij}\n\nCreates a DSSBuffer for the field data corresponding to data\n\n\n\n\n\nSpaces.create_dss_buffer(field::Field)\n\nCreate a buffer for communicating neighbour information of field.\n\n\n\n\n\n","category":"function"},{"location":"api/#ClimaCore.Spaces.DSSBuffer","page":"API","title":"ClimaCore.Spaces.DSSBuffer","text":"DSSBuffer{G, D, A, B}\n\nFields\n\ngraph_context: ClimaComms graph context for communication\nperimeter_data: Array for storing perimeter data\nsend_data: send buffer\nrecv_data: recv buffer\nsend_buf_idx: indexing array for loading send buffer from perimeter_data\nrecv_buf_idx: indexing array for loading (and summing) data from recv buffer to perimeter_data\nscalarfidx: field id for all scalar fields stored in the data array\ncovariant12fidx: field id for all covariant12vector fields stored in the data array\ncontravariant12fidx: field id for all contravariant12vector fields stored in the data array\ninternal_elems: internal local elements (lidx)\nperimeter_elems: local elements (lidx) located on process boundary\n\n\n\n\n\n","category":"type"},{"location":"api/#ClimaCore.Spaces.weighted_dss_start!","page":"API","title":"ClimaCore.Spaces.weighted_dss_start!","text":"weighted_dss_start!(\n    data::Union{\n        DataLayouts.IFH,\n        DataLayouts.VIFH,\n        DataLayouts.IJFH,\n        DataLayouts.VIJFH,\n    },\n    space::Union{\n        AbstractSpectralElementSpace,\n        ExtrudedFiniteDifferenceSpace,\n    },\n    dss_buffer::Union{DSSBuffer, Nothing},\n)\n\nIt comprises of the following steps:\n\n1). Apply Spaces.dss_transform! on perimeter elements. This weights and tranforms vector  fields to physical basis if needed. Scalar fields are weighted. The transformed and/or weighted  perimeter data is stored in perimeter_data.\n\n2). Apply Spaces.dss_local_ghost! This computes partial weighted DSS on ghost vertices, using only the information from local vertices.\n\n3). Spaces.fill_send_buffer!  Loads the send buffer from perimeter_data. For unique ghost vertices, only data from the representative ghost vertices which store result of \"ghost local\" DSS are loaded.\n\n4). Start DSS communication with neighboring processes\n\n\n\n\n\n","category":"function"},{"location":"api/#ClimaCore.Spaces.weighted_dss_internal!","page":"API","title":"ClimaCore.Spaces.weighted_dss_internal!","text":"weighted_dss_internal!(\n    data::Union{\n        DataLayouts.IFH,\n        DataLayouts.VIFH,\n        DataLayouts.IJFH,\n        DataLayouts.VIJFH,\n    },\n    space::Union{\n        AbstractSpectralElementSpace,\n        ExtrudedFiniteDifferenceSpace,\n    },\n    dss_buffer::DSSBuffer,\n)\n\n1). Apply Spaces.dss_transform! on interior elements. Local elements are split into interior  and perimeter elements to facilitate overlapping of communication with computation.\n\n2). Probe communication\n\n3). Spaces.dss_local! computes the weighted DSS on local vertices and faces.\n\n\n\n\n\n","category":"function"},{"location":"api/#ClimaCore.Spaces.weighted_dss_ghost!","page":"API","title":"ClimaCore.Spaces.weighted_dss_ghost!","text":"weighted_dss_ghost!(\n    data::Union{\n        DataLayouts.IFH,\n        DataLayouts.VIFH,\n        DataLayouts.IJFH,\n        DataLayouts.VIJFH,\n    },\n    space::Union{\n        AbstractSpectralElementSpace,\n        ExtrudedFiniteDifferenceSpace,\n    },\n    dss_buffer::Union{DSSBuffer, Nothing},\n)\n\n1). Finish communications.\n\n2). Call Spaces.load_from_recv_buffer! After the communication is complete, this adds data from the recv buffer to the corresponding location in  perimeter_data. For ghost vertices, this data is added only to the representative vertices. The values are  then scattered to other local vertices corresponding to each unique ghost vertex in dss_local_ghost.\n\n3). Call Spaces.dss_untransform! on all local elements. This transforms the DSS'd local vectors back to Covariant12 vectors, and copies the DSS'd data from the perimeter_data to data.\n\n\n\n\n\n","category":"function"},{"location":"api/#ClimaCore.Spaces.weighted_dss!","page":"API","title":"ClimaCore.Spaces.weighted_dss!","text":"function weighted_dss!(\n    data::Union{\n        DataLayouts.IFH,\n        DataLayouts.VIFH,\n        DataLayouts.IJFH,\n        DataLayouts.VIJFH,\n    },\n    space::Union{\n        AbstractSpectralElementSpace,\n        ExtrudedFiniteDifferenceSpace,\n    },\n    dss_buffer::Union{DSSBuffer, Nothing},\n)\n\nComputes weighted dss of data. \n\nIt comprises of the following steps:\n\n1). Spaces.weighted_dss_start!\n\n2). Spaces.weighted_dss_internal!\n\n3). Spaces.weighted_dss_ghost!\n\n\n\n\n\nSpaces.weighted_dss!(f::Field[, ghost_buffer = Spaces.create_dss_buffer(field)])\n\nApply weighted direct stiffness summation (DSS) to f. This operates in-place (i.e. it modifies the f). ghost_buffer contains the necessary information for communication in a distributed setting, see Spaces.create_ghost_buffer.\n\nThis is a projection operation from the piecewise polynomial space mathcalV_0 to the continuous space mathcalV_1 = mathcalV_0 cap mathcalC_0, defined as the field theta in mathcalV_1 such that for all phi in mathcalV_1\n\nint_Omega phi theta dOmega = int_Omega phi f dOmega\n\nIn matrix form, we define bar theta to be the unique global node representation, and Q to be the \"scatter\" operator which maps to the redundant node representation theta\n\ntheta = Q bar theta\n\nThen the problem can be written as\n\n(Q barphi)^top W J Q bartheta = (Q barphi)^top W J f\n\nwhich reduces to\n\ntheta = Q bartheta = Q (Q^top W J Q)^-1 Q^top W J f\n\n\n\n\n\n","category":"function"},{"location":"api/#ClimaCore.Spaces.dss!","page":"API","title":"ClimaCore.Spaces.dss!","text":"dss!(data, topology, quadrature_style)\n\nComputed unweighted/pure DSS of data.\n\n\n\n\n\n","category":"function"},{"location":"api/#ClimaCore.Spaces.unique_nodes","page":"API","title":"ClimaCore.Spaces.unique_nodes","text":"unique_nodes(space::SpectralElementField2D)\n\nAn iterator over the unique nodes of space. Each node is represented by the first ((i,j), e) triple.\n\nThis function is experimental, and may change in future.\n\n\n\n\n\n","category":"function"},{"location":"api/#Utilities","page":"API","title":"Utilities","text":"","category":"section"},{"location":"api/","page":"API","title":"API","text":"Spaces.area\nSpaces.local_area","category":"page"},{"location":"api/#ClimaCore.Spaces.area","page":"API","title":"ClimaCore.Spaces.area","text":"Spaces.area(space::Spaces.AbstractSpace)\n\nThe length/area/volume of space. This is computed as the sum of the quadrature weights W_i multiplied by the Jacobian determinants J_i:\n\nsum_i W_i J_i approx int_Omega  d Omega\n\nIf space is distributed, this uses a ClimaComms.allreduce operation.\n\n\n\n\n\n","category":"function"},{"location":"api/#ClimaCore.Spaces.local_area","page":"API","title":"ClimaCore.Spaces.local_area","text":"Spaces.local_area(space::Spaces.AbstractSpace)\n\nThe length/area/volume of space local to the current context. See Spaces.area\n\n\n\n\n\n","category":"function"},{"location":"api/#RecursiveApply","page":"API","title":"RecursiveApply","text":"","category":"section"},{"location":"api/","page":"API","title":"API","text":"RecursiveApply\nRecursiveApply.tuplemap","category":"page"},{"location":"api/#ClimaCore.RecursiveApply","page":"API","title":"ClimaCore.RecursiveApply","text":"RecursiveApply\n\nThis module contains operators to recurse over nested Tuples or NamedTuples.\n\nTo extend to another type T, define RecursiveApply.rmap(fn, args::T...)\n\n\n\n\n\n","category":"module"},{"location":"api/#ClimaCore.RecursiveApply.tuplemap","page":"API","title":"ClimaCore.RecursiveApply.tuplemap","text":"tuplemap(fn::Function, tup)\n\nA map impl for mapping function fn a tuple argument tup\n\nCurrently just calls Base.map behind the scenes but is left stubbed out for potential specialization in the future.\n\n\n\n\n\ntuplemap(fn::Function, tup1, tup2)\n\nA map impl for mapping function fn over tup1, tup2 tuple arguments.\n\nCurrently just calls Base.map behind the scenes but is left stubbed out for potential specialization in the future.\n\n\n\n\n\n","category":"function"},{"location":"api/#Fields","page":"API","title":"Fields","text":"","category":"section"},{"location":"api/","page":"API","title":"API","text":"Fields.Field\nFields.coordinate_field\nFields.local_geometry_field\nBase.zeros(::Spaces.AbstractSpace)\nBase.ones(::Spaces.AbstractSpace)\nBase.sum(::Fields.Field)\nFields.local_sum\nFields.Statistics.mean(::Fields.Field)\nFields.LinearAlgebra.norm(::Fields.Field)\nFields.set!\nFields.ColumnIndex\nFields.bycolumn\nFields.Δz_field","category":"page"},{"location":"api/#ClimaCore.Fields.Field","page":"API","title":"ClimaCore.Fields.Field","text":"Field(values, space)\n\nA set of values defined at each point of a space.\n\n\n\n\n\n","category":"type"},{"location":"api/#ClimaCore.Fields.coordinate_field","page":"API","title":"ClimaCore.Fields.coordinate_field","text":"coordinate_field(space::AbstractSpace)\n\nConstruct a Field of the coordinates of the space.\n\n\n\n\n\n","category":"function"},{"location":"api/#ClimaCore.Fields.local_geometry_field","page":"API","title":"ClimaCore.Fields.local_geometry_field","text":"local_geometry_field(space::AbstractSpace)\n\nConstruct a Field of the LocalGeometry of the space.\n\n\n\n\n\n","category":"function"},{"location":"api/#Base.zeros-Tuple{ClimaCore.Spaces.AbstractSpace}","page":"API","title":"Base.zeros","text":"zeros(space::AbstractSpace)\n\nConstruct a field on space that is zero everywhere.\n\n\n\n\n\n","category":"method"},{"location":"api/#Base.ones-Tuple{ClimaCore.Spaces.AbstractSpace}","page":"API","title":"Base.ones","text":"ones(space::AbstractSpace)\n\nConstruct a field on space that is one everywhere.\n\n\n\n\n\n","category":"method"},{"location":"api/#ClimaCore.Fields.local_sum","page":"API","title":"ClimaCore.Fields.local_sum","text":"Fields.local_sum(v::Field)\n\nCompute the approximate integral of v over the domain local to the current context.\n\nSee sum for the integral over the full domain.\n\n\n\n\n\n","category":"function"},{"location":"api/#ClimaCore.Fields.set!","page":"API","title":"ClimaCore.Fields.set!","text":"set!(f::Function, field::Field, args = ())\n\nApply function f to populate values in field field. f must have a function signature with signature f(::LocalGeometry[, args...]). Additional arguments may be passed to f with args.\n\n\n\n\n\n","category":"function"},{"location":"api/#ClimaCore.Fields.ColumnIndex","page":"API","title":"ClimaCore.Fields.ColumnIndex","text":"ColumnIndex(ij,h)\n\nAn index into a column of a field. This can be used as an argument to getindex of a Field, to return a field on that column.\n\nExample\n\ncolidx = ColumnIndex((1,1),1)\nfield[colidx]\n\n\n\n\n\n","category":"type"},{"location":"api/#ClimaCore.Fields.bycolumn","page":"API","title":"ClimaCore.Fields.bycolumn","text":"Fields.bycolumn(fn, space)\n\nCall fn(colidx) to every ColumnIndex colidx of space. This can be used to apply multiple column-wise operations in a single pass, making use of multiple threads.\n\nExample\n\n∇ = GradientF2C()\ndiv = DivergenceC2F()\n\nbycolumn(axes(f)) do colidx\n    @. ∇f[colidx] = ∇(f[colidx])\n    @. df[colidx] = div(∇f[colidx])\nend\n\n\n\n\n\n","category":"function"},{"location":"api/#ClimaCore.Fields.Δz_field","page":"API","title":"ClimaCore.Fields.Δz_field","text":"Δz_field(field::Field)\nΔz_field(space::AbstractSpace)\n\nA Field containing the Δz values on the same space as the given field.\n\n\n\n\n\n","category":"function"},{"location":"api/#Limiters","page":"API","title":"Limiters","text":"","category":"section"},{"location":"api/","page":"API","title":"API","text":"The limiters supertype is","category":"page"},{"location":"api/","page":"API","title":"API","text":"Limiters.AbstractLimiter","category":"page"},{"location":"api/#ClimaCore.Limiters.AbstractLimiter","page":"API","title":"ClimaCore.Limiters.AbstractLimiter","text":"AbstractLimiter\n\nSupertype for all limiters.\n\nInterfaces\n\nquasimonotone_limiter!\n\n\n\n\n\n","category":"type"},{"location":"api/","page":"API","title":"API","text":"This class of flux-limiters is applied only in the horizontal direction (on spectral advection operators).","category":"page"},{"location":"api/#Interfaces-4","page":"API","title":"Interfaces","text":"","category":"section"},{"location":"api/","page":"API","title":"API","text":"Limiters.QuasiMonotoneLimiter\nLimiters.compute_bounds!\nLimiters.apply_limiter!","category":"page"},{"location":"api/#ClimaCore.Limiters.QuasiMonotoneLimiter","page":"API","title":"ClimaCore.Limiters.QuasiMonotoneLimiter","text":"QuasiMonotoneLimiter\n\nThis limiter is inspired by the one presented in Guba et al Oksana Guba, Mark Taylor, Amik St-Cyr (2014). In the reference paper, it is denoted by OP1, and is outlined in eqs. (37)-(40). Quasimonotone here is meant to be monotone with respect to the spectral element nodal values. This limiter involves solving a constrained optimization problem (a weighted least square problem up to a fixed tolerance) that is completely local to each element.\n\nAs in HOMME, the implementation idea here is the following: we need to find a grid field which is closest to the initial field (in terms of weighted sum), but satisfies the min/max constraints. So, first we find values that do not satisfy constraints and bring these values to a closest constraint. This way we introduce some change in the tracer mass, which we then redistribute so that the l2 error is smallest. This redistribution might violate constraints; thus, we do a few iterations (until abs(Δtracer_mass) <= rtol * tracer_mass).\n\nρq: tracer density Field, where q denotes tracer concentration per unit mass. This can be a scalar field, or a struct-valued field.\nρ: fluid density Field (scalar).\n\nConstructor\n\nlimiter = QuasiMonotoneLimiter(ρq::Field; rtol = eps(eltype(parent(ρq))))\n\nCreates a limiter instance for the field ρq with relative tolerance rtol.\n\nUsage\n\nCall compute_bounds! on the input fields:\n\ncompute_bounds!(limiter, ρq, ρ)\n\nThen call apply_limiter! on the output fields:\n\napply_limiter!(ρq, ρ, limiter)\n\n\n\n\n\n","category":"type"},{"location":"api/#ClimaCore.Limiters.compute_bounds!","page":"API","title":"ClimaCore.Limiters.compute_bounds!","text":"compute_bounds!(limiter::QuasiMonotoneLimiter, ρq::Field, ρ::Field)\n\nCompute the desired bounds for the tracer concentration per unit mass q, based on the tracer density, ρq, and density, ρ, fields.\n\nThis is computed by\n\ncompute_element_bounds!\nstarts the ghost exchange (if distributed)\ncompute_neighbor_bounds_local!\ncompletes the ghost exchange (if distributed)\ncompute_neighbor_bounds_ghost! (if distributed)\n\n\n\n\n\n","category":"function"},{"location":"api/#ClimaCore.Limiters.apply_limiter!","page":"API","title":"ClimaCore.Limiters.apply_limiter!","text":"apply_limiter!(ρq, ρ, limiter::QuasiMonotoneLimiter)\n\nApply the limiter on the tracer density  ρq, using the computed desired bounds on the concentration q and density ρ as an optimal weight. This iterates over each element, calling apply_limit_slab!. If the limiter fails to converge for any element, a warning is issued.\n\n\n\n\n\n","category":"function"},{"location":"api/#Internals-3","page":"API","title":"Internals","text":"","category":"section"},{"location":"api/","page":"API","title":"API","text":"Limiters.compute_element_bounds!\nLimiters.compute_neighbor_bounds_local!\nLimiters.compute_neighbor_bounds_ghost!\nLimiters.apply_limit_slab!","category":"page"},{"location":"api/#ClimaCore.Limiters.compute_element_bounds!","page":"API","title":"ClimaCore.Limiters.compute_element_bounds!","text":"compute_element_bounds!(limiter::QuasiMonotoneLimiter, ρq, ρ)\n\nGiven two fields ρq and ρ, computes the min and max of q in each element, storing it in limiter.q_bounds.\n\nPart of compute_bounds!.\n\n\n\n\n\n","category":"function"},{"location":"api/#ClimaCore.Limiters.compute_neighbor_bounds_local!","page":"API","title":"ClimaCore.Limiters.compute_neighbor_bounds_local!","text":"compute_neighbor_bounds_local!(limiter::QuasiMonotoneLimiter, topology)\n\nUpdate the field limiter.q_bounds_nbr based on limiter.q_bounds in the local neighbors.\n\nPart of compute_bounds!.\n\n\n\n\n\n","category":"function"},{"location":"api/#ClimaCore.Limiters.compute_neighbor_bounds_ghost!","page":"API","title":"ClimaCore.Limiters.compute_neighbor_bounds_ghost!","text":"compute_neighbor_bounds_ghost!(limiter::QuasiMonotoneLimiter, topology)\n\nUpdate the field limiter.q_bounds_nbr based on limiter.q_bounds in the ghost neighbors. This should be called after the ghost exchange has completed.\n\nPart of compute_bounds!.\n\n\n\n\n\n","category":"function"},{"location":"api/#ClimaCore.Limiters.apply_limit_slab!","page":"API","title":"ClimaCore.Limiters.apply_limit_slab!","text":"apply_limit_slab!(slab_ρq, slab_ρ, slab_WJ, slab_q_bounds, rtol)\n\nApply the computed bounds of the tracer concentration (slab_q_bounds) in the limiter to slab_ρq, given the total mass slab_ρ, metric terms slab_WJ, and relative tolerance rtol. Return whether the tolerance condition could be satisfied.\n\n\n\n\n\n","category":"function"},{"location":"api/#InputOutput","page":"API","title":"InputOutput","text":"","category":"section"},{"location":"api/#Writers","page":"API","title":"Writers","text":"","category":"section"},{"location":"api/","page":"API","title":"API","text":"InputOutput.HDF5Writer\nInputOutput.write!","category":"page"},{"location":"api/#ClimaCore.InputOutput.HDF5Writer","page":"API","title":"ClimaCore.InputOutput.HDF5Writer","text":"HDF5Writer(filename::AbstractString[, context::ClimaComms.AbstractCommsContext])\n\nAn AbstractWriter for writing to HDF5-formatted files using the ClimaCore storage conventions. An internal cache is used to avoid writing duplicate domains, meshes, topologies and spaces to the file. Use HDF5Reader to load the data from the file.\n\nThe optional context can be used for writing distributed fields: in this case, the MPICommsContext used passed as an argument: this must match the context used for distributing the Field.\n\nnote: Note\nThe default Julia HDF5 binaries are not built with MPI support. To use the distributed functionality, you will need to configure HDF5.jl with an MPI-enabled HDF5 library, see the HDF5.jl documentation.\n\nInterface\n\nwrite!\n\nUsage\n\nwriter = InputOutput.HDF5Writer(filename)\nInputOutput.write!(writer, Y, \"Y\")\nclose(writer)\n\n\n\n\n\n","category":"type"},{"location":"api/#ClimaCore.InputOutput.write!","page":"API","title":"ClimaCore.InputOutput.write!","text":"write!(writer::AbstractWriter, obj[, preferredname])\n\nWrite the object obj using writer. An optional preferredname can be provided, otherwise defaultname will be used to generate a name. The name of the object will be returned.\n\nA cache of domains, meshes, topologies and spaces is kept: if one of these objects has already been written, then the file will not be modified: instead the name under which the object was first written will be returned. Note that Fields and FieldVectors are not cached, and so can be written multiple times.\n\n\n\n\n\nwrite!(writer::HDF5Writer, name => value...)\n\nWrite one or more name => value pairs to writer.\n\n\n\n\n\nwrite!(filename::AbstractString, name => value...)\n\nWrite one or more name => value pairs to the HDF5 file filename.\n\n\n\n\n\n","category":"function"},{"location":"api/#Readers","page":"API","title":"Readers","text":"","category":"section"},{"location":"api/","page":"API","title":"API","text":"InputOutput.HDF5Reader\nInputOutput.read_domain\nInputOutput.read_mesh\nInputOutput.read_topology\nInputOutput.read_space\nInputOutput.read_field","category":"page"},{"location":"api/#ClimaCore.InputOutput.HDF5Reader","page":"API","title":"ClimaCore.InputOutput.HDF5Reader","text":"HDF5Reader(filename::AbstractString[, context::ClimaComms.AbstractCommsContext])\n\nAn AbstractReader for reading from HDF5 files created by HDF5Writer. The reader object contains an internal cache of domains, meshes, topologies and spaces that are read so that duplicate objects are not created.\n\nThe optional context can be used for reading distributed fields: in this case, the MPICommsContext used passed as an argument: resulting Fields will be distributed using this context. As with HDF5Writer, this requires a HDF5 library with MPI support.\n\nInterface\n\nread_domain\nread_mesh\nread_topology\nread_space\nread_field\n\nUsage\n\nreader = InputOutput.HDF5Reader(filename)\nY = read_field(reader, \"Y\")\nY.c |> propertynames\nY.f |> propertynames\nρ_field = read_field(reader, \"Y.c.ρ\")\nw_field = read_field(reader, \"Y.f.w\")\nclose(reader)\n\nTo explore the contents of the reader, use either\n\njulia> reader |> propertynames\n\ne.g, to explore the components of the space, \n\njulia> reader.space_cache\nDict{Any, Any} with 3 entries:\n  \"center_extruded_finite_difference_space\" => CenterExtrudedFiniteDifferenceSpace:…\n  \"horizontal_space\"                        => SpectralElementSpace2D:…\n  \"face_extruded_finite_difference_space\"   => FaceExtrudedFiniteDifferenceSpace:…\n\nOnce \"unpacked\" as shown above, ClimaCorePlots or ClimaCoreMakie can be used to visualise fields. ClimaCoreTempestRemap supports interpolation onto user-specified grids if necessary.\n\n\n\n\n\n","category":"type"},{"location":"api/#ClimaCore.InputOutput.read_domain","page":"API","title":"ClimaCore.InputOutput.read_domain","text":"read_domain(reader::AbstractReader, name)\n\nReads a domain named name from reader. Domain objects are cached in the reader to avoid creating duplicate objects.\n\n\n\n\n\n","category":"function"},{"location":"api/#ClimaCore.InputOutput.read_mesh","page":"API","title":"ClimaCore.InputOutput.read_mesh","text":"read_mesh(reader::AbstractReader, name)\n\nReads a mesh named name from reader, or from the reader cache if it has already been read.\n\n\n\n\n\n","category":"function"},{"location":"api/#ClimaCore.InputOutput.read_topology","page":"API","title":"ClimaCore.InputOutput.read_topology","text":"read_topology(reader::AbstractReader, name)\n\nReads a topology named name from reader, or from the reader cache if it has already been read.\n\n\n\n\n\n","category":"function"},{"location":"api/#ClimaCore.InputOutput.read_space","page":"API","title":"ClimaCore.InputOutput.read_space","text":"read_space(reader::AbstractReader, name)\n\nReads a space named name from reader, or from the reader cache if it has already been read.\n\n\n\n\n\n","category":"function"},{"location":"api/#ClimaCore.InputOutput.read_field","page":"API","title":"ClimaCore.InputOutput.read_field","text":"read_field(reader, name)\n\nReads a Field or FieldVector named name from reader. Fields are not cached, so that reading the same field multiple times will create multiple distinct objects.\n\n\n\n\n\n","category":"function"},{"location":"code_of_conduct/#Code-of-Conduct","page":"Code of Conduct","title":"Code of Conduct","text":"","category":"section"},{"location":"code_of_conduct/#Our-Pledge","page":"Code of Conduct","title":"Our Pledge","text":"","category":"section"},{"location":"code_of_conduct/","page":"Code of Conduct","title":"Code of Conduct","text":"We as members, contributors, and leaders pledge to make participation in our community a harassment-free experience for everyone, regardless of age, body size, visible or invisible disability, ethnicity, sex characteristics, gender identity and expression, level of experience, education, socio-economic status, nationality, personal appearance, race, religion, or sexual identity and orientation.","category":"page"},{"location":"code_of_conduct/","page":"Code of Conduct","title":"Code of Conduct","text":"We pledge to act and interact in ways that contribute to an open, welcoming, diverse, inclusive, and healthy community.","category":"page"},{"location":"code_of_conduct/#Our-Standards","page":"Code of Conduct","title":"Our Standards","text":"","category":"section"},{"location":"code_of_conduct/","page":"Code of Conduct","title":"Code of Conduct","text":"Examples of behavior that contributes to a positive environment for our community include:","category":"page"},{"location":"code_of_conduct/","page":"Code of Conduct","title":"Code of Conduct","text":"Demonstrating empathy and kindness toward other people\nBeing respectful of differing opinions, viewpoints, and experiences\nGiving and gracefully accepting constructive feedback\nAccepting responsibility and apologizing to those affected by our mistakes, and learning from the experience\nFocusing on what is best not just for us as individuals, but for the overall community","category":"page"},{"location":"code_of_conduct/","page":"Code of Conduct","title":"Code of Conduct","text":"Examples of unacceptable behavior include:","category":"page"},{"location":"code_of_conduct/","page":"Code of Conduct","title":"Code of Conduct","text":"The use of sexualized language or imagery, and sexual attention or advances of any kind\nTrolling, insulting or derogatory comments, and personal or political attacks\nPublic or private harassment\nPublishing others' private information, such as a physical or email address, without their explicit permission\nOther conduct which could reasonably be considered inappropriate in a professional setting","category":"page"},{"location":"code_of_conduct/#Enforcement-Responsibilities","page":"Code of Conduct","title":"Enforcement Responsibilities","text":"","category":"section"},{"location":"code_of_conduct/","page":"Code of Conduct","title":"Code of Conduct","text":"Community leaders are responsible for clarifying and enforcing our standards of acceptable behavior and will take appropriate and fair corrective action in response to any behavior that they deem inappropriate, threatening, offensive, or harmful.","category":"page"},{"location":"code_of_conduct/","page":"Code of Conduct","title":"Code of Conduct","text":"Community leaders have the right and responsibility to remove, edit, or reject comments, commits, code, wiki edits, issues, and other contributions that are not aligned to this Code of Conduct, and will communicate reasons for moderation decisions when appropriate.","category":"page"},{"location":"code_of_conduct/#Enforcement","page":"Code of Conduct","title":"Enforcement","text":"","category":"section"},{"location":"code_of_conduct/","page":"Code of Conduct","title":"Code of Conduct","text":"Instances of abusive, harassing, or otherwise unacceptable behavior may be reported to the community leaders responsible for enforcement (group leader Tapio Schneider and project manager Cheikh Mbengue), but also anyone who you feel comforatable with interacting in our project and GitHub community. All complaints will be reviewed and investigated promptly and fairly.","category":"page"},{"location":"code_of_conduct/","page":"Code of Conduct","title":"Code of Conduct","text":"All community leaders are obligated to respect the privacy and security of the reporter of any incident.","category":"page"},{"location":"code_of_conduct/#Attribution-and-Credits","page":"Code of Conduct","title":"Attribution and Credits","text":"","category":"section"},{"location":"code_of_conduct/","page":"Code of Conduct","title":"Code of Conduct","text":"This Code of Conduct is heavily based on the excellent libCEED's Code of Conduct, which in turn is adapted from the Contributor Covenant, including version 2.0. For answers to common questions about the code of conduct, see the Contributor Covenant FAQ. Translations are also available.","category":"page"},{"location":"math_framework/#Mathematical-Framework","page":"Mathematical Framework","title":"Mathematical Framework","text":"","category":"section"},{"location":"math_framework/","page":"Mathematical Framework","title":"Mathematical Framework","text":"In this section we are going to introduce some mathematical concepts and their representations in ClimaCore.jl.","category":"page"},{"location":"math_framework/#Vectors-and-Vector-Fields","page":"Mathematical Framework","title":"Vectors and Vector Fields","text":"","category":"section"},{"location":"math_framework/","page":"Mathematical Framework","title":"Mathematical Framework","text":"Vector can mean a few things depending on context:","category":"page"},{"location":"math_framework/","page":"Mathematical Framework","title":"Mathematical Framework","text":"In Julia, a Vector is just an ordered collection of values (i.e., a container).\nIn mathematics, a vector is an element of a vector space: a set of objects,","category":"page"},{"location":"math_framework/","page":"Mathematical Framework","title":"Mathematical Framework","text":"which may be added together and multiplied by a scalar.","category":"page"},{"location":"math_framework/","page":"Mathematical Framework","title":"Mathematical Framework","text":"In physics, a vector typically refers to a directional quantity: that is","category":"page"},{"location":"math_framework/","page":"Mathematical Framework","title":"Mathematical Framework","text":"something with both a direction and a magnitude. This is the best way to think of vectors in ClimaCore,jl.","category":"page"},{"location":"math_framework/","page":"Mathematical Framework","title":"Mathematical Framework","text":"A vector field is then a vector-valued field: that is an assignment of a vector to each point in a space. For instance, a vector field in the plane can be visualised as a collection of arrows with a given magnitude and direction, each attached to a point in the plane.","category":"page"},{"location":"math_framework/","page":"Mathematical Framework","title":"Mathematical Framework","text":"In a coordinate system, a vector field on a domain in n-dimensional Euclidean space can be represented as a vector-valued function that associates an n-tuple of real numbers to each point of the domain. This representation of a vector field depends on the coordinate system, and there are transformation laws for passing from one coordinate system to the other.","category":"page"},{"location":"math_framework/","page":"Mathematical Framework","title":"Mathematical Framework","text":"ClmaCore supports different coordinate systems and, therefore, vector representations. In fact, one of the key requirements of ClimaCore is to support vectors specified in orthogonal (Cartesian) and curvilinear coordinate systems.","category":"page"},{"location":"math_framework/#LocalVector:-UVector,-UVVector,-and-UVWVector,-etc;-a-\"universal\"-basis","page":"Mathematical Framework","title":"LocalVector: UVector, UVVector, and UVWVector, etc; a \"universal\" basis","text":"","category":"section"},{"location":"math_framework/","page":"Mathematical Framework","title":"Mathematical Framework","text":"The easiest basis to use is the \"UVW\" basis, which can be defined in both Cartesian or spherical domains:","category":"page"},{"location":"math_framework/","page":"Mathematical Framework","title":"Mathematical Framework","text":"in a Cartesian domain, it is the usual Cartesian orthogonal vector basis","category":"page"},{"location":"math_framework/","page":"Mathematical Framework","title":"Mathematical Framework","text":"(U along the X-axis, V along the Y-axis, W along the Z-axis).","category":"page"},{"location":"math_framework/","page":"Mathematical Framework","title":"Mathematical Framework","text":"in a spherical domain, it is the orthogonal basis relative to spherical","category":"page"},{"location":"math_framework/","page":"Mathematical Framework","title":"Mathematical Framework","text":"(curvilinear) coordinates:","category":"page"},{"location":"math_framework/","page":"Mathematical Framework","title":"Mathematical Framework","text":"U is the zonal (eastward) component\nV is the meridonal (northward) component\nW is the radial component","category":"page"},{"location":"math_framework/","page":"Mathematical Framework","title":"Mathematical Framework","text":"It has some nice properties which make it convenient:","category":"page"},{"location":"math_framework/","page":"Mathematical Framework","title":"Mathematical Framework","text":"it's an orthonormal basis:\nit is easy to decompose a vector (take the projection along the basis)\nthe components are easy to interpret (they have unit scale)\nallow us to write code across domains\nU and V are always horizontal, W is vertical","category":"page"},{"location":"math_framework/","page":"Mathematical Framework","title":"Mathematical Framework","text":"We can define \"generic\" vectors via UVector, UVVector, and UVWVector that can be equally defined on Cartesian or spherical spaces.","category":"page"},{"location":"math_framework/","page":"Mathematical Framework","title":"Mathematical Framework","text":"But if users need to compute with them, or feed differential operators with them, then may want to consider different bases, as not all operators accept all bases.","category":"page"},{"location":"math_framework/#Covariant-and-Contravariant-bases","page":"Mathematical Framework","title":"Covariant and Contravariant bases","text":"","category":"section"},{"location":"math_framework/","page":"Mathematical Framework","title":"Mathematical Framework","text":"(Image: Different bases supported in ClimaCore.jl)","category":"page"},{"location":"math_framework/","page":"Mathematical Framework","title":"Mathematical Framework","text":"Covariance and contravariance describe how the quantitative description of certain geometric or physical entities changes with a change of basis.","category":"page"},{"location":"math_framework/","page":"Mathematical Framework","title":"Mathematical Framework","text":"In ClimaCore.jl, the covariant basis is specified by the partial derivative of the transformation from the reference element xi in -11^d (where d is the dimensionality of the domain Omega) to x in the physical space:","category":"page"},{"location":"math_framework/","page":"Mathematical Framework","title":"Mathematical Framework","text":"mathbfe_i = fracpartial xpartial xi^i","category":"page"},{"location":"math_framework/","page":"Mathematical Framework","title":"Mathematical Framework","text":"while the contravariant basis is the opposite: gradient in x of the coordinate (the inverse map)","category":"page"},{"location":"math_framework/","page":"Mathematical Framework","title":"Mathematical Framework","text":"mathbfe^i = nabla_x xi^i","category":"page"},{"location":"math_framework/","page":"Mathematical Framework","title":"Mathematical Framework","text":"Note:","category":"page"},{"location":"math_framework/","page":"Mathematical Framework","title":"Mathematical Framework","text":"these are specific to a given element: you generally can't compare covariant or contravariant component from one element with that in another\nin this case, you need to first convert them to UVW basis (e.g. we do this for DSS operations)\nwe choose the coordinates of the reference element so that xi^1 and xi^2 are horizontal, and xi^3 is vertical\nin a Cartesian domain, this means that covariant and contravariant components are just rescaled versions of the UVW components.\n\nthings get a little more complicated in the presence of terrain, but xi^3 is radially aligned\nthe 3rd covariant component is aligned with W, but the 3rd contravariant component may not be (e.g. at the surface it is normal to the boundary).","category":"page"},{"location":"math_framework/#Cartesian-bases","page":"Mathematical Framework","title":"Cartesian bases","text":"","category":"section"},{"location":"math_framework/","page":"Mathematical Framework","title":"Mathematical Framework","text":"Analogously to CartesianPoints, in ClimaCore, there are also CartesianVectors: these allow conversion to a global Cartesian basis. It is intended mainly for visualization purposes.","category":"page"},{"location":"math_framework/#Conversions","page":"Mathematical Framework","title":"Conversions","text":"","category":"section"},{"location":"math_framework/","page":"Mathematical Framework","title":"Mathematical Framework","text":"To convert between different vector bases, you need a LocalGeometry object: this contains all the necessary information (coordinates, metric terms, etc) to do the conversion. These are constructed as part of the Space.","category":"page"},{"location":"math_framework/#Introduction-to-the-Finite/Spectral-Element-Method","page":"Mathematical Framework","title":"Introduction to the Finite/Spectral Element Method","text":"","category":"section"},{"location":"math_framework/","page":"Mathematical Framework","title":"Mathematical Framework","text":"In finite element formulations, the weak form of a Partial Differential Equation (PDE)–-which involves integrating all terms in the PDE over the domain–-is evaluated on a subdomain Omega_e (element) and the local results are composed into a larger system of equations that models the entire problem on the global domain Omega.","category":"page"},{"location":"math_framework/","page":"Mathematical Framework","title":"Mathematical Framework","text":"A spectral element space is a function space in which each function is approximated with a finite-dimensional polynomial interpolation in each element. Hence, we use polynomials as basis functions to approximate a given function (e.g., solution state). There are different ways of defininig basis functions: nodal basis functions and modal basis functions. We use nodal basis functions (e.g. by using Lagrange interpolation), which are defined via the values of the polynomials at particular nodal points in each element (termed Finite Element nodes). Even though the basis functions can interpolate globally, it’s better to limit each function to interpolate locally within each element, so to avoid a dense matrix system of equations when adding up the element contributions on the global domain Omega.","category":"page"},{"location":"math_framework/","page":"Mathematical Framework","title":"Mathematical Framework","text":"The Finite Element nodes can be chosen to coincide with those of a particular quadrature rule, (this is referred to as using collocated nodes) which allows us to integrate functions over the domain.","category":"page"},{"location":"math_framework/","page":"Mathematical Framework","title":"Mathematical Framework","text":"Let us give a concrete example of strong and weak form of a PDE. A Poisson's problem (in strong form) is given by","category":"page"},{"location":"math_framework/","page":"Mathematical Framework","title":"Mathematical Framework","text":"   nabla cdot nabla u = f textrm for   mathbfx in Omega ","category":"page"},{"location":"math_framework/","page":"Mathematical Framework","title":"Mathematical Framework","text":"To obtain the weak form, let us multiply all terms by a test function v and integrate by parts (i.e., apply the divergence theorem in multiple dimensions):","category":"page"},{"location":"math_framework/","page":"Mathematical Framework","title":"Mathematical Framework","text":"   int_Omega nabla v cdot nabla u  dV - int_partial Omega v nabla u cdot hatmathbf n dS = int_Omega  v f  dV ","category":"page"},{"location":"math_framework/","page":"Mathematical Framework","title":"Mathematical Framework","text":"Often, we choose to represent a field (say, the velocity field) such that nabla u cdot hatmathbf n = 0, so that we're only left with the volumetric parts of the equation above.","category":"page"},{"location":"math_framework/","page":"Mathematical Framework","title":"Mathematical Framework","text":"The only supported choice for now in ClimaCore.jl is a Gauss-Legendre-Lobatto rule and nodes.","category":"page"},{"location":"tutorials/introduction/","page":"Introduction to ClimaCore.jl","title":"Introduction to ClimaCore.jl","text":"EditURL = \"https://github.com/CliMA/ClimaCore.jl/blob/main/docs/tutorials/introduction.jl\"","category":"page"},{"location":"tutorials/introduction/#Introduction-to-ClimaCore.jl","page":"Introduction to ClimaCore.jl","title":"Introduction to ClimaCore.jl","text":"","category":"section"},{"location":"tutorials/introduction/","page":"Introduction to ClimaCore.jl","title":"Introduction to ClimaCore.jl","text":"This tutorial is available as a Jupyter notebook.","category":"page"},{"location":"tutorials/introduction/#What-is-ClimaCore?","page":"Introduction to ClimaCore.jl","title":"What is ClimaCore?","text":"","category":"section"},{"location":"tutorials/introduction/","page":"Introduction to ClimaCore.jl","title":"Introduction to ClimaCore.jl","text":"A suite of tools for constructing spatial discretizations","category":"page"},{"location":"tutorials/introduction/","page":"Introduction to ClimaCore.jl","title":"Introduction to ClimaCore.jl","text":"primarily aimed at climate and weather models\ninitial aim:\nspectral element discretization in the horizontal\nstaggered finite difference in the vertical\ncurrently under development","category":"page"},{"location":"tutorials/introduction/","page":"Introduction to ClimaCore.jl","title":"Introduction to ClimaCore.jl","text":"using ClimaComms,\n    ClimaCore,\n    ClimaCorePlots,\n    LinearAlgebra,\n    IntervalSets,\n    UnPack,\n    Plots,\n    OrdinaryDiffEq","category":"page"},{"location":"tutorials/introduction/#.-Constructing-a-discretization","page":"Introduction to ClimaCore.jl","title":"1. Constructing a discretization","text":"","category":"section"},{"location":"tutorials/introduction/#.1-Domains","page":"Introduction to ClimaCore.jl","title":"1.1 Domains","text":"","category":"section"},{"location":"tutorials/introduction/","page":"Introduction to ClimaCore.jl","title":"Introduction to ClimaCore.jl","text":"A domain is a region of space (think of a mathematical domain).","category":"page"},{"location":"tutorials/introduction/","page":"Introduction to ClimaCore.jl","title":"Introduction to ClimaCore.jl","text":"column_domain = ClimaCore.Domains.IntervalDomain(\n    ClimaCore.Geometry.ZPoint(0.0) .. ClimaCore.Geometry.ZPoint(10.0),\n    boundary_tags = (:bottom, :top),\n)","category":"page"},{"location":"tutorials/introduction/","page":"Introduction to ClimaCore.jl","title":"Introduction to ClimaCore.jl","text":"rectangle_domain = ClimaCore.Domains.RectangleDomain(\n    ClimaCore.Geometry.XPoint(-2π) .. ClimaCore.Geometry.XPoint(2π),\n    ClimaCore.Geometry.YPoint(-2π) .. ClimaCore.Geometry.YPoint(2π),\n    x1periodic = true,\n    x2periodic = true,\n)","category":"page"},{"location":"tutorials/introduction/#.2-Meshes","page":"Introduction to ClimaCore.jl","title":"1.2 Meshes","text":"","category":"section"},{"location":"tutorials/introduction/","page":"Introduction to ClimaCore.jl","title":"Introduction to ClimaCore.jl","text":"A mesh is a division of a domain into elements","category":"page"},{"location":"tutorials/introduction/","page":"Introduction to ClimaCore.jl","title":"Introduction to ClimaCore.jl","text":"column_mesh = ClimaCore.Meshes.IntervalMesh(column_domain, nelems = 32)","category":"page"},{"location":"tutorials/introduction/","page":"Introduction to ClimaCore.jl","title":"Introduction to ClimaCore.jl","text":"rectangle_mesh = ClimaCore.Meshes.RectilinearMesh(rectangle_domain, 16, 16)","category":"page"},{"location":"tutorials/introduction/#.3-Topologies","page":"Introduction to ClimaCore.jl","title":"1.3 Topologies","text":"","category":"section"},{"location":"tutorials/introduction/","page":"Introduction to ClimaCore.jl","title":"Introduction to ClimaCore.jl","text":"A topology determines the ordering and connections between elements of a mesh","category":"page"},{"location":"tutorials/introduction/","page":"Introduction to ClimaCore.jl","title":"Introduction to ClimaCore.jl","text":"At the moment, this is only required for 2D meshes","category":"page"},{"location":"tutorials/introduction/","page":"Introduction to ClimaCore.jl","title":"Introduction to ClimaCore.jl","text":"rectangle_topology = ClimaCore.Topologies.Topology2D(\n    ClimaComms.SingletonCommsContext(),\n    rectangle_mesh,\n)","category":"page"},{"location":"tutorials/introduction/#.4-Spaces","page":"Introduction to ClimaCore.jl","title":"1.4 Spaces","text":"","category":"section"},{"location":"tutorials/introduction/","page":"Introduction to ClimaCore.jl","title":"Introduction to ClimaCore.jl","text":"A space represents a discretized function space over some domain. Currently two discretizations are supported.","category":"page"},{"location":"tutorials/introduction/#.4.1-Staggered-finite-difference-discretization","page":"Introduction to ClimaCore.jl","title":"1.4.1 Staggered finite difference discretization","text":"","category":"section"},{"location":"tutorials/introduction/","page":"Introduction to ClimaCore.jl","title":"Introduction to ClimaCore.jl","text":"This discretizes an interval domain by approximating the function by a value at either the center of each element (CenterFiniteDifferenceSpace), or the faces between elements (FaceFiniteDifferenceSpace).","category":"page"},{"location":"tutorials/introduction/","page":"Introduction to ClimaCore.jl","title":"Introduction to ClimaCore.jl","text":"You can construct either the center or face space from the mesh, then construct the opposite space from the original one (this is to avoid allocating additional memory).","category":"page"},{"location":"tutorials/introduction/","page":"Introduction to ClimaCore.jl","title":"Introduction to ClimaCore.jl","text":"column_center_space = ClimaCore.Spaces.CenterFiniteDifferenceSpace(column_mesh)\n# construct the face space from the center one\ncolumn_face_space =\n    ClimaCore.Spaces.FaceFiniteDifferenceSpace(column_center_space)","category":"page"},{"location":"tutorials/introduction/#.4.2-Spectral-element-discretization","page":"Introduction to ClimaCore.jl","title":"1.4.2 Spectral element discretization","text":"","category":"section"},{"location":"tutorials/introduction/","page":"Introduction to ClimaCore.jl","title":"Introduction to ClimaCore.jl","text":"A spectral element space approximates the function with polynomials in each element. The polynomials are represented using a nodal discretization, which stores the values of the polynomials at particular points in each element (termed nodes or degrees of freedom).","category":"page"},{"location":"tutorials/introduction/","page":"Introduction to ClimaCore.jl","title":"Introduction to ClimaCore.jl","text":"These nodes are chosen by a particular quadrature rule, which allows us to integrate functions over the domain. The only supported choice for now is a Gauss-Legendre-Lobatto rule.","category":"page"},{"location":"tutorials/introduction/","page":"Introduction to ClimaCore.jl","title":"Introduction to ClimaCore.jl","text":"# Gauss-Legendre-Lobatto quadrature with 4 nodes in each direction, so 16 in each element\nquad = ClimaCore.Spaces.Quadratures.GLL{4}()\nrectangle_space =\n    ClimaCore.Spaces.SpectralElementSpace2D(rectangle_topology, quad)","category":"page"},{"location":"tutorials/introduction/#.5-Fields","page":"Introduction to ClimaCore.jl","title":"1.5 Fields","text":"","category":"section"},{"location":"tutorials/introduction/","page":"Introduction to ClimaCore.jl","title":"Introduction to ClimaCore.jl","text":"Finally, we can construct a field: a function in a space. A field is simply a space and the values at each node in the space.","category":"page"},{"location":"tutorials/introduction/","page":"Introduction to ClimaCore.jl","title":"Introduction to ClimaCore.jl","text":"The easiest field to construct is the coordinate field","category":"page"},{"location":"tutorials/introduction/","page":"Introduction to ClimaCore.jl","title":"Introduction to ClimaCore.jl","text":"coord = ClimaCore.Fields.coordinate_field(rectangle_space)","category":"page"},{"location":"tutorials/introduction/","page":"Introduction to ClimaCore.jl","title":"Introduction to ClimaCore.jl","text":"This is a struct-value field: it contains coordinates in a struct at each point. We can extract just the x coordinate, to get a scalar field:","category":"page"},{"location":"tutorials/introduction/","page":"Introduction to ClimaCore.jl","title":"Introduction to ClimaCore.jl","text":"x = coord.x","category":"page"},{"location":"tutorials/introduction/","page":"Introduction to ClimaCore.jl","title":"Introduction to ClimaCore.jl","text":"Although you can't index directly into a field, it can be used in some other ways similar to a Julia Array. For example, broadcasting can be used to define new fields in terms of other ones:","category":"page"},{"location":"tutorials/introduction/","page":"Introduction to ClimaCore.jl","title":"Introduction to ClimaCore.jl","text":"sinx = sin.(x)","category":"page"},{"location":"tutorials/introduction/","page":"Introduction to ClimaCore.jl","title":"Introduction to ClimaCore.jl","text":"Fields can be easily vizualized with Plots.jl:","category":"page"},{"location":"tutorials/introduction/","page":"Introduction to ClimaCore.jl","title":"Introduction to ClimaCore.jl","text":"import Plots\nPlots.plot(sinx)","category":"page"},{"location":"tutorials/introduction/","page":"Introduction to ClimaCore.jl","title":"Introduction to ClimaCore.jl","text":"If you're using the terminal, UnicodePlots is also supported.","category":"page"},{"location":"tutorials/introduction/","page":"Introduction to ClimaCore.jl","title":"Introduction to ClimaCore.jl","text":"This works similarly for finite difference discretizations","category":"page"},{"location":"tutorials/introduction/","page":"Introduction to ClimaCore.jl","title":"Introduction to ClimaCore.jl","text":"column_center_coords = ClimaCore.Fields.coordinate_field(column_center_space)\ncolumn_face_coords = ClimaCore.Fields.coordinate_field(column_face_space)","category":"page"},{"location":"tutorials/introduction/","page":"Introduction to ClimaCore.jl","title":"Introduction to ClimaCore.jl","text":"plot(sin.(column_center_coords.z), ylim = (0.0, 10.0))\nplot!(cos.(column_face_coords.z), ylim = (0.0, 10.0))","category":"page"},{"location":"tutorials/introduction/","page":"Introduction to ClimaCore.jl","title":"Introduction to ClimaCore.jl","text":"Reduction operations are defined anologously:","category":"page"},{"location":"tutorials/introduction/","page":"Introduction to ClimaCore.jl","title":"Introduction to ClimaCore.jl","text":"sum will give the integral of the function","category":"page"},{"location":"tutorials/introduction/","page":"Introduction to ClimaCore.jl","title":"Introduction to ClimaCore.jl","text":"int_D f(x) dx","category":"page"},{"location":"tutorials/introduction/","page":"Introduction to ClimaCore.jl","title":"Introduction to ClimaCore.jl","text":"norm will give the L² function norm","category":"page"},{"location":"tutorials/introduction/","page":"Introduction to ClimaCore.jl","title":"Introduction to ClimaCore.jl","text":"sqrtint_D f(x)^2 dx","category":"page"},{"location":"tutorials/introduction/","page":"Introduction to ClimaCore.jl","title":"Introduction to ClimaCore.jl","text":"sum(sinx) ## integral","category":"page"},{"location":"tutorials/introduction/","page":"Introduction to ClimaCore.jl","title":"Introduction to ClimaCore.jl","text":"norm(sinx) ## L² norm","category":"page"},{"location":"tutorials/introduction/#.6-Vectors-and-vector-fields","page":"Introduction to ClimaCore.jl","title":"1.6 Vectors and vector fields","text":"","category":"section"},{"location":"tutorials/introduction/","page":"Introduction to ClimaCore.jl","title":"Introduction to ClimaCore.jl","text":"A vector field is a field with vector-valued quantity, i.e. at every point in space, you have a vector.","category":"page"},{"location":"tutorials/introduction/","page":"Introduction to ClimaCore.jl","title":"Introduction to ClimaCore.jl","text":"However one of the key requirements of ClimaCore is to support vectors specified in curvilinear or non-Cartesian coordinates. We will discuss this in a bit further, but for now, you can define a 2-dimensional vector field using Geometry.UVVector:","category":"page"},{"location":"tutorials/introduction/","page":"Introduction to ClimaCore.jl","title":"Introduction to ClimaCore.jl","text":"v = ClimaCore.Geometry.UVVector.(coord.y, .-coord.x)","category":"page"},{"location":"tutorials/introduction/#.-Operators","page":"Introduction to ClimaCore.jl","title":"2. Operators","text":"","category":"section"},{"location":"tutorials/introduction/","page":"Introduction to ClimaCore.jl","title":"Introduction to ClimaCore.jl","text":"Operators can compute spatial derivative operations.","category":"page"},{"location":"tutorials/introduction/","page":"Introduction to ClimaCore.jl","title":"Introduction to ClimaCore.jl","text":"for performance reasons, we need to be able to \"fuse\" multiple operators and function applications\nJulia provides a tool for this: broadcasting, with a very flexible API","category":"page"},{"location":"tutorials/introduction/","page":"Introduction to ClimaCore.jl","title":"Introduction to ClimaCore.jl","text":"Can think of operators are \"pseudo-functions\": can't be called directly, but act similar to functions in the context of broadcasting.","category":"page"},{"location":"tutorials/introduction/#.1-Spectral-element-operators","page":"Introduction to ClimaCore.jl","title":"2.1 Spectral element operators","text":"","category":"section"},{"location":"tutorials/introduction/","page":"Introduction to ClimaCore.jl","title":"Introduction to ClimaCore.jl","text":"The Gradient operator takes the gradient of a scalar field, and returns a vector field.","category":"page"},{"location":"tutorials/introduction/","page":"Introduction to ClimaCore.jl","title":"Introduction to ClimaCore.jl","text":"grad = ClimaCore.Operators.Gradient()\n∇sinx = grad.(sinx)","category":"page"},{"location":"tutorials/introduction/","page":"Introduction to ClimaCore.jl","title":"Introduction to ClimaCore.jl","text":"plot(∇sinx.components.data.:1, clim = (-1, 1))","category":"page"},{"location":"tutorials/introduction/","page":"Introduction to ClimaCore.jl","title":"Introduction to ClimaCore.jl","text":"This returns the gradient in covariant coordinates","category":"page"},{"location":"tutorials/introduction/","page":"Introduction to ClimaCore.jl","title":"Introduction to ClimaCore.jl","text":"(nabla f)_i = fracpartial fpartial xi^i","category":"page"},{"location":"tutorials/introduction/","page":"Introduction to ClimaCore.jl","title":"Introduction to ClimaCore.jl","text":"where (xi^1xi^2) are the coordinates in the reference element: a square -11^2.","category":"page"},{"location":"tutorials/introduction/","page":"Introduction to ClimaCore.jl","title":"Introduction to ClimaCore.jl","text":"This can be converted to a local orthogonal basis by multiplying by the partial derivative matrix","category":"page"},{"location":"tutorials/introduction/","page":"Introduction to ClimaCore.jl","title":"Introduction to ClimaCore.jl","text":"fracpartial xipartial x","category":"page"},{"location":"tutorials/introduction/","page":"Introduction to ClimaCore.jl","title":"Introduction to ClimaCore.jl","text":"This can be done calling ClimaCore.Geometry.LocalVector:","category":"page"},{"location":"tutorials/introduction/","page":"Introduction to ClimaCore.jl","title":"Introduction to ClimaCore.jl","text":"∇sinx_cart = ClimaCore.Geometry.LocalVector.(∇sinx)","category":"page"},{"location":"tutorials/introduction/","page":"Introduction to ClimaCore.jl","title":"Introduction to ClimaCore.jl","text":"plot(∇sinx_cart.components.data.:1, clim = (-1, 1))","category":"page"},{"location":"tutorials/introduction/","page":"Introduction to ClimaCore.jl","title":"Introduction to ClimaCore.jl","text":"plot(∇sinx_cart.components.data.:2, clim = (-1, 1))","category":"page"},{"location":"tutorials/introduction/","page":"Introduction to ClimaCore.jl","title":"Introduction to ClimaCore.jl","text":"∇sinx_ref = ClimaCore.Geometry.UVVector.(cos.(x), 0.0)\nnorm(∇sinx_cart .- ∇sinx_ref)","category":"page"},{"location":"tutorials/introduction/","page":"Introduction to ClimaCore.jl","title":"Introduction to ClimaCore.jl","text":"Similarly, the Divergence operator takes the divergence of vector field, and returns a scalar field.","category":"page"},{"location":"tutorials/introduction/","page":"Introduction to ClimaCore.jl","title":"Introduction to ClimaCore.jl","text":"If we take the divergence of a gradient, we can get a Laplacian:","category":"page"},{"location":"tutorials/introduction/","page":"Introduction to ClimaCore.jl","title":"Introduction to ClimaCore.jl","text":"div = ClimaCore.Operators.Divergence()\n∇²sinx = div.(grad.(sinx))\nplot(∇²sinx)","category":"page"},{"location":"tutorials/introduction/","page":"Introduction to ClimaCore.jl","title":"Introduction to ClimaCore.jl","text":"Note: In curvilinear coordinates, the divergence is defined in terms of the contravariant components u^i:","category":"page"},{"location":"tutorials/introduction/","page":"Introduction to ClimaCore.jl","title":"Introduction to ClimaCore.jl","text":"nabla cdot u = frac1J sum_i fracpartialpartial xi^i (J u^i)","category":"page"},{"location":"tutorials/introduction/","page":"Introduction to ClimaCore.jl","title":"Introduction to ClimaCore.jl","text":"The Divergence operator handles this conversion internally.","category":"page"},{"location":"tutorials/introduction/#.1.1-Direct-stiffness-summation","page":"Introduction to ClimaCore.jl","title":"2.1.1 Direct stiffness summation","text":"","category":"section"},{"location":"tutorials/introduction/","page":"Introduction to ClimaCore.jl","title":"Introduction to ClimaCore.jl","text":"Spectral element operators only operate within a single element, and so the result may be discontinuous. To address this, the usual fix is direct stiffness summation (DSS), which averages the values at the element boundaries.","category":"page"},{"location":"tutorials/introduction/","page":"Introduction to ClimaCore.jl","title":"Introduction to ClimaCore.jl","text":"This corresponds to the L^2 projection onto the subset of continuous functions in our function space.","category":"page"},{"location":"tutorials/introduction/","page":"Introduction to ClimaCore.jl","title":"Introduction to ClimaCore.jl","text":"∇²sinx_dss = ClimaCore.Spaces.weighted_dss!(copy(∇²sinx))\nplot(∇²sinx_dss)","category":"page"},{"location":"tutorials/introduction/","page":"Introduction to ClimaCore.jl","title":"Introduction to ClimaCore.jl","text":"plot(∇²sinx_dss .- ∇²sinx)","category":"page"},{"location":"tutorials/introduction/#.2-Finite-difference-operators","page":"Introduction to ClimaCore.jl","title":"2.2 Finite difference operators","text":"","category":"section"},{"location":"tutorials/introduction/","page":"Introduction to ClimaCore.jl","title":"Introduction to ClimaCore.jl","text":"Finite difference operators are similar with some subtle differences:","category":"page"},{"location":"tutorials/introduction/","page":"Introduction to ClimaCore.jl","title":"Introduction to ClimaCore.jl","text":"they can change staggering (center to face, or vice versa)\nthey can span multiple elements\nno DSS is required\nboundary handling may be required","category":"page"},{"location":"tutorials/introduction/","page":"Introduction to ClimaCore.jl","title":"Introduction to ClimaCore.jl","text":"We use the following convention:","category":"page"},{"location":"tutorials/introduction/","page":"Introduction to ClimaCore.jl","title":"Introduction to ClimaCore.jl","text":"centers are indexed by integers 1, 2, ..., n\nfaces are indexed by half integers ½, 1+½, ..., n+½","category":"page"},{"location":"tutorials/introduction/","page":"Introduction to ClimaCore.jl","title":"Introduction to ClimaCore.jl","text":"Face to center gradient","category":"page"},{"location":"tutorials/introduction/","page":"Introduction to ClimaCore.jl","title":"Introduction to ClimaCore.jl","text":"An finite-difference operator defines a stencil. For example, the gradient operator","category":"page"},{"location":"tutorials/introduction/","page":"Introduction to ClimaCore.jl","title":"Introduction to ClimaCore.jl","text":"nablathetai = fractheta i+tfrac12 - thetai-tfrac12Delta z","category":"page"},{"location":"tutorials/introduction/","page":"Introduction to ClimaCore.jl","title":"Introduction to ClimaCore.jl","text":"(actually, a little more complicated as it gives a vector in a covariant basis)","category":"page"},{"location":"tutorials/introduction/","page":"Introduction to ClimaCore.jl","title":"Introduction to ClimaCore.jl","text":"        ...\n      /\nθ[2+½]\n      \\\n        ∇θ[2]\n      /\nθ[1+½]\n      \\\n        ∇θ[1]\n      /\nθ[½]","category":"page"},{"location":"tutorials/introduction/","page":"Introduction to ClimaCore.jl","title":"Introduction to ClimaCore.jl","text":"Every center value is well-defined, so boundary handling is optional.","category":"page"},{"location":"tutorials/introduction/","page":"Introduction to ClimaCore.jl","title":"Introduction to ClimaCore.jl","text":"cosz = cos.(column_face_coords.z)\ngradf2c = ClimaCore.Operators.GradientF2C()\n∇cosz = gradf2c.(cosz)","category":"page"},{"location":"tutorials/introduction/","page":"Introduction to ClimaCore.jl","title":"Introduction to ClimaCore.jl","text":"plot(map(x -> x.w, ClimaCore.Geometry.WVector.(∇cosz)), ylim = (0, 10))","category":"page"},{"location":"tutorials/introduction/","page":"Introduction to ClimaCore.jl","title":"Introduction to ClimaCore.jl","text":"Center to face gradient","category":"page"},{"location":"tutorials/introduction/","page":"Introduction to ClimaCore.jl","title":"Introduction to ClimaCore.jl","text":"Uses the same stencil, but doesn't work directly:","category":"page"},{"location":"tutorials/introduction/","page":"Introduction to ClimaCore.jl","title":"Introduction to ClimaCore.jl","text":"sinz = sin.(column_center_coords.z)\ngradc2f = ClimaCore.Operators.GradientC2F()\n# ∇sinz = gradc2f.(sinz) ## this would throw an error","category":"page"},{"location":"tutorials/introduction/","page":"Introduction to ClimaCore.jl","title":"Introduction to ClimaCore.jl","text":"This throws an error because face values at the boundary are not well-defined:","category":"page"},{"location":"tutorials/introduction/","page":"Introduction to ClimaCore.jl","title":"Introduction to ClimaCore.jl","text":"...\n      \\\n        ∇θ[2+½]\n      /\nθ[2]\n      \\\n        ∇θ[1+½]\n      /\nθ[1]\n      \\\n        ????","category":"page"},{"location":"tutorials/introduction/","page":"Introduction to ClimaCore.jl","title":"Introduction to ClimaCore.jl","text":"To handle boundaries we need to modify the stencil. Two options:","category":"page"},{"location":"tutorials/introduction/","page":"Introduction to ClimaCore.jl","title":"Introduction to ClimaCore.jl","text":"provide the value theta^* of theta at the boundary:","category":"page"},{"location":"tutorials/introduction/","page":"Introduction to ClimaCore.jl","title":"Introduction to ClimaCore.jl","text":"nablathetatfrac12 = fractheta1 - theta^*Delta z 2","category":"page"},{"location":"tutorials/introduction/","page":"Introduction to ClimaCore.jl","title":"Introduction to ClimaCore.jl","text":"provide the gradient nablatheta^* of theta at the boundary:","category":"page"},{"location":"tutorials/introduction/","page":"Introduction to ClimaCore.jl","title":"Introduction to ClimaCore.jl","text":"nablathetatfrac12 = nablatheta^*","category":"page"},{"location":"tutorials/introduction/","page":"Introduction to ClimaCore.jl","title":"Introduction to ClimaCore.jl","text":"These modified stencils are provided as keyword arguments to the operator (based on the boundary label names):","category":"page"},{"location":"tutorials/introduction/","page":"Introduction to ClimaCore.jl","title":"Introduction to ClimaCore.jl","text":"sinz = sin.(column_center_coords.z)\ngradc2f = ClimaCore.Operators.GradientC2F(\n    bottom = ClimaCore.Operators.SetValue(sin(0.0)),\n    top = ClimaCore.Operators.SetGradient(\n        ClimaCore.Geometry.WVector(cos(10.0)),\n    ),\n)\n∇sinz = gradc2f.(sinz)","category":"page"},{"location":"tutorials/introduction/","page":"Introduction to ClimaCore.jl","title":"Introduction to ClimaCore.jl","text":"plot(map(x -> x.w, ClimaCore.Geometry.WVector.(∇sinz)), ylim = (0, 10))","category":"page"},{"location":"tutorials/introduction/","page":"Introduction to ClimaCore.jl","title":"Introduction to ClimaCore.jl","text":"As before, multiple operators (or functions) can be fused together with broadcasting.","category":"page"},{"location":"tutorials/introduction/","page":"Introduction to ClimaCore.jl","title":"Introduction to ClimaCore.jl","text":"One extra advantage of this is that boundaries of the inner operators only need to be specified if they would affect the final result.","category":"page"},{"location":"tutorials/introduction/","page":"Introduction to ClimaCore.jl","title":"Introduction to ClimaCore.jl","text":"Consider the center-to-center Laplacian:","category":"page"},{"location":"tutorials/introduction/","page":"Introduction to ClimaCore.jl","title":"Introduction to ClimaCore.jl","text":"...\n      \\       /\n        ∇θ[2+½]\n      /       \\\nθ[2]            ∇⋅∇θ[2]\n      \\       /\n        ∇θ[1+½]\n      /       \\\nθ[1]            ∇⋅∇θ[1]\n              /\n         ∇θ*","category":"page"},{"location":"tutorials/introduction/","page":"Introduction to ClimaCore.jl","title":"Introduction to ClimaCore.jl","text":"sinz = sin.(column_center_coords.z)\n# we don't need to specify boundaries, as the stencil won't reach that far\ngradc2f = ClimaCore.Operators.GradientC2F()\ndivf2c = ClimaCore.Operators.DivergenceF2C(\n    bottom = ClimaCore.Operators.SetValue(ClimaCore.Geometry.WVector(cos(0.0))),\n    top = ClimaCore.Operators.SetValue(ClimaCore.Geometry.WVector(cos(10.0))),\n)\n∇∇sinz = divf2c.(gradc2f.(sinz))","category":"page"},{"location":"tutorials/introduction/","page":"Introduction to ClimaCore.jl","title":"Introduction to ClimaCore.jl","text":"plot(∇∇sinz, ylim = (0, 10))","category":"page"},{"location":"tutorials/introduction/#.-Solving-PDEs","page":"Introduction to ClimaCore.jl","title":"3. Solving PDEs","text":"","category":"section"},{"location":"tutorials/introduction/","page":"Introduction to ClimaCore.jl","title":"Introduction to ClimaCore.jl","text":"ClimaCore can be used for spatial discretizations of PDEs. For temporal discretization, we can use the OrdinaryDiffEq package, which we aim to be compatibile with.","category":"page"},{"location":"tutorials/introduction/","page":"Introduction to ClimaCore.jl","title":"Introduction to ClimaCore.jl","text":"using OrdinaryDiffEq","category":"page"},{"location":"tutorials/introduction/#.1-Heat-equation-using-finite-differences","page":"Introduction to ClimaCore.jl","title":"3.1 Heat equation using finite differences","text":"","category":"section"},{"location":"tutorials/introduction/","page":"Introduction to ClimaCore.jl","title":"Introduction to ClimaCore.jl","text":"We will use a cell-center discretization of the heat equation:","category":"page"},{"location":"tutorials/introduction/","page":"Introduction to ClimaCore.jl","title":"Introduction to ClimaCore.jl","text":"fracpartial ypartial t = alpha nabla cdot nabla y","category":"page"},{"location":"tutorials/introduction/","page":"Introduction to ClimaCore.jl","title":"Introduction to ClimaCore.jl","text":"At the bottom we will use a Dirichlet condition y(0) = 1 at the bottom: since we don't actually have a value located at the bottom, we will use a SetValue boundary modifier on the inner gradient.","category":"page"},{"location":"tutorials/introduction/","page":"Introduction to ClimaCore.jl","title":"Introduction to ClimaCore.jl","text":"At the top we will use a Neumann condition fracpartial ypartial z(10) = 0. We can do this two equivalent ways:","category":"page"},{"location":"tutorials/introduction/","page":"Introduction to ClimaCore.jl","title":"Introduction to ClimaCore.jl","text":"a SetGradient on the gradient operator\na SetValue on the divergence operator","category":"page"},{"location":"tutorials/introduction/","page":"Introduction to ClimaCore.jl","title":"Introduction to ClimaCore.jl","text":"either will work.","category":"page"},{"location":"tutorials/introduction/","page":"Introduction to ClimaCore.jl","title":"Introduction to ClimaCore.jl","text":"y0 = zeros(column_center_space)\n\n# define the tendency function\nfunction heat_fd_tendency!(dydt, y, α, t)\n    gradc2f = ClimaCore.Operators.GradientC2F(\n        bottom = ClimaCore.Operators.SetValue(1.0),\n        top = ClimaCore.Operators.SetGradient(ClimaCore.Geometry.WVector(0.0)),\n    )\n    divf2c = ClimaCore.Operators.DivergenceF2C()\n    # the @. macro \"dots\" the whole expression\n    # i.e.  dydt .= α .* divf2c.(gradc2f.(y))\n    @. dydt = α * divf2c(gradc2f(y))\nend\n\nheat_fd_prob = ODEProblem(heat_fd_tendency!, y0, (0.0, 5.0), 0.1)\nheat_fd_sol = solve(heat_fd_prob, SSPRK33(), dt = 0.1, saveat = 0.25)","category":"page"},{"location":"tutorials/introduction/","page":"Introduction to ClimaCore.jl","title":"Introduction to ClimaCore.jl","text":"anim = Plots.@animate for u in heat_fd_sol.u\n    plot(u, xlim = (0, 1), ylim = (0, 10))\nend\nmp4(anim)","category":"page"},{"location":"tutorials/introduction/#.2-Heat-equation-using-continuous-Galerkin-(CG)-spectral-element","page":"Introduction to ClimaCore.jl","title":"3.2 Heat equation using continuous Galerkin (CG) spectral element","text":"","category":"section"},{"location":"tutorials/introduction/","page":"Introduction to ClimaCore.jl","title":"Introduction to ClimaCore.jl","text":"function heat_cg_tendency!(dydt, y, α, t)\n    grad = ClimaCore.Operators.Gradient()\n    wdiv = ClimaCore.Operators.WeakDivergence()\n    # apply element operators\n    @. dydt = α * wdiv(grad(y))\n\n    # direct stiffness summation (DSS): project to continuous function space\n    ClimaCore.Spaces.weighted_dss!(dydt)\n    return dydt\nend\n\ny0 = exp.(.-(coord.y .^ 2 .+ coord.x .^ 2) ./ 2)\n\nheat_cg_prob = ODEProblem(heat_cg_tendency!, y0, (0.0, 5.0), 0.1)\nheat_cg_sol = solve(heat_cg_prob, SSPRK33(), dt = 0.1, saveat = 0.5)","category":"page"},{"location":"tutorials/introduction/","page":"Introduction to ClimaCore.jl","title":"Introduction to ClimaCore.jl","text":"anim = Plots.@animate for u in heat_cg_sol.u\n    Plots.plot(u, c = :thermal)\nend\nmp4(anim)","category":"page"},{"location":"tutorials/introduction/#.3-Shallow-water-equations","page":"Introduction to ClimaCore.jl","title":"3.3 Shallow water equations","text":"","category":"section"},{"location":"tutorials/introduction/","page":"Introduction to ClimaCore.jl","title":"Introduction to ClimaCore.jl","text":"The shallow water equations in vector invariant form can be written as","category":"page"},{"location":"tutorials/introduction/","page":"Introduction to ClimaCore.jl","title":"Introduction to ClimaCore.jl","text":"beginalign*\n    fracpartial rhopartial t + nabla cdot (rho u) = 0\n    fracpartial u_ipartial t + nabla (Phi + tfrac12u^2)_i  = J (u times (nabla times u))_i\nendalign*","category":"page"},{"location":"tutorials/introduction/","page":"Introduction to ClimaCore.jl","title":"Introduction to ClimaCore.jl","text":"where J is the Jacobian determinant, and Phi = g rho.","category":"page"},{"location":"tutorials/introduction/","page":"Introduction to ClimaCore.jl","title":"Introduction to ClimaCore.jl","text":"Note that the velocity u is specified in covariant coordinates u_i.","category":"page"},{"location":"tutorials/introduction/","page":"Introduction to ClimaCore.jl","title":"Introduction to ClimaCore.jl","text":"For vizualization purposes, we can model a passive tracer theta as","category":"page"},{"location":"tutorials/introduction/","page":"Introduction to ClimaCore.jl","title":"Introduction to ClimaCore.jl","text":"fracpartial rho thetapartial t + nabla cdot (rho theta u) = 0","category":"page"},{"location":"tutorials/introduction/","page":"Introduction to ClimaCore.jl","title":"Introduction to ClimaCore.jl","text":"using ClimaCore.Geometry\n\nparameters = (\n    ϵ = 0.1,  ## perturbation size for initial condition\n    l = 0.5, ## Gaussian width\n    k = 0.5, ## Sinusoidal wavenumber\n    ρ₀ = 1.0, ## reference density\n    c = 2,\n    g = 10,\n    D₄ = 1e-4, ## hyperdiffusion coefficient\n)\n\nfunction init_state(local_geometry, p)\n    coord = local_geometry.coordinates\n    @unpack x, y = coord\n    # set initial state\n    ρ = p.ρ₀\n\n    # set initial velocity\n    U₁ = cosh(y)^(-2)\n\n    # Ψ′ = exp(-(x2 + p.l / 10)^2 / 2p.l^2) * cos(p.k * x) * cos(p.k * y)\n    # Vortical velocity fields (u₁′, u₂′) = (-∂²Ψ′, ∂¹Ψ′)\n    ϕ = exp(-(y + p.l / 10)^2 / 2p.l^2)\n    u₁′ = ϕ * (y + p.l / 10) / p.l^2 * cos(p.k * x) * cos(p.k * y)\n    u₁′ += p.k * ϕ * cos(p.k * x) * sin(p.k * y)\n    u₂′ = -p.k * ϕ * sin(p.k * x) * cos(p.k * y)\n\n    u = Geometry.Covariant12Vector(\n        Geometry.UVVector(U₁ + p.ϵ * u₁′, p.ϵ * u₂′),\n        local_geometry,\n    )\n\n    # set initial tracer\n    θ = sin(p.k * y)\n    return (ρ = ρ, u = u, ρθ = ρ * θ)\nend\n\n\ny0 =\n    init_state.(\n        ClimaCore.Fields.local_geometry_field(rectangle_space),\n        Ref(parameters),\n    )\n\n# plot initial tracer\nPlots.plot(y0.ρθ)","category":"page"},{"location":"tutorials/introduction/","page":"Introduction to ClimaCore.jl","title":"Introduction to ClimaCore.jl","text":"function shallow_water_tendency!(dydt, y, _, t)\n\n    @unpack D₄, g = parameters\n\n    sdiv = ClimaCore.Operators.Divergence()\n    wdiv = ClimaCore.Operators.WeakDivergence()\n    grad = ClimaCore.Operators.Gradient()\n    wgrad = ClimaCore.Operators.WeakGradient()\n    curl = ClimaCore.Operators.Curl()\n    wcurl = ClimaCore.Operators.WeakCurl()\n\n\n    # compute hyperviscosity first\n    @. dydt.u =\n        wgrad(sdiv(y.u)) -\n        Geometry.Covariant12Vector(wcurl(Geometry.Covariant3Vector(curl(y.u))))\n    @. dydt.ρθ = wdiv(grad(y.ρθ))\n\n    ClimaCore.Spaces.weighted_dss!(dydt)\n\n    @. dydt.u =\n        -D₄ * (\n            wgrad(sdiv(dydt.u)) - Geometry.Covariant12Vector(\n                wcurl(Geometry.Covariant3Vector(curl(dydt.u))),\n            )\n        )\n    @. dydt.ρθ = -D₄ * wdiv(grad(dydt.ρθ))\n\n    # comute rest of tendency\n    @. begin\n        dydt.ρ = -wdiv(y.ρ * y.u)\n        dydt.u += -grad(g * y.ρ + norm(y.u)^2 / 2) + y.u × curl(y.u)\n        dydt.ρθ += -wdiv(y.ρθ * y.u)\n    end\n    ClimaCore.Spaces.weighted_dss!(dydt)\n    return dydt\nend","category":"page"},{"location":"tutorials/introduction/","page":"Introduction to ClimaCore.jl","title":"Introduction to ClimaCore.jl","text":"shallow_water_prob = ODEProblem(shallow_water_tendency!, y0, (0.0, 20.0))\n@time shallow_water_sol =\n    solve(shallow_water_prob, SSPRK33(), dt = 0.05, saveat = 1.0)\nanim = Plots.@animate for u in shallow_water_sol.u\n    Plots.plot(u.ρθ, clim = (-1, 1))\nend\nmp4(anim)","category":"page"},{"location":"tutorials/introduction/","page":"Introduction to ClimaCore.jl","title":"Introduction to ClimaCore.jl","text":"","category":"page"},{"location":"tutorials/introduction/","page":"Introduction to ClimaCore.jl","title":"Introduction to ClimaCore.jl","text":"This page was generated using Literate.jl.","category":"page"},{"location":"lib/ClimaCoreTempestRemap/#ClimaCoreTempestRemap.jl","page":"ClimaCoreTempestRemap.jl","title":"ClimaCoreTempestRemap.jl","text":"","category":"section"},{"location":"lib/ClimaCoreTempestRemap/","page":"ClimaCoreTempestRemap.jl","title":"ClimaCoreTempestRemap.jl","text":"CurrentModule = ClimaCoreTempestRemap","category":"page"},{"location":"lib/ClimaCoreTempestRemap/","page":"ClimaCoreTempestRemap.jl","title":"ClimaCoreTempestRemap.jl","text":"ClimaCoreTempestRemap.jl provides an interfaces for using ClimaCore data with the TempestRemap remapping package, by Paul Ullrich.","category":"page"},{"location":"lib/ClimaCoreTempestRemap/#Interface","page":"ClimaCoreTempestRemap.jl","title":"Interface","text":"","category":"section"},{"location":"lib/ClimaCoreTempestRemap/#Online-remap","page":"ClimaCoreTempestRemap.jl","title":"Online remap","text":"","category":"section"},{"location":"lib/ClimaCoreTempestRemap/","page":"ClimaCoreTempestRemap.jl","title":"ClimaCoreTempestRemap.jl","text":"LinearMap\ngenerate_map\nremap!\nremap","category":"page"},{"location":"lib/ClimaCoreTempestRemap/#ClimaCoreTempestRemap.LinearMap","page":"ClimaCoreTempestRemap.jl","title":"ClimaCoreTempestRemap.LinearMap","text":"LinearMap{T, S, M, C, V}\n\nstores information on the TempestRemap map and the source and target data:\n\nwhere:\n\nsource_space and target_space are ClimaCore's 2D spaces.\nweights is a vector of remapping weights. (length = number of overlap-mesh nodes)\nsource_idxs a 3-element Tuple with 3 index vectors, representing (i,j,elem) indices on the source mesh. (length of each index vector = number of overlap-mesh nodes)\ntarget_idxs is the same as source_idxs but for the target mesh.\ncol_indices are the source column indices from TempestRemap. (length = number of overlap-mesh nodes)\nrow_indices are the target row indices from TempestRemap. (length = number of overlap-mesh nodes)\nout_type string that defines the output type\n\n\n\n\n\n","category":"type"},{"location":"lib/ClimaCoreTempestRemap/#ClimaCoreTempestRemap.generate_map","page":"ClimaCoreTempestRemap.jl","title":"ClimaCoreTempestRemap.generate_map","text":"generate_map(target_space, source_space; in_type=\"cgll\", out_type=\"cgll\")\n\nGenerate the remapping weights from TempestRemap, returning a LinearMap object. This should only be called once.\n\n\n\n\n\n","category":"function"},{"location":"lib/ClimaCoreTempestRemap/#ClimaCoreTempestRemap.remap!","page":"ClimaCoreTempestRemap.jl","title":"ClimaCoreTempestRemap.remap!","text":"remap!(target::Field, R::LinearMap, source::Field)\n\nApplies the remapping R to a source Field, storing the result in target.\n\n\n\n\n\n","category":"function"},{"location":"lib/ClimaCoreTempestRemap/#ClimaCoreTempestRemap.remap","page":"ClimaCoreTempestRemap.jl","title":"ClimaCoreTempestRemap.remap","text":"remap(R::LinearMap, source::Field)\n\nApplies the remapping R to a source Field, allocating a new field in the output.\n\n\n\n\n\n","category":"function"},{"location":"lib/ClimaCoreTempestRemap/#Mesh-export","page":"ClimaCoreTempestRemap.jl","title":"Mesh export","text":"","category":"section"},{"location":"lib/ClimaCoreTempestRemap/","page":"ClimaCoreTempestRemap.jl","title":"ClimaCoreTempestRemap.jl","text":"write_exodus","category":"page"},{"location":"lib/ClimaCoreTempestRemap/#ClimaCoreTempestRemap.write_exodus","page":"ClimaCoreTempestRemap.jl","title":"ClimaCoreTempestRemap.write_exodus","text":"write_exodus(filename, topology::Topology2D; normalize_coordinates=true)\n\nWrite the topology to an Exodus-formatted NetCDF file.\n\nIt tries to adhere to the Exodus II specification, but it is primarily intended for use with TempestRemap.\n\nNote: the generated meshes will use a different ordering of nodes and elements than those generated by TempestRemap itself.\n\nWhen using this function with a distributed topology input for MPI, it should only be called on a single process.\n\nOptions:\n\nnormalize_coordinates: if true, the coordinates are normalized to be on the unit sphere (this is required for use with TempestRemap)\n\nReferences\n\nEXODUS II: A finite element data model: https://www.osti.gov/biblio/10102115-exodus-ii-finite-element-data-model\n\n\n\n\n\n","category":"function"},{"location":"lib/ClimaCoreTempestRemap/#NetCDF-data-export","page":"ClimaCoreTempestRemap.jl","title":"NetCDF data export","text":"","category":"section"},{"location":"lib/ClimaCoreTempestRemap/","page":"ClimaCoreTempestRemap.jl","title":"ClimaCoreTempestRemap.jl","text":"def_time_coord\ndef_space_coord\nNCDatasets.defVar(::NCDatasets.NCDataset, ::Any, field::Fields.Field)\nBase.setindex!(::NCDatasets.CFVariable, ::Fields.Field, ::Colon)","category":"page"},{"location":"lib/ClimaCoreTempestRemap/#ClimaCoreTempestRemap.def_time_coord","page":"ClimaCoreTempestRemap.jl","title":"ClimaCoreTempestRemap.def_time_coord","text":"def_time_coord(nc::NCDataset, length=Inf, eltype=Float64;\n    units = \"seconds since 2020-01-01 00:00:00\"\n    kwargs...\n)\n\nDeine a time coordinate (dimension + variable) \"time\" in the NetCDF dataset nc. By default its length is set to be unlimited. The variable corresponding to the coordinate is returned.\n\nAdditional attributes can be added as keyword arguments.\n\nExample\n\ntimevar = add_time_coord!(nc; units = \"seconds since 2020-01-01 00:00:00\",)\ntimevar[:] = collect(0.0:0.5:60)\n\n\n\n\n\n","category":"function"},{"location":"lib/ClimaCoreTempestRemap/#ClimaCoreTempestRemap.def_space_coord","page":"ClimaCoreTempestRemap.jl","title":"ClimaCoreTempestRemap.def_space_coord","text":"def_space_coord(nc::NCDataset, space::Spaces.AbstractSpace; type = \"dgll\")\n\nAdd spatial dimensions for space in the NetCDF dataset nc, compatible with the type used by remap_weights.\n\nIf a compatible dimension already exists, it will be reused.\n\n\n\n\n\n","category":"function"},{"location":"lib/ClimaCoreTempestRemap/#NCDatasets.defVar-Tuple{NCDatasets.NCDataset, Any, ClimaCore.Fields.Field}","page":"ClimaCoreTempestRemap.jl","title":"NCDatasets.defVar","text":"NCDatasets.defVar(nc::NCDataset, name, field::Field, extradims=())\n\nDefine a new variable in nc named name of suitable for storing field, along with any further dimensions specified in extradims. The new variable is returned.\n\nnote: Note\nThis does not write any data to the variable.\n\n\n\n\n\n","category":"method"},{"location":"lib/ClimaCoreTempestRemap/#Base.setindex!-Tuple{NCDatasets.CFVariable, ClimaCore.Fields.Field, Colon}","page":"ClimaCoreTempestRemap.jl","title":"Base.setindex!","text":"var[:, extraidx...] = field\n\nWrite the data in field to a NetCDF variable var. extraidx are any extra indices of var.\n\nAppropriate spatial dimensions should already be defined by defVar.\n\n# Given a collection of fields U, write them as a single array to a NetCDF file.\ndef_space_coord(nc, space)\nnc_time = def_time_coord(nc)\nnc_u = defVar(nc, \"u\", Float64, space, (\"time\",))\nfor (i,t) in enumerate(times)\n    nc_time[i] = t\n    nc_u[:,i] = U[i]\nend\n\n\n\n\n\n","category":"method"},{"location":"lib/ClimaCoreTempestRemap/#Wrapper-functions","page":"ClimaCoreTempestRemap.jl","title":"Wrapper functions","text":"","category":"section"},{"location":"lib/ClimaCoreTempestRemap/","page":"ClimaCoreTempestRemap.jl","title":"ClimaCoreTempestRemap.jl","text":"rll_mesh\noverlap_mesh\nremap_weights\napply_remap","category":"page"},{"location":"lib/ClimaCoreTempestRemap/#ClimaCoreTempestRemap.rll_mesh","page":"ClimaCoreTempestRemap.jl","title":"ClimaCoreTempestRemap.rll_mesh","text":"rll_mesh(filename::AbstractString; nlat=90, nlon = round(Int, nlat * 1.6); verbose=false)\n\nCreate a regular latitude-longitude (RLL) mesh and write it to filename in Exodus format. nlat is the number of latitudinal cells, and nlon is the number of longitudinal cells.\n\nSet verbose=true to print information.\n\nSee Tempest remap: mesh generation\n\n\n\n\n\n","category":"function"},{"location":"lib/ClimaCoreTempestRemap/#ClimaCoreTempestRemap.overlap_mesh","page":"ClimaCoreTempestRemap.jl","title":"ClimaCoreTempestRemap.overlap_mesh","text":"overlap_mesh(outfile::AbstractString, meshfile_a::AbstractString, meshfile_b::AbstractString; verbose=false)\n\nCreate the overlap mesh of meshfile_a and meshfile_b and write it to outfile. All files should be in Exodus format.\n\nSet verbose=true to print information.\n\nSee Tempest remap: mesh generation\n\n\n\n\n\n","category":"function"},{"location":"lib/ClimaCoreTempestRemap/#ClimaCoreTempestRemap.remap_weights","page":"ClimaCoreTempestRemap.jl","title":"ClimaCoreTempestRemap.remap_weights","text":"remap_weights(\n    weightfile::AbstractString,\n    meshfile_in::AbstractString,\n    meshfile_out::AbstractString,\n    meshfile_overlap::AbstractString;\n    verbose=false,\n    kwargs...\n)\n\nCreate a file weightfile in SCRIP format containing the remapping weights from meshfile_in to meshfile_out, where overlap_meshfile is constructed via overlap_meshfile(meshfile_overlap, meshfile_in, meshfile_out).\n\nKeyword arguments are passed as command-line options. These include:\n\nin_type / out_type: the type of the input and output mesh:\n\"fv\" (default): finite volume (one value per element)\n\"cgll\": continuous GLL finite element method (a single value for colocated nodes)\n\"dgll\": discontinuous GLL finite element method (duplicate values for colocated nodes)\n'innp'/'outnp': Order of input and output meshes\n'mono': Monotonicity of remapping. Note: must be used with in_np = 1\n\nSet mono = true and in_np = 1 for monotone remapping Set verbose=true to print information.\n\nSee Tempest remap: offline map generation\n\n\n\n\n\n","category":"function"},{"location":"lib/ClimaCoreTempestRemap/#ClimaCoreTempestRemap.apply_remap","page":"ClimaCoreTempestRemap.jl","title":"ClimaCoreTempestRemap.apply_remap","text":"apply_remap(outfile::AbstractString, infile::AbstractString, weightfile::AbstractString, vars; verbose=false)\n\nRemap the NetCDF file infile to outfile, using the remapping weights weightfile constructed via remap_weights. vars should be a collection of variable names to remap.\n\nSet verbose=true to print information.\n\nSee Tempest remap: offline map application\n\n\n\n\n\n","category":"function"},{"location":"lib/ClimaCoreTempestRemap/#Example","page":"ClimaCoreTempestRemap.jl","title":"Example","text":"","category":"section"},{"location":"lib/ClimaCoreTempestRemap/","page":"ClimaCoreTempestRemap.jl","title":"ClimaCoreTempestRemap.jl","text":"The following example converts an OrdinaryDiffEq solution object sol to a netcdf file, and remaps it to an regular latitude-longitude (RLL) grid.","category":"page"},{"location":"lib/ClimaCoreTempestRemap/","page":"ClimaCoreTempestRemap.jl","title":"ClimaCoreTempestRemap.jl","text":"using ClimaCore: Geometry, Meshes, Domains, Topologies, Spaces\nusing NCDatasets, ClimaCoreTempestRemap\n\n# sol is the integrator solution\n# cspace is the center extrduded space\n# fspace is the face extruded space\n\n# the issue is that the Space types changed since this changed\n# we can reconstruct it by digging around a bit\nNq = Spaces.Quadratures.degrees_of_freedom(Spaces.quadrature_style(cspace))\n\ndatafile_cc = \"test.nc\"\nNCDataset(datafile_cc, \"c\") do nc\n    # defines the appropriate dimensions and variables for a space coordinate\n    def_space_coord(nc, cspace, type = \"cgll\")\n    def_space_coord(nc, fspace, type = \"cgll\")\n    # defines the appropriate dimensions and variables for a time coordinate (by default, unlimited size)\n    nc_time = def_time_coord(nc)\n\n    # define variables\n    nc_rho = defVar(nc, \"rho\", Float64, cspace, (\"time\",))\n    nc_theta = defVar(nc, \"theta\", Float64, cspace, (\"time\",))\n    nc_u = defVar(nc, \"u\", Float64, cspace, (\"time\",))\n    nc_v = defVar(nc, \"v\", Float64, cspace, (\"time\",))\n    nc_w = defVar(nc, \"w\", Float64, fspace, (\"time\",))\n\n    # write data to netcdf file\n    for i = 1:length(sol.u)\n        nc_time[i] = sol.t[i]\n\n        # extract fields and convert to orthogonal coordinates\n        Yc = sol.u[i].Yc\n        uₕ = Geometry.UVVector.(sol.u[i].uₕ)\n        w = Geometry.WVector.(sol.u[i].w)\n\n        # write fields to file\n        nc_rho[:,i] = Yc.ρ\n        nc_theta[:,i] = Yc.ρθ ./ Yc.ρ\n        nc_u[:,i] = map(u -> u.u, uₕ)\n        nc_v[:,i] = map(u -> u.v, uₕ)\n        nc_w[:,i] = map(u -> u.w, w)\n    end\nend\n\n# write out our cubed sphere mesh\nmeshfile_cc = \"mesh_cubedsphere.g\"\nwrite_exodus(meshfile_cc, cspace.horizontal_space.topology)\n\n# write out RLL mesh\nnlat = 90\nnlon = 180\nmeshfile_rll = \"mesh_rll.g\"\nrll_mesh(meshfile_rll; nlat = nlat, nlon = nlon)\n\n# construct overlap mesh\nmeshfile_overlap = \"mesh_overlap.g\"\noverlap_mesh(meshfile_overlap, meshfile_cc, meshfile_rll)\n\n# construct remap weight file\nweightfile = \"remap_weights.nc\"\nremap_weights(\n    weightfile,\n    meshfile_cc,\n    meshfile_rll,\n    meshfile_overlap;\n    in_type = \"cgll\",\n    in_np = Spaces.Quadratures.degrees_of_freedom(Spaces.quadrature_style(cspace)),\n)\n\n# apply remap\ndatafile_rll = \"data_rll.nc\"\napply_remap(datafile_rll, datafile_cc, weightfile, [\"rho\", \"theta\", \"u\", \"v\", \"w\"])","category":"page"},{"location":"operators/#Operators","page":"Operators","title":"Operators","text":"","category":"section"},{"location":"operators/","page":"Operators","title":"Operators","text":"CurrentModule = ClimaCore.Operators","category":"page"},{"location":"operators/","page":"Operators","title":"Operators","text":"Operators can compute spatial derivative operations.","category":"page"},{"location":"operators/","page":"Operators","title":"Operators","text":"for performance reasons, we need to be able to \"fuse\" multiple operators and","category":"page"},{"location":"operators/","page":"Operators","title":"Operators","text":"function applications","category":"page"},{"location":"operators/","page":"Operators","title":"Operators","text":"Julia provides a tool for this: broadcasting, with a very flexible API","category":"page"},{"location":"operators/","page":"Operators","title":"Operators","text":"Can think of operators are \"pseudo-functions\": can't be called directly, but act similar to functions in the context of broadcasting. They are matrix-free, in the sense that we define the action of the operator directly on a field, without explicitly assembling the matrix representing the discretized operator.","category":"page"},{"location":"operators/#Spectral-element-operators","page":"Operators","title":"Spectral element operators","text":"","category":"section"},{"location":"operators/#Differential-Operators","page":"Operators","title":"Differential Operators","text":"","category":"section"},{"location":"operators/","page":"Operators","title":"Operators","text":"Gradient\nDivergence\nWeakDivergence\nWeakGradient\nCurl\nWeakCurl","category":"page"},{"location":"operators/#ClimaCore.Operators.Gradient","page":"Operators","title":"ClimaCore.Operators.Gradient","text":"grad = Gradient()\ngrad.(f)\n\nCompute the (strong) gradient of f on each element, returning a CovariantVector-field.\n\nThe ith covariant component of the gradient is the partial derivative with respect to the reference element:\n\n(nabla f)_i = fracpartial fpartial xi^i\n\nDiscretely, this can be written in matrix form as\n\nD_i f\n\nwhere D_i is the derivative matrix along the ith dimension.\n\nReferences\n\nMark A Taylor, Aimé Fournier (2010), equation 16\n\n\n\n\n\n","category":"type"},{"location":"operators/#ClimaCore.Operators.Divergence","page":"Operators","title":"ClimaCore.Operators.Divergence","text":"div = Divergence()\ndiv.(u)\n\nComputes the per-element spectral (strong) divergence of a vector field u.\n\nThe divergence of a vector field u is defined as\n\nnabla cdot u = sum_i frac1J fracpartial (J u^i)partial xi^i\n\nwhere J is the Jacobian determinant, u^i is the ith contravariant component of u.\n\nThis is discretized by\n\nsum_i I leftfrac1J fracpartial (IJ u^i)partial xi^i right\n\nwhere Ix is the interpolation operator that projects to the unique polynomial interpolating x at the quadrature points. In matrix form, this can be written as\n\nJ^-1 sum_i D_i J u^i\n\nwhere D_i is the derivative matrix along the ith dimension\n\nReferences\n\nMark A Taylor, Aimé Fournier (2010), equation 15\n\n\n\n\n\n","category":"type"},{"location":"operators/#ClimaCore.Operators.WeakDivergence","page":"Operators","title":"ClimaCore.Operators.WeakDivergence","text":"wdiv = WeakDivergence()\nwdiv.(u)\n\nComputes the \"weak divergence\" of a vector field u.\n\nThis is defined as the scalar field theta in mathcalV_0 such that for all phiin mathcalV_0\n\nint_Omega phi theta  d Omega\n=\n- int_Omega (nabla phi) cdot u d Omega\n\nwhere mathcalV_0 is the space of u.\n\nThis arises as the contribution of the volume integral after by applying integration by parts to the weak form expression of the divergence\n\nint_Omega phi (nabla cdot u)  d Omega\n=\n- int_Omega (nabla phi) cdot u d Omega\n+ oint_partial Omega phi (u cdot n) d sigma\n\nIt can be written in matrix form as\n\nϕ^top WJ θ = - sum_i (D_i ϕ)^top WJ u^i\n\nwhich reduces to\n\nθ = -(WJ)^-1 sum_i D_i^top WJ u^i\n\nwhere\n\nJ is the diagonal Jacobian matrix\nW is the diagonal matrix of quadrature weights\nD_i is the derivative matrix along the ith dimension\n\n\n\n\n\n","category":"type"},{"location":"operators/#ClimaCore.Operators.WeakGradient","page":"Operators","title":"ClimaCore.Operators.WeakGradient","text":"wgrad = WeakGradient()\nwgrad.(f)\n\nCompute the \"weak gradient\" of f on each element.\n\nThis is defined as the the vector field theta in mathcalV_0 such that for all phi in mathcalV_0\n\nint_Omega phi cdot theta  d Omega\n=\n- int_Omega (nabla cdot phi) f  dOmega\n\nwhere mathcalV_0 is the space of f.\n\nThis arises from the contribution of the volume integral after by applying integration by parts to the weak form expression of the gradient\n\nint_Omega phi cdot (nabla f)  d Omega\n=\n- int_Omega f (nabla cdot phi)  dOmega\n+ oint_partial Omega f (phi cdot n)  d sigma\n\nIn matrix form, this becomes\n\nphi^i^top W J theta_i = - ( J^-1 D_i J phi^i )^top W J f\n\nwhich reduces to\n\ntheta_i = -W^-1 D_i^top W f\n\nwhere D_i is the derivative matrix along the ith dimension.\n\n\n\n\n\n","category":"type"},{"location":"operators/#ClimaCore.Operators.Curl","page":"Operators","title":"ClimaCore.Operators.Curl","text":"curl = Curl()\ncurl.(u)\n\nComputes the per-element spectral (strong) curl of a covariant vector field u.\n\nNote: The vector field u needs to be excliclty converted to a CovaraintVector, as then the Curl is independent of the local metric tensor.\n\nThe curl of a vector field u is a vector field with contravariant components\n\n(nabla times u)^i = frac1J sum_jk epsilon^ijk fracpartial u_kpartial xi^j\n\nwhere J is the Jacobian determinant, u_k is the kth covariant component of u, and epsilon^ijk are the Levi-Civita symbols. In other words\n\nbeginbmatrix\n  (nabla times u)^1 \n  (nabla times u)^2 \n  (nabla times u)^3\nendbmatrix\n=\nfrac1J beginbmatrix\n  fracpartial u_3partial xi^2 - fracpartial u_2partial xi^3 \n  fracpartial u_1partial xi^3 - fracpartial u_3partial xi^1 \n  fracpartial u_2partial xi^1 - fracpartial u_1partial xi^2\nendbmatrix\n\nIn matrix form, this becomes\n\nepsilon^ijk J^-1 D_j u_k\n\nNote that unused dimensions will be dropped: e.g. the 2D curl of a Covariant12Vector-field will return a Contravariant3Vector.\n\nReferences\n\nMark A Taylor, Aimé Fournier (2010), equation 17\n\n\n\n\n\n","category":"type"},{"location":"operators/#ClimaCore.Operators.WeakCurl","page":"Operators","title":"ClimaCore.Operators.WeakCurl","text":"wcurl = WeakCurl()\nwcurl.(u)\n\nComputes the \"weak curl\" on each element of a covariant vector field u.\n\nNote: The vector field u needs to be excliclty converted to a CovaraintVector, as then the WeakCurl is independent of the local metric tensor.\n\nThis is defined as the vector field theta in mathcalV_0 such that for all phi in mathcalV_0\n\nint_Omega phi cdot theta  d Omega\n=\nint_Omega (nabla times phi) cdot u d Omega\n\nwhere mathcalV_0 is the space of f.\n\nThis arises from the contribution of the volume integral after by applying integration by parts to the weak form expression of the curl\n\nint_Omega phi cdot (nabla times u) dOmega\n=\nint_Omega (nabla times phi) cdot u d Omega\n- oint_partial Omega (phi times u) cdot n dsigma\n\nIn matrix form, this becomes\n\nphi_i^top W J theta^i = (J^-1 epsilon^kji D_j phi_i)^top W J u_k\n\nwhich, by using the anti-symmetry of the Levi-Civita symbol, reduces to\n\ntheta^i = - epsilon^ijk (WJ)^-1 D_j^top W u_k\n\n\n\n\n\n","category":"type"},{"location":"operators/#Interpolation-Operators","page":"Operators","title":"Interpolation Operators","text":"","category":"section"},{"location":"operators/","page":"Operators","title":"Operators","text":"Interpolate\nRestrict","category":"page"},{"location":"operators/#ClimaCore.Operators.Interpolate","page":"Operators","title":"ClimaCore.Operators.Interpolate","text":"i = Interpolate(space)\ni.(f)\n\nInterpolates f to the space. If space has equal or higher polynomial degree as the space of f, this is exact, otherwise it will be lossy.\n\nIn matrix form, it is the linear operator\n\nI = bigotimes_i I_i\n\nwhere I_i is the barycentric interpolation matrix in the ith dimension.\n\nSee also Restrict.\n\n\n\n\n\n","category":"type"},{"location":"operators/#ClimaCore.Operators.Restrict","page":"Operators","title":"ClimaCore.Operators.Restrict","text":"r = Restrict(space)\nr.(f)\n\nComputes the projection of a field f on mathcalV_0 to a lower degree polynomial space space (mathcalV_0^*). space must be on the same topology as the space of f, but have a lower polynomial degree.\n\nIt is defined as the field theta in mathcalV_0^* such that for all phi in mathcalV_0^*\n\nint_Omega phi theta dOmega = int_Omega phi f dOmega\n\nIn matrix form, this is\n\nphi^top W^* J^* theta = (I phi)^top WJ f\n\nwhere W^* and J^* are the quadrature weights and Jacobian determinant of mathcalV_0^*, and I is the interpolation operator (see Interpolate) from mathcalV_0^* to mathcalV_0. This reduces to\n\ntheta = (W^* J^*)^-1 I^top WJ f\n\n\n\n\n\n","category":"type"},{"location":"operators/#DSS","page":"Operators","title":"DSS","text":"","category":"section"},{"location":"operators/","page":"Operators","title":"Operators","text":"Spaces.weighted_dss!\nSpaces.create_ghost_buffer\nSpaces.weighted_dss_start!\nSpaces.weighted_dss_internal!\nSpaces.weighted_dss_ghost!","category":"page"},{"location":"operators/#ClimaCore.Spaces.create_ghost_buffer","page":"Operators","title":"ClimaCore.Spaces.create_ghost_buffer","text":"Spaces.create_ghost_buffer(field::Field)\n\nCreate a buffer for communicating neighbour information of field.\n\n\n\n\n\n","category":"function"},{"location":"operators/#Finite-difference-operators","page":"Operators","title":"Finite difference operators","text":"","category":"section"},{"location":"operators/","page":"Operators","title":"Operators","text":"Finite difference operators are similar with some subtle differences:","category":"page"},{"location":"operators/","page":"Operators","title":"Operators","text":"they can change staggering (center to face, or vice versa)\nthey can span multiple elements\nno DSS is required\nboundary handling may be required","category":"page"},{"location":"operators/","page":"Operators","title":"Operators","text":"We use the following convention:","category":"page"},{"location":"operators/","page":"Operators","title":"Operators","text":"centers are indexed by integers 1, 2, ..., n\nfaces are indexed by half integers half, 1+half, ..., n+half","category":"page"},{"location":"operators/","page":"Operators","title":"Operators","text":"FiniteDifferenceOperator","category":"page"},{"location":"operators/#ClimaCore.Operators.FiniteDifferenceOperator","page":"Operators","title":"ClimaCore.Operators.FiniteDifferenceOperator","text":"FiniteDifferenceOperator\n\nAn abstract type for finite difference operators. Instances of this should define:\n\nreturn_eltype\nreturn_space\nstencil_interior_width\nstencil_interior\n\nSee also BoundaryCondition for how to define the boundaries.\n\n\n\n\n\n","category":"type"},{"location":"operators/#Interpolation-operators","page":"Operators","title":"Interpolation operators","text":"","category":"section"},{"location":"operators/","page":"Operators","title":"Operators","text":"InterpolateC2F\nInterpolateF2C\nWeightedInterpolateC2F\nWeightedInterpolateF2C\nUpwindBiasedProductC2F\nUpwind3rdOrderBiasedProductC2F\nFCTBorisBook\nFCTZalesak\nLeftBiasedC2F\nRightBiasedC2F\nLeftBiasedF2C\nRightBiasedF2C","category":"page"},{"location":"operators/#ClimaCore.Operators.InterpolateC2F","page":"Operators","title":"ClimaCore.Operators.InterpolateC2F","text":"I = InterpolateC2F(;boundaries..)\nI.(x)\n\nInterpolate a center-valued field x to faces, using the stencil\n\nI(x)i = frac12 (xi+tfrac12 + xi-tfrac12)\n\nSupported boundary conditions are:\n\nSetValue(x₀): set the value at the boundary face to be x₀. On the left boundary the stencil is\n\nI(x)tfrac12 = x₀\n\nSetGradient(v): set the value at the boundary such that the gradient is v. At the left boundary the stencil is\n\nI(x)tfrac12 = x1 - frac12 v³\n\nExtrapolate: use the closest interior point as the boundary value. At the left boundary the stencil is\n\nI(x)tfrac12 = x1\n\n\n\n\n\n","category":"type"},{"location":"operators/#ClimaCore.Operators.InterpolateF2C","page":"Operators","title":"ClimaCore.Operators.InterpolateF2C","text":"InterpolateF2C()\n\nInterpolate from face to center mesh. No boundary conditions are required (or supported).\n\n\n\n\n\n","category":"type"},{"location":"operators/#ClimaCore.Operators.WeightedInterpolateC2F","page":"Operators","title":"ClimaCore.Operators.WeightedInterpolateC2F","text":"WI = WeightedInterpolateC2F(; boundaries)\nWI.(w, x)\n\nInterpolate a center-valued field x to faces, weighted by a center-valued field w, using the stencil\n\nWI(w x)i = frac\n    wi+tfrac12 xi+tfrac12 +  wi-tfrac12 xi-tfrac12)\n\n    wi+tfrac12 + wi-tfrac12\n\n\nSupported boundary conditions are:\n\nSetValue(val): set the value at the boundary face to be val.\nSetGradient: set the value at the boundary such that the gradient is val.\nExtrapolate: use the closest interior point as the boundary value.\n\nThese have the same stencil as in InterpolateC2F.\n\n\n\n\n\n","category":"type"},{"location":"operators/#ClimaCore.Operators.WeightedInterpolateF2C","page":"Operators","title":"ClimaCore.Operators.WeightedInterpolateF2C","text":"WI = WeightedInterpolateF2C(; boundaries)\nWI.(w, x)\n\nInterpolate a face-valued field x to centers, weighted by a face-valued field w, using the stencil\n\nWI(w x)i = frac\n        wi+tfrac12 xi+tfrac12 +  wi-tfrac12 xi-tfrac12)\n    \n        wi+tfrac12 + wi-tfrac12\n    \n\nNo boundary conditions are required (or supported)\n\n\n\n\n\n","category":"type"},{"location":"operators/#ClimaCore.Operators.UpwindBiasedProductC2F","page":"Operators","title":"ClimaCore.Operators.UpwindBiasedProductC2F","text":"U = UpwindBiasedProductC2F(;boundaries)\nU.(v, x)\n\nCompute the product of the face-valued vector field v and a center-valued field x at cell faces by upwinding x according to the direction of v.\n\nMore precisely, it is computed based on the sign of the 3rd contravariant component, and it returns a Contravariant3Vector:\n\nU(boldsymbolvx)i = begincases\n  v^3i xi-tfrac12boldsymbole_3 textrm if  v^3i  0 \n  v^3i xi+tfrac12boldsymbole_3 textrm if  v^3i  0\n  endcases\n\nwhere boldsymbole_3 is the 3rd covariant basis vector.\n\nSupported boundary conditions are:\n\nSetValue(x₀): set the value of x to be x₀ in a hypothetical ghost cell on the other side of the boundary. On the left boundary the stencil is\nU(boldsymbolvx)tfrac12 = begincases\n  v^3tfrac12 x_0  boldsymbole_3 textrm if   v^3tfrac12  0 \n  v^3tfrac12 x1 boldsymbole_3 textrm if   v^3tfrac12  0\n  endcases\nExtrapolate(): set the value of x to be the same as the closest interior point. On the left boundary, the stencil is\nU(boldsymbolvx)tfrac12 = U(boldsymbolvx)1 + tfrac12\n\n\n\n\n\n","category":"type"},{"location":"operators/#ClimaCore.Operators.Upwind3rdOrderBiasedProductC2F","page":"Operators","title":"ClimaCore.Operators.Upwind3rdOrderBiasedProductC2F","text":"U = Upwind3rdOrderBiasedProductC2F(;boundaries)\nU.(v, x)\n\nCompute the product of a face-valued vector field v and a center-valued field x at cell faces by upwinding x, to third-order of accuracy, according to v\n\nU(vx)i = begincases\n  vi left(-2 xi-tfrac32 + 10 xi-tfrac12 + 4 xi+tfrac12 right)  12  textrm if  vi  0 \n  vi left(4 xi-tfrac12 + 10 xi+tfrac12 -2 xi+tfrac32  right)  12  textrm if  vi  0\n  endcases\n\nThis stencil is based on Louis J. Wicker, William C. Skamarock (2002), eq. 4(a).\n\nSupported boundary conditions are:\n\nFirstOrderOneSided(x₀): uses the first-order downwind scheme to compute x on the left boundary, and the first-order upwind scheme to compute x on the right boundary.\nThirdOrderOneSided(x₀): uses the third-order downwind reconstruction to compute x on the left boundary,\n\nand the third-order upwind reconstruction to compute x on the right boundary.\n\nnote: Note\nThese boundary conditions do not define the value at the actual boundary faces, and so this operator cannot be materialized directly: it needs to be composed with another operator that does not make use of this value, e.g. a DivergenceF2C operator, with a SetValue boundary.\n\n\n\n\n\n","category":"type"},{"location":"operators/#ClimaCore.Operators.FCTBorisBook","page":"Operators","title":"ClimaCore.Operators.FCTBorisBook","text":"U = FCTBorisBook(;boundaries)\nU.(v, x)\n\nCorrect the flux using the flux-corrected transport formulation by Boris and Book Jay P Boris, David L Book (1973).\n\nInput arguments:\n\na face-valued vector field v\na center-valued field x\n\nAc(vx)i =\n  si max left0 min left vi  si left( xi+tfrac32 - xi+tfrac12  right)   si left( xi-tfrac12 - xi-tfrac32  right) right right\n\nwhere si = +1 if  vi geq 0 and si = -1 if  vi leq 0, and Ac represents the resulting corrected antidiffusive flux. This formulation is based on Jay P Boris, David L Book (1973), as reported in Dale R Durran (2010) section 5.4.1.\n\nSupported boundary conditions are:\n\nFirstOrderOneSided(x₀): uses the first-order downwind reconstruction to compute x on the left boundary, and the first-order upwind reconstruction to compute x on the right boundary.\n\nnote: Note\nSimilar to the Upwind3rdOrderBiasedProductC2F operator, these boundary conditions do not define the value at the actual boundary faces, and so this operator cannot be materialized directly: it needs to be composed with another operator that does not make use of this value, e.g. a DivergenceF2C operator, with a SetValue boundary.\n\n\n\n\n\n","category":"type"},{"location":"operators/#ClimaCore.Operators.FCTZalesak","page":"Operators","title":"ClimaCore.Operators.FCTZalesak","text":"U = FCTZalesak(;boundaries)\nU.(A, Φ, Φᵗᵈ)\n\nCorrect the flux using the flux-corrected transport formulation by Zalesak Steven T Zalesak (1979).\n\nInput arguments:\n\na face-valued vector field A\na center-valued field Φ\na center-valued field Φᵗᵈ\n\nΦ_j^n+1 = Φ_j^td - (C_j+frac12A_j+frac12 - C_j-frac12A_j-frac12)\n\nThis stencil is based on Steven T Zalesak (1979), as reported in Dale R Durran (2010) section 5.4.2, where C denotes the corrected antidiffusive flux.\n\nSupported boundary conditions are:\n\nFirstOrderOneSided(x₀): uses the first-order downwind reconstruction to compute x on the left boundary, and the first-order upwind reconstruction to compute x on the right boundary.\n\nnote: Note\nSimilar to the Upwind3rdOrderBiasedProductC2F operator, these boundary conditions do not define the value at the actual boundary faces, and so this operator cannot be materialized directly: it needs to be composed with another operator that does not make use of this value, e.g. a DivergenceF2C operator, with a SetValue boundary.\n\n\n\n\n\n","category":"type"},{"location":"operators/#ClimaCore.Operators.LeftBiasedC2F","page":"Operators","title":"ClimaCore.Operators.LeftBiasedC2F","text":"L = LeftBiasedC2F(;boundaries)\nL.(x)\n\nInterpolate a center-value field to a face-valued field from the left.\n\nL(x)i = xi-tfrac12\n\nOnly the left boundary condition should be set. Currently supported is:\n\nSetValue(x₀): set the value to be x₀ on the boundary.\n\nL(x)tfrac12 = x_0\n\n\n\n\n\n","category":"type"},{"location":"operators/#ClimaCore.Operators.RightBiasedC2F","page":"Operators","title":"ClimaCore.Operators.RightBiasedC2F","text":"R = RightBiasedC2F(;boundaries)\nR.(x)\n\nInterpolate a center-valued field to a face-valued field from the right.\n\nR(x)i = xi+tfrac12\n\nOnly the right boundary condition should be set. Currently supported is:\n\nSetValue(x₀): set the value to be x₀ on the boundary.\n\nR(x)n+tfrac12 = x_0\n\n\n\n\n\n","category":"type"},{"location":"operators/#ClimaCore.Operators.LeftBiasedF2C","page":"Operators","title":"ClimaCore.Operators.LeftBiasedF2C","text":"L = LeftBiasedF2C(;boundaries)\nL.(x)\n\nInterpolate a face-value field to a center-valued field from the left.\n\nL(x)i+tfrac12 = xi\n\nOnly the left boundary condition should be set. Currently supported is:\n\nSetValue(x₀): set the value to be x₀ on the boundary.\n\nL(x)1 = x_0\n\n\n\n\n\n","category":"type"},{"location":"operators/#ClimaCore.Operators.RightBiasedF2C","page":"Operators","title":"ClimaCore.Operators.RightBiasedF2C","text":"R = RightBiasedF2C(;boundaries)\nR.(x)\n\nInterpolate a face-valued field to a center-valued field from the right.\n\nR(x)i = xi+tfrac12\n\nOnly the right boundary condition should be set. Currently supported is:\n\nSetValue(x₀): set the value to be x₀ on the boundary.\n\nR(x)n+tfrac12 = x_0\n\n\n\n\n\n","category":"type"},{"location":"operators/#Derivative-operators","page":"Operators","title":"Derivative operators","text":"","category":"section"},{"location":"operators/","page":"Operators","title":"Operators","text":"GradientF2C\nGradientC2F\nAdvectionF2F\nAdvectionC2C\nDivergenceF2C\nDivergenceC2F\nCurlC2F","category":"page"},{"location":"operators/#ClimaCore.Operators.GradientF2C","page":"Operators","title":"ClimaCore.Operators.GradientF2C","text":"G = GradientF2C(;boundaryname=boundarycondition...)\nG.(x)\n\nCompute the gradient of a face-valued field x, returning a center-valued Covariant3 vector field, using the stencil:\n\nG(x)i^3 = xi+tfrac12 - xi-tfrac12\n\nWe note that the usual division factor 1  Delta z that appears in a first-order finite difference operator is accounted for in the LocalVector basis. Hence, users need to cast the output of the GradientF2C to a UVector, VVector or WVector, according to the type of domain on which the operator is defined.\n\nThe following boundary conditions are supported:\n\nby default, the value of x at the boundary face will be used.\nSetValue(x₀): calculate the gradient assuming the value at the boundary is x₀. For the left boundary, this becomes:\n\nG(x)1³ = x1+tfrac12 - x₀\n\nExtrapolate(): set the value at the center closest to the boundary\n\nto be the same as the neighbouring interior value. For the left boundary, this becomes:\n\nG(x)1³ = G(x)2³\n\n\n\n\n\n","category":"type"},{"location":"operators/#ClimaCore.Operators.GradientC2F","page":"Operators","title":"ClimaCore.Operators.GradientC2F","text":"G = GradientC2F(;boundaryname=boundarycondition...)\nG.(x)\n\nCompute the gradient of a center-valued field x, returning a face-valued Covariant3 vector field, using the stencil:\n\nG(x)i^3 = xi+tfrac12 - xi-tfrac12\n\nThe following boundary conditions are supported:\n\nSetValue(x₀): calculate the gradient assuming the value at the boundary is x₀. For the left boundary, this becomes:\nG(x)tfrac12³ = 2 (x1 - x₀)\nSetGradient(v₀): set the value of the gradient at the boundary to be v₀. For the left boundary, this becomes:\nG(x)tfrac12 = v₀\n\n\n\n\n\n","category":"type"},{"location":"operators/#ClimaCore.Operators.AdvectionF2F","page":"Operators","title":"ClimaCore.Operators.AdvectionF2F","text":"A = AdvectionF2F(;boundaries)\nA.(v, θ)\n\nVertical advection operator at cell faces, for a face-valued velocity field v and face-valued variables θ, approximating v^3 partial_3 theta.\n\nIt uses the following stencil\n\nA(vθ)i = frac12 (θi+1 - θi-1) v³i\n\nNo boundary conditions are currently supported.\n\n\n\n\n\n","category":"type"},{"location":"operators/#ClimaCore.Operators.AdvectionC2C","page":"Operators","title":"ClimaCore.Operators.AdvectionC2C","text":"A = AdvectionC2C(;boundaries)\nA.(v, θ)\n\nVertical advection operator at cell centers, for cell face velocity field v cell center variables θ, approximating v^3 partial_3 theta.\n\nIt uses the following stencil\n\nA(vθ)i = frac12  (θi+1 - θi) v³i+tfrac12 + (θi - θi-1)v³i-tfrac12\n\nSupported boundary conditions:\n\nSetValue(θ₀): set the value of θ at the boundary face to be θ₀. At the lower boundary, this is:\n\nA(vθ)1 = frac12  (θ2 - θ1) v³1 + tfrac12 + (θ1 - θ₀)v³tfrac12\n\nExtrapolate: use the closest interior point as the boundary value. At the lower boundary, this is:\n\nA(vθ)1 = (θ2 - θ1) v³1 + tfrac12 \n\n\n\n\n\n","category":"type"},{"location":"operators/#ClimaCore.Operators.DivergenceF2C","page":"Operators","title":"ClimaCore.Operators.DivergenceF2C","text":"D = DivergenceF2C(;boundaryname=boundarycondition...)\nD.(v)\n\nCompute the vertical contribution to the divergence of a face-valued field vector v, returning a center-valued scalar field, using the stencil\n\nD(v)i = (Jv³i+tfrac12 - Jv³i-tfrac12)  Ji\n\nwhere Jv³ is the Jacobian multiplied by the third contravariant component of v.\n\nThe following boundary conditions are supported:\n\nby default, the value of v at the boundary face will be used.\nSetValue(v₀): calculate the divergence assuming the value at the boundary is v₀. For the left boundary, this becomes:\n\nD(v)1 = (Jv³1+tfrac12 - Jv³₀)  Ji\n\nExtrapolate(): set the value at the center closest to the boundary to be the same as the neighbouring interior value. For the left boundary, this becomes:\n\nD(v)1³ = D(v)2³\n\n\n\n\n\n","category":"type"},{"location":"operators/#ClimaCore.Operators.DivergenceC2F","page":"Operators","title":"ClimaCore.Operators.DivergenceC2F","text":"D = DivergenceC2F(;boundaryname=boundarycondition...)\nD.(v)\n\nCompute the vertical contribution to the divergence of a center-valued field vector v, returning a face-valued scalar field, using the stencil\n\nD(v)i = (Jv³i+tfrac12 - Jv³i-tfrac12)  Ji\n\nwhere Jv³ is the Jacobian multiplied by the third contravariant component of v.\n\nThe following boundary conditions are supported:\n\nSetValue(v₀): calculate the divergence assuming the value at the  boundary is v₀. For the left boundary, this becomes:\nD(v)tfrac12 = frac12 (Jv³1 - Jv³₀)  Ji\nSetDivergence(x): set the value of the divergence at the boundary to be x.\nD(v)tfrac12 = x\n\n\n\n\n\n","category":"type"},{"location":"operators/#ClimaCore.Operators.CurlC2F","page":"Operators","title":"ClimaCore.Operators.CurlC2F","text":"C = CurlC2F(;boundaryname=boundarycondition...)\nC.(v)\n\nCompute the vertical-derivative contribution to the curl of a center-valued covariant vector field v. It acts on the horizontal covariant components of v (that is it only depends on v₁ and v₂), and will return a face-valued horizontal contravariant vector field (that is C(v)³ = 0).\n\nSpecifically it approximates:\n\nbeginalign*\nC(v)^1 = -frac1J fracpartial v_2partial xi^3  \nC(v)^2 = frac1J fracpartial v_1partial xi^3 \nendalign*\n\nusing the stencils\n\nbeginalign*\nC(v)i^1 = - frac1Ji (v₂i+tfrac12 - v₂i-tfrac12) \nC(v)i^2 = frac1Ji  (v₁i+tfrac12 - v₁i-tfrac12)\nendalign*\n\nwhere v₁ and v₂ are the 1st and 2nd covariant components of v, and J is the Jacobian determinant.\n\nThe following boundary conditions are supported:\n\nSetValue(v₀): calculate the curl assuming the value of v at the  boundary is v₀. For the left boundary, this becomes:\nC(v)tfrac12^1 = -frac2Ji (v_21 - (v₀)_2)\nC(v)tfrac12^2 = frac2Ji (v_11 - (v₀)_1)\nSetCurl(v⁰): enforce the curl operator output at the boundary to be the contravariant vector v⁰.\n\n\n\n\n\n","category":"type"},{"location":"operators/#Other","page":"Operators","title":"Other","text":"","category":"section"},{"location":"operators/","page":"Operators","title":"Operators","text":"SetBoundaryOperator\nFirstOrderOneSided\nThirdOrderOneSided","category":"page"},{"location":"operators/#ClimaCore.Operators.SetBoundaryOperator","page":"Operators","title":"ClimaCore.Operators.SetBoundaryOperator","text":"SetBoundaryOperator(;boundaries...)\n\nThis operator only modifies the values at the boundary:\n\nSetValue(val): set the value to be val on the boundary.\n\n\n\n\n\n","category":"type"},{"location":"operators/#ClimaCore.Operators.FirstOrderOneSided","page":"Operators","title":"ClimaCore.Operators.FirstOrderOneSided","text":"FirstOrderOneSided()\n\nUse a first-order up/down-wind scheme to compute the value at the boundary.\n\n\n\n\n\n","category":"type"},{"location":"operators/#ClimaCore.Operators.ThirdOrderOneSided","page":"Operators","title":"ClimaCore.Operators.ThirdOrderOneSided","text":"ThirdOrderOneSided()\n\nUse a third-order up/down-wind scheme to compute the value at the boundary.\n\n\n\n\n\n","category":"type"},{"location":"operators/#Finite-difference-boundary-conditions","page":"Operators","title":"Finite difference boundary conditions","text":"","category":"section"},{"location":"operators/","page":"Operators","title":"Operators","text":"BoundaryCondition\nSetValue\nSetGradient\nSetDivergence\nExtrapolate","category":"page"},{"location":"operators/#ClimaCore.Operators.BoundaryCondition","page":"Operators","title":"ClimaCore.Operators.BoundaryCondition","text":"BoundaryCondition\n\nAn abstract type for boundary conditions for FiniteDifferenceOperators.\n\nSubtypes should define:\n\nboundary_width\nstencil_left_boundary\nstencil_right_boundary\n\n\n\n\n\n","category":"type"},{"location":"operators/#ClimaCore.Operators.SetValue","page":"Operators","title":"ClimaCore.Operators.SetValue","text":"SetValue(val)\n\nSet the value at the boundary to be val. In the case of gradient operators, this will set the input value from which the gradient is computed.\n\n\n\n\n\n","category":"type"},{"location":"operators/#ClimaCore.Operators.SetGradient","page":"Operators","title":"ClimaCore.Operators.SetGradient","text":"SetGradient(val)\n\nSet the gradient at the boundary to be val. In the case of gradient operators this will set the output value of the gradient.\n\n\n\n\n\n","category":"type"},{"location":"operators/#ClimaCore.Operators.SetDivergence","page":"Operators","title":"ClimaCore.Operators.SetDivergence","text":"SetDivergence(val)\n\nSet the divergence at the boundary to be val.\n\n\n\n\n\n","category":"type"},{"location":"operators/#ClimaCore.Operators.Extrapolate","page":"Operators","title":"ClimaCore.Operators.Extrapolate","text":"Extrapolate()\n\nSet the value at the boundary to be the same as the closest interior point.\n\n\n\n\n\n","category":"type"},{"location":"operators/#Internal-APIs","page":"Operators","title":"Internal APIs","text":"","category":"section"},{"location":"operators/","page":"Operators","title":"Operators","text":"return_eltype\nreturn_space\nstencil_interior_width\nstencil_interior\nboundary_width\nstencil_left_boundary\nstencil_right_boundary","category":"page"},{"location":"operators/#ClimaCore.Operators.return_eltype","page":"Operators","title":"ClimaCore.Operators.return_eltype","text":"return_eltype(::Op, fields...)\n\nDefines the element type of the result of operator Op\n\n\n\n\n\n","category":"function"},{"location":"operators/#ClimaCore.Operators.return_space","page":"Operators","title":"ClimaCore.Operators.return_space","text":"return_space(::Op, spaces...)\n\nDefines the space the operator Op returns values on.\n\n\n\n\n\n","category":"function"},{"location":"operators/#ClimaCore.Operators.stencil_interior_width","page":"Operators","title":"ClimaCore.Operators.stencil_interior_width","text":"stencil_interior_width(::Op, args...)\n\nDefines the width of the interior stencil for the operator Op with the given arguments. Returns a tuple of 2-tuples: each 2-tuple should be the lower and upper bounds of the index offsets of the stencil for each argument in the stencil.\n\nExample\n\nstencil(::Op, arg1, arg2) = ((-half, 1+half), (0,0))\n\nimplies that at index i, the stencil accesses arg1 at i-half, i+half and i+1+half, and arg2 at index i.\n\n\n\n\n\n","category":"function"},{"location":"operators/#ClimaCore.Operators.stencil_interior","page":"Operators","title":"ClimaCore.Operators.stencil_interior","text":"stencil_interior(::Op, loc, idx, args...)\n\nDefines the stencil of the operator Op in the interior of the domain at idx; args are the input arguments.\n\n\n\n\n\n","category":"function"},{"location":"operators/#ClimaCore.Operators.boundary_width","page":"Operators","title":"ClimaCore.Operators.boundary_width","text":"boundary_width(::Op, ::BC, args...)\n\nDefines the width of a boundary condition BC on an operator Op. This is the number of locations that are used in a modified stencil.\n\n\n\n\n\n","category":"function"},{"location":"operators/#ClimaCore.Operators.stencil_left_boundary","page":"Operators","title":"ClimaCore.Operators.stencil_left_boundary","text":"stencil_left_boundary(::Op, ::BC, loc, idx, args...)\n\nDefines the stencil of operator Op at idx near the left boundary, with boundary condition BC.\n\n\n\n\n\n","category":"function"},{"location":"operators/#ClimaCore.Operators.stencil_right_boundary","page":"Operators","title":"ClimaCore.Operators.stencil_right_boundary","text":"stencil_right_boundary(::Op, ::BC, loc, idx, args...)\n\nDefines the stencil of operator Op at idx near the right boundary, with boundary condition BC.\n\n\n\n\n\n","category":"function"},{"location":"examples/#Examples","page":"Examples","title":"Examples","text":"","category":"section"},{"location":"examples/#D-Column-examples","page":"Examples","title":"1D Column examples","text":"","category":"section"},{"location":"examples/#D-Cartesian-examples","page":"Examples","title":"2D Cartesian examples","text":"","category":"section"},{"location":"examples/#Flux-Limiters-advection","page":"Examples","title":"Flux Limiters advection","text":"","category":"section"},{"location":"examples/","page":"Examples","title":"Examples","text":"The 2D Cartesian advection/transport example in examples/plane/limiters_advection.jl demonstrates the application of flux limiters in the horizontal direction, namely QuasiMonotoneLimiter, in a 2D Cartesian domain.","category":"page"},{"location":"examples/#Equations-and-discretizations","page":"Examples","title":"Equations and discretizations","text":"","category":"section"},{"location":"examples/#Mass","page":"Examples","title":"Mass","text":"","category":"section"},{"location":"examples/","page":"Examples","title":"Examples","text":"Follows the continuity equation","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"beginequation\n  fracpartialpartial t rho = - nabla cdot(rho boldsymbolu) \nlabeleq2d-plane-advection-lim-continuity\nendequation","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"This is discretized using the following","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"beginequation\n  fracpartialpartial t rho approx - wD rho boldsymbolu \nlabeleq2d-plane-advection-lim-discrete-continuity\nendequation","category":"page"},{"location":"examples/#Tracers","page":"Examples","title":"Tracers","text":"","category":"section"},{"location":"examples/","page":"Examples","title":"Examples","text":"For the tracer concentration per unit mass q, the tracer density (scalar) rho q follows the advection/transport equation","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"beginequation\n  fracpartialpartial t rho q = - nabla cdot(rho q boldsymbolu)  + g(rho q)\nlabeleq2d-plane-advection-lim-tracers\nendequation","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"This is discretized using the following","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"beginequation\nfracpartialpartial t rho q approx - wD rho q boldsymbolu + g(rho q)\nlabeleq2d-plane-advection-lim-discrete-tracers\nendequation","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"where g(rho q) = - nu_4 nabla^4_h (rho q) represents the horizontal hyperdiffusion operator, with nu_4 (measured in m^4/s) the hyperviscosity constant coefficient (set equal to zero by default in the example).","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"Currently tracers are only treated explicitly in the time discretization.","category":"page"},{"location":"examples/#Prognostic-variables","page":"Examples","title":"Prognostic variables","text":"","category":"section"},{"location":"examples/","page":"Examples","title":"Examples","text":"rho: density measured in kg/m³.\nboldsymbolu velocity, a vector measured in m/s. Since this is a 2D problem, boldsymbolu equiv boldsymbolu_h.\nrho q: the tracer density scalar, where q is the tracer concentration per unit mass.","category":"page"},{"location":"examples/#Differentiation-operators","page":"Examples","title":"Differentiation operators","text":"","category":"section"},{"location":"examples/","page":"Examples","title":"Examples","text":"Because this is a purely 2D problem, there is no staggered vertical discretization, hence, there is no need of specifying variables at cell centers, faces or to reconstruct from faces to centers and vice versa.","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"wD is the discrete horizontal weak spectral divergence, called wdiv in the example code.\nG is the discrete horizontal strong spectral gradient, called grad in the example code.","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"To discretize the hyperdiffusion operator, g(rho q) = - nu_4 nabla^4 (rho q), in the horizontal direction, we compose the horizontal weak divergence, wD, and the horizontal gradient operator, G_h, twice, with an intermediate call to weighted_dss! between the two compositions, as in g_2(rho g) circ DSS(rho q) circ g_1(rho q), with:","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"g_1(rho q) = wD(G_h(q))\nDSS(rho q) = DSS(g_1(rho q))\ng_2(rho q) = -nu_4 wD(rho G_h(rho q))\nwith nu_4 the hyperviscosity coefficient.","category":"page"},{"location":"examples/#Problem-flow-and-set-up","page":"Examples","title":"Problem flow and set-up","text":"","category":"section"},{"location":"examples/","page":"Examples","title":"Examples","text":"This test case is set up in a Cartesian planar domain -2 pi 2 pi^2, doubly periodic.","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"The flow was chosen to be a horizontal uniform rotation. Moreover, the flow is reversed halfway through the time period so that the tracer blobs go back to its initial configuration (using the same speed scaling constant which was derived to account for the distance travelled in all directions in a half period).","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"beginalign\n    u = -u_0 (y - c_y) cos(pi t  T_f) nonumber \n    v = u_0 (x - c_x) cos(pi t  T_f)\nlabeleq2d-plane-advection-lim-flow\nendalign","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"where u_0 = pi  2 is the speed scaling factor to have the flow reversed halfway through the time period, boldsymbolc = (c_x c_y) is the center of the rotational flow, which coincides with the center of the domain, and T_f = 2 pi is the final simulation time, which coincides with the temporal period to have a full rotation.","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"This example is set up to run with three possible initial conditions:","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"cosine_bells\ngaussian_bells\ncylinders: two 2D slotted cylinders (test case available in the literature, cfr: Oksana Guba, Mark Taylor, Amik St-Cyr (2014)).","category":"page"},{"location":"examples/#Application-of-Flux-Limiters","page":"Examples","title":"Application of Flux Limiters","text":"","category":"section"},{"location":"examples/","page":"Examples","title":"Examples","text":"Because this is a fully 2D problem, the application of limiters does not affect the order of operations, which is implemented as follows:","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"Horizontal trasport with hyperdiffusion (with weak divergence wD)\nHorizontal flux limiters\nDSS","category":"page"},{"location":"examples/#D-Cartesian-examples-2","page":"Examples","title":"3D Cartesian examples","text":"","category":"section"},{"location":"examples/#Flux-Limiters-advection-2","page":"Examples","title":"Flux Limiters advection","text":"","category":"section"},{"location":"examples/","page":"Examples","title":"Examples","text":"The 3D Cartesian advection/transport example in examples/hybrid/box/limiters_advection.jl demonstrates the application of flux limiters in the horizontal direction, namely QuasiMonotoneLimiter, in a hybrid Cartesian domain. It also demonstrates the usage of the high-order upwinding scheme in the vertical direction, called Upwind3rdOrderBiasedProductC2F.","category":"page"},{"location":"examples/#Equations-and-discretizations-2","page":"Examples","title":"Equations and discretizations","text":"","category":"section"},{"location":"examples/#Mass-2","page":"Examples","title":"Mass","text":"","category":"section"},{"location":"examples/","page":"Examples","title":"Examples","text":"Follows the continuity equation","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"beginequation\n  fracpartialpartial t rho = - nabla cdot(rho boldsymbolu) \nlabeleq3d-box-advection-lim-continuity\nendequation","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"This is discretized using the following","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"beginequation\n  fracpartialpartial t rho approx - D_h rho (boldsymbolu_h + I^c(boldsymbolu_v)) - D^c_vI^f(rho boldsymbolu_h)) + I^f(rho) boldsymbolu_v) \nlabeleq3d-box-advection-lim-discrete-continuity\nendequation","category":"page"},{"location":"examples/#Tracers-2","page":"Examples","title":"Tracers","text":"","category":"section"},{"location":"examples/","page":"Examples","title":"Examples","text":"For the tracer concentration per unit mass q, the tracer density (scalar) rho q follows the advection/transport equation","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"beginequation\n  fracpartialpartial t rho q = - nabla cdot(rho q boldsymbolu)  + g(rho q)\nlabeleq3d-box-advection-lim-tracers\nendequation","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"This is discretized using the following","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"beginequation\nfracpartialpartial t rho q approx\n- D_h rho q (boldsymbolu_h + I^c(boldsymbolu_v))\n- D^c_vleftI^f(rho q) U^fleft(I^f(boldsymbolu_h) + boldsymbolu_v fracrho qrho right) right + g(rho q)\nlabeleq3d-box-advection-lim-discrete-tracers\nendequation","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"where g(rho q) = - nu_4 nabla^4_h (rho q) represents the horizontal hyperdiffusion operator, with nu_4 (measured in m^4/s) the hyperviscosity constant coefficient.","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"Currently tracers are only treated explicitly in the time discretization.","category":"page"},{"location":"examples/#Prognostic-variables-2","page":"Examples","title":"Prognostic variables","text":"","category":"section"},{"location":"examples/","page":"Examples","title":"Examples","text":"rho: density measured in kg/m³. This is discretized at cell centers.\nboldsymbolu velocity, a vector measured in m/s. This is discretized via boldsymbolu = boldsymbolu_h + boldsymbolu_v where\nboldsymbolu_h = u_1 boldsymbole^1 + u_2 boldsymbole^2 is the projection onto horizontal covariant components (covariance here means with respect to the reference element), stored at cell centers.\nboldsymbolu_v = u_3 boldsymbole^3 is the projection onto the vertical covariant components, stored at cell faces.\nrho q: the tracer density scalar, where q is the tracer concentration per unit mass, is stored at cell centers.","category":"page"},{"location":"examples/#Operators","page":"Examples","title":"Operators","text":"","category":"section"},{"location":"examples/","page":"Examples","title":"Examples","text":"We make use of the following operators","category":"page"},{"location":"examples/#Reconstructions","page":"Examples","title":"Reconstructions","text":"","category":"section"},{"location":"examples/","page":"Examples","title":"Examples","text":"I^c is the face-to-center reconstruction operator, called first_order_If2c in the example code.\nI^f is the center-to-face reconstruction operator, called first_order_Ic2f in the example code.\nCurrently this is just the arithmetic mean, but we will need to use a weighted version with stretched vertical grids.\nU^f is the center-to-face upwind product operator, called third_order_upwind_c2f in the example code\nThis operator is of third-order of accuracy (when used with a constant vertical velocity and some reduced, but still high-order for non constant vertical velocity).","category":"page"},{"location":"examples/#Differentiation-operators-2","page":"Examples","title":"Differentiation operators","text":"","category":"section"},{"location":"examples/","page":"Examples","title":"Examples","text":"D_h is the discrete horizontal strong spectral divergence, called hdiv in the example code.\nwD_h is the discrete horizontal weak spectral divergence, called hwdiv in the example code.\nD^c_v is the face-to-center vertical divergence, called vdivf2c in the example code.\nThis example uses advective fluxes equal to zero at the top and bottom boundaries.\nG_h is the discrete horizontal spectral gradient, called hgrad in the example code.","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"To discretize the hyperdiffusion operator, g(rho q) = - nu_4 nabla^4 (rho q), in the horizontal direction, we compose the horizontal weak divergence, wD_h, and the horizontal gradient operator, G_h, twice, with an intermediate call to weighted_dss! between the two compositions, as in g_2(rho g) circ DSS(rho q) circ g_1(rho q), with:","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"g_1(rho q) = wD_h(G_h(q))\nDSS(rho q) = DSS(g_1(rho q))\ng_2(rho q) = -nu_4 wD_h(rho G_h(rho q))\nwith nu_4 the hyperviscosity coefficient.","category":"page"},{"location":"examples/#Application-of-Flux-Limiters-2","page":"Examples","title":"Application of Flux Limiters","text":"","category":"section"},{"location":"examples/","page":"Examples","title":"Examples","text":"note: Note\nSince we use flux limiters that limit only operators defined in the spectral space (i.e., they are applied level-wise in the horizontal direction), the application of limiters has to follow a precise order in the sequence of operations that specifies the total tendency.","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"The order of operations should be the following:","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"Horizontal transport (with strong divergence D_h)\nHorizontal Flux Limiters\nHorizontal hyperdiffusion (with weak divergence wD_h)\nVertical transport\nDSS","category":"page"},{"location":"examples/#Problem-flow-and-set-up-2","page":"Examples","title":"Problem flow and set-up","text":"","category":"section"},{"location":"examples/","page":"Examples","title":"Examples","text":"This test case is set up in a Cartesian (box) domain -2 pi 2 pi^2 times 0 4 pi textrmm^3, doubly periodic in the horizontal direction, but not in the vertical direction.","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"The flow was chosen to be a spiral, i.e., so to have a horizontal uniform rotation, and a vertical velocity boldsymbolu_v equiv w = 0 at the top and bottom boundaries, and boldsymbolu_v equiv w = 1 in the center of the domain. Moreover, the flow is reversed in all directions halfway through the time period so that the tracer blobs go back to its initial configuration (using the same speed scaling constant which was derived to account for the distance travelled in all directions in a half period).","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"beginalign\n    u = -u_0 (y - c_y) cos(pi t  T_f) nonumber \n    v = u_0 (x - c_x) cos(pi t  T_f) nonumber \n    w = u_0 sin(pi z  z_m) cos(pi t  T_f) nonumber\nlabeleq3d-box-advection-lim-flow\nendalign","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"where u_0 = pi  2 is the speed scaling factor to have the flow reversed halfway through the time period, boldsymbolc = (c_x c_y) is the center of the rotational flow, which coincides with the center of the domain,  z_m = 4 pi is the maximum height of the domain, and T_f = 2 pi is the final simulation time, which coincides with the temporal period to have a full rotation in the horizontal direction.","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"This example is set up to run with three possible initial conditions:","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"cosine_bells\ngaussian_bells\nslotted_spheres: a slight modification of the 2D slotted cylinder test case available in the literature (cfr: Oksana Guba, Mark Taylor, Amik St-Cyr (2014)).","category":"page"},{"location":"examples/#Application-of-Flux-Limiters-3","page":"Examples","title":"Application of Flux Limiters","text":"","category":"section"},{"location":"examples/","page":"Examples","title":"Examples","text":"Because this is a Cartesian 3D problem, the application of limiters does not affect the order of operations, which is implemented as follows:","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"Horizontal transport + hyperdiffusion (with weak divergence wD_h)\nHorizontal flux limiters\nVertical transport\nDSS","category":"page"},{"location":"examples/#D-Sphere-examples","page":"Examples","title":"2D Sphere examples","text":"","category":"section"},{"location":"examples/#Flux-Limiters-advection-3","page":"Examples","title":"Flux Limiters advection","text":"","category":"section"},{"location":"examples/","page":"Examples","title":"Examples","text":"The 2D sphere advection/transport example in examples/sphere/limiters_advection.jl demonstrates the application of flux limiters in the horizontal direction, namely QuasiMonotoneLimiter, in a 2D spherical domain.","category":"page"},{"location":"examples/#Equations-and-discretizations-3","page":"Examples","title":"Equations and discretizations","text":"","category":"section"},{"location":"examples/#Mass-3","page":"Examples","title":"Mass","text":"","category":"section"},{"location":"examples/","page":"Examples","title":"Examples","text":"Follows the continuity equation","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"beginequation\n  fracpartialpartial t rho = - nabla cdot(rho boldsymbolu) \nlabeleq2d-sphere-advection-lim-continuity\nendequation","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"This is discretized using the following","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"beginequation\n  fracpartialpartial t rho approx - wD rho boldsymbolu \nlabeleq2d-sphere-advection-lim-discrete-continuity\nendequation","category":"page"},{"location":"examples/#Tracers-3","page":"Examples","title":"Tracers","text":"","category":"section"},{"location":"examples/","page":"Examples","title":"Examples","text":"For the tracer concentration per unit mass q, the tracer density (scalar) rho q follows the advection/transport equation","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"beginequation\n  fracpartialpartial t rho q = - nabla cdot(rho q boldsymbolu)  + g(rho q)\nlabeleq2d-sphere-advection-lim-tracers\nendequation","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"This is discretized using the following","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"beginequation\nfracpartialpartial t rho q approx - wD rho q boldsymbolu + g(rho q)\nlabeleq2d-sphere-advection-lim-discrete-tracers\nendequation","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"where g(rho q) = - nu_4 nabla^4_h (rho q) represents the horizontal hyperdiffusion operator, with nu_4 (measured in m^4/s) the hyperviscosity constant coefficient.","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"Currently tracers are only treated explicitly in the time discretization.","category":"page"},{"location":"examples/#Prognostic-variables-3","page":"Examples","title":"Prognostic variables","text":"","category":"section"},{"location":"examples/","page":"Examples","title":"Examples","text":"rho: density measured in kg/m³.\nboldsymbolu velocity, a vector measured in m/s. Since this is a 2D problem, boldsymbolu equiv boldsymbolu_h.\nrho q: the tracer density scalar, where q is the tracer concentration per unit mass.","category":"page"},{"location":"examples/#Differentiation-operators-3","page":"Examples","title":"Differentiation operators","text":"","category":"section"},{"location":"examples/","page":"Examples","title":"Examples","text":"Because this is a purely 2D problem, there is no staggered vertical discretization, hence, there is no need of specifying variables at cell centers, faces or to reconstruct from faces to centers and vice versa.","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"wD is the discrete horizontal weak spectral divergence, called wdiv in the example code.\nG is the discrete horizontal strong spectral gradient, called grad in the example code.","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"To discretize the hyperdiffusion operator, g(rho q) = - nu_4 nabla^4 (rho q), in the horizontal direction, we compose the horizontal weak divergence, wD, and the horizontal gradient operator, G_h, twice, with an intermediate call to weighted_dss! between the two compositions, as in g_2(rho g) circ DSS(rho q) circ g_1(rho q), with:","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"g_1(rho q) = wD(G_h(q))\nDSS(rho q) = DSS(g_1(rho q))\ng_2(rho q) = -nu_4 wD(rho G_h(rho q))\nwith nu_4 the hyperviscosity coefficient.","category":"page"},{"location":"examples/#Problem-flow-and-set-up-3","page":"Examples","title":"Problem flow and set-up","text":"","category":"section"},{"location":"examples/","page":"Examples","title":"Examples","text":"This test case is set up in a Cartesian planar domain -2 pi 2 pi^2, doubly periodic.","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"The flow was chosen to be a horizontal uniform rotation. Moreover, the flow is reversed halfway through the time period so that the tracer blobs go back to its initial configuration (using the same speed scaling constant which was derived to account for the distance travelled in all directions in a half period).","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"beginalign\n    u = k sin (lambda)^2  sin (2  phi)  cos(pi  t  T_f) +\n       frac2 piT_f cos (phi) nonumber \n    v = k sin (2  lambda) cos (phi) cos(pi t  T_f)\nlabeleq2d-sphere-lim-flow\nendalign","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"where u_0 = 2 pi R  T_f is the speed scaling factor to have the flow reversed halfway through the time period, T_f = 86400 * 12 (i.e., 12 days in seconds) is the final simulation time, which coincides with the temporal period to have a full rotation around the sphere of radius R.","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"This example is set up to run with three possible initial conditions:","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"cosine_bells\ngaussian_bells\ncylinders: two 2D slotted cylinders (test case available in the literature, cfr: Oksana Guba, Mark Taylor, Amik St-Cyr (2014)).","category":"page"},{"location":"examples/#Application-of-Flux-Limiters-4","page":"Examples","title":"Application of Flux Limiters","text":"","category":"section"},{"location":"examples/","page":"Examples","title":"Examples","text":"Because this is a fully 2D problem, the application of limiters does not affect the order of operations, which is implemented as follows:","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"Horizontal trasport with hyperdiffusion (with weak divergence wD)\nHorizontal flux limiters\nDSS","category":"page"},{"location":"examples/#Shallow-water-equations","page":"Examples","title":"Shallow-water equations","text":"","category":"section"},{"location":"examples/","page":"Examples","title":"Examples","text":"The shallow water equations in the so-called vector invariant form from Lei Bao, Ramachandran D. Nair, Henry M. Tufo (2014) are:","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"beginalign\n  fracpartial hpartial t + nabla cdot (h u) = 0\n  fracpartial u_ipartial t + nabla (Phi + tfrac12u^2)_i  = (boldsymbolu times (f + nabla times boldsymbolu))_i\nlabeleqshallow-water\nendalign","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"where f is the Coriolis term and Phi = g(h+h_s), with g the gravitational accelration constant, h the (free) height of the fluid and  h_s a non-uniform reference surface.","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"To the above set of equations, we allow the uset to add a hyperdiffusion operator, g(h boldsymbolu) = - nu_4 nabla^4 (h boldsymbolu), with nu_4 (measured in m^4/s) the hyperviscosity constant coefficient. In the hyperdiffusion expression, nabla^4 represents a biharmonic operator, and it assumes a different formulation on curvilinear reference systems, depending on it being applied to a scalar field, such as h, or a vector field, such as boldsymbolu.","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"The governing equations then become:","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"beginalign\n  fracpartial hpartial t + nabla cdot (h u) = g(h boldsymbolu)\n  fracpartial u_ipartial t + nabla (Phi + tfrac12u^2)_i  = (boldsymbolu times (f + nabla times boldsymbolu))_i + g(h boldsymbolu)\nlabeleqshallow-water-with-hyperdiff\nendalign","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"Since this is a 2D problem (with related 2D vector field), the curl is defined to be","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"beginalign\n omega^i = (nabla times u)^i =\n    begincases\n        0 text if i =12\n        frac1J left fracpartial u_2partial xi^1 - fracpartial u_1partial xi^2 right text if i=3\n    endcases\nlabeleq2Dvorticity\nendalign","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"where we have used the coordinate system in each 2D reference element, i.e., (xi^1 xi^2) in -11times-11. Similarly, if additionally v^1 = v^2 = 0, then","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"beginalign\n   (boldsymbolu times boldsymbolv)_i =\n    begincases\n          J u^2 v^3 text if i=1\n        - J u^1 v^3 text if i=2\n        0 text if i=3\n    endcases\nendalign","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"Hence, we can rewrite equations \\eqref{eq:shallow-water} using the velocity representation in covariant coordinates, in this case u = u_1 boldsymbolb^1 + u_2 boldsymbolb^2 + 0boldsymbolb^3, and g(h boldsymbolu) = 0 for simplicity, as:","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"beginalign\n    fracpartial hpartial t + frac1Jfracpartialpartial xi^jBig(h J u^jBig) = 0\n    fracpartial u_ipartial t + fracpartialpartial xi^i (Phi + tfrac12u^2)  = E_ijku^j (f^k + omega^k) \nlabeleqcovariant-shallow-water\nendalign","category":"page"},{"location":"examples/#Prognostic-variables-4","page":"Examples","title":"Prognostic variables","text":"","category":"section"},{"location":"examples/","page":"Examples","title":"Examples","text":"h: scalar height field of the fluid, measured in m.\nboldsymbolu velocity, a 2D vector measured in m/s.","category":"page"},{"location":"examples/#Differentiation-operators-4","page":"Examples","title":"Differentiation operators","text":"","category":"section"},{"location":"examples/","page":"Examples","title":"Examples","text":"Because this is a purely 2D problem, there is no staggered vertical discretization, hence, there is no need of specifying variables at cell centers, faces or to reconstruct from faces to centers and vice versa.","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"D is the discrete horizontal strong spectral divergence, called div in the example code.\nwD is the discrete horizontal weak spectral divergence, called wdiv in the example code.\nG is the discrete horizontal strong spectral gradient, called grad in the example code.\nwG is the discrete horizontal weak spectral gradient, called wgrad in the example code.\nCurl is the discrete curl, called curl in the example code.\nwCurl is the discrete weak curl, called wcurl in the example code.","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"To discretize the hyperdiffusion operator, g(h boldsymbolu) = - nu_4 nabla^4 (h boldsymbolu), in the horizontal direction, we compose the weak divergence, wD, and the gradient operator, G, twice, with an intermediate call to weighted_dss! between the two compositions, as in g_2(h boldsymbolu) circ DSS(h boldsymbolu) circ g_1(h boldsymbolu). Moreover, when g(h boldsymbolu) = - nu_4 nabla^4 (h), i.e., the operator is applied to a scalar field only, it is discretized composing the following operations:","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"g_1(h) = wD(G(h))\nDSS(g_1(h))\ng_2(h) = -nu_4 wD(G(h))","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"whereas, when the operator is applied to a vector field, i.e., g(h boldsymbolu) = - nu_4 nabla^4 (boldsymbolu), it is discretized as:","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"g_1(h boldsymbolu) = wG(D(boldsymbolu)) - wCurl(Curl(boldsymbolu))\nDSS(h boldsymbolu) = DSS(g_1(h boldsymbolu))\ng_2(h boldsymbolu) = -nu_4 left wG(D(boldsymbolu)) - wCurl(Curl(boldsymbolu)) right","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"In both cases, nu_4 is the hyperviscosity coefficient.","category":"page"},{"location":"examples/#Problem-flow-and-set-up-4","page":"Examples","title":"Problem flow and set-up","text":"","category":"section"},{"location":"examples/","page":"Examples","title":"Examples","text":"This test case is set up on a 2D (surface) spherical domain represented by a cubed-sphere manifold.","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"This suite of examples contains five different test cases:","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"One, invoked via the command-line argument steady_state, which reproduces Test Case 2 in David L. Williamson, John B. Drake, James J. Hack, Rüdiger Jakob, Paul N. Swarztrauber (1992). This test case gives the steady-state solution to the non-linear shallow water equations. It consists of a solid body rotation or zonal flow with the corresponding geostrophic height field. The Coriolis parameter is a function of latitude and longitude so the flow can be specified with the spherical coordinate poles not necessarily coincident with Earth's rotation axis. Hence, this test case can be run with a specified command-line argument for the angle alpha that represents the angle between the north pole and the center of the top cube panel of the cubed-sphere geometry.\nA second one, invoked via the command-line argument steady_state_compact, reproduces Test Case 3 in David L. Williamson, John B. Drake, James J. Hack, Rüdiger Jakob, Paul N. Swarztrauber (1992). This test case gives the steady-state solution to the non-linear shallow water equations with nonlinear zonal geostrophic flow with compact support.\nA third one, invoked via the command-line argument mountain, reproduces Test Case 5 in David L. Williamson, John B. Drake, James J. Hack, Rüdiger Jakob, Paul N. Swarztrauber (1992). It represents a zonal flow over an isolated mountain, where the governing equations describe a global steady-state nonlinear zonal geostrophic flow, with a corresponding geostrophic height field over a non-uniform reference surface h_s.\nA fourth one, invoked via the command-line argument rossby_haurwitz, reproduces Test Case 6 in David L. Williamson, John B. Drake, James J. Hack, Rüdiger Jakob, Paul N. Swarztrauber (1992). It represents the solution of the nonlinear barotropic vorticity equation on the sphere.\nA fifth one, invoked via the command-line argument barotropic_instability, reproduces the test case in Joseph Galewsky, Richard K. Scott, Lorenzo M. Polvani (2004) (also in Sec. 7.6 in Paul A. Ullrich, Christiane Jablonowski, Bram van Leer (2010)). This test case consists of a zonal jet with compact support at a latitude of 45. A small height disturbance is then added, which causes the jet to become unstable and collapse into a highly vortical structure.","category":"page"},{"location":"examples/#D-Sphere-examples-2","page":"Examples","title":"3D Sphere examples","text":"","category":"section"},{"location":"examples/#Deformation-Flow-with-Flux-Limiters","page":"Examples","title":"Deformation Flow with Flux Limiters","text":"","category":"section"},{"location":"examples/","page":"Examples","title":"Examples","text":"The 3D sphere advection/transport example in examples/hybrid/sphere/deformation_flow.jl demonstrates the application of flux limiters in the horziontal direction, namely QuasiMonotoneLimiter, in a hybrid 3D spherical domain. It also demonstrates the usage of the flux-corrected transport in the vertical direction; by default, it uses FCTZalesak.","category":"page"},{"location":"examples/#Equations-and-discretizations-4","page":"Examples","title":"Equations and discretizations","text":"","category":"section"},{"location":"examples/","page":"Examples","title":"Examples","text":"The original test case (without limiters or flux-corrected transport) is specified in Section 1.1 of Paul Aaron Ullrich, Christiane Jablonowski, James Kent, Peter H. Lauritzen, Ramachandran D. Nair (2012).","category":"page"},{"location":"examples/#Mass-4","page":"Examples","title":"Mass","text":"","category":"section"},{"location":"examples/","page":"Examples","title":"Examples","text":"Follows the continuity equation","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"beginequation\n  fracpartialpartial t rho = - nabla cdot(rho boldsymbolu) \nlabeleq3d-sphere-lim-continuity\nendequation","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"This is discretized using the following","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"beginequation\n  fracpartialpartial t rho approx - D_hrho boldsymbolu^c - D^c_vI^f(rho) boldsymbolu^f\nlabeleq3d-sphere-lim-discrete-continuity\nendequation","category":"page"},{"location":"examples/#Tracers-4","page":"Examples","title":"Tracers","text":"","category":"section"},{"location":"examples/","page":"Examples","title":"Examples","text":"This test case has five different tracer concentrations per unit mass q_i, hence five different tracer densities (scalar) rho q_i. They all follow the same advection/transport equation","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"beginequation\n  fracpartialpartial t rho q = - nabla cdot(rho q boldsymbolu)  + g(rho q)\nlabeleq3d-sphere-lim-tracers\nendequation","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"This is discretized using the following","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"beginequation\nfracpartialpartial t rho q approx\n- D_h rho q boldsymbolu^c\n- D^c_vleftI^f(rho q) * boldsymbolu^f_h + FCT^fleft( boldsymbolu^f_v fracrho qrho right) right + g(rho q)\nlabeleq3d-sphere-lim-discrete-tracers\nendequation","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"where g(rho q) = - nu_4 nabla^4_h (rho q) represents the horizontal hyperdiffusion operator, with nu_4 (measured in m^4/s) the hyperviscosity constant coefficient.","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"Currently tracers are only treated explicitly in the time discretization.","category":"page"},{"location":"examples/#Prognostic-variables-5","page":"Examples","title":"Prognostic variables","text":"","category":"section"},{"location":"examples/","page":"Examples","title":"Examples","text":"rho: density measured in kg/m³. This is discretized at cell centers.\nboldsymbolu velocity, a vector measured in m/s. This is discretized via boldsymbolu = boldsymbolu_h + boldsymbolu_v where\nboldsymbolu_h = u_1 boldsymbole^1 + u_2 boldsymbole^2 is the projection onto horizontal covariant components (covariance here means with respect to the reference element), stored at cell centers.\nboldsymbolu_v = u_3 boldsymbole^3 is the projection onto the vertical covariant components, stored at cell faces.\nrho q_i: tracer density scalars, where q_i is a tracer concentration per unit mass, are stored at cell centers.","category":"page"},{"location":"examples/#Operators-2","page":"Examples","title":"Operators","text":"","category":"section"},{"location":"examples/","page":"Examples","title":"Examples","text":"We make use of the following operators","category":"page"},{"location":"examples/#Reconstructions-2","page":"Examples","title":"Reconstructions","text":"","category":"section"},{"location":"examples/","page":"Examples","title":"Examples","text":"I^c is the face-to-center reconstruction operator, called If2c in the example code.\nI^f is the center-to-face reconstruction operator, called Ic2f in the example code.\nCurrently this is just the arithmetic mean, but we will need to use a weighted version with stretched vertical grids.\nFCT^f denotes either the center-to-face upwind product operator (which represents no flux-corrected transport), the center-to-face Boris & Book FCT operator, or the center-to-face Zalesak FCT operator.","category":"page"},{"location":"examples/#Differentiation-operators-5","page":"Examples","title":"Differentiation operators","text":"","category":"section"},{"location":"examples/","page":"Examples","title":"Examples","text":"D_h is the discrete horizontal strong spectral divergence, called hdiv in the example code.\nwD_h is the discrete horizontal weak spectral divergence, called hwdiv in the example code.\nD^c_v is the face-to-center vertical divergence, called vdivf2c in the example code.\nThis example uses advective fluxes equal to zero at the top and bottom boundaries.\nG_h is the discrete horizontal spectral gradient, called hgrad in the example code.","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"To discretize the hyperdiffusion operator for each tracer concentration, g(rho q_i) = - nu_4 nabla^4 (rho q_i), in the horizontal direction, we compose the horizontal weak divergence, wD_h, and the horizontal gradient operator, G_h, twice, with an intermediate call to weighted_dss! between the two compositions, as in g_2(rho g) circ DSS(rho q) circ g_1(rho q_i), with:","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"g_1(rho q_i) = wD_h(G_h(q_i))\nDSS(rho q_i) = DSS(g_1(rho q_i))\ng_2(rho q_i) = -nu_4 wD_h(rho G_h(rho q_i))\nwith nu_4 the hyperviscosity coefficient.","category":"page"},{"location":"examples/#Application-of-Flux-Limiters-5","page":"Examples","title":"Application of Flux Limiters","text":"","category":"section"},{"location":"examples/","page":"Examples","title":"Examples","text":"note: Note\nSince we use flux limiters that limit only operators defined in the spectral space (i.e., they are applied level-wise in the horizontal direction), the application of limiters has to follow a precise order in the sequence of operations that specifies the total tendency.","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"The order of operations should be the following:","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"Horizontal transport (with strong divergence D_h)\nHorizontal flux limiters\nHorizontal hyperdiffusion (with weak divergence wD_h)\nVertical transport\nDSS","category":"page"},{"location":"examples/#Problem-flow-and-set-up-5","page":"Examples","title":"Problem flow and set-up","text":"","category":"section"},{"location":"examples/","page":"Examples","title":"Examples","text":"This test case is set up in a 3D (shell) spherical domain where the elevation goes from z=0textrmm (i.e., from the radius of the sphere R = 637122 10^6textrmm) to z_textrmtop = 12000textrmm.","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"The flow (reversed halfway through the time period) is specified as boldsymbolu = boldsymbolu_a + boldsymbolu_d, where the components are defined as follows:","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"beginalign\n  u_a = k sin (lambda)^2  sin (2  phi)  cos(pi  t  tau) +\n      frac2 pi Rtau cos (phi) nonumber \n  v_a = k sin (2  lambda) cos (phi) cos(pi t  tau) nonumber \n  u_d = fracomega_0  R b  p_textrmtop cos (lambda) cos(phi)^2 cos(2 pi t  tau) left-exp left( frac(p - p_0) b p_textrmtop right) + exp left( frac(p_textrmtop - p(zc))b p_textrmtop right) right nonumber\nlabeleq3d-sphere-lim-flow\nendalign","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"where all values of the parameters can be found in Table 1.1 in the reference Paul Aaron Ullrich, Christiane Jablonowski, James Kent, Peter H. Lauritzen, Ramachandran D. Nair (2012).","category":"page"},{"location":"#ClimaCore.jl","page":"Home","title":"ClimaCore.jl","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"ClimaCore.jl constitutes the dynamical core (dycore) of the atmosphere and land models for CliMA's Earth System Model (ESM). ClimaCore.jl provides flexible and composable discretization tools to solve the governing equations of the ESM component models. In fact, ClimaCore.jl's high-level application programming interface (API) facilitates modularity and composition of differential operators and the definition of flexible discretizations. This, in turn, is coupled with low-level APIs that support different data layouts, specialized implementations, and flexible models for threading, to better face high-performance optimization, data storage, and scalability challenges on modern HPC architectures.","category":"page"}]
}
