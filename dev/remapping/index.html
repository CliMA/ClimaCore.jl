<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Remapping · ClimaCore.jl</title><meta name="title" content="Remapping · ClimaCore.jl"/><meta property="og:title" content="Remapping · ClimaCore.jl"/><meta property="twitter:title" content="Remapping · ClimaCore.jl"/><meta name="description" content="Documentation for ClimaCore.jl."/><meta property="og:description" content="Documentation for ClimaCore.jl."/><meta property="twitter:description" content="Documentation for ClimaCore.jl."/><script data-outdated-warner src="../assets/warner.js"></script><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.050/juliamono.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.16.8/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL=".."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../assets/documenter.js"></script><script src="../search_index.js"></script><script src="../siteinfo.js"></script><script src="../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/catppuccin-mocha.css" data-theme-name="catppuccin-mocha"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/catppuccin-macchiato.css" data-theme-name="catppuccin-macchiato"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/catppuccin-frappe.css" data-theme-name="catppuccin-frappe"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/catppuccin-latte.css" data-theme-name="catppuccin-latte"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><a class="docs-logo" href="../"><img src="../assets/logo.png" alt="ClimaCore.jl logo"/></a><div class="docs-package-name"><span class="docs-autofit"><a href="../">ClimaCore.jl</a></span></div><button class="docs-search-query input is-rounded is-small is-clickable my-2 mx-auto py-1 px-2" id="documenter-search-query">Search docs (Ctrl + /)</button><ul class="docs-menu"><li><a class="tocitem" href="../">Home</a></li><li><a class="tocitem" href="../intro/">Introduction</a></li><li><a class="tocitem" href="../math_framework/">Mathematical Framework</a></li><li><a class="tocitem" href="../installation_instructions/">Installation and How-to Guides</a></li><li><a class="tocitem" href="../geometry/">Geometry</a></li><li><a class="tocitem" href="../operators/">Operators</a></li><li class="is-active"><a class="tocitem" href>Remapping</a><ul class="internal"><li><a class="tocitem" href="#Non-conservative-remapping"><span>Non-conservative remapping</span></a></li><li><a class="tocitem" href="#Conservative-remapping-with-TempestRemap"><span>Conservative remapping with <code>TempestRemap</code></span></a></li><li class="toplevel"><a class="tocitem" href="#Interpolating-to-pressure-coordinates"><span>Interpolating to pressure coordinates</span></a></li><li><a class="tocitem" href="#Quick-start-2"><span>Quick start</span></a></li><li><a class="tocitem" href="#How-it-works"><span>How it works</span></a></li><li><a class="tocitem" href="#Space-and-staggering-requirements"><span>Space and staggering requirements</span></a></li></ul></li><li><a class="tocitem" href="../matrix_fields/">MatrixFields</a></li><li><input class="collapse-toggle" id="menuitem-9" type="checkbox"/><label class="tocitem" for="menuitem-9"><span class="docs-label">API</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../APIs/utilities_api/">Utilities</a></li><li><a class="tocitem" href="../APIs/datalayouts_api/">DataLayouts</a></li><li><a class="tocitem" href="../APIs/geometry_api/">Geometry</a></li><li><a class="tocitem" href="../APIs/domains_api/">Domains</a></li><li><a class="tocitem" href="../APIs/meshes_api/">Meshes</a></li><li><a class="tocitem" href="../APIs/topologies_api/">Topologies</a></li><li><a class="tocitem" href="../APIs/grids_api/">Grids</a></li><li><a class="tocitem" href="../APIs/hypso_api/">Hypsography</a></li><li><a class="tocitem" href="../APIs/dss_api/">DSS</a></li><li><a class="tocitem" href="../APIs/common_grids_api/">CommonGrids</a></li><li><a class="tocitem" href="../APIs/spaces_api/">Spaces</a></li><li><a class="tocitem" href="../APIs/common_spaces_api/">CommonSpaces</a></li><li><a class="tocitem" href="../APIs/quadratures_api/">Quadratures</a></li><li><a class="tocitem" href="../APIs/fields_api/">Fields</a></li><li><a class="tocitem" href="../APIs/limiters_api/">Limiters</a></li><li><a class="tocitem" href="../APIs/input_output_api/">InputOutput</a></li><li><a class="tocitem" href="../APIs/remapping_api/">Remapping</a></li><li><a class="tocitem" href="../APIs/recursive_apply_api/">RecursiveApply</a></li><li><a class="tocitem" href="../APIs/devices_api/">Devices</a></li><li><a class="tocitem" href="../APIs/debug_only_api/">DebugOnly</a></li></ul></li><li><input class="collapse-toggle" id="menuitem-10" type="checkbox"/><label class="tocitem" for="menuitem-10"><span class="docs-label">Developer docs</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../performance_tips/">Performance tips</a></li><li><a class="tocitem" href="../shmem_design/">Shared memory design</a></li></ul></li><li><input class="collapse-toggle" id="menuitem-11" type="checkbox"/><label class="tocitem" for="menuitem-11"><span class="docs-label">Tutorials</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../tutorials/introduction/">Introduction to ClimaCore.jl</a></li></ul></li><li><a class="tocitem" href="../examples/">Examples</a></li><li><a class="tocitem" href="../masks/">Masks</a></li><li><a class="tocitem" href="../debugging/">Debugging</a></li><li><input class="collapse-toggle" id="menuitem-15" type="checkbox"/><label class="tocitem" for="menuitem-15"><span class="docs-label">Libraries</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../lib/ClimaCorePlots/">ClimaCorePlots.jl</a></li><li><a class="tocitem" href="../lib/ClimaCoreMakie/">ClimaCoreMakie.jl</a></li><li><a class="tocitem" href="../lib/ClimaCoreVTK/">ClimaCoreVTK.jl</a></li><li><a class="tocitem" href="../lib/ClimaCoreTempestRemap/">ClimaCoreTempestRemap.jl</a></li><li><a class="tocitem" href="../lib/ClimaCoreSpectra/">ClimaCoreSpectra.jl</a></li></ul></li><li><a class="tocitem" href="../Contributing/">Contributing guide</a></li><li><a class="tocitem" href="../code_of_conduct/">Code of Conduct</a></li><li><a class="tocitem" href="../faq/">Frequently asked questions</a></li><li><a class="tocitem" href="../references/">References</a></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><a class="docs-sidebar-button docs-navbar-link fa-solid fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a><nav class="breadcrumb"><ul class="is-hidden-mobile"><li class="is-active"><a href>Remapping</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>Remapping</a></li></ul></nav><div class="docs-right"><a class="docs-navbar-link" href="https://github.com/CliMA/ClimaCore.jl" title="View the repository on GitHub"><span class="docs-icon fa-brands"></span><span class="docs-label is-hidden-touch">GitHub</span></a><a class="docs-navbar-link" href="https://github.com/CliMA/ClimaCore.jl/blob/main/docs/src/remapping.md" title="Edit source on GitHub"><span class="docs-icon fa-solid"></span></a><a class="docs-settings-button docs-navbar-link fa-solid fa-gear" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-article-toggle-button fa-solid fa-chevron-up" id="documenter-article-toggle-button" href="javascript:;" title="Collapse all docstrings"></a></div></header><article class="content" id="documenter-page"><h1 id="Remapping-to-regular-grids"><a class="docs-heading-anchor" href="#Remapping-to-regular-grids">Remapping to regular grids</a><a id="Remapping-to-regular-grids-1"></a><a class="docs-heading-anchor-permalink" href="#Remapping-to-regular-grids" title="Permalink"></a></h1><p><code>ClimaCore</code> horizontal domains are spectral elements. Points are not distributed uniformly within an element, and elements are also not necessarily organized in a simple way. For these reasons, remapping to regular grids becomes a fundamental operations when inspecting the simulation output. In this section, we describe the remappers currently available in <code>ClimaCore</code>.</p><p>Broadly speaking, we can classify remappers in two categories: conservative, and non-conservative. Conservative remappers preserve areas (and masses) when interpolating from the spectral grid to Cartesian ones. Conservative remappers are non-local operations (meaning that they require communication between different elements) and are more expensive, so they are typically reserved to operations where physical conservation is important (e.g., exchange between component models in a coupled simulation). On the other hand, non-conservative remappers are local to an element and faster to evaluate, which makes them suitable to operations like diagnostics and plotting, where having perfect physical conservation is not as important.</p><h2 id="Non-conservative-remapping"><a class="docs-heading-anchor" href="#Non-conservative-remapping">Non-conservative remapping</a><a id="Non-conservative-remapping-1"></a><a class="docs-heading-anchor-permalink" href="#Non-conservative-remapping" title="Permalink"></a></h2><p>Non-conservative remappers are fast and do not require communication, but they are not as accurate as conservative remappers, especially with large elements with sharp gradients. These remappers are better suited for diagnostics and plots.</p><p>The main non-conservative remapper currently implemented utilizes a Lagrange interpolation with the barycentric formula in [Berrut2004], equation (3.2), for the horizontal interpolation. Vertical interpolation is linear except in the boundary elements where it is 0th order.</p><h3 id="Quick-start"><a class="docs-heading-anchor" href="#Quick-start">Quick start</a><a id="Quick-start-1"></a><a class="docs-heading-anchor-permalink" href="#Quick-start" title="Permalink"></a></h3><p>Assuming you have a <code>ClimaCore</code> <code>Field</code> with name <code>field</code>, the simplest way to interpolate onto a uniform grid is with</p><pre><code class="language-julia hljs">julia&gt; import ClimaCore.Remapping
julia&gt; Remapping.interpolate(field)</code></pre><p>This will return an <code>Array</code> (or a <code>CuArray</code>) with the <code>field</code> interpolated on some uniform grid that is automatically determined based on the <code>Space</code> of the given <code>field</code>. To obtain such coordinates, you can call the <code>Remapping.default_target_hcoords</code> and <code>Remapping.default_target_zcoords</code> functions. These functions return an <code>Array</code> with the coordinates over which interpolation will occur. These arrays are of type <code>Geometry.Point</code>s.</p><p>By default, vertical interpolation is off (field evaluated on levels). Horizontal interpolation: <code>SpectralElementRemapping()</code> (default; uses spectral element quadrature weights) or <code>BilinearRemapping()</code>:</p><pre><code class="language-julia hljs">interpolated_array = Remapping.interpolate(field; horizontal_method = Remapping.BilinearRemapping())</code></pre><p><code>ClimaCore.Remapping.interpolate</code> allocates new output arrays. As such, it is not suitable for performance-critical applications. <code>ClimaCore.Remapping.interpolate!</code> performs interpolation in-place. When using the in-place version<code>, the</code>dest<code>ination has to have the same array type as the device in use (e.g.,</code>CuArray<code>for CUDA runs) and has to be</code>nothing<code>for non-root processes. For performance-critical applications, it is preferable to a</code>ClimaCore.Remapping.Remapper` and use it directly (see next Section).</p><h4 id="Example"><a class="docs-heading-anchor" href="#Example">Example</a><a id="Example-1"></a><a class="docs-heading-anchor-permalink" href="#Example" title="Permalink"></a></h4><p>Given <code>field</code>, a <code>Field</code> defined on a cubed sphere.</p><p>By default, a target uniform grid is chosen (with resolution <code>hresolution</code> and <code>vresolution</code>), so remapping is</p><pre><code class="language-julia hljs">interpolated_array = interpolate(field, hcoords, zcoords)</code></pre><p>Coordinates can be specified:</p><pre><code class="language-julia hljs">longpts = range(-180.0, 180.0, 21)
latpts = range(-80.0, 80.0, 21)
zpts = range(0.0, 1000.0, 21)

hcoords = [Geometry.LatLongPoint(lat, long) for long in longpts, lat in latpts]
zcoords = [Geometry.ZPoint(z) for z in zpts]

interpolated_array = interpolate(field, hcoords, zcoords)
# Or, to use bilinear remapping without spectral element weighting:
# interpolate(field, hcoords, zcoords; horizontal_method = Remapping.BilinearRemapping())</code></pre><p>The output is defined on the Cartesian product of <code>hcoords</code> with <code>zcoords</code>.</p><p>If the default target coordinates are being used, it is possible to broadcast <code>ClimaCore.Geometry.components</code> to extract them as a vector of tuples (and then broadcast <code>getindex</code> to extract the respective coordinates as vectors).</p><p>This also provides the simplest way to plot a <code>Field</code>. Suppose <code>field</code> is a 2D <code>Field</code>:</p><pre><code class="language-julia hljs">using CairoMakie
heatmap(ClimaCore.Remapping.interpolate(field))</code></pre><h3 id="Remapping-methods:-Bilinear-vs-SpectralElementRemapping"><a class="docs-heading-anchor" href="#Remapping-methods:-Bilinear-vs-SpectralElementRemapping">Remapping methods: Bilinear vs SpectralElementRemapping</a><a id="Remapping-methods:-Bilinear-vs-SpectralElementRemapping-1"></a><a class="docs-heading-anchor-permalink" href="#Remapping-methods:-Bilinear-vs-SpectralElementRemapping" title="Permalink"></a></h3><p>Two horizontal remapping methods are available:</p><ul><li><strong><code>SpectralElementRemapping()</code></strong> (default): Uses spectral element quadrature weights for high-order polynomial interpolation. More accurate for smooth fields but can produce overshoots/undershoots near discontinuities.</li><li><strong><code>BilinearRemapping()</code></strong>: Uses bilinear interpolation on the 2×2 GLL cell containing each target point. More conservative (bounds-preserving) but lower-order accuracy.</li></ul><p>Both methods can be used with <code>interpolate_array</code> or <code>Remapper</code>:</p><pre><code class="language-julia hljs">using ClimaCore.Remapping: SpectralElementRemapping, BilinearRemapping

# Use spectral remapping (default)
interpolated = Remapping.interpolate_array(field, xpts, ypts)

# Use bilinear remapping
interpolated = Remapping.interpolate_array(
    field, xpts, ypts; horizontal_method = BilinearRemapping()
)

# With Remapper
remapper = Remapper(space; target_hcoords, horizontal_method = BilinearRemapping())</code></pre><h4 id="Slotted-cylinder-example-(demo-of-horizontal-remapping-types)"><a class="docs-heading-anchor" href="#Slotted-cylinder-example-(demo-of-horizontal-remapping-types)">Slotted-cylinder example (demo of horizontal remapping types)</a><a id="Slotted-cylinder-example-(demo-of-horizontal-remapping-types)-1"></a><a class="docs-heading-anchor-permalink" href="#Slotted-cylinder-example-(demo-of-horizontal-remapping-types)" title="Permalink"></a></h4><pre><code class="language-julia hljs">using ClimaComms
using ClimaCore:
    Geometry, Domains, Meshes, Topologies, Spaces, Fields, Remapping, Quadratures
using CairoMakie

device = ClimaComms.CPUSingleThreaded()
nelements_horz = 6
Nq = 4
n_interp = 24

# Simple test field: disk with slot (discontinuous)
slot_radius = 0.15
slot_cx, slot_cy = 0.5, 0.5
slot_half_width = 0.025
slot_y_hi = slot_cy + slot_radius

horzdomain = Domains.RectangleDomain(
    Geometry.XPoint(0.0) .. Geometry.XPoint(1.0),
    Geometry.YPoint(0.0) .. Geometry.YPoint(1.0),
    x1periodic = true, x2periodic = true,
)

quad = Quadratures.GLL{Nq}()
horzmesh = Meshes.RectilinearMesh(horzdomain, nelements_horz, nelements_horz)
horztopology = Topologies.Topology2D(ClimaComms.SingletonCommsContext(device), horzmesh)
space = Spaces.SpectralElementSpace2D(horztopology, quad)

coords = Fields.coordinate_field(space)
function slotted_cylinder(x, y)
    in_disk = (x - slot_cx)^2 + (y - slot_cy)^2 &lt;= slot_radius^2
    in_slot = (abs(x - slot_cx) &lt;= slot_half_width) &amp;&amp; (y &gt;= slot_cy) &amp;&amp; (y &lt;= slot_y_hi)
    return (in_disk &amp;&amp; !in_slot) ? 1.0 : 0.0
end
field = @. slotted_cylinder(coords.x, coords.y)
Spaces.weighted_dss!(field)

xpts = range(Geometry.XPoint(0.0), Geometry.XPoint(1.0), length = n_interp)
ypts = range(Geometry.YPoint(0.0), Geometry.YPoint(1.0), length = n_interp)

# Compare both methods
interp_bilinear = Remapping.interpolate_array(
    field, xpts, ypts; horizontal_method = Remapping.BilinearRemapping(),
)
interp_spectral = Remapping.interpolate_array(
    field, xpts, ypts; horizontal_method = Remapping.SpectralElementRemapping(),
)

# Error (bilinear − spectral): highlights where the methods differ
err_bilinear_spectral = interp_bilinear .- interp_spectral

# Raw data at GLL nodes (source field before interpolation)
x_se = Float64[]
y_se = Float64[]
vals_se = Float64[]
Fields.byslab(space) do slabidx
    x_data = parent(Fields.slab(coords.x, slabidx))
    y_data = parent(Fields.slab(coords.y, slabidx))
    f_data = parent(Fields.slab(field, slabidx))
    for j in 1:Nq, i in 1:Nq
        push!(x_se, x_data[i, j])
        push!(y_se, y_data[i, j])
        push!(vals_se, f_data[i, j])
    end
end

x_plot = [p.x for p in xpts]
y_plot = [p.y for p in ypts]

fig = Figure(size = (1200, 700))
ax1 = Axis(fig[1, 1], title = &quot;Bilinear&quot;, xlabel = &quot;x&quot;, ylabel = &quot;y&quot;)
hm1 = heatmap!(
    ax1, x_plot, y_plot, interp_bilinear&#39;;
    colorrange = (0, 1), colormap = :viridis,
    lowclip = :orange, highclip = :red,
)
Colorbar(fig[1, 2], hm1; label = &quot;value&quot;)

ax2 = Axis(fig[1, 3], title = &quot;Spectral&quot;, xlabel = &quot;x&quot;, ylabel = &quot;y&quot;)
hm2 = heatmap!(
    ax2, x_plot, y_plot, interp_spectral&#39;;
    colorrange = (0, 1), colormap = :viridis,
    lowclip = :orange, highclip = :red,
)
Colorbar(fig[1, 4], hm2; label = &quot;value&quot;)

ax3 = Axis(fig[1, 5], title = &quot;Error (bilinear − spectral)&quot;, xlabel = &quot;x&quot;, ylabel = &quot;y&quot;)
erange = extrema(err_bilinear_spectral)
hm3 = heatmap!(
    ax3, x_plot, y_plot, err_bilinear_spectral&#39;;
    colorrange = erange, colormap = :RdBu,
)
Colorbar(fig[1, 6], hm3; label = &quot;error&quot;)

# Row 2: raw spectral element grid (exact values at GLL nodes)
# Swap (y_se, x_se) so orientation matches heatmaps (slab i,j vs display x,y convention)
ax_se = Axis(
    fig[2, 1],
    title = &quot;Raw spectral element grid (GLL nodes)&quot;,
    xlabel = &quot;x&quot;,
    ylabel = &quot;y&quot;,
)
sc_se = scatter!(
    ax_se, y_se, x_se;
    color = vals_se,
    colorrange = (0, 1),
    colormap = :viridis,
    lowclip = :orange,
    highclip = :red,
    markersize = 8,
)
boundary_pos = (0:nelements_horz) ./ nelements_horz
vlines!(ax_se, boundary_pos; color = :pink, linewidth = 2)
hlines!(ax_se, boundary_pos; color = :pink, linewidth = 2)
limits!(ax_se, 0, 1, 0, 1)
Colorbar(fig[2, 2], sc_se; label = &quot;value&quot;)

fig</code></pre><img src="110a869f.png" alt="Example block output"/><p>Row 1: heatmaps use <strong>orange</strong> for undershoots (&amp;lt; 0) and <strong>red</strong> for overshoots (&amp;gt; 1). The spectral method produces overshoots/undershoots near the discontinuity; bilinear stays in [0, 1]. The error panel (bilinear − spectral) shows where the two methods differ. Row 2: raw field values at the GLL nodes (the source data); pink lines show element boundaries.</p><h3 id="The-Remapper-object"><a class="docs-heading-anchor" href="#The-Remapper-object">The <code>Remapper</code> object</a><a id="The-Remapper-object-1"></a><a class="docs-heading-anchor-permalink" href="#The-Remapper-object" title="Permalink"></a></h3><p>A <code>Remapping.Remapper</code> is an object that is tied to a specified <code>Space</code> and can interpolate scalar <code>Field</code>s defined on that space onto a predefined target grid. The grid does not have to be regular, but it has to be defined as a Cartesian product between some horizontal and vertical coordinates (meaning, for each horizontal point, there is a fixed column of vertical coordinates).</p><p>Let us create our first remapper, assuming we have <code>space</code> defined on the surface of the sphere</p><pre><code class="language-julia hljs">import ClimaCore.Geometry: LatLongPoint, ZPoint
import ClimaCore.Remapping: Remapper

hcoords = [Geometry.LatLongPoint(lat, long) for long in -180.:180., lat in -90.:90.]
remapper = Remapper(space, target_hcoords)</code></pre><p>This <code>remapper</code> object knows can interpolate <code>Field</code>s defined on <code>space</code> with the same <code>interpolate</code> and <code>interpolate!</code> functions.</p><pre><code class="language-julia hljs">import ClimaCore.Fields: coordinate_field
import ClimaCore.Remapping: interpolate, interpolate!

example_field = coordinate_field(space)
interpolated_array = interpolate(remapper, example_field)

# Interpolate in place
interpolate!(interpolated_array, remapper, example_field)</code></pre><p>Multiple fields defined on the same space can be interpolate at the same time</p><pre><code class="language-julia hljs">example_field2 = cosd.(example_field)
interpolated_arrays = interpolate(remapper, [example_field, example_field2])</code></pre><p>When interpolating multiple fields, greater performance can be achieved by creating the <code>Remapper</code> with a larger internal buffer to store intermediate values for interpolation. Effectively, this controls how many fields can be remapped simultaneously in <code>interpolate</code>. When more fields than <code>buffer_length</code> are passed, the remapper will batch the work in sizes of <code>buffer_length</code>. The optimal number of fields passed is the <code>buffer_length</code> of the <code>remapper</code>. If more fields are passed, the <code>remapper</code> will batch work with size up to its <code>buffer_length</code>.</p><h4 id="Example-2"><a class="docs-heading-anchor" href="#Example-2">Example</a><a class="docs-heading-anchor-permalink" href="#Example-2" title="Permalink"></a></h4><p>Given <code>field1</code>,<code>field2</code>, two <code>Field</code> defined on a cubed sphere.</p><pre><code class="language-julia hljs">longpts = range(-180.0, 180.0, 21)
latpts = range(-80.0, 80.0, 21)
zpts = range(0.0, 1000.0, 21)

hcoords = [Geometry.LatLongPoint(lat, long) for long in longpts, lat in latpts]
zcoords = [Geometry.ZPoint(z) for z in zpts]

space = axes(field1)

remapper = Remapper(space, hcoords, zcoords)

int1 = interpolate(remapper, field1)
int2 = interpolate(remapper, field2)

# Or
int12 = interpolate(remapper, [field1, field2])
# With int1 = int12[1, :, :, :]</code></pre><h2 id="Conservative-remapping-with-TempestRemap"><a class="docs-heading-anchor" href="#Conservative-remapping-with-TempestRemap">Conservative remapping with <code>TempestRemap</code></a><a id="Conservative-remapping-with-TempestRemap-1"></a><a class="docs-heading-anchor-permalink" href="#Conservative-remapping-with-TempestRemap" title="Permalink"></a></h2><p>This section hasn&#39;t been written yet. You can help by writing it.</p><p>TODO: finish writing this section.</p><h1 id="Interpolating-to-pressure-coordinates"><a class="docs-heading-anchor" href="#Interpolating-to-pressure-coordinates">Interpolating to pressure coordinates</a><a id="Interpolating-to-pressure-coordinates-1"></a><a class="docs-heading-anchor-permalink" href="#Interpolating-to-pressure-coordinates" title="Permalink"></a></h1><p>In addition to the <code>Remapper</code>, you can also interpolate to pressure coordinates. This can be used with the <code>Remapper</code> to remap a <code>ClimaCore</code> <code>Field</code> to a regular grid, where the vertical is pressure.</p><p><code>ClimaCore</code> provides the <code>PressureInterpolator</code> for efficient vertical interpolation from height to pressure coordinates.</p><h2 id="Quick-start-2"><a class="docs-heading-anchor" href="#Quick-start-2">Quick start</a><a class="docs-heading-anchor-permalink" href="#Quick-start-2" title="Permalink"></a></h2><p>The simplest way to interpolate a field to pressure coordinates:</p><pre><code class="language-julia hljs">import ClimaCore: Remapping, Fields
using ClimaInterpolations

# Define target pressure levels (in ascending order)
pressure_levels = 100.0 .* [100.0, 250.0, 500.0, 850.0, 1000.0]

# Create the interpolator
# pressure_field is a pressure field on center space
pressure_intp = Remapping.PressureInterpolator(pressure_field, pressure_levels)

# Interpolate the field to pressure coordinates
field_on_pressure_space = Remapping.interpolate_pressure(field, pressure_intp)

# Get the pressure field and space with pressure as the vertical
p_field = Remapping.pfull_field(pressure_intp)
p_space = Remapping.pressure_space(pressure_intp)

# If the pressure field changes, then you need to call update!
Remapping.update!(pressure_intp)

# This mutates both field_on_pressure_space and the interpolation done
# in-place
field_on_pressure_space =
    Remapping.interpolate_pressure!(field_on_pressure_space, field, pressure_intp)</code></pre><p>The result <code>field_on_pressure_space</code> is defined on a new space where the vertical coordinate is pressure rather than height.</p><h2 id="How-it-works"><a class="docs-heading-anchor" href="#How-it-works">How it works</a><a id="How-it-works-1"></a><a class="docs-heading-anchor-permalink" href="#How-it-works" title="Permalink"></a></h2><p>The <code>PressureInterpolator</code> performs the following steps:</p><ol><li><strong>Ensure monotonicity</strong>: Applies a cumulative minimum along each column to ensure pressure decreases monotonically with height.</li><li><strong>Vertical interpolation</strong>: Interpolates field values to the specified pressure coordinates using linear interpolation with constant boundary conditions.</li></ol><div class="admonition is-warning" id="Pressure-height-relationship-1b63d0bf686a8478"><header class="admonition-header">Pressure-height relationship<a class="admonition-anchor" href="#Pressure-height-relationship-1b63d0bf686a8478" title="Permalink"></a></header><div class="admonition-body"><p>The implementation assumes pressure decreases monotonically with height. If the interpolated field appears unrealistic, check for instabilities or inversions in your pressure field.</p></div></div><div class="admonition is-info" id="Boundary-conditions-dd247ba696ea4761"><header class="admonition-header">Boundary conditions<a class="admonition-anchor" href="#Boundary-conditions-dd247ba696ea4761" title="Permalink"></a></header><div class="admonition-body"><p>By default, vertical interpolation uses constant boundary conditions at the top and bottom of the atmosphere. Interpolated values at pressure levels outside the model&#39;s vertical range may be inaccurate.</p></div></div><h2 id="Space-and-staggering-requirements"><a class="docs-heading-anchor" href="#Space-and-staggering-requirements">Space and staggering requirements</a><a id="Space-and-staggering-requirements-1"></a><a class="docs-heading-anchor-permalink" href="#Space-and-staggering-requirements" title="Permalink"></a></h2><div class="admonition is-info" id="Space-compatibility-cc4014bfd29e2094"><header class="admonition-header">Space compatibility<a class="admonition-anchor" href="#Space-compatibility-cc4014bfd29e2094" title="Permalink"></a></header><div class="admonition-body"><p>The pressure field and the field being interpolated must be defined on the same space with the same vertical staggering (<code>CellCenter</code> or <code>CellFace</code>). The pressure field must use <code>CellCenter</code> staggering.</p></div></div><p>The <code>PressureInterpolator</code> works with:</p><ul><li><code>ExtrudedFiniteDifferenceSpace</code> - 3D spaces (e.g., cubed sphere with vertical levels)</li><li><code>FiniteDifferenceSpace</code> - 1D column spaces</li></ul><p>Interpolating fields on center and face spaces are supported, but the pressure field itself must always be on a center space.</p></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../operators/">« Operators</a><a class="docs-footer-nextpage" href="../matrix_fields/">MatrixFields »</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="auto">Automatic (OS)</option><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option><option value="catppuccin-latte">catppuccin-latte</option><option value="catppuccin-frappe">catppuccin-frappe</option><option value="catppuccin-macchiato">catppuccin-macchiato</option><option value="catppuccin-mocha">catppuccin-mocha</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 1.17.0 on <span class="colophon-date" title="Friday 20 February 2026 22:28">Friday 20 February 2026</span>. Using Julia version 1.10.10.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
